[
    {
        "title": "Maximum Path Quality of a Graph",
        "question_content": "There is an undirected graph with n nodes numbered from 0 to n - 1 (inclusive). You are given a 0-indexed integer array values where values[i] is the value of the ith node. You are also given a 0-indexed 2D integer array edges, where each edges[j] = [uj, vj, timej] indicates that there is an undirected edge between the nodes uj and vj, and it takes timej seconds to travel between the two nodes. Finally, you are given an integer maxTime.\nA valid path in the graph is any path that starts at node 0, ends at node 0, and takes at most maxTime seconds to complete. You may visit the same node multiple times. The quality of a valid path is the sum of the values of the unique nodes visited in the path (each node's value is added at most once to the sum).\nReturn the maximum quality of a valid path.\nNote: There are at most four edges connected to each node.\n&nbsp;\nExample 1:\n\nInput: values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49\nOutput: 75\nExplanation:\nOne possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75.\n\nExample 2:\n\nInput: values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30\nOutput: 25\nExplanation:\nOne possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30.\nThe nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25.\n\nExample 3:\n\nInput: values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50\nOutput: 7\nExplanation:\nOne possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50.\nThe nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7.\n\n&nbsp;\nConstraints:\n\n\tn == values.length\n\t1 <= n <= 1000\n\t0 <= values[i] <= 108\n\t0 <= edges.length <= 2000\n\tedges[j].length == 3 \n\t0 <= uj < vj <= n - 1\n\t10 <= timej, maxTime <= 100\n\tAll the pairs [uj, vj] are unique.\n\tThere are at most four edges connected to each node.\n\tThe graph may not be connected.",
        "solutions": [
            {
                "id": 1563704,
                "title": "python-short-dfs-explained",
                "content": "Key to success in this problem is to read problem constraints carefully: I spend like 10 minutes before I understand that problem can be solved using very simple dfs. Why? Because it is given that `maxTime <= 100` and `time_j >= 10`. It means that we can make no more than `10` steps in our graph! So, all we need to do is to run `dfs(node, visited, gain, cost)`, where:\\n\\n1. `node` is current node we are in.\\n2. `visited` is set of visited nodes: we need to keep set, because we count visitet nodes only once.\\n3. `gain` is total gain we have so far.\\n4. `cost` is how much time we still have.\\n\\n#### Complexity\\nWe have at most `10` steps, and it is also given that each node have at most degree `4`, so in total we can make no more than `4^10` states. That is why we will not get TLE.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maximalPathQuality(self, values, E, maxTime):\\n        G = defaultdict(list)\\n        for x, y, w in E:\\n            G[x].append((y, w))\\n            G[y].append((x, w))\\n            \\n        def dfs(node, visited, gain, cost):\\n            if node == 0: self.ans = max(self.ans, gain)\\n            for neib, w in G[node]:\\n                if w <= cost:\\n                    dfs(neib, visited | set([neib]), gain + (neib not in visited) * values[neib], cost - w)\\n\\n        self.ans = 0\\n        dfs(0, set([0]), values[0], maxTime)\\n        return self.ans\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def maximalPathQuality(self, values, E, maxTime):\\n        G = defaultdict(list)\\n        for x, y, w in E:\\n            G[x].append((y, w))\\n            G[y].append((x, w))\\n            \\n        def dfs(node, visited, gain, cost):\\n            if node == 0: self.ans = max(self.ans, gain)\\n            for neib, w in G[node]:\\n                if w <= cost:\\n                    dfs(neib, visited | set([neib]), gain + (neib not in visited) * values[neib], cost - w)\\n\\n        self.ans = 0\\n        dfs(0, set([0]), values[0], maxTime)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563770,
                "title": "simple-dfs-solution-c",
                "content": "We will do DFS in this problem. We have the condition here that we can visit a node any number of times but we shall add its value only once for that path for the calculation of its quality. \\n\\nSo, we would require a visited array which would keep track of the visited nodes so that we do not add its value again into the quality score. \\n\\nHere, we are doing DFS and we increase the count of that node in visited array indicating how many times we have visited that node. If its being visited for the first time, we add its value to our sum. After we have processed all its neighbours, we then mark the current node as unvisited i.e. we reduce the count of that node from the visited array. \\n\\nWe do not use a boolean visited array since if we go that way we would not be able to track visited properly since if we turn visited back to false after processing its neighbours, it would mean we treat that node as non visited even if its been visited multiple times before. To account for that, we use counter based visited array which increases or decreases the visited count thus serving its purpose.\\n\\nThe code provided below is self explanatory and I am sure you would be able to understand it easily.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        int res = values[0];\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        dfs(graph, values, visited, res, 0, 0, 0, maxTime);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<pair<int,int>>>& graph, vector<int>& values, vector<int>& visited, int& res, int node, int score, int time, int& maxTime)\\n    {\\n        if(time > maxTime)\\n            return;\\n        \\n        if(visited[node] == 0)\\n            score += values[node];\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0visited[node]++;\\n\\t\\t\\n \\xA0 \\xA0 \\xA0\\n \\xA0 \\xA0 \\xA0 \\xA0if(node == 0)\\n            res = max(res, score);\\n        \\n        for(auto it : graph[node])\\n        {\\n            int neigh = it.first;\\n            int newTime = time + it.second;\\n            dfs(graph, values, visited, res, neigh, score, newTime, maxTime);\\n        }\\n        \\n        visited[node]--;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        int res = values[0];\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        dfs(graph, values, visited, res, 0, 0, 0, maxTime);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<pair<int,int>>>& graph, vector<int>& values, vector<int>& visited, int& res, int node, int score, int time, int& maxTime)\\n    {\\n        if(time > maxTime)\\n            return;\\n        \\n        if(visited[node] == 0)\\n            score += values[node];\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0visited[node]++;\\n\\t\\t\\n \\xA0 \\xA0 \\xA0\\n \\xA0 \\xA0 \\xA0 \\xA0if(node == 0)\\n            res = max(res, score);\\n        \\n        for(auto it : graph[node])\\n        {\\n            int neigh = it.first;\\n            int newTime = time + it.second;\\n            dfs(graph, values, visited, res, neigh, score, newTime, maxTime);\\n        }\\n        \\n        visited[node]--;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563898,
                "title": "python-concise-dfs",
                "content": "**Python**\\n```py\\n    def maximalPathQuality(self, A, edges, maxTime):\\n        G = collections.defaultdict(dict)\\n        for i, j, t in edges:\\n            G[i][j] = G[j][i] = t\\n\\n        def dfs(i, seen, time):\\n            res = sum(A[j] for j in seen) if i == 0 else 0\\n            for j in G[i]:\\n                if time >= G[i][j]:\\n                    res = max(res, dfs(j, seen | {j}, time - G[i][j]))\\n            return res\\n\\n        return dfs(0, {0}, maxTime)\\n```",
                "solutionTags": [],
                "code": "```py\\n    def maximalPathQuality(self, A, edges, maxTime):\\n        G = collections.defaultdict(dict)\\n        for i, j, t in edges:\\n            G[i][j] = G[j][i] = t\\n\\n        def dfs(i, seen, time):\\n            res = sum(A[j] for j in seen) if i == 0 else 0\\n            for j in G[i]:\\n                if time >= G[i][j]:\\n                    res = max(res, dfs(j, seen | {j}, time - G[i][j]))\\n            return res\\n\\n        return dfs(0, {0}, maxTime)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1563744,
                "title": "plain-dfs",
                "content": "Perhaps this problem would be more interesting if we have more nodes, or max time is not limited to `100`.\\n\\nHere, we first build an adjacency list, and then run DFS, subtracting time and tracking the current value.\\n\\nThe visited array helps us determine when a node is visited for the first time. We add the node value when we visit the node for the first time.\\n\\n**C++**\\n```cpp\\nint max_val = 0;\\nint dfs(vector<vector<pair<int, int>>> &al, vector<int> &vis, vector<int>& vals, int i, int time, int val) {\\n    val += (++vis[i] == 1) ? vals[i] : 0;\\n    if (i == 0)\\n        max_val = max(max_val, val);\\n    for (auto [j, t] : al[i])\\n        if (time - t >= 0)\\n            dfs(al, vis, vals, j, time - t, val);\\n    --vis[i];\\n    return max_val;\\n}\\nint maximalPathQuality(vector<int>& vals, vector<vector<int>>& edges, int maxTime) {\\n    vector<vector<pair<int, int>>> al(vals.size());\\n    vector<int> vis(vals.size());\\n    for (auto &e : edges) {\\n        al[e[0]].push_back({e[1], e[2]});\\n        al[e[1]].push_back({e[0], e[2]});\\n    }\\n    return dfs(al, vis, vals, 0, maxTime, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint max_val = 0;\\nint dfs(vector<vector<pair<int, int>>> &al, vector<int> &vis, vector<int>& vals, int i, int time, int val) {\\n    val += (++vis[i] == 1) ? vals[i] : 0;\\n    if (i == 0)\\n        max_val = max(max_val, val);\\n    for (auto [j, t] : al[i])\\n        if (time - t >= 0)\\n            dfs(al, vis, vals, j, time - t, val);\\n    --vis[i];\\n    return max_val;\\n}\\nint maximalPathQuality(vector<int>& vals, vector<vector<int>>& edges, int maxTime) {\\n    vector<vector<pair<int, int>>> al(vals.size());\\n    vector<int> vis(vals.size());\\n    for (auto &e : edges) {\\n        al[e[0]].push_back({e[1], e[2]});\\n        al[e[1]].push_back({e[0], e[2]});\\n    }\\n    return dfs(al, vis, vals, 0, maxTime, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1564001,
                "title": "java-dfs-o-2-20-with-explanation",
                "content": "I spent a few minutes but I can\\'t come out a workable solution until I read the constraints very carefully.\\n\\n**Analysis**\\n1. `10 <= time[j], maxTime <= 100` By this constraint, there are at most 10 nodes in a path.\\n2. There are at most `four` edges connected to each node\\n3. Based on the aforementioned constraints, the brute force approach runs in O(4^10) = O(2^20) which is sufficient to pass the tests.\\n\\n```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        List<int[]>[] adj = new List[n];\\n        for (int i = 0; i < n; ++i) adj[i] = new LinkedList();\\n        for (int[] e : edges) {\\n            int i = e[0], j = e[1], t = e[2];\\n            adj[i].add(new int[]{j, t});\\n            adj[j].add(new int[]{i, t});\\n        }\\n        int[] res = new int[1];\\n        int[] seen = new int[n];\\n        seen[0]++;\\n        dfs(adj, 0, values, maxTime, seen, res, values[0]);\\n        return res[0];\\n    }\\n    private void dfs(List<int[]>[] adj, int src, int[] values, int maxTime, int[] seen, int[] res, int sum) {\\n        if (0 == src) {\\n            res[0] = Math.max(res[0], sum);\\n        }\\n        if (0 > maxTime) return;\\n        for (int[] data : adj[src]) {\\n            int dst = data[0], t = data[1];\\n            if (0 > maxTime - t) continue;\\n            seen[dst]++;\\n            dfs(adj, dst, values, maxTime - t, seen, res, sum + (1 == seen[dst] ? values[dst] : 0));\\n            seen[dst]--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        List<int[]>[] adj = new List[n];\\n        for (int i = 0; i < n; ++i) adj[i] = new LinkedList();\\n        for (int[] e : edges) {\\n            int i = e[0], j = e[1], t = e[2];\\n            adj[i].add(new int[]{j, t});\\n            adj[j].add(new int[]{i, t});\\n        }\\n        int[] res = new int[1];\\n        int[] seen = new int[n];\\n        seen[0]++;\\n        dfs(adj, 0, values, maxTime, seen, res, values[0]);\\n        return res[0];\\n    }\\n    private void dfs(List<int[]>[] adj, int src, int[] values, int maxTime, int[] seen, int[] res, int sum) {\\n        if (0 == src) {\\n            res[0] = Math.max(res[0], sum);\\n        }\\n        if (0 > maxTime) return;\\n        for (int[] data : adj[src]) {\\n            int dst = data[0], t = data[1];\\n            if (0 > maxTime - t) continue;\\n            seen[dst]++;\\n            dfs(adj, dst, values, maxTime - t, seen, res, sum + (1 == seen[dst] ? values[dst] : 0));\\n            seen[dst]--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583510,
                "title": "python-top-99-6-196ms-dfs-caching-dijkstra",
                "content": "Initially, we can just write a DFS. Something like this:\\n\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        neighbours = defaultdict(list)\\n        for v,w,t in edges:\\n            neighbours[v].append((w,t))\\n            neighbours[w].append((v,t))\\n            \\n        def dfs(time, quality, visited, node):\\n            q = quality if node == 0 else -float(\"inf\")\\n            for nb,t in neighbours[node]:\\n                if time+t <= maxTime:\\n                    res = dfs(time+t, quality, visited | set([nb]), nb)\\n                    q = max(q, res if nb in visited else res+values[nb])\\n            return q\\n                \\n        return dfs(0, values[0], set([0]), 0)\\n```\\n\\nThis code is already fast enough to get an `Accepted`, but it takes 2912ms.\\n\\nWe can speed this up by adding some caching. We can use `@cache` from `functools` to do this. However, `@cache` requires that all function parameters, in this case `time`, `quality`, `visited`, `node`, are hashable types, and `visited` is a set and therefore not hashable. We can fix this by using an int to store the visited nodes. Ints are hashable, and thus we can use caching now. The dfs now looks like this:\\n\\n```\\n        @cache\\n        def dfs(time, quality, visited, node):\\n            q = quality if node == 0 else -float(\"inf\")\\n            for nb,t in neighbours[node]:\\n                if time+t <= maxTime:\\n                    res = dfs(time+t, quality, visited | (1<<nb), nb)\\n                    q = max(q, res if (visited >> nb) & 1 else res+values[nb])\\n            return q\\n                \\n        return dfs(0, values[0], 1, 0)\\n```\\n\\nThis code brings us down from 2912ms to 296ms, which was faster than 96.89% of sumissions. We can still speed it up further though. Observe the following lines from the dfs:\\n\\n```\\n            for nb,t in neighbours[node]:\\n                if time+t <= maxTime:\\n```\\n\\nWe have this `if`-statement because we only want to recurse to neighbours that we can reach within `maxTime` seconds. However, note that if we go to such a neighbour, we *also* have to be able to go all the way back to our end node, node 0, within `maxTime`. Therefore, we can change it to:\\n\\n```\\n            for nb,t in neighbours[node]:\\n                if time+t+timeFrom0ToNb <= maxTime:\\n```\\n\\nWe can use Dijkstras algorithm to calculate `timeFrom0ToNb` for all nodes in the graph. We then arrive at the final submission:\\n\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        neighbours = defaultdict(list)\\n        for v,w,t in edges:\\n            neighbours[v].append((w,t))\\n            neighbours[w].append((v,t))\\n            \\n        times = defaultdict(lambda: float(\"inf\"))\\n        q = [(0, 0)]\\n        while len(q):\\n            time, node = heappop(q)\\n            if times[(node,0)] == float(\"inf\"):\\n                times[(node,0)] = time\\n                for nb,t in neighbours[node]:\\n                    if time+t <= maxTime//2 and times[(nb,0)] == float(\"inf\"):\\n                        heappush(q, (time+t, nb))\\n            \\n        @cache\\n        def dfs(time, quality, visited, node):\\n            q = quality if node == 0 else -float(\"inf\")\\n            for nb,t in neighbours[node]:\\n                if time+t+times[(nb,0)] <= maxTime:\\n                    res = dfs(time+t, quality, visited | (1<<nb), nb)\\n                    q = max(q, res if (visited >> nb) & 1 else res+values[nb])\\n            return q\\n                \\n        return dfs(0, values[0], 1, 0)\\n```\\n\\nThis submission took 196ms, and was faster than 99.6% of submissions.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        neighbours = defaultdict(list)\\n        for v,w,t in edges:\\n            neighbours[v].append((w,t))\\n            neighbours[w].append((v,t))\\n            \\n        def dfs(time, quality, visited, node):\\n            q = quality if node == 0 else -float(\"inf\")\\n            for nb,t in neighbours[node]:\\n                if time+t <= maxTime:\\n                    res = dfs(time+t, quality, visited | set([nb]), nb)\\n                    q = max(q, res if nb in visited else res+values[nb])\\n            return q\\n                \\n        return dfs(0, values[0], set([0]), 0)\\n```\n```\\n        @cache\\n        def dfs(time, quality, visited, node):\\n            q = quality if node == 0 else -float(\"inf\")\\n            for nb,t in neighbours[node]:\\n                if time+t <= maxTime:\\n                    res = dfs(time+t, quality, visited | (1<<nb), nb)\\n                    q = max(q, res if (visited >> nb) & 1 else res+values[nb])\\n            return q\\n                \\n        return dfs(0, values[0], 1, 0)\\n```\n```\\n            for nb,t in neighbours[node]:\\n                if time+t <= maxTime:\\n```\n```\\n            for nb,t in neighbours[node]:\\n                if time+t+timeFrom0ToNb <= maxTime:\\n```\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        neighbours = defaultdict(list)\\n        for v,w,t in edges:\\n            neighbours[v].append((w,t))\\n            neighbours[w].append((v,t))\\n            \\n        times = defaultdict(lambda: float(\"inf\"))\\n        q = [(0, 0)]\\n        while len(q):\\n            time, node = heappop(q)\\n            if times[(node,0)] == float(\"inf\"):\\n                times[(node,0)] = time\\n                for nb,t in neighbours[node]:\\n                    if time+t <= maxTime//2 and times[(nb,0)] == float(\"inf\"):\\n                        heappush(q, (time+t, nb))\\n            \\n        @cache\\n        def dfs(time, quality, visited, node):\\n            q = quality if node == 0 else -float(\"inf\")\\n            for nb,t in neighbours[node]:\\n                if time+t+times[(nb,0)] <= maxTime:\\n                    res = dfs(time+t, quality, visited | (1<<nb), nb)\\n                    q = max(q, res if (visited >> nb) & 1 else res+values[nb])\\n            return q\\n                \\n        return dfs(0, values[0], 1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965727,
                "title": "python-bfs-99-33-commented",
                "content": "Hello, just wrote this and wanted to checkout other\\'s solution, and I couldn\\'t find fast BFS solutions, so I am just sharing my code.\\n\\nI wonder how can I not keeping copy of set every append to queue. Please **any suggest** will be appreciated\\n\\n**Thought process:**\\n1. build undirected graph\\n2. start BFS from 0 with (current vertex / time taken so far / quality collected so far / used vertext so far for this path)\\n3. **Memoization** here which let you stop if current vertext can\\'t give you better result extremely accelerate the whole algorithm\\n4. Also if the time taken so far is more than the limit, no need to proceed\\n5. If we are at node \\'0\\' then let\\'s keep the maximum quality points collected so far\\n6. quality will only be updated if has not been collected for the path. I am copying the set to use for new path. (like I said, any suggestion to use instead of this is big thanks)\\n\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = defaultdict(list)\\n\\t\\t# build graph\\n        for edge in edges:\\n            graph[edge[0]].append((edge[1], edge[2]))\\n            graph[edge[1]].append((edge[0], edge[2]))\\n        \\n        q = deque()\\n        q.append((0, 0, values[0], set([0])))\\n        cache = {}\\n        maxPoint = 0\\n\\t\\t\\n        while q:\\n            currV, currTime, currPoints, currSet = q.popleft()\\n            if currV in cache:\\n\\t\\t\\t\\t# if vertex has been visited, and if the previousTime is \\n\\t\\t\\t\\t# less or equal to current time but current points is lower?\\n\\t\\t\\t\\t# then this path can\\'t give us better quality so stop proceeding.\\n                prevTime, prevPoints = cache[currV]\\n                if prevTime <= currTime and prevPoints > currPoints:\\n                    continue\\n            cache[currV] = (currTime, currPoints)\\n\\t\\t\\t# can\\'t go over the maxTime limit\\n            if currTime > maxTime:\\n                continue\\n\\t\\t\\t# collect maxPoint only if current vertex is 0\\n            if currV == 0:\\n                maxPoint = max(maxPoint, currPoints)\\n            for neigh, neighTime in graph[currV]:\\n                newSet = currSet.copy()\\n\\t\\t\\t\\t# collects quality only if not collected before\\n                if neigh not in currSet:\\n                    newSet.add(neigh)\\n                    newPoint = currPoints + values[neigh]\\n                else:\\n                    newPoint = currPoints\\n                q.append((neigh, currTime + neighTime, newPoint, newSet))\\n        return maxPoint\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c9479bfe-7695-4fec-ad77-c424e5416ec2_1650432955.8708572.png)\\n\\n**Please correct me if I am wrong !\\nPlease UPVOTE if you find this solution helpful !\\nHappy algo!**\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = defaultdict(list)\\n\\t\\t# build graph\\n        for edge in edges:\\n            graph[edge[0]].append((edge[1], edge[2]))\\n            graph[edge[1]].append((edge[0], edge[2]))\\n        \\n        q = deque()\\n        q.append((0, 0, values[0], set([0])))\\n        cache = {}\\n        maxPoint = 0\\n\\t\\t\\n        while q:\\n            currV, currTime, currPoints, currSet = q.popleft()\\n            if currV in cache:\\n\\t\\t\\t\\t# if vertex has been visited, and if the previousTime is \\n\\t\\t\\t\\t# less or equal to current time but current points is lower?\\n\\t\\t\\t\\t# then this path can\\'t give us better quality so stop proceeding.\\n                prevTime, prevPoints = cache[currV]\\n                if prevTime <= currTime and prevPoints > currPoints:\\n                    continue\\n            cache[currV] = (currTime, currPoints)\\n\\t\\t\\t# can\\'t go over the maxTime limit\\n            if currTime > maxTime:\\n                continue\\n\\t\\t\\t# collect maxPoint only if current vertex is 0\\n            if currV == 0:\\n                maxPoint = max(maxPoint, currPoints)\\n            for neigh, neighTime in graph[currV]:\\n                newSet = currSet.copy()\\n\\t\\t\\t\\t# collects quality only if not collected before\\n                if neigh not in currSet:\\n                    newSet.add(neigh)\\n                    newPoint = currPoints + values[neigh]\\n                else:\\n                    newPoint = currPoints\\n                q.append((neigh, currTime + neighTime, newPoint, newSet))\\n        return maxPoint\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563734,
                "title": "c-dfs",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. DFS\\n\\nSince `10 <= timej, maxTime <= 100`, the path at most have `10` edges. Since each node at most has `4` edges, the maximum number of possible paths is `4^10 ~= 1e6`, so a brute force DFS should work.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-path-quality-of-a-graph/\\n// Author: github.com/lzl124631x\\n// Time: O(4^10)\\n// Space: O(V + E)\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& V, vector<vector<int>>& E, int maxTime) {\\n        int N = V.size();\\n        vector<vector<pair<int, int>>> G(N); // build graph\\n        for (auto &e : E) {\\n            int u = e[0], v = e[1], c = e[2];\\n            G[u].emplace_back(v, c);\\n            G[v].emplace_back(u, c);\\n        }\\n        vector<int> cnt(N); // `cnt[u]` is the number of times we\\'ve visted node `u` in the current path\\n        int ans = 0;\\n        function<void(int, int, int)> dfs = [&](int u, int val, int time) {\\n            if (cnt[u] == 0) val += V[u];\\n            cnt[u]++;\\n            if (u == 0) ans = max(ans, val); // Only update answer if the current node is `0`.\\n            for (auto &[v, c] : G[u]) {\\n                if (time + c > maxTime) continue; // if the current time + the edge time is greater than maxTime, skip\\n                dfs(v, val, time + c);\\n            }\\n            cnt[u]--;\\n        };\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n\\nOr we can optionally add Dijkstra to backtrack earlier.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-path-quality-of-a-graph/\\n// Author: github.com/lzl124631x\\n// Time: O(ElogE + 4^10)\\n// Space: O(V + E)\\nclass Solution {\\n    typedef array<int, 2> T;\\npublic:\\n    int maximalPathQuality(vector<int>& V, vector<vector<int>>& E, int maxTime) {\\n        int N = V.size();\\n        vector<vector<array<int, 2>>> G(N); // build graph\\n        for (auto &e : E) {\\n            int u = e[0], v = e[1], c = e[2];\\n            G[u].push_back({v, c});\\n            G[v].push_back({u, c});\\n        }\\n        priority_queue<T, vector<T>, greater<T>> pq; // use Dijkstra to find the shortest distance from node 0 to all other nodes.\\n        vector<int> dist(N, INT_MAX);\\n        dist[0] = 0;\\n        pq.push({0, 0});\\n        while (pq.size()) {\\n            auto [d, u] = pq.top();\\n            pq.pop();\\n            if (d > dist[u]) continue;\\n            for (auto &[v, c] : G[u]) {\\n                if (dist[v] > dist[u] + c) {\\n                    dist[v] = dist[u] + c;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n        }\\n        vector<int> cnt(N); // `cnt[u]` is the number of times we\\'ve visted node `u` in the current path\\n        int ans = 0;\\n        function<void(int, int, int)> dfs = [&](int u, int val, int time) {\\n            if (cnt[u] == 0) val += V[u];\\n            cnt[u]++;\\n            if (u == 0) ans = max(ans, val); // Only update answer if the current node is `0`.\\n            for (auto &[v, c] : G[u]) {\\n                if (time + c + dist[v] > maxTime) continue; // if the current time + the edge time + dist[u] is greater than maxTime, skip\\n                dfs(v, val, time + c);\\n            }\\n            cnt[u]--;\\n        };\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximum-path-quality-of-a-graph/\\n// Author: github.com/lzl124631x\\n// Time: O(4^10)\\n// Space: O(V + E)\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& V, vector<vector<int>>& E, int maxTime) {\\n        int N = V.size();\\n        vector<vector<pair<int, int>>> G(N); // build graph\\n        for (auto &e : E) {\\n            int u = e[0], v = e[1], c = e[2];\\n            G[u].emplace_back(v, c);\\n            G[v].emplace_back(u, c);\\n        }\\n        vector<int> cnt(N); // `cnt[u]` is the number of times we\\'ve visted node `u` in the current path\\n        int ans = 0;\\n        function<void(int, int, int)> dfs = [&](int u, int val, int time) {\\n            if (cnt[u] == 0) val += V[u];\\n            cnt[u]++;\\n            if (u == 0) ans = max(ans, val); // Only update answer if the current node is `0`.\\n            for (auto &[v, c] : G[u]) {\\n                if (time + c > maxTime) continue; // if the current time + the edge time is greater than maxTime, skip\\n                dfs(v, val, time + c);\\n            }\\n            cnt[u]--;\\n        };\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-path-quality-of-a-graph/\\n// Author: github.com/lzl124631x\\n// Time: O(ElogE + 4^10)\\n// Space: O(V + E)\\nclass Solution {\\n    typedef array<int, 2> T;\\npublic:\\n    int maximalPathQuality(vector<int>& V, vector<vector<int>>& E, int maxTime) {\\n        int N = V.size();\\n        vector<vector<array<int, 2>>> G(N); // build graph\\n        for (auto &e : E) {\\n            int u = e[0], v = e[1], c = e[2];\\n            G[u].push_back({v, c});\\n            G[v].push_back({u, c});\\n        }\\n        priority_queue<T, vector<T>, greater<T>> pq; // use Dijkstra to find the shortest distance from node 0 to all other nodes.\\n        vector<int> dist(N, INT_MAX);\\n        dist[0] = 0;\\n        pq.push({0, 0});\\n        while (pq.size()) {\\n            auto [d, u] = pq.top();\\n            pq.pop();\\n            if (d > dist[u]) continue;\\n            for (auto &[v, c] : G[u]) {\\n                if (dist[v] > dist[u] + c) {\\n                    dist[v] = dist[u] + c;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n        }\\n        vector<int> cnt(N); // `cnt[u]` is the number of times we\\'ve visted node `u` in the current path\\n        int ans = 0;\\n        function<void(int, int, int)> dfs = [&](int u, int val, int time) {\\n            if (cnt[u] == 0) val += V[u];\\n            cnt[u]++;\\n            if (u == 0) ans = max(ans, val); // Only update answer if the current node is `0`.\\n            for (auto &[v, c] : G[u]) {\\n                if (time + c + dist[v] > maxTime) continue; // if the current time + the edge time + dist[u] is greater than maxTime, skip\\n                dfs(v, val, time + c);\\n            }\\n            cnt[u]--;\\n        };\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563733,
                "title": "java-dfs",
                "content": "```java\\nclass Solution {\\n    public class Node {\\n        int id;\\n        int value;\\n        List<Edge> edges;\\n        public Node(int id, int value) {\\n            this.id = id;\\n            this.value = value;\\n            edges = new ArrayList<>();\\n        }\\n    }\\n    \\n    public class Edge {\\n        int id1;\\n        int id2;\\n        int cost;\\n        public Edge(int id1, int id2, int cost) {\\n            this.id1 = id1;\\n            this.id2 = id2;\\n            this.cost = cost;\\n        }\\n    }\\n    \\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        List<Node> nodes = new ArrayList<>();\\n        for (int i = 0; i < values.length; i++) {\\n            nodes.add(new Node(i, values[i]));\\n        }\\n        \\n        for (int[] edge : edges) {\\n            Edge e = new Edge(edge[0], edge[1], edge[2]);\\n            nodes.get(edge[0]).edges.add(e);\\n            nodes.get(edge[1]).edges.add(e);\\n        }\\n        \\n        for (Node node : nodes) {\\n            Collections.sort(node.edges, (e1, e2) -> {\\n                return e1.cost - e2.cost;\\n            });\\n        }\\n        \\n        Set<Integer> qualityAdded = new HashSet<>();\\n        qualityAdded.add(0);\\n        return visit(nodes, 0, qualityAdded, maxTime, nodes.get(0).value, 0);\\n    }\\n    \\n    private int visit(List<Node> nodes, int curId, Set<Integer> qualityAdded, int maxTime, int quality, int time) {     \\n        if (time > maxTime) {\\n            return Integer.MIN_VALUE;\\n        }\\n        \\n        int maxQuality = Integer.MIN_VALUE;\\n        if (curId == 0 && time <= maxTime) {\\n            maxQuality = Math.max(maxQuality, quality);\\n        }\\n        \\n        for (Edge edge : nodes.get(curId).edges) {\\n            if (time + edge.cost > maxTime) {\\n                break;\\n            }\\n            \\n            int nbrId = edge.id1 != curId ? edge.id1 : edge.id2;\\n            boolean hasAdded = qualityAdded.contains(nbrId);\\n            qualityAdded.add(nbrId);\\n            int newQuality = hasAdded ? quality : quality + nodes.get(nbrId).value;\\n            maxQuality = Math.max(maxQuality, visit(nodes, nbrId, qualityAdded, maxTime, newQuality, time + edge.cost));\\n            if (!hasAdded) {\\n                qualityAdded.remove(nbrId);\\n            }\\n        }\\n        \\n        return maxQuality;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public class Node {\\n        int id;\\n        int value;\\n        List<Edge> edges;\\n        public Node(int id, int value) {\\n            this.id = id;\\n            this.value = value;\\n            edges = new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1581232,
                "title": "java-dfs",
                "content": "```\\n\\tpublic int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        List<List<int[]>> adjList = new ArrayList();\\n        for(int i : values) {\\n            adjList.add(new ArrayList());\\n        }\\n        \\n        for(int edge[] : edges) {\\n            adjList.get(edge[0]).add(new int[] {edge[1], edge[2]});\\n            adjList.get(edge[1]).add(new int[] {edge[0], edge[2]});\\n        }\\n        int[] visited = new int[values.length];\\n        solve(values, adjList, visited, 0, maxTime, 0, 0);\\n        return ans;\\n    }\\n    int ans;\\n    \\n    void solve(int[] values, List<List<int[]>> adjList, int[] visited, int node, int maxTime, int currTime, int score) {\\n        if(currTime > maxTime) {\\n            return;\\n        }\\n        if(visited[node] == 0) {\\n            score += values[node];\\n        }\\n        \\n        if(node == 0) {\\n            ans = Math.max(ans, score);\\n        }\\n        \\n        visited[node]++;\\n        \\n        for(int[] v : adjList.get(node)) {\\n            solve(values, adjList, visited, v[0], maxTime, currTime + v[1], score);\\n        }\\n        \\n        visited[node]--;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tpublic int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        List<List<int[]>> adjList = new ArrayList();\\n        for(int i : values) {\\n            adjList.add(new ArrayList());\\n        }\\n        \\n        for(int edge[] : edges) {\\n            adjList.get(edge[0]).add(new int[] {edge[1], edge[2]});\\n            adjList.get(edge[1]).add(new int[] {edge[0], edge[2]});\\n        }\\n        int[] visited = new int[values.length];\\n        solve(values, adjList, visited, 0, maxTime, 0, 0);\\n        return ans;\\n    }\\n    int ans;\\n    \\n    void solve(int[] values, List<List<int[]>> adjList, int[] visited, int node, int maxTime, int currTime, int score) {\\n        if(currTime > maxTime) {\\n            return;\\n        }\\n        if(visited[node] == 0) {\\n            score += values[node];\\n        }\\n        \\n        if(node == 0) {\\n            ans = Math.max(ans, score);\\n        }\\n        \\n        visited[node]++;\\n        \\n        for(int[] v : adjList.get(node)) {\\n            solve(values, adjList, visited, v[0], maxTime, currTime + v[1], score);\\n        }\\n        \\n        visited[node]--;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590243,
                "title": "backtracking-dfs-based-approach-c-clean-code",
                "content": "# Code : \\n```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        \\n        int n = values.size();\\n        \\n        vector<vector<pair<int, int>>> adj(n);\\n        \\n        for(auto& edge : edges) {\\n            adj[edge[0]].push_back({edge[1], edge[2]});\\n            adj[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        \\n        vector<int> vis(n, 0);     \\n        return explorePaths(adj, values, vis, 0, values[0], maxTime);\\n    }\\n\\t\\n    int explorePaths(vector<vector<pair<int, int>>>& adj, vector<int>& values, vector<int>& vis, int node, int quality, int time) {\\n        \\n        int maxQuality = 0;\\n        \\n        if(node == 0) maxQuality = max(maxQuality, quality);\\n        \\n        vis[node]++;\\n        \\n        for(auto& [adjnode, wt] : adj[node]) {\\n            if(wt <= time)\\n            {\\n                int val = quality + (vis[adjnode] ? 0 : values[adjnode]);\\n                maxQuality = max(maxQuality, explorePaths(adj, values, vis, adjnode, val, time - wt));\\n            }\\n        }\\n        \\n        vis[node]--;\\n        \\n        return maxQuality;\\n    }\\n};\\n```\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        \\n        int n = values.size();\\n        \\n        vector<vector<pair<int, int>>> adj(n);\\n        \\n        for(auto& edge : edges) {\\n            adj[edge[0]].push_back({edge[1], edge[2]});\\n            adj[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        \\n        vector<int> vis(n, 0);     \\n        return explorePaths(adj, values, vis, 0, values[0], maxTime);\\n    }\\n\\t\\n    int explorePaths(vector<vector<pair<int, int>>>& adj, vector<int>& values, vector<int>& vis, int node, int quality, int time) {\\n        \\n        int maxQuality = 0;\\n        \\n        if(node == 0) maxQuality = max(maxQuality, quality);\\n        \\n        vis[node]++;\\n        \\n        for(auto& [adjnode, wt] : adj[node]) {\\n            if(wt <= time)\\n            {\\n                int val = quality + (vis[adjnode] ? 0 : values[adjnode]);\\n                maxQuality = max(maxQuality, explorePaths(adj, values, vis, adjnode, val, time - wt));\\n            }\\n        }\\n        \\n        vis[node]--;\\n        \\n        return maxQuality;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563806,
                "title": "naive-dfs-backtrack-simple-but-my-internet-went-off",
                "content": "Let\\'s go directly to the data size, `time >= 10` and `maxTime <= 100`. We will let it traverse at most 10 steps from 0. \\nThe sentence, `at most four edges for each node`, indicate that we will have at most 4^10 steps to move in total which is\\naround 10^6 to 10^7 steps. So searching in a brute force way should work on LeetCode...\\n\\nI use backtrack here as it\\'s easier to mark qualities from unique nodes.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        // 10 steps at most, 4 directions at most -> 4 ^ 10 -> 2 ^ 20\\n        this->maxTime = maxTime;\\n        this->n = values.size();\\n        visited = vector<int>(1000, 0);\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(vector<int>& vec : edges) {\\n            graph[vec[0]].emplace_back(vec[1], vec[2]);\\n            graph[vec[1]].emplace_back(vec[0], vec[2]);\\n        }\\n        \\n        // run backtracking\\n        visited[0] = 1;\\n        backtrack(graph, values, 0, values[0], 0);\\n        return res;\\n    }\\nprivate:\\n    int res = 0;\\n    int maxTime, n;\\n    vector<int> visited;\\n    void backtrack(vector<vector<pair<int,int>>>& graph, vector<int>& values, int curr, int quality, int time) {        \\n        if(curr == 0) {\\n            res = max(quality, res);\\n        }\\n        for(auto [v, t] : graph[curr]) {\\n            if(time + t > maxTime) continue;\\n            if(visited[v] > 0) // visited\\n                backtrack(graph, values, v, quality, time + t);            \\n            else {\\n                visited[v] = 1;\\n                backtrack(graph, values, v, quality + values[v], time + t);\\n                visited[v] = 0;\\n            }\\n        } \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        // 10 steps at most, 4 directions at most -> 4 ^ 10 -> 2 ^ 20\\n        this->maxTime = maxTime;\\n        this->n = values.size();\\n        visited = vector<int>(1000, 0);\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(vector<int>& vec : edges) {\\n            graph[vec[0]].emplace_back(vec[1], vec[2]);\\n            graph[vec[1]].emplace_back(vec[0], vec[2]);\\n        }\\n        \\n        // run backtracking\\n        visited[0] = 1;\\n        backtrack(graph, values, 0, values[0], 0);\\n        return res;\\n    }\\nprivate:\\n    int res = 0;\\n    int maxTime, n;\\n    vector<int> visited;\\n    void backtrack(vector<vector<pair<int,int>>>& graph, vector<int>& values, int curr, int quality, int time) {        \\n        if(curr == 0) {\\n            res = max(quality, res);\\n        }\\n        for(auto [v, t] : graph[curr]) {\\n            if(time + t > maxTime) continue;\\n            if(visited[v] > 0) // visited\\n                backtrack(graph, values, v, quality, time + t);            \\n            else {\\n                visited[v] = 1;\\n                backtrack(graph, values, v, quality + values[v], time + t);\\n                visited[v] = 0;\\n            }\\n        } \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563716,
                "title": "javascript-simple-dfs",
                "content": "```javascript\\nvar maximalPathQuality = function(values, edges, maxTime) {\\n    const adjacencyList = values.map(() => []);\\n    for (const [node1, node2, time] of edges) {\\n        adjacencyList[node1].push([node2, time]);\\n        adjacencyList[node2].push([node1, time]);\\n    }\\n    \\n    const dfs = (node, quality, time, seen) => {\\n        // if we returned back to the 0 node, then we log it as a valid value\\n        let best = node === 0 ? quality : 0;\\n        \\n        // try to visit all the neighboring nodes within the maxTime\\n        // given while recording the max\\n        for (const [neighbor, routeTime] of adjacencyList[node]) {\\n            const totalTime = time + routeTime;\\n            if (totalTime > maxTime) continue;\\n            if (seen.has(neighbor)) {\\n                best = Math.max(best, \\n                                dfs(neighbor, quality, totalTime, seen));\\n            } else {\\n                seen.add(neighbor);\\n                best = Math.max(best, \\n                                dfs(neighbor, quality + values[neighbor], totalTime, seen));\\n                seen.delete(neighbor);\\n            }\\n        }\\n        return best;\\n    }\\n    return dfs(0, values[0], 0, new Set([0]));\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\nvar maximalPathQuality = function(values, edges, maxTime) {\\n    const adjacencyList = values.map(() => []);\\n    for (const [node1, node2, time] of edges) {\\n        adjacencyList[node1].push([node2, time]);\\n        adjacencyList[node2].push([node1, time]);\\n    }\\n    \\n    const dfs = (node, quality, time, seen) => {\\n        // if we returned back to the 0 node, then we log it as a valid value\\n        let best = node === 0 ? quality : 0;\\n        \\n        // try to visit all the neighboring nodes within the maxTime\\n        // given while recording the max\\n        for (const [neighbor, routeTime] of adjacencyList[node]) {\\n            const totalTime = time + routeTime;\\n            if (totalTime > maxTime) continue;\\n            if (seen.has(neighbor)) {\\n                best = Math.max(best, \\n                                dfs(neighbor, quality, totalTime, seen));\\n            } else {\\n                seen.add(neighbor);\\n                best = Math.max(best, \\n                                dfs(neighbor, quality + values[neighbor], totalTime, seen));\\n                seen.delete(neighbor);\\n            }\\n        }\\n        return best;\\n    }\\n    return dfs(0, values[0], 0, new Set([0]));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1564102,
                "title": "python-dfs-and-bfs-solution",
                "content": "DFS solution:\\n```python\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        ans = 0\\n        graph = collections.defaultdict(dict)\\n        for u, v, t in edges:\\n            graph[u][v] = t\\n            graph[v][u] = t\\n        \\n        def dfs(curr, visited, score, cost):\\n            if curr == 0:\\n                nonlocal ans\\n                ans = max(ans, score)\\n            \\n            for nxt, time in graph[curr].items():\\n                if time <= cost:\\n                    dfs(nxt, visited|set([nxt]), score+values[nxt]*(nxt not in visited), cost-time)\\n        \\n        dfs(0, set([0]), values[0], maxTime)\\n        return ans\\n```\\n\\nBFS solution\\n```python\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        ans = 0\\n        graph = collections.defaultdict(dict)\\n        for u,v,t in edges:\\n            graph[u][v] = t\\n            graph[v][u] = t\\n        \\n        # node, cost, visited, score\\n        q = collections.deque([(0, maxTime, set([0]), values[0])])\\n        while q:\\n            curr, cost, visited, score = q.popleft()\\n            if curr == 0:\\n                ans = max(ans, score)\\n            for nxt, time in graph[curr].items():\\n                if time > cost:\\n                    continue\\n                q.append((nxt, cost-time, visited|set([nxt]), score + values[nxt]*(nxt not in visited)))\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        ans = 0\\n        graph = collections.defaultdict(dict)\\n        for u, v, t in edges:\\n            graph[u][v] = t\\n            graph[v][u] = t\\n        \\n        def dfs(curr, visited, score, cost):\\n            if curr == 0:\\n                nonlocal ans\\n                ans = max(ans, score)\\n            \\n            for nxt, time in graph[curr].items():\\n                if time <= cost:\\n                    dfs(nxt, visited|set([nxt]), score+values[nxt]*(nxt not in visited), cost-time)\\n        \\n        dfs(0, set([0]), values[0], maxTime)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        ans = 0\\n        graph = collections.defaultdict(dict)\\n        for u,v,t in edges:\\n            graph[u][v] = t\\n            graph[v][u] = t\\n        \\n        # node, cost, visited, score\\n        q = collections.deque([(0, maxTime, set([0]), values[0])])\\n        while q:\\n            curr, cost, visited, score = q.popleft()\\n            if curr == 0:\\n                ans = max(ans, score)\\n            for nxt, time in graph[curr].items():\\n                if time > cost:\\n                    continue\\n                q.append((nxt, cost-time, visited|set([nxt]), score + values[nxt]*(nxt not in visited)))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382234,
                "title": "dfs-brute-force",
                "content": "```python\\n\\'\\'\\'\\ndfs, brute force\\nO(4^n), O(4^n)\\n\\'\\'\\'\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = collections.defaultdict(list)\\n        for u, v, time in edges:\\n            graph[u].append((v, time))\\n            graph[v].append((u, time))\\n        \\n        max_quality = 0\\n        visited = {0}\\n        def dfs(node, visited, quality, time_left):\\n            nonlocal max_quality\\n            \\n            if node == 0:\\n                max_quality = max(max_quality, quality)\\n            \\n            for neighbor, time in graph[node]:\\n                if time <= time_left:\\n                    if neighbor in visited:\\n                        dfs(neighbor, visited, quality, time_left - time)\\n                    else:\\n                        visited.add(neighbor)\\n                        dfs(neighbor, visited, quality + values[neighbor], time_left - time)\\n                        visited.remove(neighbor)\\n        \\n        dfs(0, visited, values[0], maxTime)\\n        return max_quality\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\n\\'\\'\\'\\ndfs, brute force\\nO(4^n), O(4^n)\\n\\'\\'\\'\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = collections.defaultdict(list)\\n        for u, v, time in edges:\\n            graph[u].append((v, time))\\n            graph[v].append((u, time))\\n        \\n        max_quality = 0\\n        visited = {0}\\n        def dfs(node, visited, quality, time_left):\\n            nonlocal max_quality\\n            \\n            if node == 0:\\n                max_quality = max(max_quality, quality)\\n            \\n            for neighbor, time in graph[node]:\\n                if time <= time_left:\\n                    if neighbor in visited:\\n                        dfs(neighbor, visited, quality, time_left - time)\\n                    else:\\n                        visited.add(neighbor)\\n                        dfs(neighbor, visited, quality + values[neighbor], time_left - time)\\n                        visited.remove(neighbor)\\n        \\n        dfs(0, visited, values[0], maxTime)\\n        return max_quality\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251875,
                "title": "max-simplified-backtracking-cpp",
                "content": "# Why Backtracking ?\\nBecause we got at most 4 children of a node and no need of worrying out infinite recursive call as your DFS tree is bounded by the maxTime. Also look at constraints backtracking seems good bet.\\n# Logic \\n* Basically if you somehow were able reach to  the node 0  then you should update the sum you have with answer , this will be always valid as we have a conditional check \" if(currTime+child.second<=maxTime)\" while traversing. Thus we reach next recursive call only when our currTime is <=maxTime.\\n\\n* If the node\\'s frequency is one then this means that it was visited the very first time and we can add its value to our sum variable.\\n\\n* Before recursive call pops off the stack undo our work by decrementing node from hashmap (Essence of Backtracking ).\\n\\n```\\n    int ans=INT_MIN;// global variable\\n\\n    void dfs(vector<int>& values,vector<pair<int,int>> adj[],int& maxTime,int currTime,unordered_map<int,int>& frequency,int node,int sum)\\n    {\\n        frequency[node]++;// in both cases if visited before or first time increment its frequency\\n        \\n        if(frequency[node]==1)// visited first time\\n            sum+=values[node];\\n    \\n        if(node==0)// arrived at destination aka node 0\\n            ans=max(ans,sum);\\n        \\n         for(auto child:adj[node])// exploring children\\n         {\\n            if(currTime+child.second<=maxTime)// validation check\\n                 dfs(values,adj,maxTime,currTime+child.second,frequency,child.first,sum);   \\n         }\\n    \\n          if(--frequency[node]==0)frequency.erase(node);// backtrack from this node\\n    }\\n    \\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        \\n        int n=values.size();\\n        \\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto a:edges)\\n        {\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});// dont forget this undirected graph is given\\n        }\\n        \\n        unordered_map<int,int> frequency;\\n        \\n        dfs(values,adj,maxTime,0,frequency,0,0);\\n        \\n        return ans;\\n        \\n    }\\n```\\n\\n**The graph may not be connected**. This is just given to confuse us we only care about the component in which node 0 lies. No need to bother about the other components as we have to reach back to node 0.",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n    int ans=INT_MIN;// global variable\\n\\n    void dfs(vector<int>& values,vector<pair<int,int>> adj[],int& maxTime,int currTime,unordered_map<int,int>& frequency,int node,int sum)\\n    {\\n        frequency[node]++;// in both cases if visited before or first time increment its frequency\\n        \\n        if(frequency[node]==1)// visited first time\\n            sum+=values[node];\\n    \\n        if(node==0)// arrived at destination aka node 0\\n            ans=max(ans,sum);\\n        \\n         for(auto child:adj[node])// exploring children\\n         {\\n            if(currTime+child.second<=maxTime)// validation check\\n                 dfs(values,adj,maxTime,currTime+child.second,frequency,child.first,sum);   \\n         }\\n    \\n          if(--frequency[node]==0)frequency.erase(node);// backtrack from this node\\n    }\\n    \\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        \\n        int n=values.size();\\n        \\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto a:edges)\\n        {\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});// dont forget this undirected graph is given\\n        }\\n        \\n        unordered_map<int,int> frequency;\\n        \\n        dfs(values,adj,maxTime,0,frequency,0,0);\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1565396,
                "title": "c-2065-maximum-path-quality-of-a-graph",
                "content": "Based on @votrubac\\'s solution\\n```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size(); \\n        vector<vector<pair<int, int>>> graph(n); \\n        for (auto& x : edges) {\\n            graph[x[0]].emplace_back(x[1], x[2]); \\n            graph[x[1]].emplace_back(x[0], x[2]); \\n        }\\n        \\n        int ans = 0; \\n        vector<int> freq(n); freq[0] = 1; \\n        \\n        function<void(int, int, int)> fn = [&](int u, int time, int val) {\\n            if (u == 0) ans = max(ans, val); \\n            for (auto& [v, t] : graph[u]) \\n                if (time + t <= maxTime) {\\n                    if (++freq[v] == 1) fn(v, time+t, val + values[v]); \\n                    else fn(v, time+t, val); \\n                    --freq[v]; \\n                }\\n        }; \\n        \\n        fn(0, 0, values[0]); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size(); \\n        vector<vector<pair<int, int>>> graph(n); \\n        for (auto& x : edges) {\\n            graph[x[0]].emplace_back(x[1], x[2]); \\n            graph[x[1]].emplace_back(x[0], x[2]); \\n        }\\n        \\n        int ans = 0; \\n        vector<int> freq(n); freq[0] = 1; \\n        \\n        function<void(int, int, int)> fn = [&](int u, int time, int val) {\\n            if (u == 0) ans = max(ans, val); \\n            for (auto& [v, t] : graph[u]) \\n                if (time + t <= maxTime) {\\n                    if (++freq[v] == 1) fn(v, time+t, val + values[v]); \\n                    else fn(v, time+t, val); \\n                    --freq[v]; \\n                }\\n        }; \\n        \\n        fn(0, 0, values[0]); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563853,
                "title": "java-dfs-solution",
                "content": "Classic DFS. Since we can visit a node many times, it is necessary to keep its frequency in a hashmap. The code should explains itself.\\n```\\nclass Solution {\\n    Map<Integer, List<Pair<Integer, Integer>>> map = new HashMap<>(); // source, dest, time\\n    int max = 0;\\n    int[] values;\\n    \\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        this.values = values;\\n        \\n        // construct map\\n        for (int[] edge : edges) {\\n            int v1 = edge[0];\\n            int v2 = edge[1];\\n            int time = edge[2];\\n            \\n            insert(v1, new Pair(v2, time));\\n            insert(v2, new Pair(v1, time));\\n        }\\n        \\n        // use hashmap to record the path\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        freq.put(0, 1);\\n        dfs(0, maxTime, 0, freq);\\n        \\n        return max;\\n    }\\n    \\n    private void insert(int key, Pair<Integer, Integer> pair) {\\n        if (!map.containsKey(key)) {\\n            map.put(key, new ArrayList<>());\\n        }\\n        map.get(key).add(pair);\\n    }\\n    \\n    private void dfs(int root, int maxTime, int currTime, Map<Integer, Integer> freq) {\\n        if (currTime > maxTime) {\\n            return;\\n        }\\n        if (root == 0) {\\n            max = Math.max(max, computeValues(freq));\\n        }\\n        \\n        List<Pair<Integer, Integer>> neighbors = map.get(root);\\n            \\n        if (neighbors != null) {\\n            for (Pair<Integer, Integer> pair : neighbors) {\\n                int n_idx = pair.getKey();\\n                int n_time = pair.getValue();\\n                \\n                freq.put(n_idx, freq.getOrDefault(n_idx, 0) + 1);\\n                dfs(n_idx, maxTime, currTime + n_time, freq);\\n                freq.put(n_idx, freq.get(n_idx) - 1);\\n                \\n                // remember to remove the node if its frequency is 0\\n                if (freq.get(n_idx) == 0) {\\n                    freq.remove(n_idx);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private int computeValues(Map<Integer, Integer> freq) {\\n        int sum = 0;\\n        \\n        for (int idx : freq.keySet()) {\\n            sum += values[idx];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Pair<Integer, Integer>>> map = new HashMap<>(); // source, dest, time\\n    int max = 0;\\n    int[] values;\\n    \\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        this.values = values;\\n        \\n        // construct map\\n        for (int[] edge : edges) {\\n            int v1 = edge[0];\\n            int v2 = edge[1];\\n            int time = edge[2];\\n            \\n            insert(v1, new Pair(v2, time));\\n            insert(v2, new Pair(v1, time));\\n        }\\n        \\n        // use hashmap to record the path\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        freq.put(0, 1);\\n        dfs(0, maxTime, 0, freq);\\n        \\n        return max;\\n    }\\n    \\n    private void insert(int key, Pair<Integer, Integer> pair) {\\n        if (!map.containsKey(key)) {\\n            map.put(key, new ArrayList<>());\\n        }\\n        map.get(key).add(pair);\\n    }\\n    \\n    private void dfs(int root, int maxTime, int currTime, Map<Integer, Integer> freq) {\\n        if (currTime > maxTime) {\\n            return;\\n        }\\n        if (root == 0) {\\n            max = Math.max(max, computeValues(freq));\\n        }\\n        \\n        List<Pair<Integer, Integer>> neighbors = map.get(root);\\n            \\n        if (neighbors != null) {\\n            for (Pair<Integer, Integer> pair : neighbors) {\\n                int n_idx = pair.getKey();\\n                int n_time = pair.getValue();\\n                \\n                freq.put(n_idx, freq.getOrDefault(n_idx, 0) + 1);\\n                dfs(n_idx, maxTime, currTime + n_time, freq);\\n                freq.put(n_idx, freq.get(n_idx) - 1);\\n                \\n                // remember to remove the node if its frequency is 0\\n                if (freq.get(n_idx) == 0) {\\n                    freq.remove(n_idx);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private int computeValues(Map<Integer, Integer> freq) {\\n        int sum = 0;\\n        \\n        for (int idx : freq.keySet()) {\\n            sum += values[idx];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563769,
                "title": "weak-testcase",
                "content": "[0,32,43,1000]\\n[[0,1,10],[1,3,10],[2,3,35],[0,2,10]]\\n 49\\n \\n [0,32,43,1000]\\n[[0,2,10],[0,1,10],[1,3,10],[2,3,35]]\\n 49\\n \\nit\\'s giving wrong ans on my code but still it passed internal testcase\\n\\n`\\n     ArrayList<int[]> tree[];\\n\\t \\n\\t public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n          int n=values.length;\\n          tree=new ArrayList[n];\\n          for (int i = 0; i <n; i++) {\\n            tree[i]=new ArrayList<>();\\n          }\\n\\n         for (int x[]:edges) {\\n            tree[x[0]].add(new int[]{x[1],x[2]});\\n            tree[x[1]].add(new int[]{x[0],x[2]});\\n        }\\n        int m[]=new int[n];\\n         Queue<Node> q=new LinkedList<>();\\n         q.add(new Node(0,0,values[0],new HashSet<>()));\\n         int max=0;\\n         while (!q.isEmpty()){\\n             Node c=q.remove();\\n             int time=c.time;\\n             if(m[c.node]>c.val) continue;\\n             m[c.node]=c.val;\\n             if (c.node==0){\\n                 max=Math.max(max,c.val);\\n                \\n             }\\n\\n             for (int x[]:tree[c.node]) {\\n                 int newval=c.val;\\n                 if (!c.vis.contains(x[0])){\\n                    newval+=values[x[0]];\\n                 }\\n                 if (time+x[1]>maxTime) continue;\\n\\n                 q.add(new Node(\\n                        x[0],time+x[1],newval,c.vis\\n                ));\\n             }\\n         }\\n         return max;\\n    }\\n    static class Node{\\n        int node;\\n        int time;\\n        int val;\\n\\n        public Node(int node, int time, int val, HashSet<Integer> x) {\\n            this.node = node;\\n            this.time = time;\\n            this.val = val;\\n            vis.addAll(x);\\n            vis.add(node);\\n        }\\n\\n        HashSet<Integer> vis=new HashSet<>();\\n\\n    }\\n\\n`",
                "solutionTags": [],
                "code": "[0,32,43,1000]\\n[[0,1,10],[1,3,10],[2,3,35],[0,2,10]]\\n 49\\n \\n [0,32,43,1000]\\n[[0,2,10],[0,1,10],[1,3,10],[2,3,35]]\\n 49\\n \\nit\\'s giving wrong ans on my code but still it passed internal testcase\\n\\n`\\n     ArrayList<int[]> tree[];\\n\\t \\n\\t public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n          int n=values.length;\\n          tree=new ArrayList[n];\\n          for (int i = 0; i <n; i++) {\\n            tree[i]=new ArrayList<>();\\n          }\\n\\n         for (int x[]:edges) {\\n            tree[x[0]].add(new int[]{x[1],x[2]});\\n            tree[x[1]].add(new int[]{x[0],x[2]});\\n        }\\n        int m[]=new int[n];\\n         Queue<Node> q=new LinkedList<>();\\n         q.add(new Node(0,0,values[0],new HashSet<>()));\\n         int max=0;\\n         while (!q.isEmpty()){\\n             Node c=q.remove();\\n             int time=c.time;\\n             if(m[c.node]>c.val) continue;\\n             m[c.node]=c.val;\\n             if (c.node==0){\\n                 max=Math.max(max,c.val);\\n                \\n             }\\n\\n             for (int x[]:tree[c.node]) {\\n                 int newval=c.val;\\n                 if (!c.vis.contains(x[0])){\\n                    newval+=values[x[0]];\\n                 }\\n                 if (time+x[1]>maxTime) continue;\\n\\n                 q.add(new Node(\\n                        x[0],time+x[1],newval,c.vis\\n                ));\\n             }\\n         }\\n         return max;\\n    }\\n    static class Node{\\n        int node;\\n        int time;\\n        int val;\\n\\n        public Node(int node, int time, int val, HashSet<Integer> x) {\\n            this.node = node;\\n            this.time = time;\\n            this.val = val;\\n            vis.addAll(x);\\n            vis.add(node);\\n        }\\n\\n        HashSet<Integer> vis=new HashSet<>();\\n\\n    }\\n\\n`",
                "codeTag": "Java"
            },
            {
                "id": 1563743,
                "title": "python3-iterative-dfs",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/6b6e6b9115d2b659e68dcf3ea8e21befefaae16c) for solutions of weekly 266. \\n\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = [[] for _ in values]\\n        for u, v, t in edges: \\n            graph[u].append((v, t))\\n            graph[v].append((u, t))\\n        \\n        ans = 0 \\n        stack = [(0, values[0], 0, 1)]\\n        while stack: \\n            time, val, u, mask = stack.pop()\\n            if u == 0: ans = max(ans, val)\\n            for v, t in graph[u]: \\n                if time + t <= maxTime: \\n                    if not mask & 1<<v: stack.append((time+t, val+values[v], v, mask ^ 1<<v))\\n                    else: stack.append((time+t, val, v, mask))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = [[] for _ in values]\\n        for u, v, t in edges: \\n            graph[u].append((v, t))\\n            graph[v].append((u, t))\\n        \\n        ans = 0 \\n        stack = [(0, values[0], 0, 1)]\\n        while stack: \\n            time, val, u, mask = stack.pop()\\n            if u == 0: ans = max(ans, val)\\n            for v, t in graph[u]: \\n                if time + t <= maxTime: \\n                    if not mask & 1<<v: stack.append((time+t, val+values[v], v, mask ^ 1<<v))\\n                    else: stack.append((time+t, val, v, mask))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563699,
                "title": "java-c-dfs-with-optimization",
                "content": "A straightforward idea is to try all paths from node `0` and calculate the `max path quality` for paths also end with node `0`.\\n\\nOne **optimization** we can add is: once we cannot return back to node `0`, we stop. The `min_time` required from any node to node `0` can be pre-computed using *Dijkstra algorithm*.\\n\\n**Time complexity**: `O(4^10)`\\n\\n**Note the constraints**: `10 <= time_j, maxTime <= 100` and There are at most **four** edges connected to each node..\\nIt means the max levels of `dfs` search is `10`, and at each level we have maximum of `4` neighbouring nodes to try. \\nSo the time complexity is: `O(4^10)`.\\n\\n**Java solution**\\n```\\npublic int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n    final int N = values.length;\\n    List<List<int[]>> map = new ArrayList<>();\\n    for (int i = 0; i < N; i++) {\\n        map.add(new ArrayList<>());\\n    }\\n    for (int[] e : edges) {\\n        map.get(e[0]).add(new int[]{e[1], e[2]});\\n        map.get(e[1]).add(new int[]{e[0], e[2]});\\n    }\\n    \\n    int[] minTimeToZero = bfs(map, N);\\n    Set<Integer> visited = new HashSet<>();\\n    visited.add(0);\\n    int[] res = new int[]{0};\\n    dfs(map, minTimeToZero, N, values, 0, maxTime, visited, res);\\n    return res[0];\\n}\\n\\nprivate void dfs(List<List<int[]>> map, int[] minTimeToZero, int N, int[] values, int cur, int maxTime, Set<Integer> visited, int[] res) {\\n    if (cur == 0) {\\n        int sum = 0;\\n        for (int i : visited) {\\n            sum += values[i];\\n        }\\n        res[0] = Math.max(res[0], sum);\\n    }\\n    \\n    for (int[] nei : map.get(cur)) {\\n        if (minTimeToZero[nei[0]] + nei[1] <= maxTime) {\\n            boolean added = visited.add(nei[0]);\\n            dfs(map, minTimeToZero, N, values, nei[0], maxTime - nei[1], visited, res);\\n            if (added) {\\n                visited.remove(nei[0]);\\n            }\\n        }\\n    }\\n}\\n\\nprivate int[] bfs(List<List<int[]>> map, int N) {\\n    int[] minTimeToZero = new int[N];\\n    Arrays.fill(minTimeToZero, Integer.MAX_VALUE);\\n    PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\\n    q.offer(new int[]{0, 0});\\n    minTimeToZero[0] = 0;\\n    while (!q.isEmpty()) {\\n        int[] cur = q.poll();\\n        if (cur[1] > minTimeToZero[cur[0]]) {\\n            continue;\\n        }\\n        for (int[] nei : map.get(cur[0])) {\\n            if (nei[1] + cur[1] < minTimeToZero[nei[0]]) {\\n                minTimeToZero[nei[0]] = nei[1] + cur[1];\\n                q.offer(new int[]{nei[0], nei[1] + cur[1]});\\n            }\\n        }\\n    }\\n    return minTimeToZero;\\n}\\n```\\n\\n**C++ solution**\\n```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        const int N = values.size();\\n        vector<unordered_map<int, int>> mp(N, unordered_map<int, int>());\\n        for (const auto& e : edges) {\\n            mp[e[0]][e[1]] = e[2];\\n            mp[e[1]][e[0]] = e[2];\\n        }\\n        vector<int> min_time0 = bfs(mp, N);\\n        unordered_set<int> visited;\\n        visited.insert(0);\\n        int res = 0;\\n        dfs(mp, min_time0, values, 0, maxTime, visited, res);\\n        return res;\\n    }\\nprivate:\\n    void dfs(const vector<unordered_map<int, int>>& mp, const vector<int>& min_time0, const vector<int>& values, \\n             int cur, int max_time, unordered_set<int>& visited, int& res) {\\n        if (cur == 0) {\\n            int sum = 0;\\n            for (int i : visited) {\\n                sum += values[i];\\n            }\\n            res = max(sum, res);\\n        }\\n        \\n        for (const auto& [next, time] : mp[cur]) {\\n            if (time + min_time0[next] <= max_time) {\\n                bool added = visited.count(next) == 0;\\n                visited.insert(next);\\n                dfs(mp, min_time0, values, next, max_time - time, visited, res);\\n                if (added) {\\n                    visited.erase(next);\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> bfs(const vector<unordered_map<int, int>>& mp, const int N) {\\n        vector<int> min_time0(N, INT_MAX);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\\n        min_heap.push({0, 0});\\n        min_time0[0] = 0;\\n        while (!min_heap.empty()) {\\n            pair cur = min_heap.top();\\n            min_heap.pop();\\n            for (const auto& [next, time] : mp[cur.second]) {\\n                if (time + cur.first < min_time0[next]) {\\n                    min_time0[next] = time + cur.first;\\n                    min_heap.push({time + cur.first, next});\\n                }\\n            }\\n        }\\n        return min_time0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n    final int N = values.length;\\n    List<List<int[]>> map = new ArrayList<>();\\n    for (int i = 0; i < N; i++) {\\n        map.add(new ArrayList<>());\\n    }\\n    for (int[] e : edges) {\\n        map.get(e[0]).add(new int[]{e[1], e[2]});\\n        map.get(e[1]).add(new int[]{e[0], e[2]});\\n    }\\n    \\n    int[] minTimeToZero = bfs(map, N);\\n    Set<Integer> visited = new HashSet<>();\\n    visited.add(0);\\n    int[] res = new int[]{0};\\n    dfs(map, minTimeToZero, N, values, 0, maxTime, visited, res);\\n    return res[0];\\n}\\n\\nprivate void dfs(List<List<int[]>> map, int[] minTimeToZero, int N, int[] values, int cur, int maxTime, Set<Integer> visited, int[] res) {\\n    if (cur == 0) {\\n        int sum = 0;\\n        for (int i : visited) {\\n            sum += values[i];\\n        }\\n        res[0] = Math.max(res[0], sum);\\n    }\\n    \\n    for (int[] nei : map.get(cur)) {\\n        if (minTimeToZero[nei[0]] + nei[1] <= maxTime) {\\n            boolean added = visited.add(nei[0]);\\n            dfs(map, minTimeToZero, N, values, nei[0], maxTime - nei[1], visited, res);\\n            if (added) {\\n                visited.remove(nei[0]);\\n            }\\n        }\\n    }\\n}\\n\\nprivate int[] bfs(List<List<int[]>> map, int N) {\\n    int[] minTimeToZero = new int[N];\\n    Arrays.fill(minTimeToZero, Integer.MAX_VALUE);\\n    PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));\\n    q.offer(new int[]{0, 0});\\n    minTimeToZero[0] = 0;\\n    while (!q.isEmpty()) {\\n        int[] cur = q.poll();\\n        if (cur[1] > minTimeToZero[cur[0]]) {\\n            continue;\\n        }\\n        for (int[] nei : map.get(cur[0])) {\\n            if (nei[1] + cur[1] < minTimeToZero[nei[0]]) {\\n                minTimeToZero[nei[0]] = nei[1] + cur[1];\\n                q.offer(new int[]{nei[0], nei[1] + cur[1]});\\n            }\\n        }\\n    }\\n    return minTimeToZero;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        const int N = values.size();\\n        vector<unordered_map<int, int>> mp(N, unordered_map<int, int>());\\n        for (const auto& e : edges) {\\n            mp[e[0]][e[1]] = e[2];\\n            mp[e[1]][e[0]] = e[2];\\n        }\\n        vector<int> min_time0 = bfs(mp, N);\\n        unordered_set<int> visited;\\n        visited.insert(0);\\n        int res = 0;\\n        dfs(mp, min_time0, values, 0, maxTime, visited, res);\\n        return res;\\n    }\\nprivate:\\n    void dfs(const vector<unordered_map<int, int>>& mp, const vector<int>& min_time0, const vector<int>& values, \\n             int cur, int max_time, unordered_set<int>& visited, int& res) {\\n        if (cur == 0) {\\n            int sum = 0;\\n            for (int i : visited) {\\n                sum += values[i];\\n            }\\n            res = max(sum, res);\\n        }\\n        \\n        for (const auto& [next, time] : mp[cur]) {\\n            if (time + min_time0[next] <= max_time) {\\n                bool added = visited.count(next) == 0;\\n                visited.insert(next);\\n                dfs(mp, min_time0, values, next, max_time - time, visited, res);\\n                if (added) {\\n                    visited.erase(next);\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> bfs(const vector<unordered_map<int, int>>& mp, const int N) {\\n        vector<int> min_time0(N, INT_MAX);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\\n        min_heap.push({0, 0});\\n        min_time0[0] = 0;\\n        while (!min_heap.empty()) {\\n            pair cur = min_heap.top();\\n            min_heap.pop();\\n            for (const auto& [next, time] : mp[cur.second]) {\\n                if (time + cur.first < min_time0[next]) {\\n                    min_time0[next] = time + cur.first;\\n                    min_heap.push({time + cur.first, next});\\n                }\\n            }\\n        }\\n        return min_time0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785173,
                "title": "bfs-177ms-beats-100-00-of-users-with-python3",
                "content": "# Intuition\\nGraph question - first think about using BFS\\n\\n# Approach\\nBFS\\n\\n# Complexity\\n![Screenshot 2023-07-18 at 3.40.29 PM.png](https://assets.leetcode.com/users/images/7305d8e8-92d6-4b5e-be59-a806c94ce0db_1689720115.546126.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n\\n        graph = collections.defaultdict(list)\\n        for u, v, t in edges :\\n            graph[u].append((v,t))\\n            graph[v].append((u,t))\\n\\n        queue = collections.deque([(0, 0, values[0], [0])]) # (node, time, totalVal, path)\\n        valList = [(-1,-1)]*len(values)\\n        valList[0] = (values[0], 0)\\n        output = 0\\n        while queue :\\n            node, curTime, curVal, visited = queue.popleft()\\n            if node == 0 :\\n                output = max(output, curVal)\\n            for nxt, t in graph[node] :\\n                if curTime + t > maxTime :\\n                    continue\\n                nxtVal = curVal\\n                if nxt not in visited:\\n                    nxtVal += values[nxt]\\n                #This is the condition that significantly reduces the runtime\\n                if curTime+t >= valList[nxt][1] and nxtVal < valList[nxt][0] :\\n                    continue\\n                queue.append((nxt, curTime+t, nxtVal, visited + [nxt]))\\n                valList[nxt] = (nxtVal, curTime+t)\\n        return output\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n\\n        graph = collections.defaultdict(list)\\n        for u, v, t in edges :\\n            graph[u].append((v,t))\\n            graph[v].append((u,t))\\n\\n        queue = collections.deque([(0, 0, values[0], [0])]) # (node, time, totalVal, path)\\n        valList = [(-1,-1)]*len(values)\\n        valList[0] = (values[0], 0)\\n        output = 0\\n        while queue :\\n            node, curTime, curVal, visited = queue.popleft()\\n            if node == 0 :\\n                output = max(output, curVal)\\n            for nxt, t in graph[node] :\\n                if curTime + t > maxTime :\\n                    continue\\n                nxtVal = curVal\\n                if nxt not in visited:\\n                    nxtVal += values[nxt]\\n                #This is the condition that significantly reduces the runtime\\n                if curTime+t >= valList[nxt][1] and nxtVal < valList[nxt][0] :\\n                    continue\\n                queue.append((nxt, curTime+t, nxtVal, visited + [nxt]))\\n                valList[nxt] = (nxtVal, curTime+t)\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475175,
                "title": "here-s-my-journey-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThese kinds of problem are not very common , as normally the composer tries to make a problem interesting by mixing the use of differnt algorithm or making a different version of algorithm .\\nBut in this question It was just constraints Hell.\\n\\nWhich took a hell lot of time to resolve.\\n\\nAnd one more thing it\\'s not easy to calculate time complexity for such problems , I just gave it a go and thankfully it got accepted.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Just go through all possible which can start and also ent at 0 , but keep track of the visited node as they will be counted only once.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    vector<vector<pair<int , int>>> edges;\\n    vector<int> vis;\\n\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edgess, int maxTime) {\\n        \\n        int n = values.size();\\n        edges.resize(n);\\n        vis.resize(n);\\n\\n        ans = 0;\\n\\n\\n        for(auto vec : edgess) {\\n            edges[vec[0]].push_back({vec[1] , vec[2]});\\n            edges[vec[1]].push_back({vec[0] , vec[2]});\\n        }\\n        dfs(0 , 0 , values[0] , maxTime , values);\\n\\n        return ans;\\n\\n    }\\n\\n    void dfs(int node , int curr_time , int curr_sum , int mx_time , vector<int> &vals) {\\n        \\n        if(node == 0) {\\n            ans = max(ans , curr_sum);\\n        }\\n\\n        vis[node]++;\\n\\n        for(auto [next , time] : edges[node]) {\\n            if(curr_time + time > mx_time) continue;\\n            dfs(next , curr_time + time , curr_sum + (vis[next] ? 0 : vals[next]) , mx_time , vals);\\n        }\\n\\n        vis[node]--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    vector<vector<pair<int , int>>> edges;\\n    vector<int> vis;\\n\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edgess, int maxTime) {\\n        \\n        int n = values.size();\\n        edges.resize(n);\\n        vis.resize(n);\\n\\n        ans = 0;\\n\\n\\n        for(auto vec : edgess) {\\n            edges[vec[0]].push_back({vec[1] , vec[2]});\\n            edges[vec[1]].push_back({vec[0] , vec[2]});\\n        }\\n        dfs(0 , 0 , values[0] , maxTime , values);\\n\\n        return ans;\\n\\n    }\\n\\n    void dfs(int node , int curr_time , int curr_sum , int mx_time , vector<int> &vals) {\\n        \\n        if(node == 0) {\\n            ans = max(ans , curr_sum);\\n        }\\n\\n        vis[node]++;\\n\\n        for(auto [next , time] : edges[node]) {\\n            if(curr_time + time > mx_time) continue;\\n            dfs(next , curr_time + time , curr_sum + (vis[next] ? 0 : vals[next]) , mx_time , vals);\\n        }\\n\\n        vis[node]--;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137337,
                "title": "dfs-backtracking-c-easy-to-understand-60-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        int res = values[0];\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        dfs(graph, values, visited, res, 0, 0, 0, maxTime);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<pair<int,int>>>& graph, vector<int>& values, vector<int>& visited, int& res, int node, int score, int time, int& maxTime)\\n    {\\n        if(time > maxTime)\\n            return;\\n        \\n        if(visited[node] == 0)\\n            score += values[node];\\n        \\n        visited[node]++;\\n\\t\\t\\n      \\n        if(node == 0)\\n            res = max(res, score);\\n        \\n        for(auto it : graph[node])\\n        {\\n            int neigh = it.first;\\n            int newTime = time + it.second;\\n            dfs(graph, values, visited, res, neigh, score, newTime, maxTime);\\n        }\\n        \\n        visited[node]--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        int res = values[0];\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        dfs(graph, values, visited, res, 0, 0, 0, maxTime);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<pair<int,int>>>& graph, vector<int>& values, vector<int>& visited, int& res, int node, int score, int time, int& maxTime)\\n    {\\n        if(time > maxTime)\\n            return;\\n        \\n        if(visited[node] == 0)\\n            score += values[node];\\n        \\n        visited[node]++;\\n\\t\\t\\n      \\n        if(node == 0)\\n            res = max(res, score);\\n        \\n        for(auto it : graph[node])\\n        {\\n            int neigh = it.first;\\n            int newTime = time + it.second;\\n            dfs(graph, values, visited, res, neigh, score, newTime, maxTime);\\n        }\\n        \\n        visited[node]--;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137327,
                "title": "dfs-backtracking-c-easy-to-understand-60-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        int res = values[0];\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        dfs(graph, values, visited, res, 0, 0, 0, maxTime);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<pair<int,int>>>& graph, vector<int>& values, vector<int>& visited, int& res, int node, int score, int time, int& maxTime)\\n    {\\n        if(time > maxTime)\\n            return;\\n        \\n        if(visited[node] == 0)\\n            score += values[node];\\n        \\n        visited[node]++;\\n\\t\\t\\n      \\n        if(node == 0)\\n            res = max(res, score);\\n        \\n        for(auto it : graph[node])\\n        {\\n            int neigh = it.first;\\n            int newTime = time + it.second;\\n            dfs(graph, values, visited, res, neigh, score, newTime, maxTime);\\n        }\\n        \\n        visited[node]--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        int res = values[0];\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        dfs(graph, values, visited, res, 0, 0, 0, maxTime);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<pair<int,int>>>& graph, vector<int>& values, vector<int>& visited, int& res, int node, int score, int time, int& maxTime)\\n    {\\n        if(time > maxTime)\\n            return;\\n        \\n        if(visited[node] == 0)\\n            score += values[node];\\n        \\n        visited[node]++;\\n\\t\\t\\n      \\n        if(node == 0)\\n            res = max(res, score);\\n        \\n        for(auto it : graph[node])\\n        {\\n            int neigh = it.first;\\n            int newTime = time + it.second;\\n            dfs(graph, values, visited, res, neigh, score, newTime, maxTime);\\n        }\\n        \\n        visited[node]--;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818706,
                "title": "python-backtrack",
                "content": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        \\n        ans, res = values[0], 0\\n        nodes = defaultdict(list)\\n        for x,y,c in edges:\\n            nodes[x].append((y, c))\\n            nodes[y].append((x, c))\\n\\n        def backtrack(visit, time, value):\\n            nonlocal res\\n            x = visit[-1]\\n            if value > res and x == 0:\\n                res = value\\n            \\n            for y,c in nodes[x]:\\n                if  c + time <= maxTime:\\n                    total = value + values[y] if y not in visit else value\\n                    visit.append(y)\\n                    backtrack(visit, c + time, total)\\n                    visit.pop()\\n        \\n        backtrack([0], 0 , values[0])\\n        return res \\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        \\n        ans, res = values[0], 0\\n        nodes = defaultdict(list)\\n        for x,y,c in edges:\\n            nodes[x].append((y, c))\\n            nodes[y].append((x, c))\\n\\n        def backtrack(visit, time, value):\\n            nonlocal res\\n            x = visit[-1]\\n            if value > res and x == 0:\\n                res = value\\n            \\n            for y,c in nodes[x]:\\n                if  c + time <= maxTime:\\n                    total = value + values[y] if y not in visit else value\\n                    visit.append(y)\\n                    backtrack(visit, c + time, total)\\n                    visit.pop()\\n        \\n        backtrack([0], 0 , values[0])\\n        return res \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796379,
                "title": "python-commented-dfs-solution-concise",
                "content": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        # Creating an adjaceny list \\n        G = defaultdict(list)\\n        for u,v,w in edges:\\n            G[u].append([v,w])\\n            G[v].append([u,w])\\n            \\n        def dfs(current, path, left):\\n            # We calculate the total path quality when we reach Node 0\\n            # So the most trivial case would be when we just call dfs() the first time\\n            # Later on, if we end up tracking back to Node 0 Again, we have a candidate for a \"valid path\"\\n            # So we add up values for all the nodes in the set\\n            # We continue our dfs() until we have some time left\\n            if current == 0:\\n                tmp = 0\\n                for node in path:\\n                    tmp += values[node]\\n                self.best = max(self.best, tmp)\\n            # Moving to neighbour nodes and calling dfs() until time left\\n            for nei, wei in G[current]:\\n                if wei <= left:\\n                    dfs(nei, {nei} | path, left - wei)\\n        \\n        self.best = 0\\n        # Calling helper dfs() method\\n        # arguments signify : current node, current path set, time left \\n        dfs(0, {0}, maxTime)\\n        return self.best\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        # Creating an adjaceny list \\n        G = defaultdict(list)\\n        for u,v,w in edges:\\n            G[u].append([v,w])\\n            G[v].append([u,w])\\n            \\n        def dfs(current, path, left):\\n            # We calculate the total path quality when we reach Node 0\\n            # So the most trivial case would be when we just call dfs() the first time\\n            # Later on, if we end up tracking back to Node 0 Again, we have a candidate for a \"valid path\"\\n            # So we add up values for all the nodes in the set\\n            # We continue our dfs() until we have some time left\\n            if current == 0:\\n                tmp = 0\\n                for node in path:\\n                    tmp += values[node]\\n                self.best = max(self.best, tmp)\\n            # Moving to neighbour nodes and calling dfs() until time left\\n            for nei, wei in G[current]:\\n                if wei <= left:\\n                    dfs(nei, {nei} | path, left - wei)\\n        \\n        self.best = 0\\n        # Calling helper dfs() method\\n        # arguments signify : current node, current path set, time left \\n        dfs(0, {0}, maxTime)\\n        return self.best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674938,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& v, vector<vector<int>>& e, int m) {\\n        int res = 0, seen[1001]{};\\n        vector<pair<int, int>> g[1001];\\n        for(auto & i : e) {\\n            g[i[0]].push_back({i[1], i[2]});\\n            g[i[1]].push_back({i[0], i[2]});\\n        }\\n        auto dfs = [&](auto&& self, int n, int t, int cur) {\\n            if(t < 0) return;\\n            if(!seen[n]) cur += v[n];\\n            if(n == 0) res = max(cur, res);\\n            seen[n]++;\\n            for(auto & c : g[n]) self(self, c.first, t-c.second, cur);\\n            seen[n]--;\\n        };\\n        dfs(dfs, 0, m, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& v, vector<vector<int>>& e, int m) {\\n        int res = 0, seen[1001]{};\\n        vector<pair<int, int>> g[1001];\\n        for(auto & i : e) {\\n            g[i[0]].push_back({i[1], i[2]});\\n            g[i[1]].push_back({i[0], i[2]});\\n        }\\n        auto dfs = [&](auto&& self, int n, int t, int cur) {\\n            if(t < 0) return;\\n            if(!seen[n]) cur += v[n];\\n            if(n == 0) res = max(cur, res);\\n            seen[n]++;\\n            for(auto & c : g[n]) self(self, c.first, t-c.second, cur);\\n            seen[n]--;\\n        };\\n        dfs(dfs, 0, m, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369217,
                "title": "python-3-dfs-backtrack",
                "content": "\\tclass Solution:\\n\\t\\tdef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n\\t\\t\\tn=len(values)\\n\\t\\t\\tG=[[] for _ in range(n)]\\n\\t\\t\\tfor u,v,t in edges:\\n\\t\\t\\t\\tG[u].append([v,t])\\n\\t\\t\\t\\tG[v].append([u,t])\\n\\t\\t\\tself.res=0\\n\\t\\t\\tdef dfs(node,time,path,val):\\n\\t\\t\\t\\tif node==0:\\n\\t\\t\\t\\t\\tself.res=max(self.res,val)\\n\\t\\t\\t\\tfor child,t in G[node]:\\n\\t\\t\\t\\t\\tif time+t<=maxTime\\n\\t\\t\\t\\t\\t\\tif child in path:\\n\\t\\t\\t\\t\\t\\t\\tdfs(child,time+t,path,val)\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tpath.add(child)\\n\\t\\t\\t\\t\\t\\t\\tdfs(child,time+t,path,val+values[child])\\n\\t\\t\\t\\t\\t\\t\\tpath.remove(child)\\n\\t\\t\\tdfs(0,0,set([0]),values[0])\\n\\t\\t\\treturn self.res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n\\t\\t\\tn=len(values)\\n\\t\\t\\tG=[[] for _ in range(n)]\\n\\t\\t\\tfor u,v,t in edges:\\n\\t\\t\\t\\tG[u].append([v,t])\\n\\t\\t\\t\\tG[v].append([u,t])\\n\\t\\t\\tself.res=0\\n\\t\\t\\tdef dfs(node,time,path,val):\\n\\t\\t\\t\\tif node==0:\\n\\t\\t\\t\\t\\tself.res=max(self.res,val)\\n\\t\\t\\t\\tfor child,t in G[node]:\\n\\t\\t\\t\\t\\tif time+t<=maxTime\\n\\t\\t\\t\\t\\t\\tif child in path:\\n\\t\\t\\t\\t\\t\\t\\tdfs(child,time+t,path,val)\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tpath.add(child)\\n\\t\\t\\t\\t\\t\\t\\tdfs(child,time+t,path,val+values[child])\\n\\t\\t\\t\\t\\t\\t\\tpath.remove(child)\\n\\t\\t\\tdfs(0,0,set([0]),values[0])\\n\\t\\t\\treturn self.res",
                "codeTag": "Java"
            },
            {
                "id": 2206944,
                "title": "python-dfs-recursive",
                "content": "```\\nclass Solution:\\n    \\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        d = defaultdict(list)\\n        n = len(values)\\n        \\n        for edge in edges:\\n            d[edge[0]].append([edge[1], edge[2]])\\n            d[edge[1]].append([edge[0], edge[2]])\\n        \\n        visited = [0]*n\\n        ans = 0\\n        \\n        def dfs(node, curTime, total):\\n            nonlocal ans\\n            if curTime > maxTime:\\n                return\\n            \\n            if visited[node] == 0:\\n                total+= values[node]\\n            \\n            if node == 0:\\n                if total > ans:\\n                    ans = total\\n            \\n            visited[node] += 1\\n            \\n            for vertex, time in d[node]:\\n                dfs(vertex, curTime + time, total)\\n            \\n            visited[node] -= 1\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        d = defaultdict(list)\\n        n = len(values)\\n        \\n        for edge in edges:\\n            d[edge[0]].append([edge[1], edge[2]])\\n            d[edge[1]].append([edge[0], edge[2]])\\n        \\n        visited = [0]*n\\n        ans = 0\\n        \\n        def dfs(node, curTime, total):\\n            nonlocal ans\\n            if curTime > maxTime:\\n                return\\n            \\n            if visited[node] == 0:\\n                total+= values[node]\\n            \\n            if node == 0:\\n                if total > ans:\\n                    ans = total\\n            \\n            visited[node] += 1\\n            \\n            for vertex, time in d[node]:\\n                dfs(vertex, curTime + time, total)\\n            \\n            visited[node] -= 1\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158757,
                "title": "python-dfs-with-just-3-dimensions-using-node-traversal-count-to-stop",
                "content": "Its mentioned that : `There are at most four edges connected to each node.`\\nSo I have implemented a map to store how many times a `node` has been traversed.\\nI break the `dfs` process when the a node has been traversed for the `5th` time. \\nThis is because **`nodes should be traversed back and forth for a max of 4 times coz it can have only 4 edges max`**\\nHence the dfs gets stopped from running infinitely like `node0->node1->node0->node1.....`.\\nAlso we break when the cumulatime `time` taken exceeds the `maxTime`.\\nWhenever we reach node 0 , we store the total quality value `qual` so far in `sol`\\n\\n```py\\nclass Solution:\\n    def maximalPathQuality(self, quality: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph, sol = defaultdict(list), []\\n        sol = []\\n        for x, y, time in edges:\\n            graph[x].append((y, time))\\n            graph[y].append((x, time))\\n\\n        def dfs(node, time, qual):\\n            if node == 0: sol.append(qual)\\n            new_qual = qual\\n            for nxt_node, nxt_time in graph[node]:\\n                if time + nxt_time <= maxTime:\\n                    if vis[nxt_node] + 1 >= 5: return -inf\\n                    vis[nxt_node] += 1\\n                    new_qual = max(dfs(nxt_node, nxt_time + time, qual + quality[nxt_node] * (vis[nxt_node] == 1)), new_qual)\\n                    vis[nxt_node] -= 1\\n            return new_qual\\n\\n        vis = defaultdict(int, {0: 1})\\n        dfs(0, 0, quality[0])\\n        return max(sol)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9aed2db9-53bf-45cb-b502-db6949cc77f7_1655408346.8382185.png)\\n\\n\\n\\n\\n**Happy Coding !!**\\n\\nIn case of any questions, feel free to ask.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution:\\n    def maximalPathQuality(self, quality: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph, sol = defaultdict(list), []\\n        sol = []\\n        for x, y, time in edges:\\n            graph[x].append((y, time))\\n            graph[y].append((x, time))\\n\\n        def dfs(node, time, qual):\\n            if node == 0: sol.append(qual)\\n            new_qual = qual\\n            for nxt_node, nxt_time in graph[node]:\\n                if time + nxt_time <= maxTime:\\n                    if vis[nxt_node] + 1 >= 5: return -inf\\n                    vis[nxt_node] += 1\\n                    new_qual = max(dfs(nxt_node, nxt_time + time, qual + quality[nxt_node] * (vis[nxt_node] == 1)), new_qual)\\n                    vis[nxt_node] -= 1\\n            return new_qual\\n\\n        vis = defaultdict(int, {0: 1})\\n        dfs(0, 0, quality[0])\\n        return max(sol)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073961,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int rec(vector<int>& values, vector<vector<pair<int,int>>>& vec, int maxt,int x)\\n    {\\n        int ans=INT_MIN;\\n        if(x==0)\\n            ans=0;\\n        for(int i=0;i<vec[x].size();i++)\\n        {\\n            int a=vec[x][i].first,b=vec[x][i].second;\\n            if(b<=maxt)\\n            {\\n                int v=values[a];\\n                values[a]=0;\\n                int p=rec(values,vec,maxt-b,a);\\n                if(p!=INT_MIN)\\n                    ans=max(ans,p+v);\\n                values[a]=v;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxt) {\\n        int trav=0;\\n        vector<vector<pair<int,int>>> vec(values.size()+5);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int a=edges[i][0],b=edges[i][1],c=edges[i][2];\\n            vec[a].push_back({b,c});\\n            vec[b].push_back({a,c});\\n        }\\n        int v=values[0];\\n        values[0]=0;\\n        return rec(values,vec,maxt,0)+v; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(vector<int>& values, vector<vector<pair<int,int>>>& vec, int maxt,int x)\\n    {\\n        int ans=INT_MIN;\\n        if(x==0)\\n            ans=0;\\n        for(int i=0;i<vec[x].size();i++)\\n        {\\n            int a=vec[x][i].first,b=vec[x][i].second;\\n            if(b<=maxt)\\n            {\\n                int v=values[a];\\n                values[a]=0;\\n                int p=rec(values,vec,maxt-b,a);\\n                if(p!=INT_MIN)\\n                    ans=max(ans,p+v);\\n                values[a]=v;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxt) {\\n        int trav=0;\\n        vector<vector<pair<int,int>>> vec(values.size()+5);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int a=edges[i][0],b=edges[i][1],c=edges[i][2];\\n            vec[a].push_back({b,c});\\n            vec[b].push_back({a,c});\\n        }\\n        int v=values[0];\\n        values[0]=0;\\n        return rec(values,vec,maxt,0)+v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738863,
                "title": "python-dfs-recursive-with-cache-and-frozen-set",
                "content": "Idea inspired from @float4, using cashe to speed up the dfs so it\\'s do any unnecessary recalucations that were made before, however as cache doesn\\'t work with sets and maps, had to use a immuatble version of set --> [frozenset](https://www.programiz.com/python-programming/methods/built-in/frozenset) \\n\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph=defaultdict(list)\\n        \\n        for in_,out,cost in edges:\\n            graph[in_].append((out,cost))\\n            graph[out].append((in_,cost))\\n        \\n        \\n        self.max_res=0\\n        @cache\\n        def dfs(node,time,val,seen):\\n         \\n            if node==0:\\n                self.max_res=max(self.max_res,val)\\n            \\n            for neigh,t in graph[node]:\\n                if time+t>maxTime:\\n                      continue\\n                dfs(neigh,  time+t,  val+(neigh not in seen) * values[neigh],   seen | frozenset([neigh]) )\\n        dfs(0,0,values[0],frozenset([0]))\\n        return self.max_res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph=defaultdict(list)\\n        \\n        for in_,out,cost in edges:\\n            graph[in_].append((out,cost))\\n            graph[out].append((in_,cost))\\n        \\n        \\n        self.max_res=0\\n        @cache\\n        def dfs(node,time,val,seen):\\n         \\n            if node==0:\\n                self.max_res=max(self.max_res,val)\\n            \\n            for neigh,t in graph[node]:\\n                if time+t>maxTime:\\n                      continue\\n                dfs(neigh,  time+t,  val+(neigh not in seen) * values[neigh],   seen | frozenset([neigh]) )\\n        dfs(0,0,values[0],frozenset([0]))\\n        return self.max_res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654290,
                "title": "dfs-c-easy-to-understand",
                "content": "```\\nclass Solution {\\n    vector<vector<pair<int,int>>> grp;\\n    int ans;\\n    void dfs(int u,int cost,int gain,vector<int>& values,vector<int> &vis){\\n        if(!vis[u]) gain+=values[u];\\n        if(u==0) ans=max(ans,gain);\\n        vis[u]++;    \\n        for(auto j:grp[u])\\n            if(j.second<=cost) dfs(j.first,cost-j.second,gain,values,vis);\\n        vis[u]--;\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        grp.clear();\\n        ans=0;\\n        grp=vector<vector<pair<int,int>>> (n);\\n        for(auto &i:edges){\\n            grp[i[0]].push_back({i[1],i[2]});\\n            grp[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int> vis(n,0);\\n        dfs(0,maxTime,0,values,vis);\\n        return ans;\\n    }\\n};\\n```\\n\\nPassed in 128 ms.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<pair<int,int>>> grp;\\n    int ans;\\n    void dfs(int u,int cost,int gain,vector<int>& values,vector<int> &vis){\\n        if(!vis[u]) gain+=values[u];\\n        if(u==0) ans=max(ans,gain);\\n        vis[u]++;    \\n        for(auto j:grp[u])\\n            if(j.second<=cost) dfs(j.first,cost-j.second,gain,values,vis);\\n        vis[u]--;\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        grp.clear();\\n        ans=0;\\n        grp=vector<vector<pair<int,int>>> (n);\\n        for(auto &i:edges){\\n            grp[i[0]].push_back({i[1],i[2]});\\n            grp[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int> vis(n,0);\\n        dfs(0,maxTime,0,values,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574056,
                "title": "c-dfs",
                "content": "long long int max(long long int ans,long long int sum)\\n{\\n    return ans>=sum?ans:sum;\\n}\\nvoid fun(int a,vector<vector<pair<int,int>>>& g,vector<int>& values,int maxTime,long long int & sum,int & time,long long int & ans)\\n{\\n    if(a==0) {  ans=max(ans,sum);  }\\n    for(auto x : g[a])\\n    {\\n        if((time+x.second)<=maxTime)\\n        {\\n            sum=sum+values[x.first];\\n            int temp=values[x.first];\\n            values[x.first]=0;\\n            time=time+x.second;\\n            fun(x.first,g,values,maxTime,sum,time,ans);\\n            time=time-x.second;\\n            sum=sum-temp;\\n            values[x.first]=temp;\\n        }\\n    }\\n}\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {       \\n        long long int ans=INT_MIN;\\n        int n=values.size();\\n        vector<vector<pair<int,int>>> g(n);\\n        for(auto x : edges)\\n        {\\n            g[x[0]].push_back(make_pair(x[1],x[2]));\\n            g[x[1]].push_back(make_pair(x[0],x[2]));\\n        }\\n        ans=max(ans,values[0]);  long long int sum=values[0]; int time=0;  values[0]=0;\\n        fun(0,g,values,maxTime,sum,time,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {       \\n        long long int ans=INT_MIN;\\n        int n=values.size();\\n        vector<vector<pair<int,int>>> g(n);\\n        for(auto x : edges)\\n        {\\n            g[x[0]].push_back(make_pair(x[1],x[2]));\\n            g[x[1]].push_back(make_pair(x[0],x[2]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1572265,
                "title": "scala-functional-no-vars-dfs-solution",
                "content": "```\\n  def maximalPathQuality(values: Array[Int], edges: Array[Array[Int]], maxTime: Int): Int = {\\n    val adjList = edges.foldLeft(Map.empty[Int, Seq[(Int, Int)]].withDefaultValue(Seq.empty)) {\\n      case (adj, Array(n1, n2, cost)) =>\\n        adj\\n          .updated(n1, adj(n1) :+ (n2, cost))\\n          .updated(n2, adj(n2) :+ (n1, cost))\\n    }\\n\\n    def dfs(node: Int, visited: Set[Int], quality: Int, budget: Int): Int =\\n      adjList(node)\\n        .collect {\\n          case (next, cost) if (cost <= budget) =>\\n            val nextQuality = Option.when(!visited.contains(next))(values(next)).getOrElse(0)\\n            dfs(next, visited + next, quality + nextQuality, budget - cost)\\n        }\\n        .appendedAll(Option.when(node == 0)(quality))\\n        .maxOption\\n        .getOrElse(0)\\n\\n    dfs(node = 0, visited = Set(0), quality = values.head, budget = maxTime)\\n  }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n  def maximalPathQuality(values: Array[Int], edges: Array[Array[Int]], maxTime: Int): Int = {\\n    val adjList = edges.foldLeft(Map.empty[Int, Seq[(Int, Int)]].withDefaultValue(Seq.empty)) {\\n      case (adj, Array(n1, n2, cost)) =>\\n        adj\\n          .updated(n1, adj(n1) :+ (n2, cost))\\n          .updated(n2, adj(n2) :+ (n1, cost))\\n    }\\n\\n    def dfs(node: Int, visited: Set[Int], quality: Int, budget: Int): Int =\\n      adjList(node)\\n        .collect {\\n          case (next, cost) if (cost <= budget) =>\\n            val nextQuality = Option.when(!visited.contains(next))(values(next)).getOrElse(0)\\n            dfs(next, visited + next, quality + nextQuality, budget - cost)\\n        }\\n        .appendedAll(Option.when(node == 0)(quality))\\n        .maxOption\\n        .getOrElse(0)\\n\\n    dfs(node = 0, visited = Set(0), quality = values.head, budget = maxTime)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1564139,
                "title": "never-use-map-if-you-can-use-array-in-java-on-leetcode",
                "content": "Just backtracking solution for Q4, but I use `Map<Integer, Integer> visited`, then I get a TLE, after the contest, I tried `int[] visited`, and AC.\\n\\n\\nTLE code\\n```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        Map<Integer, Map<Integer, Integer>> edgeMap = new HashMap<>();\\n        for(int[] edge: edges){\\n            edgeMap.putIfAbsent(edge[0], new HashMap<>());\\n            edgeMap.get(edge[0]).put(edge[1], edge[2]);\\n            edgeMap.putIfAbsent(edge[1], new HashMap<>());\\n            edgeMap.get(edge[1]).put(edge[0], edge[2]);\\n        }\\n        Map<Integer, Integer> visited = new HashMap<>();\\n        visited.put(0, 1);\\n        backtrack(values, edgeMap, visited, 0, 0, maxTime, values[0]);\\n        return res;\\n    }\\n    \\n    int res = 0;\\n    \\n    void backtrack(int[] values, Map<Integer, Map<Integer, Integer>> edgeMap, Map<Integer, Integer> visited, int cur, int time, int maxTime, int gain){\\n        if(time > maxTime){\\n            return;\\n        }\\n        if(cur == 0){\\n            res = Math.max(res, gain);\\n        }\\n        if(!edgeMap.containsKey(cur)){\\n            return;\\n        }\\n        for(int next: edgeMap.get(cur).keySet()){\\n            int cost = edgeMap.get(cur).get(next);\\n            int value = visited.containsKey(next) ? 0 : values[next];\\n            visited.put(next, visited.getOrDefault(next, 0) + 1);\\n            backtrack(values, edgeMap, visited, next, time + cost, maxTime, gain + value);\\n            visited.put(next, visited.get(next) - 1);\\n            if(visited.get(next) == 0){\\n                visited.remove(next);\\n            }\\n        }\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        Map<Integer, Map<Integer, Integer>> edgeMap = new HashMap<>();\\n        for(int[] edge: edges){\\n            edgeMap.putIfAbsent(edge[0], new HashMap<>());\\n            edgeMap.get(edge[0]).put(edge[1], edge[2]);\\n            edgeMap.putIfAbsent(edge[1], new HashMap<>());\\n            edgeMap.get(edge[1]).put(edge[0], edge[2]);\\n        }\\n        Map<Integer, Integer> visited = new HashMap<>();\\n        visited.put(0, 1);\\n        backtrack(values, edgeMap, visited, 0, 0, maxTime, values[0]);\\n        return res;\\n    }\\n    \\n    int res = 0;\\n    \\n    void backtrack(int[] values, Map<Integer, Map<Integer, Integer>> edgeMap, Map<Integer, Integer> visited, int cur, int time, int maxTime, int gain){\\n        if(time > maxTime){\\n            return;\\n        }\\n        if(cur == 0){\\n            res = Math.max(res, gain);\\n        }\\n        if(!edgeMap.containsKey(cur)){\\n            return;\\n        }\\n        for(int next: edgeMap.get(cur).keySet()){\\n            int cost = edgeMap.get(cur).get(next);\\n            int value = visited.containsKey(next) ? 0 : values[next];\\n            visited.put(next, visited.getOrDefault(next, 0) + 1);\\n            backtrack(values, edgeMap, visited, next, time + cost, maxTime, gain + value);\\n            visited.put(next, visited.get(next) - 1);\\n            if(visited.get(next) == 0){\\n                visited.remove(next);\\n            }\\n        }\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564061,
                "title": "java-dfs-solution",
                "content": "Inspiration from @votrubac \\'s Plain DFS solution :\\nhttps://leetcode.com/problems/maximum-path-quality-of-a-graph/discuss/1563744/Plain-DFS\\n\\n```\\nclass Solution {\\n    \\n    int result = 0;\\n    List<List<int[]>> graph = new ArrayList<>();\\n    int[] values;\\n    int[] visited;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        \\n        int vertices = values.length;\\n        this.values = values;\\n    \\n        visited = new int[vertices];\\n        \\n        \\n        for (int i = 0; i < vertices; i++) {\\n            graph.add(new ArrayList<>());\\n             \\n         }\\n        \\n        for (int i = 0; i < edges.length; i++) {            \\n            \\n            int v1 = edges[i][0];\\n            int v2 = edges[i][1];\\n            int w = edges[i][2];            \\n            \\n            graph.get(v1).add(new int[]{v2, w});\\n            graph.get(v2).add(new int[]{v1, w});\\n        }\\n        \\n        dfs(0, visited, 0, maxTime);\\n        return result;\\n        \\n    }\\n    \\n    public void dfs(int node, int[] visited, int gain, int cost) {\\n        \\n        if (visited[node] == 0) {\\n            gain += values[node];\\n        }\\n        visited[node]++;\\n        \\n        if (node == 0) {\\n            result = Math.max(result, gain);\\n        }\\n        \\n        for (int[] n : graph.get(node)) {\\n            \\n            int neighbour = n[0];\\n            int w = n[1];\\n            \\n            if (w <= cost) {\\n                \\n                dfs(neighbour, visited, gain, cost - w);\\n            \\n            }\\n        }\\n        visited[node]--;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int result = 0;\\n    List<List<int[]>> graph = new ArrayList<>();\\n    int[] values;\\n    int[] visited;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        \\n        int vertices = values.length;\\n        this.values = values;\\n    \\n        visited = new int[vertices];\\n        \\n        \\n        for (int i = 0; i < vertices; i++) {\\n            graph.add(new ArrayList<>());\\n             \\n         }\\n        \\n        for (int i = 0; i < edges.length; i++) {            \\n            \\n            int v1 = edges[i][0];\\n            int v2 = edges[i][1];\\n            int w = edges[i][2];            \\n            \\n            graph.get(v1).add(new int[]{v2, w});\\n            graph.get(v2).add(new int[]{v1, w});\\n        }\\n        \\n        dfs(0, visited, 0, maxTime);\\n        return result;\\n        \\n    }\\n    \\n    public void dfs(int node, int[] visited, int gain, int cost) {\\n        \\n        if (visited[node] == 0) {\\n            gain += values[node];\\n        }\\n        visited[node]++;\\n        \\n        if (node == 0) {\\n            result = Math.max(result, gain);\\n        }\\n        \\n        for (int[] n : graph.get(node)) {\\n            \\n            int neighbour = n[0];\\n            int w = n[1];\\n            \\n            if (w <= cost) {\\n                \\n                dfs(neighbour, visited, gain, cost - w);\\n            \\n            }\\n        }\\n        visited[node]--;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564000,
                "title": "java-backtracking-concise-o-4-10",
                "content": "Backtracking with the length of the paths limited to 10 at most. The branch factor is 4. So Time O(4^10).\\n\\n```\\nclass Solution {\\n    Map<Integer, Map<Integer, Integer> > g = new HashMap();\\n    int res = 0;\\n    int[] values;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        this.values = values;\\n        for(int[] e : edges) {\\n            int u = e[0], v = e[1], t = e[2];\\n            g.computeIfAbsent(u, x -> new HashMap()).put(v, t);\\n            g.computeIfAbsent(v, x -> new HashMap()).put(u, t);\\n        }\\n        dfs(new ArrayList(), 0, maxTime, 0);\\n        return res;\\n    }\\n    void dfs(List<Integer> path, int cur, int maxTime, int time) {\\n        path.add(cur);\\n        if(cur == 0) {\\n            int tmp = 0;\\n            Set<Integer> hs = new HashSet();\\n            for(int i : path) {\\n                if(hs.add(i)) tmp += values[i];\\n            }\\n            res = Math.max(res, tmp);\\n        }\\n        for(var en : g.getOrDefault(cur, new HashMap<>()).entrySet()) {\\n            int nei = en.getKey(), t = en.getValue();\\n            if(t + time > maxTime) continue;\\n            dfs(path, nei, maxTime, t + time);\\n        }\\n        path.remove(path.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Map<Integer, Integer> > g = new HashMap();\\n    int res = 0;\\n    int[] values;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        this.values = values;\\n        for(int[] e : edges) {\\n            int u = e[0], v = e[1], t = e[2];\\n            g.computeIfAbsent(u, x -> new HashMap()).put(v, t);\\n            g.computeIfAbsent(v, x -> new HashMap()).put(u, t);\\n        }\\n        dfs(new ArrayList(), 0, maxTime, 0);\\n        return res;\\n    }\\n    void dfs(List<Integer> path, int cur, int maxTime, int time) {\\n        path.add(cur);\\n        if(cur == 0) {\\n            int tmp = 0;\\n            Set<Integer> hs = new HashSet();\\n            for(int i : path) {\\n                if(hs.add(i)) tmp += values[i];\\n            }\\n            res = Math.max(res, tmp);\\n        }\\n        for(var en : g.getOrDefault(cur, new HashMap<>()).entrySet()) {\\n            int nei = en.getKey(), t = en.getValue();\\n            if(t + time > maxTime) continue;\\n            dfs(path, nei, maxTime, t + time);\\n        }\\n        path.remove(path.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563939,
                "title": "c-dfs",
                "content": "<strong>Logical Thinking</strong>\\n<p>Since each node\\'s value can be added only once, we\\'d better use <strong>Depth-First Search</strong> to solve this problem. So we start from node <code>0</code>, and try all possible paths (edges can be used more than once). Each time we come to a new node which is not counted before, update the current quality with its value. Whenever we come back to node <code>0</code>, update the answer with current quality. If current time is larger than the maximal time, stop the current path and try the next one.</p>\\n\\n\\n<strong>C++</strong>\\n\\n```\\n// Topic     : 2065. Maximum Path Quality of a Graph (https://leetcode.com/problems/maximum-path-quality-of-a-graph/)\\n// Author    : YCX\\n// Time      : O(max<int>(M + N, T / minE))\\n// Space     : O(M + N)\\n\\n\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        unordered_map<int, vector<pair<int, int>>> connect;\\n        for (auto e : edges)\\n        {\\n            connect[e[0]].push_back({e[1], e[2]});\\n            connect[e[1]].push_back({e[0], e[2]});\\n        }\\n        int n = values.size(), ans = 0;\\n        vector<int> cal(n, 0);\\n        cal[0] = 1;\\n        dfs(0, connect, cal, values, values[0], maxTime, 0, ans);\\n        return ans;\\n    }\\n    \\nprivate: \\n    void dfs(int start, unordered_map<int, vector<pair<int, int>>>& connect, vector<int>& cal, vector<int>& values, int curQuality, int maxTime, int curTime, int& ans)\\n    {\\n        if (curTime > maxTime)\\n            return;\\n        if (start == 0)\\n            ans = max<int>(ans, curQuality);\\n        for (auto i : connect[start])\\n        {\\n            if (cal[i.first] == 0)\\n            {\\n                cal[i.first] = 1;\\n                dfs(i.first, connect, cal, values, curQuality + values[i.first], maxTime, curTime + i.second, ans);\\n                cal[i.first] = 0;\\n            }\\n            else\\n                dfs(i.first, connect, cal, values, curQuality, maxTime, curTime + i.second, ans);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n// Topic     : 2065. Maximum Path Quality of a Graph (https://leetcode.com/problems/maximum-path-quality-of-a-graph/)\\n// Author    : YCX\\n// Time      : O(max<int>(M + N, T / minE))\\n// Space     : O(M + N)\\n\\n\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        unordered_map<int, vector<pair<int, int>>> connect;\\n        for (auto e : edges)\\n        {\\n            connect[e[0]].push_back({e[1], e[2]});\\n            connect[e[1]].push_back({e[0], e[2]});\\n        }\\n        int n = values.size(), ans = 0;\\n        vector<int> cal(n, 0);\\n        cal[0] = 1;\\n        dfs(0, connect, cal, values, values[0], maxTime, 0, ans);\\n        return ans;\\n    }\\n    \\nprivate: \\n    void dfs(int start, unordered_map<int, vector<pair<int, int>>>& connect, vector<int>& cal, vector<int>& values, int curQuality, int maxTime, int curTime, int& ans)\\n    {\\n        if (curTime > maxTime)\\n            return;\\n        if (start == 0)\\n            ans = max<int>(ans, curQuality);\\n        for (auto i : connect[start])\\n        {\\n            if (cal[i.first] == 0)\\n            {\\n                cal[i.first] = 1;\\n                dfs(i.first, connect, cal, values, curQuality + values[i.first], maxTime, curTime + i.second, ans);\\n                cal[i.first] = 0;\\n            }\\n            else\\n                dfs(i.first, connect, cal, values, curQuality, maxTime, curTime + i.second, ans);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563899,
                "title": "easy-understanding-java-code-plain-dfs",
                "content": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        int[] res = new int[]{Integer.MIN_VALUE};\\n        List<List<int[]>> graph = buildGraph(n, edges);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        helper(graph, values, 0, 0, maxTime, visited, res);\\n        return res[0];\\n    }\\n    private void helper(List<List<int[]>> graph, int[] values, int curNode, int curTime, int maxTime, Set<Integer> visited, int[] res) {\\n        if (curTime > maxTime) {\\n            return;\\n        }\\n        if (curNode == 0) {\\n            int tmp = 0;\\n            for (int key : visited) {\\n                tmp += values[key];\\n            }\\n            res[0] = Math.max(res[0], tmp);\\n        }\\n        for (int[] info : graph.get(curNode)) {\\n            int neiborNode = info[0];\\n            int neiborTimeCost = info[1];\\n            boolean flag = visited.add(neiborNode);\\n            helper(graph, values, neiborNode, curTime + neiborTimeCost, maxTime, visited, res);\\n            if (flag) {\\n                visited.remove(neiborNode);\\n            }\\n        }\\n    }\\n    private List<List<int[]>> buildGraph(int n, int[][] edges) {\\n        List<List<int[]>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] e : edges) {\\n            graph.get(e[0]).add(new int[]{e[1], e[2]});\\n            graph.get(e[1]).add(new int[]{e[0], e[2]});\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        int[] res = new int[]{Integer.MIN_VALUE};\\n        List<List<int[]>> graph = buildGraph(n, edges);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        helper(graph, values, 0, 0, maxTime, visited, res);\\n        return res[0];\\n    }\\n    private void helper(List<List<int[]>> graph, int[] values, int curNode, int curTime, int maxTime, Set<Integer> visited, int[] res) {\\n        if (curTime > maxTime) {\\n            return;\\n        }\\n        if (curNode == 0) {\\n            int tmp = 0;\\n            for (int key : visited) {\\n                tmp += values[key];\\n            }\\n            res[0] = Math.max(res[0], tmp);\\n        }\\n        for (int[] info : graph.get(curNode)) {\\n            int neiborNode = info[0];\\n            int neiborTimeCost = info[1];\\n            boolean flag = visited.add(neiborNode);\\n            helper(graph, values, neiborNode, curTime + neiborTimeCost, maxTime, visited, res);\\n            if (flag) {\\n                visited.remove(neiborNode);\\n            }\\n        }\\n    }\\n    private List<List<int[]>> buildGraph(int n, int[][] edges) {\\n        List<List<int[]>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] e : edges) {\\n            graph.get(e[0]).add(new int[]{e[1], e[2]});\\n            graph.get(e[1]).add(new int[]{e[0], e[2]});\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563810,
                "title": "i-have-one-conjecture-need-some1-to-prove-for-optimal-pruning-during-dfs-search",
                "content": "Hi, my statement is that:\\n\\n```\\n\"This path(or at least one of the best path)  won\\'t contain duplicate directional edge. \"\\n```\\n\\nI mean it can contain 0->1 and 1->0, but it won\\'t contian two 0->1.",
                "solutionTags": [],
                "code": "```\\n\"This path(or at least one of the best path)  won\\'t contain duplicate directional edge. \"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563796,
                "title": "python-simple-dijkstra",
                "content": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = defaultdict(dict) # dict of dict to store weights\\n        pq = []\\n        res = 0\\n\\n        heapq.heappush(pq, (-values[0], 0, 0, {0})) # quality, time, index, nodes\\n\\n        for i in range(len(edges)):\\n            u, v, w = edges[i]\\n            graph[u][v] = w\\n            graph[v][u] = w\\n\\n        while pq:\\n            top = heapq.heappop(pq)\\n            u = top[2]\\n            if u == 0:\\n                res = max(res, -top[0])\\n            for v in graph[u]:\\n                time = top[1] + graph[u][v]\\n                nodes = top[3].copy()\\n                if time <= maxTime:\\n                    if v in nodes:\\n                        heapq.heappush(pq, (top[0], time, v, nodes))\\n                    else:\\n                        nodes.add(v)\\n                        heapq.heappush(pq, (top[0] - values[v], time, v, nodes))\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = defaultdict(dict) # dict of dict to store weights\\n        pq = []\\n        res = 0\\n\\n        heapq.heappush(pq, (-values[0], 0, 0, {0})) # quality, time, index, nodes\\n\\n        for i in range(len(edges)):\\n            u, v, w = edges[i]\\n            graph[u][v] = w\\n            graph[v][u] = w\\n\\n        while pq:\\n            top = heapq.heappop(pq)\\n            u = top[2]\\n            if u == 0:\\n                res = max(res, -top[0])\\n            for v in graph[u]:\\n                time = top[1] + graph[u][v]\\n                nodes = top[3].copy()\\n                if time <= maxTime:\\n                    if v in nodes:\\n                        heapq.heappush(pq, (top[0], time, v, nodes))\\n                    else:\\n                        nodes.add(v)\\n                        heapq.heappush(pq, (top[0] - values[v], time, v, nodes))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563713,
                "title": "python-simple-brute-force-dfs-o-4-10",
                "content": "We can just DFS / backtrack the graph starting from the initial node in the simplistic way. Cyclic paths are allowed because visited nodes are not filtered out as they are in typical graph traversal. There won\\'t be stack overflow since the constraints on input are pretty small. \\n\\n> There are *at most four* edges connected to each node.\\n\\nFor every nodes, we have at most four neighbours to traverse.\\n\\n> `10 <= timej, maxTime <= 100`\\n\\n`maxTime / time_j <= 10` and hence the maximum path length is at most `10`.\\n\\nAt each DFS/backtracking level, we have at most 4 sub-functions to call. And the depths of DFS/backtracking are at most `10`. So we have `T = O(4^10) = O(2^20)`, which is reasonble to get accepted.\\n\\n\\n```python\\n\\nfrom collections import defaultdict, Counter\\n\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        g = defaultdict(dict) # construct the graph\\n        for a, b, t in edges:\\n            g[a][b] = t\\n            g[b][a] = t\\n        \\n        mpq = pq = 0 # global maximal path quality, path quality of the current path\\n        remaining_time = maxTime\\n        visited = Counter() # nodes of the current path\\n        def backtrack(node):\\n            nonlocal pq, mpq, remaining_time\\n            visited[node] += 1\\n            if visited[node] == 1: # one more unique node\\n                pq += values[node] # update path quality\\n            if node == 0: # path is valid (from 0 to 0)\\n                mpq = max(mpq, pq) # update maximal path quality\\n            for neigh, time in g[node].items():\\n                if remaining_time >= time:\\n                    remaining_time -= time\\n                    backtrack(neigh)\\n                    remaining_time += time\\n            visited[node] -= 1\\n            if visited[node] == 0:\\n                del visited[node]\\n                pq -= values[node]\\n        backtrack(0)\\n        return mpq\\n```",
                "solutionTags": [],
                "code": "```python\\n\\nfrom collections import defaultdict, Counter\\n\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        g = defaultdict(dict) # construct the graph\\n        for a, b, t in edges:\\n            g[a][b] = t\\n            g[b][a] = t\\n        \\n        mpq = pq = 0 # global maximal path quality, path quality of the current path\\n        remaining_time = maxTime\\n        visited = Counter() # nodes of the current path\\n        def backtrack(node):\\n            nonlocal pq, mpq, remaining_time\\n            visited[node] += 1\\n            if visited[node] == 1: # one more unique node\\n                pq += values[node] # update path quality\\n            if node == 0: # path is valid (from 0 to 0)\\n                mpq = max(mpq, pq) # update maximal path quality\\n            for neigh, time in g[node].items():\\n                if remaining_time >= time:\\n                    remaining_time -= time\\n                    backtrack(neigh)\\n                    remaining_time += time\\n            visited[node] -= 1\\n            if visited[node] == 0:\\n                del visited[node]\\n                pq -= values[node]\\n        backtrack(0)\\n        return mpq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048924,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        int res = values[0];\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        dfs(graph, values, visited, res, 0, 0, 0, maxTime);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<pair<int,int>>>& graph, vector<int>& values, vector<int>& visited, int& res, int node, int score, int time, int& maxTime)\\n    {\\n        if(time > maxTime)\\n            return;\\n        \\n        if(visited[node] == 0)\\n            score += values[node];\\n        \\n        visited[node]++;\\n\\t\\t\\n      \\n        if(node == 0)\\n            res = max(res, score);\\n        \\n        for(auto it : graph[node])\\n        {\\n            int neigh = it.first;\\n            int newTime = time + it.second;\\n            dfs(graph, values, visited, res, neigh, score, newTime, maxTime);\\n        }\\n        \\n        visited[node]--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        int res = values[0];\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        dfs(graph, values, visited, res, 0, 0, 0, maxTime);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<pair<int,int>>>& graph, vector<int>& values, vector<int>& visited, int& res, int node, int score, int time, int& maxTime)\\n    {\\n        if(time > maxTime)\\n            return;\\n        \\n        if(visited[node] == 0)\\n            score += values[node];\\n        \\n        visited[node]++;\\n\\t\\t\\n      \\n        if(node == 0)\\n            res = max(res, score);\\n        \\n        for(auto it : graph[node])\\n        {\\n            int neigh = it.first;\\n            int newTime = time + it.second;\\n            dfs(graph, values, visited, res, neigh, score, newTime, maxTime);\\n        }\\n        \\n        visited[node]--;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039882,
                "title": "easy-backtracking-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sol(vector<pair<int,int>> adj[],vector<int> &values,int maxTime,int &ans,vector<int> &visi,int node,int time){\\n        if(node == 0 && time <= maxTime){\\n            int temp = 0;\\n            for(int i=0;i<visi.size();i++){\\n                if(visi[i] == 1){\\n                    temp += values[i];\\n                }\\n            }\\n            ans = max(ans,temp);\\n        }\\n        if(time > maxTime){\\n            return;\\n        }\\n        for(auto i:adj[node]){\\n            if(i.second + time <= maxTime){\\n                bool check = visi[node];\\n                visi[node] = true;\\n                sol(adj,values,maxTime,ans,visi,i.first,time+i.second);\\n                if(!check) visi[node] = false;\\n            }\\n        }\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        vector<pair<int,int>> adj[values.size()];\\n        for(auto i:edges){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int> visi(values.size(),0);\\n        int ans = INT_MIN;\\n        visi[0] = 1;\\n        sol(adj,values,maxTime,ans,visi,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sol(vector<pair<int,int>> adj[],vector<int> &values,int maxTime,int &ans,vector<int> &visi,int node,int time){\\n        if(node == 0 && time <= maxTime){\\n            int temp = 0;\\n            for(int i=0;i<visi.size();i++){\\n                if(visi[i] == 1){\\n                    temp += values[i];\\n                }\\n            }\\n            ans = max(ans,temp);\\n        }\\n        if(time > maxTime){\\n            return;\\n        }\\n        for(auto i:adj[node]){\\n            if(i.second + time <= maxTime){\\n                bool check = visi[node];\\n                visi[node] = true;\\n                sol(adj,values,maxTime,ans,visi,i.first,time+i.second);\\n                if(!check) visi[node] = false;\\n            }\\n        }\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        vector<pair<int,int>> adj[values.size()];\\n        for(auto i:edges){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int> visi(values.size(),0);\\n        int ans = INT_MIN;\\n        visi[0] = 1;\\n        sol(adj,values,maxTime,ans,visi,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974153,
                "title": "c-backtraking-dfs",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    List<Distance>[] _graph;\\n    int[] _seen;\\n    int _maxTime; \\n    int[] _values;\\n    int _ans;\\n    public int MaximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        _values = values;\\n        _maxTime = maxTime;\\n        Prepare(edges);\\n        DFS(0, 0, 0);\\n        return _ans;\\n    }\\n\\n    void DFS(int node, int currTime, int curSum){\\n        if(currTime > _maxTime) return;\\n        if(_seen[node] == 0)\\n            curSum += _values[node];\\n        if(node == 0)\\n            _ans = Math.Max(_ans, curSum);\\n        _seen[node]++;\\n        foreach(var el in _graph[node]){\\n            var (to, time) = el;\\n            DFS(to, time + currTime, curSum);\\n        }\\n        _seen[node]--;\\n    }\\n\\n    void Prepare(int[][] edges){\\n        var n = _values.Length;\\n        _graph = new List<Distance>[n];\\n        _seen = new int[n];\\n        for(var i = 0; i < n; i++) _graph[i] = new List<Distance>();\\n        foreach(var el in edges){\\n            var node1 = el[0];\\n            var node2 = el[1];\\n            var time = el[2];\\n            _graph[node1].Add(new Distance(node2, time));\\n            _graph[node2].Add(new Distance(node1, time));\\n        }\\n    }\\n\\n    public record Distance(int To, int Time);\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    List<Distance>[] _graph;\\n    int[] _seen;\\n    int _maxTime; \\n    int[] _values;\\n    int _ans;\\n    public int MaximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        _values = values;\\n        _maxTime = maxTime;\\n        Prepare(edges);\\n        DFS(0, 0, 0);\\n        return _ans;\\n    }\\n\\n    void DFS(int node, int currTime, int curSum){\\n        if(currTime > _maxTime) return;\\n        if(_seen[node] == 0)\\n            curSum += _values[node];\\n        if(node == 0)\\n            _ans = Math.Max(_ans, curSum);\\n        _seen[node]++;\\n        foreach(var el in _graph[node]){\\n            var (to, time) = el;\\n            DFS(to, time + currTime, curSum);\\n        }\\n        _seen[node]--;\\n    }\\n\\n    void Prepare(int[][] edges){\\n        var n = _values.Length;\\n        _graph = new List<Distance>[n];\\n        _seen = new int[n];\\n        for(var i = 0; i < n; i++) _graph[i] = new List<Distance>();\\n        foreach(var el in edges){\\n            var node1 = el[0];\\n            var node2 = el[1];\\n            var time = el[2];\\n            _graph[node1].Add(new Distance(node2, time));\\n            _graph[node2].Add(new Distance(node1, time));\\n        }\\n    }\\n\\n    public record Distance(int To, int Time);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952666,
                "title": "simple-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(int node,int maxTime,vector<int> &vis,vector<vector<pair<int,int>>> &adj,int &sum,vector<int> &values){\\n        vis[node]++;\\n        if(vis[node]==1) sum+=values[node];\\n        if(node==0) ans=max(ans,sum);\\n        for(auto it:adj[node]){\\n            if(it.second<=maxTime){\\n                dfs(it.first,maxTime-it.second,vis,adj,sum,values);\\n            }\\n        }\\n        vis[node]--;\\n        if(vis[node]==0) sum-=values[node];\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<vector<pair<int,int>>> adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0],v=edges[i][1],wt=edges[i][2];\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        vector<int> vis(n,0);\\n        int sum=0;\\n        dfs(0,maxTime,vis,adj,sum,values);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(int node,int maxTime,vector<int> &vis,vector<vector<pair<int,int>>> &adj,int &sum,vector<int> &values){\\n        vis[node]++;\\n        if(vis[node]==1) sum+=values[node];\\n        if(node==0) ans=max(ans,sum);\\n        for(auto it:adj[node]){\\n            if(it.second<=maxTime){\\n                dfs(it.first,maxTime-it.second,vis,adj,sum,values);\\n            }\\n        }\\n        vis[node]--;\\n        if(vis[node]==0) sum-=values[node];\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<vector<pair<int,int>>> adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0],v=edges[i][1],wt=edges[i][2];\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        vector<int> vis(n,0);\\n        int sum=0;\\n        dfs(0,maxTime,vis,adj,sum,values);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919377,
                "title": "dfs-and-djikstra-approach",
                "content": "# Intuition:\\nAt some point along a path, there is a point where it is impossible to get back to the source node under the Max Time.\\nWith that in mind, whenever we reach a node, we should check whether it\\'s even possible to return back to the source node, if not, then let\\'s stop there and not calculate the rest of that invalid path. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe most intuitive approach is to do dfs. My implementation incorporates DFS along with Djikstra\\'s algorithm.\\n\\nI used Djikstra\\'s algorithm to get the minimum required time to get back to the source node, in this case 0, from each node -- and put them into a map called \\'minTimes\\'. I believe the code is self explanatory.\\n\\nThe DFS part will go through the nodes starting from node 0, and will run the following condition at the start\\n\\n```\\nif(minTimes[curNode] + curTime > maxTime)\\n    return;\\n```\\nHere we look at the minTimes map we created and check whether it is possible to return back to the source node under the maxTime, if not, we return.\\n\\nOtherwise, we continue going through the edges of the graph and updating maxScore as long as we can return back to node 0 -- from the current node.\\n\\n\\nThanks for reading!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<int, vector<pair<int,int>>>& graph, int curNode, vector<int>& visited, int curTime, int maxTime, vector<int>& values, int& ret, int curScore, unordered_map<int,int>& minTimes){\\n\\n        //return if we can\\'t reach 0 node from this node\\n        if(minTimes[curNode] + curTime > maxTime)\\n            return;\\n\\n        if(visited[curNode] == 0)\\n            curScore += values[curNode];\\n\\n        ++visited[curNode];\\n\\n        //we can reach 0 node from here, update maxScore\\n        ret = max(ret, curScore);\\n\\n        //go through other nodes\\n        for(int i = 0; i < graph[curNode].size(); ++i){\\n            int nextNode = graph[curNode][i].first;\\n            int nextTime = graph[curNode][i].second;\\n            dfs(graph, nextNode, visited, curTime + nextTime, maxTime, values, ret, curScore, minTimes);\\n        }\\n        --visited[curNode];\\n    }\\n\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        \\n        //pair: 1st val: node   2nd val: time\\n        unordered_map<int, vector<pair<int,int>>> graph;\\n\\n        for(int i = 0; i < edges.size(); ++i){\\n            int node1 = edges[i][0];\\n            int node2 = edges[i][1];\\n            int time = edges[i][2];\\n\\n            graph[node1].push_back({node2, time});\\n            graph[node2].push_back({node1, time});\\n        }\\n\\n        //djikstra part. get min times to get from one node back to node 0\\n        unordered_map<int,int> minTimes;\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, 0});\\n        unordered_set<int> visited;\\n        while(!pq.empty()){\\n            int curTime = pq.top().first;\\n            int curNode = pq.top().second;\\n            pq.pop();\\n\\n            if(visited.find(curNode) != visited.end())\\n                continue;\\n            visited.insert(curNode);\\n            minTimes[curNode] = curTime;\\n            \\n            for(int i = 0; i < graph[curNode].size(); ++i){\\n                int nextNode = graph[curNode][i].first;\\n                int nextTime = graph[curNode][i].second;\\n\\n                pq.push({curTime + nextTime, nextNode});\\n            }\\n        }\\n\\n        //dfs\\n        \\n        int ret = 0;\\n        vector<int> visited2(values.size() + 1);\\n        dfs(graph, 0, visited2, 0, maxTime, values, ret, 0, minTimes);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(minTimes[curNode] + curTime > maxTime)\\n    return;\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<int, vector<pair<int,int>>>& graph, int curNode, vector<int>& visited, int curTime, int maxTime, vector<int>& values, int& ret, int curScore, unordered_map<int,int>& minTimes){\\n\\n        //return if we can\\'t reach 0 node from this node\\n        if(minTimes[curNode] + curTime > maxTime)\\n            return;\\n\\n        if(visited[curNode] == 0)\\n            curScore += values[curNode];\\n\\n        ++visited[curNode];\\n\\n        //we can reach 0 node from here, update maxScore\\n        ret = max(ret, curScore);\\n\\n        //go through other nodes\\n        for(int i = 0; i < graph[curNode].size(); ++i){\\n            int nextNode = graph[curNode][i].first;\\n            int nextTime = graph[curNode][i].second;\\n            dfs(graph, nextNode, visited, curTime + nextTime, maxTime, values, ret, curScore, minTimes);\\n        }\\n        --visited[curNode];\\n    }\\n\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        \\n        //pair: 1st val: node   2nd val: time\\n        unordered_map<int, vector<pair<int,int>>> graph;\\n\\n        for(int i = 0; i < edges.size(); ++i){\\n            int node1 = edges[i][0];\\n            int node2 = edges[i][1];\\n            int time = edges[i][2];\\n\\n            graph[node1].push_back({node2, time});\\n            graph[node2].push_back({node1, time});\\n        }\\n\\n        //djikstra part. get min times to get from one node back to node 0\\n        unordered_map<int,int> minTimes;\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        pq.push({0, 0});\\n        unordered_set<int> visited;\\n        while(!pq.empty()){\\n            int curTime = pq.top().first;\\n            int curNode = pq.top().second;\\n            pq.pop();\\n\\n            if(visited.find(curNode) != visited.end())\\n                continue;\\n            visited.insert(curNode);\\n            minTimes[curNode] = curTime;\\n            \\n            for(int i = 0; i < graph[curNode].size(); ++i){\\n                int nextNode = graph[curNode][i].first;\\n                int nextTime = graph[curNode][i].second;\\n\\n                pq.push({curTime + nextTime, nextNode});\\n            }\\n        }\\n\\n        //dfs\\n        \\n        int ret = 0;\\n        vector<int> visited2(values.size() + 1);\\n        dfs(graph, 0, visited2, 0, maxTime, values, ret, 0, minTimes);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908426,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n\\ntypedef pair<int,int> pii;\\nclass Solution {\\npublic:\\n    void dfs(int node,int time,int cur,int &res,vector<int>&values,vector<vector<pii>>&adj,int &maxTime,vector<int>&vis)\\n    {\\n        if (time>maxTime) return;\\n\\n        if (vis[node]==0)\\n        {\\n            cur+=values[node];\\n        }\\n\\n        if (node==0)\\n       { res=max(res,cur);}\\n\\n\\n        vis[node]++;\\n        for (auto it:adj[node])\\n        {\\n            dfs(it.first,time+it.second,cur,res,values,adj,maxTime,vis);\\n        }\\n        vis[node]--;\\n        \\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) \\n    {\\n        int n=values.size();\\n        vector<vector<pii>>adj(n);\\n        for(auto it: edges)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int>vis(n,0);\\n        int res=0;\\n        dfs(0,0,0,res,values,adj,maxTime,vis);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntypedef pair<int,int> pii;\\nclass Solution {\\npublic:\\n    void dfs(int node,int time,int cur,int &res,vector<int>&values,vector<vector<pii>>&adj,int &maxTime,vector<int>&vis)\\n    {\\n        if (time>maxTime) return;\\n\\n        if (vis[node]==0)\\n        {\\n            cur+=values[node];\\n        }\\n\\n        if (node==0)\\n       { res=max(res,cur);}\\n\\n\\n        vis[node]++;\\n        for (auto it:adj[node])\\n        {\\n            dfs(it.first,time+it.second,cur,res,values,adj,maxTime,vis);\\n        }\\n        vis[node]--;\\n        \\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) \\n    {\\n        int n=values.size();\\n        vector<vector<pii>>adj(n);\\n        for(auto it: edges)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int>vis(n,0);\\n        int res=0;\\n        dfs(0,0,0,res,values,adj,maxTime,vis);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906529,
                "title": "c-dfs",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<pair<int,int>>> adj;\\n    int ans=INT_MIN;\\n    \\n    void dfs(int u,vector<int>& values,int maxtime,unordered_multiset<int> &s,int time,int sum)\\n    {\\n        if(u==0)\\n        ans= max(ans,sum);\\n        \\n        for(auto p: adj[u])\\n        {\\n            if(time+p.second<maxtime)\\n            {\\n                if(s.count(p.first))\\n                {\\n                    s.insert(p.first);\\n                    dfs(p.first,values,maxtime,s,time+p.second,sum);\\n                    s.erase(s.find(p.first));\\n                }\\n                else\\n                {\\n                    s.insert(p.first);\\n                    dfs(p.first,values,maxtime,s,time+p.second,sum+values[p.first]);\\n                    s.erase(s.find(p.first));\\n                }\\n            }\\n            else if(time+p.second==maxtime && p.first==0)\\n            {\\n                s.insert(p.first);\\n                dfs(p.first,values,maxtime,s,time+p.second,sum);\\n                s.erase(s.find(p.first));\\n            }\\n        }\\n    }\\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n= values.size();\\n        \\n         adj.resize(n);\\n        \\n        for(auto edge: edges)\\n        {\\n            int u= edge[0];\\n            int v= edge[1];\\n            int wt= edge[2];\\n            \\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        \\n        unordered_multiset<int> s;\\n        s.insert(0);\\n        dfs(0,values,maxTime,s,0,values[0]);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<pair<int,int>>> adj;\\n    int ans=INT_MIN;\\n    \\n    void dfs(int u,vector<int>& values,int maxtime,unordered_multiset<int> &s,int time,int sum)\\n    {\\n        if(u==0)\\n        ans= max(ans,sum);\\n        \\n        for(auto p: adj[u])\\n        {\\n            if(time+p.second<maxtime)\\n            {\\n                if(s.count(p.first))\\n                {\\n                    s.insert(p.first);\\n                    dfs(p.first,values,maxtime,s,time+p.second,sum);\\n                    s.erase(s.find(p.first));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3809070,
                "title": "simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<pair<int,int>>adj[],int i,int &maxtime,int sum,vector<int>& values,int cost,int &ans,vector<int>&vis)\\n    {\\n        if(i==0)\\n        ans=max(ans,cost);\\n        for(auto it:adj[i])\\n        {   \\n            if(sum+it.first<=maxtime)\\n            {  if(!vis[it.second])\\n               { vis[it.second]=1;\\n               dfs(adj,it.second,maxtime,sum+it.first,values,cost+values[it.second],ans,vis);\\n               vis[it.second]=0;}\\n               else\\n                dfs(adj,it.second,maxtime,sum+it.first,values,cost,ans,vis);\\n            }\\n        }\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxtime) {\\n        vector<pair<int,int>>adj[values.size()];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back({edges[i][2],edges[i][1]});\\n            adj[edges[i][1]].push_back({edges[i][2],edges[i][0]});\\n        }\\n        int ans=INT_MIN;\\n        vector<int>vis(values.size(),0);\\n        vis[0]=1;\\n        dfs(adj,0,maxtime,0,values,values[0],ans,vis);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<pair<int,int>>adj[],int i,int &maxtime,int sum,vector<int>& values,int cost,int &ans,vector<int>&vis)\\n    {\\n        if(i==0)\\n        ans=max(ans,cost);\\n        for(auto it:adj[i])\\n        {   \\n            if(sum+it.first<=maxtime)\\n            {  if(!vis[it.second])\\n               { vis[it.second]=1;\\n               dfs(adj,it.second,maxtime,sum+it.first,values,cost+values[it.second],ans,vis);\\n               vis[it.second]=0;}\\n               else\\n                dfs(adj,it.second,maxtime,sum+it.first,values,cost,ans,vis);\\n            }\\n        }\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxtime) {\\n        vector<pair<int,int>>adj[values.size()];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back({edges[i][2],edges[i][1]});\\n            adj[edges[i][1]].push_back({edges[i][2],edges[i][0]});\\n        }\\n        int ans=INT_MIN;\\n        vector<int>vis(values.size(),0);\\n        vis[0]=1;\\n        dfs(adj,0,maxtime,0,values,values[0],ans,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712427,
                "title": "c-backtracking-dfs",
                "content": "# Complexity\\n- Time complexity: O(E*(V+E)) \\nwhere, V -> Number of nodes and E -> Number of edges\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void dfs(int node, int time, int quality, int maxTime, vector<int>& values, vector<pair<int,int>> adj[]) {\\n        if(time>maxTime) return;\\n        quality+=values[node];\\n        if(node==0) {\\n            ans=max(quality, ans);\\n        }\\n        int temp = values[node];\\n        values[node] = 0;\\n        for(auto it:adj[node]) {\\n            dfs(it.first, time+it.second, quality, maxTime, values, adj);\\n        }\\n        values[node] = temp;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        vector<pair<int,int>>adj[n];\\n        for(auto e:edges) {\\n            adj[e[0]].push_back({e[1] , e[2]});\\n            adj[e[1]].push_back({e[0] , e[2]});\\n        }\\n        dfs(0, 0, 0, maxTime, values, adj);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void dfs(int node, int time, int quality, int maxTime, vector<int>& values, vector<pair<int,int>> adj[]) {\\n        if(time>maxTime) return;\\n        quality+=values[node];\\n        if(node==0) {\\n            ans=max(quality, ans);\\n        }\\n        int temp = values[node];\\n        values[node] = 0;\\n        for(auto it:adj[node]) {\\n            dfs(it.first, time+it.second, quality, maxTime, values, adj);\\n        }\\n        values[node] = temp;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        vector<pair<int,int>>adj[n];\\n        for(auto e:edges) {\\n            adj[e[0]].push_back({e[1] , e[2]});\\n            adj[e[1]].push_back({e[0] , e[2]});\\n        }\\n        dfs(0, 0, 0, maxTime, values, adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560418,
                "title": "c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy taking a look a this problem, we can see that we need to traverse the graph. As we are given a constraint on the path length (time), we might think about shortest path problem. But here we also need to maximize the value of the path we chose. Also, we can revisit a node, so conventional shortest path problems are not going to be useful here. So looking at the constraints, we can see that each node can only have atmost 4 edges to it. Also the time constraint is such that, in any path maximum nodes can only be 10 or the path length will only be 10. Hence, when traversing from 0, there will be atmost 4 choices at each node and number of nodes are limited to 10 in a path. Therefore maximum number of combinations possible is $$4^{10} = 1048576 < 2.10^6$$. Hence, we can think of using backtracking as the solution is within limits.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can perform **DFS with backtracking** to solve this problem. However, we need to keep in mind that we can visit same node multiple times but can only add its value to result once. To solve this constraint, we can keep a hash table and use the node\\'s number as key and will increment the value for that node each time we visit it. Also once we exit the DFS for that node, we will decrement the value. Before incrementing the value, we can check if value is 0, then we will add that node\\'s value to the total value of the path.\\n\\nTo implement the time constraint, we can use a variable $$time$$, initially set to 0, whose value is incremented by the weight of the edge we used to visit the next node. Then the next node checks if $$time > maxTime$$ and if so, we stop and backtrack, else we continue with the rest of logic.\\n\\nTo store the result, we create a variable $$res$$ whose initial value is $-1$. As the path must terminate at node 0, so whenever we visit node 0, we check if the **value of path so far** is $$> res$$ and if so, we update the $res$ with the **value of path so far**.\\n\\nAfter all possible combinations are checked, $res$ is the final result. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we are performing DFS with repeated nodes but with max combinations limited to $$2*10^6$$, we can assume that the time complexity is $$O(n^2)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe additional space required is of order $$O(n)$$.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void DFS(int i, vector<vector<pair<int, int>>>& adj, unordered_map<int, int>& mp, vector<int>& values, int& res, int value, int time, int maxt){\\n        if (time > maxt) return;\\n        if (mp[i] == 0){\\n            value += values[i];\\n        }\\n        mp[i]++;\\n        if (i == 0){\\n            res = max(res, value);\\n        }\\n        for (auto &x: adj[i]){\\n            DFS(x.first, adj, mp, values, res, value, time + x.second, maxt);\\n        }\\n        mp[i]--;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        vector<vector<pair<int, int>>> adj(n);\\n        for (auto &x: edges){\\n            adj[x[0]].push_back({x[1], x[2]});\\n            adj[x[1]].push_back({x[0], x[2]});\\n        }\\n        unordered_map<int, int> mp;\\n        int res = -1;\\n        DFS(0, adj, mp, values, res, 0, 0, maxTime);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(int i, vector<vector<pair<int, int>>>& adj, unordered_map<int, int>& mp, vector<int>& values, int& res, int value, int time, int maxt){\\n        if (time > maxt) return;\\n        if (mp[i] == 0){\\n            value += values[i];\\n        }\\n        mp[i]++;\\n        if (i == 0){\\n            res = max(res, value);\\n        }\\n        for (auto &x: adj[i]){\\n            DFS(x.first, adj, mp, values, res, value, time + x.second, maxt);\\n        }\\n        mp[i]--;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        vector<vector<pair<int, int>>> adj(n);\\n        for (auto &x: edges){\\n            adj[x[0]].push_back({x[1], x[2]});\\n            adj[x[1]].push_back({x[0], x[2]});\\n        }\\n        unordered_map<int, int> mp;\\n        int res = -1;\\n        DFS(0, adj, mp, values, res, 0, 0, maxTime);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559236,
                "title": "dfs-backtracking-optimised-by-dijkstra",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    void dfs(int src,int &res,int score,int tm,vector<int>values,vector<pair<int,int>>graph[],int maxTime,vector<int>&vis,vector<int>dis){\\n        \\n        if(tm>maxTime)\\n        return;\\n        \\n        if(vis[src]==0){\\n            score+=values[src];\\n        }\\n        vis[src]++;\\n\\n        if(src==0){\\n            res=max(res,score);    \\n        }\\n        \\n        for(auto it:graph[src]){\\n            int newTm=tm+it.second;\\n            int leftTm=maxTime-newTm;\\n            if(leftTm>=dis[it.first])\\n            dfs(it.first,res,score,tm+it.second,values,graph,maxTime,vis,dis);    \\n        }\\n        vis[src]--;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<pair<int,int>>graph[n];\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        vector<int>dis(n,INT_MAX);\\n        pq.push({0,0});\\n        dis[0]=0;\\n        while(pq.size()){\\n            int weight=pq.top().first;\\n            int src=pq.top().second;\\n            pq.pop();\\n            for(auto it:graph[src]){\\n                if(weight+it.second<dis[it.first]){\\n                    dis[it.first]=weight+it.second;\\n                    pq.push({dis[it.first],it.first});\\n                }\\n            }\\n        }\\n        \\n        \\n        int res=0,score=0;\\n        vector<int>vis(n,0);\\n        \\n        dfs(0,res,score,0,values,graph,maxTime,vis,dis);\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void dfs(int src,int &res,int score,int tm,vector<int>values,vector<pair<int,int>>graph[],int maxTime,vector<int>&vis,vector<int>dis){\\n        \\n        if(tm>maxTime)\\n        return;\\n        \\n        if(vis[src]==0){\\n            score+=values[src];\\n        }\\n        vis[src]++;\\n\\n        if(src==0){\\n            res=max(res,score);    \\n        }\\n        \\n        for(auto it:graph[src]){\\n            int newTm=tm+it.second;\\n            int leftTm=maxTime-newTm;\\n            if(leftTm>=dis[it.first])\\n            dfs(it.first,res,score,tm+it.second,values,graph,maxTime,vis,dis);    \\n        }\\n        vis[src]--;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<pair<int,int>>graph[n];\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        vector<int>dis(n,INT_MAX);\\n        pq.push({0,0});\\n        dis[0]=0;\\n        while(pq.size()){\\n            int weight=pq.top().first;\\n            int src=pq.top().second;\\n            pq.pop();\\n            for(auto it:graph[src]){\\n                if(weight+it.second<dis[it.first]){\\n                    dis[it.first]=weight+it.second;\\n                    pq.push({dis[it.first],it.first});\\n                }\\n            }\\n        }\\n        \\n        \\n        int res=0,score=0;\\n        vector<int>vis(n,0);\\n        \\n        dfs(0,res,score,0,values,graph,maxTime,vis,dis);\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536336,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//simple backtracking apporach nothing more,like u find the permuationso f stirng using backtracking\\n// in similar manner we do,one extra thing, if(node==0)res=max(res,score) because from every node,we have to come to 0\\n    void dfs(vector<int>& values, vector<int>&vis,int &res,int node,int score,int time,int &maxTime, vector<vector<pair<int,int>>>&graph){\\n        if(time>maxTime)return;\\n        if(vis[node]==0)score+=values[node];\\n \\n        vis[node]++;  //ye node visit ho chuki\\n        \\n        \\n\\n        if(node ==0)res=max(res,score);  //jab bhi 0th node pai aye kuki backtracking chl ri,tabhimxfind krlo\\n\\n       \\n        for(auto it:graph[node]){\\n            int x=it.first;  //node\\n            int y=time + it.second;  //new time\\n            dfs(values,vis,res,x,score,y,maxTime,graph);\\n        }\\n        vis[node]--;  //backtracking,node pai gye phir vapas hogye\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<vector<pair<int,int>>>graph(n);\\n        for(int  i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        vector<int>visited(n,0);\\n        int res=values[0];\\n         dfs(values,visited,res,0,0,0,maxTime,graph); //0,0,0 node,score,time\\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//simple backtracking apporach nothing more,like u find the permuationso f stirng using backtracking\\n// in similar manner we do,one extra thing, if(node==0)res=max(res,score) because from every node,we have to come to 0\\n    void dfs(vector<int>& values, vector<int>&vis,int &res,int node,int score,int time,int &maxTime, vector<vector<pair<int,int>>>&graph){\\n        if(time>maxTime)return;\\n        if(vis[node]==0)score+=values[node];\\n \\n        vis[node]++;  //ye node visit ho chuki\\n        \\n        \\n\\n        if(node ==0)res=max(res,score);  //jab bhi 0th node pai aye kuki backtracking chl ri,tabhimxfind krlo\\n\\n       \\n        for(auto it:graph[node]){\\n            int x=it.first;  //node\\n            int y=time + it.second;  //new time\\n            dfs(values,vis,res,x,score,y,maxTime,graph);\\n        }\\n        vis[node]--;  //backtracking,node pai gye phir vapas hogye\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<vector<pair<int,int>>>graph(n);\\n        for(int  i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            graph[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        vector<int>visited(n,0);\\n        int res=values[0];\\n         dfs(values,visited,res,0,0,0,maxTime,graph); //0,0,0 node,score,time\\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490573,
                "title": "c-backtrack-dfs-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\ntypedef pair<int,int> PI;\\nint f(int node,vector<vector<PI>>& adj,vector<int>& values,int max_t,int t,vector<bool>& visited){\\n    int ans=0;\\n    bool ch=0;\\n    for(auto& [a,b]: adj[node]){\\n        if(t+b<=max_t){\\n            \\n            bool temp=visited[a];\\n            visited[a]=1;\\n            int res=f(a,adj,values,max_t,t+b,visited)+((temp==0)?values[a]:0);\\n            if(res>=0){\\n                ch=1;\\n            }\\n            ans=max(ans,res);\\n            visited[a]=temp;\\n        }\\n    }\\n    if(ch==0 && node!=0){\\n        ans=-1e8;\\n    }\\n    return ans;\\n}\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<vector<PI>> adj(n);\\n        for(auto& ele: edges){\\n            adj[ele[0]].push_back({ele[1],ele[2]});\\n            adj[ele[1]].push_back({ele[0],ele[2]});\\n        }\\n        vector<bool> visited(n,0);\\n        visited[0]=1;\\n\\n        int ans=values[0]+f(0,adj,values,maxTime,0,visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef pair<int,int> PI;\\nint f(int node,vector<vector<PI>>& adj,vector<int>& values,int max_t,int t,vector<bool>& visited){\\n    int ans=0;\\n    bool ch=0;\\n    for(auto& [a,b]: adj[node]){\\n        if(t+b<=max_t){\\n            \\n            bool temp=visited[a];\\n            visited[a]=1;\\n            int res=f(a,adj,values,max_t,t+b,visited)+((temp==0)?values[a]:0);\\n            if(res>=0){\\n                ch=1;\\n            }\\n            ans=max(ans,res);\\n            visited[a]=temp;\\n        }\\n    }\\n    if(ch==0 && node!=0){\\n        ans=-1e8;\\n    }\\n    return ans;\\n}\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<vector<PI>> adj(n);\\n        for(auto& ele: edges){\\n            adj[ele[0]].push_back({ele[1],ele[2]});\\n            adj[ele[1]].push_back({ele[0],ele[2]});\\n        }\\n        vector<bool> visited(n,0);\\n        visited[0]=1;\\n\\n        int ans=values[0]+f(0,adj,values,maxTime,0,visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471154,
                "title": "crawl-until-exceed-the-max-time",
                "content": "# Intuition\\nIterative crawling in all possible nodes\\n\\n# Approach\\nContinue visit more node if time not exceed the maximum. at then end find the highest value from founded paths.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private val aIndex = 0\\n    private val bIndex = 1\\n    private val timeIndex = 2\\n    private var edgeNodes = HashMap<Int, MutableList<Int>>()\\n    private var times = HashMap<String, Int>()\\n    private var nodeValues = HashMap<Int, Int>()\\n    private val checkNodes = ArrayList<Track>()\\n    private var maxTime = 0\\n\\n    private fun getKey(a: Int, b: Int): String {\\n        val (small, big) = if (a < b) Pair(a, b) else Pair(b, a)\\n        return \"$small-$big\"\\n    }\\n\\n    private fun addPath(path: IntArray) {\\n        val a = path[aIndex]\\n        val b = path[bIndex]\\n        val distance = path[timeIndex]\\n        val key = getKey(a, b)\\n        if (times.getOrPut(key) { distance } < distance) times[key] = distance\\n        edgeNodes.getOrPut(a) { mutableListOf() }.add(b)\\n        edgeNodes.getOrPut(b) { mutableListOf() }.add(a)\\n    }\\n\\n\\n    private fun addEdgeNodesIfUnderMaxTime(track: Track) {\\n        edgeNodes[track.node]?.forEach { edgeNode ->\\n            val addedEdgeTime = times[getKey(track.node, edgeNode)]!! + track.sumTime\\n            if (addedEdgeTime <= maxTime) {\\n                checkNodes.add(\\n                    Track(\\n                        edgeNode, track.visitedNodes + edgeNode, addedEdgeTime\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    data class Track(val node: Int, val visitedNodes: IntArray, val sumTime: Int)\\n\\n\\n    private fun getBigger(n1: Int, n2: Int) = if (n1 > n2) n1 else n2\\n\\n    fun maximalPathQuality(values: IntArray, edges: Array<IntArray>, maxTime: Int): Int {\\n        edgeNodes.clear()\\n        nodeValues.clear()\\n        this.maxTime = maxTime\\n        values.forEachIndexed { index, i -> nodeValues[index] = i }\\n        edges.forEach { addPath(it) }\\n        var maxQuality = nodeValues[0]!!\\n        var index = 0\\n        checkNodes.add(Track(0, intArrayOf(0), 0))\\n        val pathsIndex = mutableListOf<Int>()\\n        do {\\n            val track = checkNodes[index]\\n            addEdgeNodesIfUnderMaxTime(track)\\n            if (track.node == 0) pathsIndex.add(index)\\n            index++\\n        } while (index < checkNodes.size)\\n\\n        pathsIndex.forEach { index ->\\n            val track = checkNodes[index]\\n            maxQuality = getBigger(maxQuality, track.visitedNodes.toSet().sumBy { values[it] })\\n        }\\n        return maxQuality\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    private val aIndex = 0\\n    private val bIndex = 1\\n    private val timeIndex = 2\\n    private var edgeNodes = HashMap<Int, MutableList<Int>>()\\n    private var times = HashMap<String, Int>()\\n    private var nodeValues = HashMap<Int, Int>()\\n    private val checkNodes = ArrayList<Track>()\\n    private var maxTime = 0\\n\\n    private fun getKey(a: Int, b: Int): String {\\n        val (small, big) = if (a < b) Pair(a, b) else Pair(b, a)\\n        return \"$small-$big\"\\n    }\\n\\n    private fun addPath(path: IntArray) {\\n        val a = path[aIndex]\\n        val b = path[bIndex]\\n        val distance = path[timeIndex]\\n        val key = getKey(a, b)\\n        if (times.getOrPut(key) { distance } < distance) times[key] = distance\\n        edgeNodes.getOrPut(a) { mutableListOf() }.add(b)\\n        edgeNodes.getOrPut(b) { mutableListOf() }.add(a)\\n    }\\n\\n\\n    private fun addEdgeNodesIfUnderMaxTime(track: Track) {\\n        edgeNodes[track.node]?.forEach { edgeNode ->\\n            val addedEdgeTime = times[getKey(track.node, edgeNode)]!! + track.sumTime\\n            if (addedEdgeTime <= maxTime) {\\n                checkNodes.add(\\n                    Track(\\n                        edgeNode, track.visitedNodes + edgeNode, addedEdgeTime\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    data class Track(val node: Int, val visitedNodes: IntArray, val sumTime: Int)\\n\\n\\n    private fun getBigger(n1: Int, n2: Int) = if (n1 > n2) n1 else n2\\n\\n    fun maximalPathQuality(values: IntArray, edges: Array<IntArray>, maxTime: Int): Int {\\n        edgeNodes.clear()\\n        nodeValues.clear()\\n        this.maxTime = maxTime\\n        values.forEachIndexed { index, i -> nodeValues[index] = i }\\n        edges.forEach { addPath(it) }\\n        var maxQuality = nodeValues[0]!!\\n        var index = 0\\n        checkNodes.add(Track(0, intArrayOf(0), 0))\\n        val pathsIndex = mutableListOf<Int>()\\n        do {\\n            val track = checkNodes[index]\\n            addEdgeNodesIfUnderMaxTime(track)\\n            if (track.node == 0) pathsIndex.add(index)\\n            index++\\n        } while (index < checkNodes.size)\\n\\n        pathsIndex.forEach { index ->\\n            val track = checkNodes[index]\\n            maxQuality = getBigger(maxQuality, track.visitedNodes.toSet().sumBy { values[it] })\\n        }\\n        return maxQuality\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428567,
                "title": "python-simple-dfs",
                "content": "\\n```\\nclass Solution:\\n    def maximalPathQuality(self, vals: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        N = len(vals)\\n        nbr = [[] for i in range(N)]\\n        for u, v, time in edges:\\n            nbr[u].append(To(v, time))\\n            nbr[v].append(To(u, time))\\n        \\n        self.res = 0\\n        def dfs(u, quality, timeElapsed):\\n            if u == 0:\\n                self.res = max(self.res, quality)          \\n\\n            for v in nbr[u]:\\n                if timeElapsed + v.time <= maxTime:\\n                    if vis[v.id]:\\n                        dfs(v.id, quality, timeElapsed + v.time)\\n                    else:\\n                        vis[v.id] = True\\n                        dfs(v.id, quality + vals[v.id], timeElapsed + v.time)\\n                        vis[v.id] = False\\n        \\n        vis = [False] * N\\n        vis[0] = True\\n        dfs(0, vals[0], 0)\\n        return self.res\\n        \\nclass To:\\n    def __init__(self, id, time):\\n        self.id, self.time = id, time\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, vals: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        N = len(vals)\\n        nbr = [[] for i in range(N)]\\n        for u, v, time in edges:\\n            nbr[u].append(To(v, time))\\n            nbr[v].append(To(u, time))\\n        \\n        self.res = 0\\n        def dfs(u, quality, timeElapsed):\\n            if u == 0:\\n                self.res = max(self.res, quality)          \\n\\n            for v in nbr[u]:\\n                if timeElapsed + v.time <= maxTime:\\n                    if vis[v.id]:\\n                        dfs(v.id, quality, timeElapsed + v.time)\\n                    else:\\n                        vis[v.id] = True\\n                        dfs(v.id, quality + vals[v.id], timeElapsed + v.time)\\n                        vis[v.id] = False\\n        \\n        vis = [False] * N\\n        vis[0] = True\\n        dfs(0, vals[0], 0)\\n        return self.res\\n        \\nclass To:\\n    def __init__(self, id, time):\\n        self.id, self.time = id, time\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423223,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ;\\nclass Solution {\\n    int n ;\\n    vector<int>visited ;\\n    vector<vector<PII>>graph ;\\n    int ret = 0 ;\\n    int maxTime ;\\n    vector<int> values ;\\n    void dfs(int cur, int value, int CurTime){\\n        if(cur == 0)\\n            ret = max(ret, value) ;\\n        \\n        for(auto [nxt, time] : graph[cur]){\\n            if(time + CurTime > maxTime)\\n                continue ;\\n            visited[nxt]++ ;\\n            int newValue = value + (visited[nxt] == 1 ? values[nxt] : 0) ;\\n            dfs(nxt, newValue, time + CurTime) ;\\n            visited[nxt]-- ;\\n        }\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        this->n = values.size() ;  \\n        this->maxTime = maxTime ;\\n        this->values = values ;\\n        visited.resize(n) ;\\n        graph.resize(n) ;\\n                \\n        for(auto& edge : edges){\\n            int u = edge[0] ;\\n            int v = edge[1] ;\\n            int t = edge[2] ;\\n            graph[u].push_back({v, t}) ;\\n            graph[v].push_back({u, t}) ;\\n        } \\n        visited[0]++ ;\\n        dfs(0, values[0], 0) ;\\n        visited[0]-- ;\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nusing PII = pair<int, int> ;\\nclass Solution {\\n    int n ;\\n    vector<int>visited ;\\n    vector<vector<PII>>graph ;\\n    int ret = 0 ;\\n    int maxTime ;\\n    vector<int> values ;\\n    void dfs(int cur, int value, int CurTime){\\n        if(cur == 0)\\n            ret = max(ret, value) ;\\n        \\n        for(auto [nxt, time] : graph[cur]){\\n            if(time + CurTime > maxTime)\\n                continue ;\\n            visited[nxt]++ ;\\n            int newValue = value + (visited[nxt] == 1 ? values[nxt] : 0) ;\\n            dfs(nxt, newValue, time + CurTime) ;\\n            visited[nxt]-- ;\\n        }\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        this->n = values.size() ;  \\n        this->maxTime = maxTime ;\\n        this->values = values ;\\n        visited.resize(n) ;\\n        graph.resize(n) ;\\n                \\n        for(auto& edge : edges){\\n            int u = edge[0] ;\\n            int v = edge[1] ;\\n            int t = edge[2] ;\\n            graph[u].push_back({v, t}) ;\\n            graph[v].push_back({u, t}) ;\\n        } \\n        visited[0]++ ;\\n        dfs(0, values[0], 0) ;\\n        visited[0]-- ;\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422400,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int ans;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n=values.length;\\n        int v[]=new int[n];\\n        ArrayList<ArrayList<int[]>>l=new ArrayList<>();\\n        for(int i=0;i<n;i++)l.add(new ArrayList<>());\\n        for(int r[]:edges)\\n        {\\n            l.get(r[0]).add(new int[]{r[1],r[2]});\\n            l.get(r[1]).add(new int[]{r[0],r[2]});\\n        }\\n        dfs(0,l,v,values,maxTime,0,0);\\n        return ans;\\n    }\\n    public void dfs(int node,ArrayList<ArrayList<int[]>>l,int v[],int values[],int maxTime,int curTime,int res)\\n    {\\n        if(curTime>maxTime)return;\\n        if(v[node]==0)res+=values[node];\\n        if(node==0)ans=(int)Math.max(ans,res);\\n        v[node]+=1;\\n        for(int it[]:l.get(node))\\n            dfs(it[0],l,v,values,maxTime,curTime+it[1],res);\\n        v[node]-=1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n=values.length;\\n        int v[]=new int[n];\\n        ArrayList<ArrayList<int[]>>l=new ArrayList<>();\\n        for(int i=0;i<n;i++)l.add(new ArrayList<>());\\n        for(int r[]:edges)\\n        {\\n            l.get(r[0]).add(new int[]{r[1],r[2]});\\n            l.get(r[1]).add(new int[]{r[0],r[2]});\\n        }\\n        dfs(0,l,v,values,maxTime,0,0);\\n        return ans;\\n    }\\n    public void dfs(int node,ArrayList<ArrayList<int[]>>l,int v[],int values[],int maxTime,int curTime,int res)\\n    {\\n        if(curTime>maxTime)return;\\n        if(v[node]==0)res+=values[node];\\n        if(node==0)ans=(int)Math.max(ans,res);\\n        v[node]+=1;\\n        for(int it[]:l.get(node))\\n            dfs(it[0],l,v,values,maxTime,curTime+it[1],res);\\n        v[node]-=1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382937,
                "title": "c-easy-solution-dfs-backtraking-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    void dfs(int node,int time,int& sum,vector<int>& values,map<int,vector<pair<int,int>>>& mp,vector<int>& vis,int maxTime){\\n        if(node==0){\\n            if(time<=maxTime){\\n                maxi=max(maxi,sum);\\n            }\\n        }\\n        for(auto it:mp[node]){\\n            vis[it.first]++;\\n            if(vis[it.first]==1){\\n                sum+=values[it.first];\\n                \\n            }\\n            if((time+it.second)<=maxTime){\\n                dfs(it.first,time+it.second,sum,values,mp,vis,maxTime);\\n            }\\n            vis[it.first]--;\\n            if(vis[it.first]==0){\\n                sum-=values[it.first];\\n            }\\n        }\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        maxi=0;\\n        map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            mp[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        int n=values.size();\\n        vector<int> vis(n,0);\\n         vis[0]=1;\\n        dfs(0,0,values[0],values,mp,vis,maxTime);\\n        return maxi;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=0;\\n    void dfs(int node,int time,int& sum,vector<int>& values,map<int,vector<pair<int,int>>>& mp,vector<int>& vis,int maxTime){\\n        if(node==0){\\n            if(time<=maxTime){\\n                maxi=max(maxi,sum);\\n            }\\n        }\\n        for(auto it:mp[node]){\\n            vis[it.first]++;\\n            if(vis[it.first]==1){\\n                sum+=values[it.first];\\n                \\n            }\\n            if((time+it.second)<=maxTime){\\n                dfs(it.first,time+it.second,sum,values,mp,vis,maxTime);\\n            }\\n            vis[it.first]--;\\n            if(vis[it.first]==0){\\n                sum-=values[it.first];\\n            }\\n        }\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        maxi=0;\\n        map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            mp[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        int n=values.size();\\n        vector<int> vis(n,0);\\n         vis[0]=1;\\n        dfs(0,0,values[0],values,mp,vis,maxTime);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365783,
                "title": "simple-dfs-with-a-slight-variation-in-visited-array",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    void dfs(vector<pair<int,int>>adj[],int n,int maxtime,int node,int res,vector<int>&values,vector<int>&vis){\\n        if(maxtime<0)return ;\\n       \\n        if(vis[node]==0){\\n            res+=values[node];\\n           \\n        }    \\n        if(node==0){\\n            ans=max(ans,res);\\n        }\\n        vis[node]++;\\n        \\n       \\n        for(auto it:adj[node]){\\n            dfs(adj,n,maxtime-it.second,it.first,res,values, vis);\\n            \\n        }\\n        vis[node]--;\\n        \\n\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& e, int maxTime) {\\n        int n=values.size();\\n        vector<pair<int,int>>adj[n];\\n        vector<int>vis(n,0);\\n        for(auto it:e){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        int res=0;\\n        ans=0;\\n        dfs(adj,n,maxTime,0,res,values,vis);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void dfs(vector<pair<int,int>>adj[],int n,int maxtime,int node,int res,vector<int>&values,vector<int>&vis){\\n        if(maxtime<0)return ;\\n       \\n        if(vis[node]==0){\\n            res+=values[node];\\n           \\n        }    \\n        if(node==0){\\n            ans=max(ans,res);\\n        }\\n        vis[node]++;\\n        \\n       \\n        for(auto it:adj[node]){\\n            dfs(adj,n,maxtime-it.second,it.first,res,values, vis);\\n            \\n        }\\n        vis[node]--;\\n        \\n\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& e, int maxTime) {\\n        int n=values.size();\\n        vector<pair<int,int>>adj[n];\\n        vector<int>vis(n,0);\\n        for(auto it:e){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        int res=0;\\n        ans=0;\\n        dfs(adj,n,maxTime,0,res,values,vis);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347098,
                "title": "simple-dfs-solution-java-easy-to-understand-code",
                "content": "```\\nclass Solution {\\n    class Node{\\n        int node;\\n        int time;\\n        public Node(int node , int time){\\n            this.node = node;\\n            this.time = time;\\n        }\\n    }\\n    int ans = 0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int V = values.length;\\n        ArrayList<ArrayList<Node>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < V ; i++) adj.add(new ArrayList<>());\\n        for(int i = 0 ; i < edges.length ; i++){\\n            int s = edges[i][0];\\n            int e = edges[i][1];\\n            int time = edges[i][2];\\n            adj.get(s).add(new Node(e , time));\\n            adj.get(e).add(new Node(s , time));\\n        }\\n        HashSet<Integer> map = new HashSet<>();\\n        map.add(0);\\n        get(0 , adj , map , 0 , maxTime , values[0] , values);\\n        return ans;\\n    }\\n    private void get(int curNode , ArrayList<ArrayList<Node>> adj , HashSet<Integer> map , int curTime , int maxTime , int curCount , int[] values){\\n        if(curTime > maxTime) return;\\n        if(curNode == 0){\\n            ans = Math.max(ans , curCount);\\n        }\\n        for(Node node : adj.get(curNode)){\\n            int ele = node.node;\\n            int time = node.time;\\n            if(!map.contains(ele)){\\n                map.add(ele);\\n                get(ele , adj , map , curTime + time , maxTime , curCount + values[ele] , values);\\n                map.remove(ele);\\n            }else{\\n                get(ele , adj , map , curTime + time , maxTime , curCount , values);\\n            }\\n        }\\n    }\\n}\\n```\\n***Please UpVote, if found useful :)***",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        int node;\\n        int time;\\n        public Node(int node , int time){\\n            this.node = node;\\n            this.time = time;\\n        }\\n    }\\n    int ans = 0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int V = values.length;\\n        ArrayList<ArrayList<Node>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < V ; i++) adj.add(new ArrayList<>());\\n        for(int i = 0 ; i < edges.length ; i++){\\n            int s = edges[i][0];\\n            int e = edges[i][1];\\n            int time = edges[i][2];\\n            adj.get(s).add(new Node(e , time));\\n            adj.get(e).add(new Node(s , time));\\n        }\\n        HashSet<Integer> map = new HashSet<>();\\n        map.add(0);\\n        get(0 , adj , map , 0 , maxTime , values[0] , values);\\n        return ans;\\n    }\\n    private void get(int curNode , ArrayList<ArrayList<Node>> adj , HashSet<Integer> map , int curTime , int maxTime , int curCount , int[] values){\\n        if(curTime > maxTime) return;\\n        if(curNode == 0){\\n            ans = Math.max(ans , curCount);\\n        }\\n        for(Node node : adj.get(curNode)){\\n            int ele = node.node;\\n            int time = node.time;\\n            if(!map.contains(ele)){\\n                map.add(ele);\\n                get(ele , adj , map , curTime + time , maxTime , curCount + values[ele] , values);\\n                map.remove(ele);\\n            }else{\\n                get(ele , adj , map , curTime + time , maxTime , curCount , values);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249944,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximal_path_quality(values: Vec<i32>, edges: Vec<Vec<i32>>, max_time: i32) -> i32 {\\n        fn dfs(\\n            al: &Vec<Vec<(usize, i32)>>,\\n            vis: &mut Vec<i32>,\\n            vals: &Vec<i32>,\\n            i: usize,\\n            time: i32,\\n            val: i32,\\n            max_val: &mut i32,\\n        ) -> i32 {\\n            vis[i] += 1;\\n            let val = val + if vis[i] == 1 { vals[i] } else { 0 };\\n            if i == 0 {\\n                *max_val = std::cmp::max(*max_val, val);\\n            }\\n            for (j, t) in &al[i] {\\n                if time - t >= 0 {\\n                    dfs(al, vis, vals, *j, time - t, val, max_val);\\n                }\\n            }\\n            vis[i] -= 1;\\n            *max_val\\n        }\\n\\n        let mut max_val = 0;\\n        let mut al = vec![vec![]; values.len()];\\n        let mut vis = vec![0; values.len()];\\n        for e in edges {\\n            al[e[0] as usize].push((e[1] as usize, e[2]));\\n            al[e[1] as usize].push((e[0] as usize, e[2]));\\n        }\\n        dfs(&al, &mut vis, &values, 0, max_time, 0, &mut max_val)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximal_path_quality(values: Vec<i32>, edges: Vec<Vec<i32>>, max_time: i32) -> i32 {\\n        fn dfs(\\n            al: &Vec<Vec<(usize, i32)>>,\\n            vis: &mut Vec<i32>,\\n            vals: &Vec<i32>,\\n            i: usize,\\n            time: i32,\\n            val: i32,\\n            max_val: &mut i32,\\n        ) -> i32 {\\n            vis[i] += 1;\\n            let val = val + if vis[i] == 1 { vals[i] } else { 0 };\\n            if i == 0 {\\n                *max_val = std::cmp::max(*max_val, val);\\n            }\\n            for (j, t) in &al[i] {\\n                if time - t >= 0 {\\n                    dfs(al, vis, vals, *j, time - t, val, max_val);\\n                }\\n            }\\n            vis[i] -= 1;\\n            *max_val\\n        }\\n\\n        let mut max_val = 0;\\n        let mut al = vec![vec![]; values.len()];\\n        let mut vis = vec![0; values.len()];\\n        for e in edges {\\n            al[e[0] as usize].push((e[1] as usize, e[2]));\\n            al[e[1] as usize].push((e[0] as usize, e[2]));\\n        }\\n        dfs(&al, &mut vis, &values, 0, max_time, 0, &mut max_val)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3217884,
                "title": "c-simple-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    void dfs(vector<int> &values, vector<vector<pair<int, int>>> &adj, vector<int> &vis, int maxTime, int node, int sum, int time){\\n        if(vis[node] == 0) sum += values[node];\\n        vis[node]++;\\n        if(node == 0) ans = max(ans, sum);\\n        for(auto nbr : adj[node]){\\n            if(time + nbr.second <= maxTime){\\n                dfs(values, adj, vis, maxTime, nbr.first, sum, time + nbr.second);\\n            }\\n        }\\n        vis[node]--;\\n    }\\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back({edge[1], edge[2]});\\n            adj[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        vector<int> vis(n, 0);\\n        dfs(values, adj, vis, maxTime, 0, 0, 0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int ans = INT_MIN;\\n    void dfs(vector<int> &values, vector<vector<pair<int, int>>> &adj, vector<int> &vis, int maxTime, int node, int sum, int time){\\n        if(vis[node] == 0) sum += values[node];\\n        vis[node]++;\\n        if(node == 0) ans = max(ans, sum);\\n        for(auto nbr : adj[node]){\\n            if(time + nbr.second <= maxTime){\\n                dfs(values, adj, vis, maxTime, nbr.first, sum, time + nbr.second);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3168991,
                "title": "go-beats-100-dfs-dijkstra-s-algorithm-comments",
                "content": "# Approach\\nSee code comments.\\n\\n# Complexity\\nThese complexities are tentative \\u2013 this is a difficult one to work out. I\\'m open to feedback if anyone has better ideas.\\n\\n- Time complexity:\\n$$O(me)$$, where $$m$$ is the number of paths of weight <= maxTime that start and end at the source, and $$e$$ is the number of edge stemming from the vertices on such a path, which must all be processed.\\n\\n- Space complexity:\\n$$O(p)$$, where $$p$$ is the maximum length of a path with $$weight <= maxTime$$, which may be greater than the number of vertices in the graph.\\n\\n# Code\\n```\\n// maximalPathQuality builds a weighted, undirected graph from the given\\n// edges, calculates the shortest paths from the source to each other\\n// vertex, then uses this data to speed up the DFS calculation of the\\n// maximum quality.\\nfunc maximalPathQuality(values []int, edges [][]int, maxTime int) int {\\n    g := newGraph(len(values), edges)\\n    shortestPaths := newDijkstraSP(g, 0)\\n    return calcMaxQuality(g, shortestPaths, values, maxTime)\\n}\\n\\n// Use depth-first search to explore all possible paths of weight maxTime\\n// that start and end at the source. Each time we encounter the source node,\\n// we record the quality of the current path and compare it to the maximum\\n// quality that could be obtained by exploring further. The maximum of these\\n// values is returned up the stack at each stage, resulting in the highest\\n// overall quality being returned.\\n// Using the shortest paths generated by Dijkstra\\'s algorithm, we ensure that\\n// we only explore paths that have a possibility of ending at the source.\\n// Time: O(me), where m is the number of paths of weight <= maxTime that start\\n// and end at the source, and e is the number of edge stemming from the vertices\\n// on such a path.\\n// Space: O(p), where p is the maximum length of a path with weight <= maxTime,\\n// which may be greater than the number of vertices in the graph.\\nfunc calcMaxQuality(g graph, shortestPaths *dijkstraSP, values []int, maxTime int) int {\\n    visited := make([]int, len(g))\\n\\n    var dfs func(v, time, quality int) int\\n    dfs = func(v, time, quality int) int {\\n        // If there\\'s no way to get back to the source in time, this path is no\\n        // good.\\n        if time+shortestPaths.timeTo[v] > maxTime {\\n            return 0\\n        }\\n\\n        // Add the value of the current node on the first visit.\\n        if visited[v] == 0 {\\n            quality += values[v]\\n        }\\n\\n        // Track the number of visits to the node in the current recursion.\\n        visited[v]++\\n\\n        // The maxQuality for the current recursion is 0 until the path meets\\n        // the source again.\\n        var maxQuality int\\n        if v == 0 {\\n            maxQuality = quality\\n        }\\n\\n        // Check each neighbor for paths with a higher maxQuality than we\\'ve\\n        // found so far.\\n        for _, e := range g[v] {\\n            w := e.other(v)\\n            timeToW := time + e.time\\n            qualityThroughW := dfs(w, timeToW, quality)\\n            maxQuality = max(maxQuality, qualityThroughW)\\n        }\\n\\n        visited[v]--\\n        \\n        return maxQuality\\n    }\\n\\n\\n    return dfs(0, 0, 0)\\n}\\n\\ntype edge struct {\\n    v, w int\\n    time int\\n}\\n\\nfunc (e *edge) either() int {\\n    return e.v\\n}\\n\\nfunc (e *edge) other(x int) int {\\n    if x == e.v {\\n        return e.w\\n    }\\n    if x == e.w {\\n        return e.v\\n    }\\n    panic(errors.New(fmt.Sprintf(\"edge %+v has no vertex %d\", e, x)))\\n}\\n\\ntype graph [][]*edge\\n\\n// newGraph builds a graph from the given edges.\\nfunc newGraph(n int, edges [][]int) graph {\\n    g := make(graph, n)\\n    for _, inputEdge := range edges {\\n        v, w, time := inputEdge[0], inputEdge[1], inputEdge[2]\\n        graphEdge := &edge{v, w, time}\\n        g[v] = append(g[v], graphEdge)\\n        g[w] = append(g[w], graphEdge)\\n    }\\n\\n    return g\\n}\\n\\n// dijkstraSP calculates and stores the smallest time to travel from\\n// the given source node to each other node in the graph using Dijkstra\\'s\\n// algorithm.\\ntype dijkstraSP struct {\\n    timeTo []int\\n}\\n\\nfunc newDijkstraSP(g graph, source int) *dijkstraSP {\\n    d := &dijkstraSP{}\\n    d.build(g, source)\\n    return d\\n}\\n\\n// Dijkstra\\'s algorithm. This implementation uses a symbol heap with\\n// random access to store only the shortest known edge to each vertex\\n// whose shortest path has not yet been discovered. This allows us\\n// to calculate all shortest paths in O(E\\xB7logV) time.\\nfunc (d *dijkstraSP) build(g graph, source int) {\\n    timeTo := make([]int, len(g))\\n    timePQ := newTimeMinHeap()\\n\\n    for i := range timeTo {\\n        timeTo[i] = math.MaxInt\\n    }\\n    timeTo[source] = 0\\n    timePQ.Push(0, 0)\\n\\n    relax := func(v int) {\\n        for _, e := range g[v] {\\n            w := e.other(v)\\n            candidateTime := timeTo[v] + e.time\\n            if candidateTime < timeTo[w] {\\n                timeTo[w] = candidateTime\\n                timePQ.Update(w, candidateTime)\\n            }\\n        }\\n    }\\n\\n    for v, _, ok := timePQ.Pop(); ok; v, _, ok = timePQ.Pop() {\\n        relax(v)\\n    }\\n\\n    d.timeTo = timeTo\\n}\\n\\n// timeMinHeap implements a priority queue for integers with random access\\n// using integer keys that correspond to vertices. The nature of Go\\'s\\n// standard container/heap interface is such that it requires just as many\\n// lines of code to implement a symbol heap from scratch as it does to\\n// wrap the standard library functions with extra logic to handle random\\n// access.\\ntype timeMinHeap struct {\\n    data []int\\n    indices map[int]int\\n    keys []int\\n}\\n\\nfunc newTimeMinHeap() *timeMinHeap {\\n    return &timeMinHeap {\\n        indices: make(map[int]int),\\n    }\\n}\\n\\nfunc (h *timeMinHeap) Contains(key int) bool {\\n    _, ok := h.indices[key]\\n    return ok\\n}\\n\\nfunc (h *timeMinHeap) Push(k int, v int) {\\n    if h.Contains(k) {\\n        h.update(k, v)\\n        return\\n    }\\n    h.push(k, v)\\n}\\n\\nfunc (h *timeMinHeap) push(k int, v int) {\\n    h.data = append(h.data, v)\\n    h.keys = append(h.keys, k)\\n    h.indices[k] = len(h.data)-1\\n\\n    h.swim(len(h.data)-1)\\n}\\n\\nfunc (h *timeMinHeap) Update(k int, v int) {\\n    if !h.Contains(k) {\\n        h.push(k, v)\\n        return\\n    }\\n    h.update(k, v)\\n}\\n\\nfunc (h *timeMinHeap) update(k int, v int) {\\n    idx := h.indices[k]\\n    h.data[idx] = v\\n    h.swim(idx)\\n    h.sink(idx)\\n}\\n\\nfunc (h *timeMinHeap) Pop() (int, int, bool) {\\n    if len(h.data) == 0 {\\n        return 0, 0, false\\n    }\\n\\n    k, v := h.keys[0], h.data[0]\\n    lastIdx := len(h.data)-1\\n    h.swap(0, lastIdx)\\n    h.data[lastIdx] = 0\\n    h.data = h.data[:lastIdx]\\n    h.keys = h.keys[:lastIdx]\\n    delete(h.indices, k)\\n    h.sink(0)\\n\\n    return k, v, true\\n}\\n\\nfunc (h *timeMinHeap) swim(idx int) {\\n    for ; idx > 0 && h.hasPriority(idx, (idx-1)/2); idx = (idx-1)/2 {\\n        h.swap(idx, (idx-1)/2)\\n    }\\n}\\n\\nfunc (h *timeMinHeap) sink(idx int) {\\n    for 2*idx+1 < len(h.data) {\\n        priorityChild := 2*idx + 1\\n        if priorityChild < len(h.data)-1 && h.hasPriority(priorityChild+1, priorityChild) {\\n            priorityChild++\\n        }\\n\\n        if !h.hasPriority(priorityChild, idx) {\\n            break\\n        }\\n\\n        h.swap(idx, priorityChild)\\n        idx = priorityChild\\n    }\\n}\\n\\nfunc (h *timeMinHeap) hasPriority(i, j int) bool {\\n    return h.data[i] < h.data[j]\\n} \\n\\nfunc (h *timeMinHeap) swap(i, j int) {\\n    iKey, jKey := h.keys[i], h.keys[j]\\n    h.data[i], h.data[j] = h.data[j], h.data[i]\\n    h.keys[i], h.keys[j] = h.keys[j], h.keys[i]\\n    h.indices[iKey], h.indices[jKey] = h.indices[jKey], h.indices[iKey]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// maximalPathQuality builds a weighted, undirected graph from the given\\n// edges, calculates the shortest paths from the source to each other\\n// vertex, then uses this data to speed up the DFS calculation of the\\n// maximum quality.\\nfunc maximalPathQuality(values []int, edges [][]int, maxTime int) int {\\n    g := newGraph(len(values), edges)\\n    shortestPaths := newDijkstraSP(g, 0)\\n    return calcMaxQuality(g, shortestPaths, values, maxTime)\\n}\\n\\n// Use depth-first search to explore all possible paths of weight maxTime\\n// that start and end at the source. Each time we encounter the source node,\\n// we record the quality of the current path and compare it to the maximum\\n// quality that could be obtained by exploring further. The maximum of these\\n// values is returned up the stack at each stage, resulting in the highest\\n// overall quality being returned.\\n// Using the shortest paths generated by Dijkstra\\'s algorithm, we ensure that\\n// we only explore paths that have a possibility of ending at the source.\\n// Time: O(me), where m is the number of paths of weight <= maxTime that start\\n// and end at the source, and e is the number of edge stemming from the vertices\\n// on such a path.\\n// Space: O(p), where p is the maximum length of a path with weight <= maxTime,\\n// which may be greater than the number of vertices in the graph.\\nfunc calcMaxQuality(g graph, shortestPaths *dijkstraSP, values []int, maxTime int) int {\\n    visited := make([]int, len(g))\\n\\n    var dfs func(v, time, quality int) int\\n    dfs = func(v, time, quality int) int {\\n        // If there\\'s no way to get back to the source in time, this path is no\\n        // good.\\n        if time+shortestPaths.timeTo[v] > maxTime {\\n            return 0\\n        }\\n\\n        // Add the value of the current node on the first visit.\\n        if visited[v] == 0 {\\n            quality += values[v]\\n        }\\n\\n        // Track the number of visits to the node in the current recursion.\\n        visited[v]++\\n\\n        // The maxQuality for the current recursion is 0 until the path meets\\n        // the source again.\\n        var maxQuality int\\n        if v == 0 {\\n            maxQuality = quality\\n        }\\n\\n        // Check each neighbor for paths with a higher maxQuality than we\\'ve\\n        // found so far.\\n        for _, e := range g[v] {\\n            w := e.other(v)\\n            timeToW := time + e.time\\n            qualityThroughW := dfs(w, timeToW, quality)\\n            maxQuality = max(maxQuality, qualityThroughW)\\n        }\\n\\n        visited[v]--\\n        \\n        return maxQuality\\n    }\\n\\n\\n    return dfs(0, 0, 0)\\n}\\n\\ntype edge struct {\\n    v, w int\\n    time int\\n}\\n\\nfunc (e *edge) either() int {\\n    return e.v\\n}\\n\\nfunc (e *edge) other(x int) int {\\n    if x == e.v {\\n        return e.w\\n    }\\n    if x == e.w {\\n        return e.v\\n    }\\n    panic(errors.New(fmt.Sprintf(\"edge %+v has no vertex %d\", e, x)))\\n}\\n\\ntype graph [][]*edge\\n\\n// newGraph builds a graph from the given edges.\\nfunc newGraph(n int, edges [][]int) graph {\\n    g := make(graph, n)\\n    for _, inputEdge := range edges {\\n        v, w, time := inputEdge[0], inputEdge[1], inputEdge[2]\\n        graphEdge := &edge{v, w, time}\\n        g[v] = append(g[v], graphEdge)\\n        g[w] = append(g[w], graphEdge)\\n    }\\n\\n    return g\\n}\\n\\n// dijkstraSP calculates and stores the smallest time to travel from\\n// the given source node to each other node in the graph using Dijkstra\\'s\\n// algorithm.\\ntype dijkstraSP struct {\\n    timeTo []int\\n}\\n\\nfunc newDijkstraSP(g graph, source int) *dijkstraSP {\\n    d := &dijkstraSP{}\\n    d.build(g, source)\\n    return d\\n}\\n\\n// Dijkstra\\'s algorithm. This implementation uses a symbol heap with\\n// random access to store only the shortest known edge to each vertex\\n// whose shortest path has not yet been discovered. This allows us\\n// to calculate all shortest paths in O(E\\xB7logV) time.\\nfunc (d *dijkstraSP) build(g graph, source int) {\\n    timeTo := make([]int, len(g))\\n    timePQ := newTimeMinHeap()\\n\\n    for i := range timeTo {\\n        timeTo[i] = math.MaxInt\\n    }\\n    timeTo[source] = 0\\n    timePQ.Push(0, 0)\\n\\n    relax := func(v int) {\\n        for _, e := range g[v] {\\n            w := e.other(v)\\n            candidateTime := timeTo[v] + e.time\\n            if candidateTime < timeTo[w] {\\n                timeTo[w] = candidateTime\\n                timePQ.Update(w, candidateTime)\\n            }\\n        }\\n    }\\n\\n    for v, _, ok := timePQ.Pop(); ok; v, _, ok = timePQ.Pop() {\\n        relax(v)\\n    }\\n\\n    d.timeTo = timeTo\\n}\\n\\n// timeMinHeap implements a priority queue for integers with random access\\n// using integer keys that correspond to vertices. The nature of Go\\'s\\n// standard container/heap interface is such that it requires just as many\\n// lines of code to implement a symbol heap from scratch as it does to\\n// wrap the standard library functions with extra logic to handle random\\n// access.\\ntype timeMinHeap struct {\\n    data []int\\n    indices map[int]int\\n    keys []int\\n}\\n\\nfunc newTimeMinHeap() *timeMinHeap {\\n    return &timeMinHeap {\\n        indices: make(map[int]int),\\n    }\\n}\\n\\nfunc (h *timeMinHeap) Contains(key int) bool {\\n    _, ok := h.indices[key]\\n    return ok\\n}\\n\\nfunc (h *timeMinHeap) Push(k int, v int) {\\n    if h.Contains(k) {\\n        h.update(k, v)\\n        return\\n    }\\n    h.push(k, v)\\n}\\n\\nfunc (h *timeMinHeap) push(k int, v int) {\\n    h.data = append(h.data, v)\\n    h.keys = append(h.keys, k)\\n    h.indices[k] = len(h.data)-1\\n\\n    h.swim(len(h.data)-1)\\n}\\n\\nfunc (h *timeMinHeap) Update(k int, v int) {\\n    if !h.Contains(k) {\\n        h.push(k, v)\\n        return\\n    }\\n    h.update(k, v)\\n}\\n\\nfunc (h *timeMinHeap) update(k int, v int) {\\n    idx := h.indices[k]\\n    h.data[idx] = v\\n    h.swim(idx)\\n    h.sink(idx)\\n}\\n\\nfunc (h *timeMinHeap) Pop() (int, int, bool) {\\n    if len(h.data) == 0 {\\n        return 0, 0, false\\n    }\\n\\n    k, v := h.keys[0], h.data[0]\\n    lastIdx := len(h.data)-1\\n    h.swap(0, lastIdx)\\n    h.data[lastIdx] = 0\\n    h.data = h.data[:lastIdx]\\n    h.keys = h.keys[:lastIdx]\\n    delete(h.indices, k)\\n    h.sink(0)\\n\\n    return k, v, true\\n}\\n\\nfunc (h *timeMinHeap) swim(idx int) {\\n    for ; idx > 0 && h.hasPriority(idx, (idx-1)/2); idx = (idx-1)/2 {\\n        h.swap(idx, (idx-1)/2)\\n    }\\n}\\n\\nfunc (h *timeMinHeap) sink(idx int) {\\n    for 2*idx+1 < len(h.data) {\\n        priorityChild := 2*idx + 1\\n        if priorityChild < len(h.data)-1 && h.hasPriority(priorityChild+1, priorityChild) {\\n            priorityChild++\\n        }\\n\\n        if !h.hasPriority(priorityChild, idx) {\\n            break\\n        }\\n\\n        h.swap(idx, priorityChild)\\n        idx = priorityChild\\n    }\\n}\\n\\nfunc (h *timeMinHeap) hasPriority(i, j int) bool {\\n    return h.data[i] < h.data[j]\\n} \\n\\nfunc (h *timeMinHeap) swap(i, j int) {\\n    iKey, jKey := h.keys[i], h.keys[j]\\n    h.data[i], h.data[j] = h.data[j], h.data[i]\\n    h.keys[i], h.keys[j] = h.keys[j], h.keys[i]\\n    h.indices[iKey], h.indices[jKey] = h.indices[jKey], h.indices[iKey]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167725,
                "title": "go-dfs-with-memoization-spoiler-not-worth-the-performance-overhead",
                "content": "# Approach\\nUse DFS to visit all paths of weight maxTime, memoizing the quality of already-visited paths to save time on subsequent passess.\\n\\nThis is effective in theory, but since Go slice types are non-comparable, the only way to cache the already-visited nodes for each DFS call is to use a large bit vector, which must be copied on each call.\\n\\nThe performance overhead of these copies outweighs any gains from the caching.\\n\\n# Complexity\\n- Time complexity:\\n$$O(pq)$$, where $$p$$ is the number of paths of weight maxTime, and $$q$$ is the maximum number of vertices on such a path.\\n\\n- Space complexity:\\n$$O(max(n, q))$$, where n is the number of vertices in the graph, and q is the maximum number of vertices on a path of weight maxTime (since vertices may be repeated, this is not limited by the number of vertices in the graph).\\n\\n# Code\\n```\\ntype edge struct {\\n    v, w int\\n    time int\\n}\\n\\nfunc (e *edge) either() int {\\n    return e.v\\n}\\n\\nfunc (e *edge) other(x int) int {\\n    if x == e.v {\\n        return e.w\\n    }\\n    if x == e.w {\\n        return e.v\\n    }\\n    panic(errors.New(fmt.Sprintf(\"edge %+v has no vertex %d\", e, x)))\\n}\\n\\ntype graph [][]*edge\\n\\nfunc newGraph(n int, edges [][]int) graph {\\n    g := make(graph, n)\\n    for _, inputEdge := range edges {\\n        v, w, time := inputEdge[0], inputEdge[1], inputEdge[2]\\n        graphEdge := &edge{v, w, time}\\n        g[v] = append(g[v], graphEdge)\\n        g[w] = append(g[w], graphEdge)\\n    }\\n\\n    return g\\n}\\n\\n// dfsParams represent the parameters in a single call to a dfsFunc.\\ntype dfsParams struct {\\n    v, time, quality int\\n    visited intSet\\n}\\n\\n// dfsCache stores the maxQuality of a depth-first search for the given\\n// parameters.\\ntype dfsCache map[dfsParams]int\\n\\nfunc (c dfsCache) set(v, time, quality, maxQuality int, visited intSet) {\\n    params := dfsParams{\\n        v: v,\\n        time: time,\\n        quality: quality,\\n        visited: visited,\\n    }\\n    c[params] = maxQuality\\n}\\n\\nfunc (c dfsCache) get(v, time, quality int, visited intSet) (int, bool) {\\n    params := dfsParams{\\n        v: v,\\n        time: time,\\n        quality: quality,\\n        visited: visited,\\n    }\\n    maxQuality, ok := c[params]\\n    return maxQuality, ok\\n}\\n\\n// dfsFunc is a memoizable depth-first search function.\\ntype dfsFunc func(v, time, quality int, visited intSet) int\\n\\n// dfsMemo wraps a dfsFunc and memoizes its calls.\\ntype dfsMemo struct {\\n    dfsFunc dfsFunc\\n    cache dfsCache\\n}\\n\\nfunc (memo *dfsMemo) dfs(v, time, quality int, visited intSet) int {\\n    if cached, ok := memo.cache.get(v, time, quality, visited); ok {\\n        return cached\\n    }\\n\\n    maxQuality := memo.dfsFunc(v, time, quality, visited)\\n    memo.cache.set(v, time, quality, maxQuality, visited)\\n    return maxQuality\\n}\\n\\n// intSet is a bit vector representing a set of ints up to 1024,\\n// enough to handle the maxiumum input vertices of 1000.\\ntype intSet [16]int64\\n\\nfunc (s *intSet) set(i int64) {\\n    word := i / 64\\n    bit := i % 64\\n    s[word] |= (1<<bit)\\n}\\n\\nfunc (s *intSet) contains(i int64) bool {\\n    word := i / 64\\n    bit := i % 64\\n    return s[word] & (1<<bit) != 0\\n}\\n\\n// maximalPathQuality builds a weighted, undirected graph from the given\\n// edges, then calculates the maximum quality for the graph using DFS.\\nfunc maximalPathQuality(values []int, edges [][]int, maxTime int) int {\\n    g := newGraph(len(values), edges)\\n    return calcMaxQuality(g, values, maxTime)\\n}\\n\\n// Use depth-first search to explore all possible paths of weight maxTime,\\n// returning the discovered maxQuality up the call stack when we encounter\\n// the 0-node, or setting maxQuality for a given path to zero if we exceed\\n// the time limit.\\n// Time: O(mn), where m is the number of paths of weight maxTime, and n is\\n// the maximum number of vertices on such a path.\\n// Space: O(n).\\nfunc calcMaxQuality(g graph, values []int, maxTime int) int {\\n    var dfs dfsFunc\\n    dfs = func(v, time, quality int, visited intSet) int {\\n        if time > maxTime {\\n            return 0\\n        }\\n\\n        if !visited.contains(int64(v)) {\\n            quality += values[v]\\n            visited.set(int64(v))\\n        }\\n\\n        var maxQuality int\\n        if v == 0 {\\n            maxQuality = quality\\n        }\\n\\n        for _, e := range g[v] {\\n            w := e.other(v)\\n            timeToW := time + e.time\\n            qualityThroughW := dfs(w, timeToW, quality, visited)\\n            maxQuality = max(maxQuality, qualityThroughW)\\n        }\\n        \\n        return maxQuality\\n    }\\n\\n    // Memoizing the result of each depth-first search theoretically allows\\n    // us to save time by not repeating dead-end paths. However, since Go\\n    // slice types are not comparable, we must pass a large bit vector as part\\n    // of the cache key. Copying the bit vector down the call stack has a\\n    // performance overhead greater than the time savings of the cache.\\n    memo := &dfsMemo{\\n        dfsFunc: dfs,\\n        cache: make(dfsCache),\\n    }\\n\\n    var visited intSet\\n    visited.set(0)\\n    return memo.dfs(0, 0, values[0], visited)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype edge struct {\\n    v, w int\\n    time int\\n}\\n\\nfunc (e *edge) either() int {\\n    return e.v\\n}\\n\\nfunc (e *edge) other(x int) int {\\n    if x == e.v {\\n        return e.w\\n    }\\n    if x == e.w {\\n        return e.v\\n    }\\n    panic(errors.New(fmt.Sprintf(\"edge %+v has no vertex %d\", e, x)))\\n}\\n\\ntype graph [][]*edge\\n\\nfunc newGraph(n int, edges [][]int) graph {\\n    g := make(graph, n)\\n    for _, inputEdge := range edges {\\n        v, w, time := inputEdge[0], inputEdge[1], inputEdge[2]\\n        graphEdge := &edge{v, w, time}\\n        g[v] = append(g[v], graphEdge)\\n        g[w] = append(g[w], graphEdge)\\n    }\\n\\n    return g\\n}\\n\\n// dfsParams represent the parameters in a single call to a dfsFunc.\\ntype dfsParams struct {\\n    v, time, quality int\\n    visited intSet\\n}\\n\\n// dfsCache stores the maxQuality of a depth-first search for the given\\n// parameters.\\ntype dfsCache map[dfsParams]int\\n\\nfunc (c dfsCache) set(v, time, quality, maxQuality int, visited intSet) {\\n    params := dfsParams{\\n        v: v,\\n        time: time,\\n        quality: quality,\\n        visited: visited,\\n    }\\n    c[params] = maxQuality\\n}\\n\\nfunc (c dfsCache) get(v, time, quality int, visited intSet) (int, bool) {\\n    params := dfsParams{\\n        v: v,\\n        time: time,\\n        quality: quality,\\n        visited: visited,\\n    }\\n    maxQuality, ok := c[params]\\n    return maxQuality, ok\\n}\\n\\n// dfsFunc is a memoizable depth-first search function.\\ntype dfsFunc func(v, time, quality int, visited intSet) int\\n\\n// dfsMemo wraps a dfsFunc and memoizes its calls.\\ntype dfsMemo struct {\\n    dfsFunc dfsFunc\\n    cache dfsCache\\n}\\n\\nfunc (memo *dfsMemo) dfs(v, time, quality int, visited intSet) int {\\n    if cached, ok := memo.cache.get(v, time, quality, visited); ok {\\n        return cached\\n    }\\n\\n    maxQuality := memo.dfsFunc(v, time, quality, visited)\\n    memo.cache.set(v, time, quality, maxQuality, visited)\\n    return maxQuality\\n}\\n\\n// intSet is a bit vector representing a set of ints up to 1024,\\n// enough to handle the maxiumum input vertices of 1000.\\ntype intSet [16]int64\\n\\nfunc (s *intSet) set(i int64) {\\n    word := i / 64\\n    bit := i % 64\\n    s[word] |= (1<<bit)\\n}\\n\\nfunc (s *intSet) contains(i int64) bool {\\n    word := i / 64\\n    bit := i % 64\\n    return s[word] & (1<<bit) != 0\\n}\\n\\n// maximalPathQuality builds a weighted, undirected graph from the given\\n// edges, then calculates the maximum quality for the graph using DFS.\\nfunc maximalPathQuality(values []int, edges [][]int, maxTime int) int {\\n    g := newGraph(len(values), edges)\\n    return calcMaxQuality(g, values, maxTime)\\n}\\n\\n// Use depth-first search to explore all possible paths of weight maxTime,\\n// returning the discovered maxQuality up the call stack when we encounter\\n// the 0-node, or setting maxQuality for a given path to zero if we exceed\\n// the time limit.\\n// Time: O(mn), where m is the number of paths of weight maxTime, and n is\\n// the maximum number of vertices on such a path.\\n// Space: O(n).\\nfunc calcMaxQuality(g graph, values []int, maxTime int) int {\\n    var dfs dfsFunc\\n    dfs = func(v, time, quality int, visited intSet) int {\\n        if time > maxTime {\\n            return 0\\n        }\\n\\n        if !visited.contains(int64(v)) {\\n            quality += values[v]\\n            visited.set(int64(v))\\n        }\\n\\n        var maxQuality int\\n        if v == 0 {\\n            maxQuality = quality\\n        }\\n\\n        for _, e := range g[v] {\\n            w := e.other(v)\\n            timeToW := time + e.time\\n            qualityThroughW := dfs(w, timeToW, quality, visited)\\n            maxQuality = max(maxQuality, qualityThroughW)\\n        }\\n        \\n        return maxQuality\\n    }\\n\\n    // Memoizing the result of each depth-first search theoretically allows\\n    // us to save time by not repeating dead-end paths. However, since Go\\n    // slice types are not comparable, we must pass a large bit vector as part\\n    // of the cache key. Copying the bit vector down the call stack has a\\n    // performance overhead greater than the time savings of the cache.\\n    memo := &dfsMemo{\\n        dfsFunc: dfs,\\n        cache: make(dfsCache),\\n    }\\n\\n    var visited intSet\\n    visited.set(0)\\n    return memo.dfs(0, 0, values[0], visited)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3134009,
                "title": "javascript-backtracking",
                "content": "```\\n/**\\n * @param {number[]} values\\n * @param {number[][]} edges\\n * @param {number} maxTime\\n * @return {number}\\n */\\nvar maximalPathQuality = function (values, edges, maxTime) {\\n  const n = values.length;\\n  const graph = new Array(n).fill().map((_) => []);\\n  for (const [v1, v2, time] of edges) {\\n    graph[v1].push([v2, time]);\\n    graph[v2].push([v1, time]);\\n  }\\n\\n  const visited = new Array(n).fill(0);\\n  visited[0] = 1;\\n  const ans = { val: 0 };\\n  backtrack(ans, graph, maxTime, values[0], 0, values, visited);\\n\\n  return ans.val;\\n};\\n\\nfunction backtrack(ans, graph, maxTime, sum, node, values, visited) {\\n  if (node === 0) {\\n    ans.val = Math.max(ans.val, sum);\\n  }\\n\\n  for (const [next, time] of graph[node]) {\\n    const nextMaxTime = maxTime - time;\\n    if (nextMaxTime < 0) continue;\\n\\n    visited[next]++;\\n    let nextSum = sum;\\n    if (visited[next] === 1) nextSum += values[next];\\n    backtrack(ans, graph, nextMaxTime, nextSum, next, values, visited);\\n    visited[next]--;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} values\\n * @param {number[][]} edges\\n * @param {number} maxTime\\n * @return {number}\\n */\\nvar maximalPathQuality = function (values, edges, maxTime) {\\n  const n = values.length;\\n  const graph = new Array(n).fill().map((_) => []);\\n  for (const [v1, v2, time] of edges) {\\n    graph[v1].push([v2, time]);\\n    graph[v2].push([v1, time]);\\n  }\\n\\n  const visited = new Array(n).fill(0);\\n  visited[0] = 1;\\n  const ans = { val: 0 };\\n  backtrack(ans, graph, maxTime, values[0], 0, values, visited);\\n\\n  return ans.val;\\n};\\n\\nfunction backtrack(ans, graph, maxTime, sum, node, values, visited) {\\n  if (node === 0) {\\n    ans.val = Math.max(ans.val, sum);\\n  }\\n\\n  for (const [next, time] of graph[node]) {\\n    const nextMaxTime = maxTime - time;\\n    if (nextMaxTime < 0) continue;\\n\\n    visited[next]++;\\n    let nextSum = sum;\\n    if (visited[next] === 1) nextSum += values[next];\\n    backtrack(ans, graph, nextMaxTime, nextSum, next, values, visited);\\n    visited[next]--;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3122144,
                "title": "golang-simple-backtracking-easy-to-understand",
                "content": "```go\\nfunc maximalPathQuality(values []int, edges [][]int, maxTime int) int {\\n  adjacencyList := make([][][2]int, len(values))\\n  for _, edge := range edges {\\n    adjacencyList[edge[0]] = append(adjacencyList[edge[0]], [2]int{edge[1], edge[2]})\\n    adjacencyList[edge[1]] = append(adjacencyList[edge[1]], [2]int{edge[0], edge[2]})\\n  }\\n  // We\\'ll keep track of the count of each visits so we can only add the value\\n  // when we\\'re visiting the node for the first time.\\n  visited := make([]int, len(values))\\n  var res int\\n  visited[0] = 1\\n  backtrack(adjacencyList, values, 0, values[0], 0, maxTime, visited, &res)\\n  return res\\n}\\n\\nfunc backtrack(adjacencyList [][][2]int, values []int, node int, currVal, currTime int, maxTime int, visited []int, res *int) {\\n  if node == 0 {\\n    // If we\\'re visiting node 0 and we\\'ve already visited previously\\n    *res = max(*res, currVal)\\n  }\\n  for _, next := range adjacencyList[node] {\\n    nei, time := next[0], next[1]\\n    if currTime + time > maxTime {\\n      continue\\n    }\\n    newVal := currVal\\n    if visited[nei] == 0 {\\n      // If this is the first time we\\'re visiting this node\\n      newVal += values[nei]\\n    }\\n    visited[nei]++\\n    backtrack(adjacencyList, values, nei, newVal, currTime + time, maxTime, visited, res)\\n    visited[nei]--\\n  }\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```go\\nfunc maximalPathQuality(values []int, edges [][]int, maxTime int) int {\\n  adjacencyList := make([][][2]int, len(values))\\n  for _, edge := range edges {\\n    adjacencyList[edge[0]] = append(adjacencyList[edge[0]], [2]int{edge[1], edge[2]})\\n    adjacencyList[edge[1]] = append(adjacencyList[edge[1]], [2]int{edge[0], edge[2]})\\n  }\\n  // We\\'ll keep track of the count of each visits so we can only add the value\\n  // when we\\'re visiting the node for the first time.\\n  visited := make([]int, len(values))\\n  var res int\\n  visited[0] = 1\\n  backtrack(adjacencyList, values, 0, values[0], 0, maxTime, visited, &res)\\n  return res\\n}\\n\\nfunc backtrack(adjacencyList [][][2]int, values []int, node int, currVal, currTime int, maxTime int, visited []int, res *int) {\\n  if node == 0 {\\n    // If we\\'re visiting node 0 and we\\'ve already visited previously\\n    *res = max(*res, currVal)\\n  }\\n  for _, next := range adjacencyList[node] {\\n    nei, time := next[0], next[1]\\n    if currTime + time > maxTime {\\n      continue\\n    }\\n    newVal := currVal\\n    if visited[nei] == 0 {\\n      // If this is the first time we\\'re visiting this node\\n      newVal += values[nei]\\n    }\\n    visited[nei]++\\n    backtrack(adjacencyList, values, nei, newVal, currTime + time, maxTime, visited, res)\\n    visited[nei]--\\n  }\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3108773,
                "title": "c-dfs-with-pruning-by-distance",
                "content": "# Approach\\nWe can DFS on the graph until we run out of time, and collect the max value we got every time we reach the start point.\\nAs an optimazation, we can stop searching when we are sure that we can not return to start point with the time remain. To do so, we pre-calculate all the minimal costs from start point to each node using shortest path algorithm.\\n\\n# Complexity\\n- Time complexity: Dijkstra using min-heap $$O(N+logE)$$ + DFS $$O(4^{PathSize})$$ (up to 4 edges per node)\\n\\n- Space complexity: $$O(N+E)$$ + stack $$O(PathSize)$$\\n\\n# Code\\n```\\nstruct edge_t {\\n    int next;\\n    int cost;\\n};\\nstruct node_t {\\n    int value;\\n    int min_cost{numeric_limits<int>::max()};\\n    bool visited{};\\n    vector<edge_t> adjs;\\n};\\n\\nclass Solution {\\n    // Dijkstra\\'s Algorithm\\n    void generate_min_paths(vector<node_t> & nodes) {\\n        priority_queue q{[&](int l, int r){\\n            return nodes[l].min_cost > nodes[r].min_cost;\\n        }, vector<int>()};\\n        nodes[0].min_cost = 0;\\n        q.push(0);\\n        while (!q.empty()) {\\n            int i = q.top();\\n            q.pop();\\n            for (auto & adj : nodes[i].adjs) {\\n                if (nodes[i].min_cost + adj.cost < nodes[adj.next].min_cost) {\\n                    nodes[adj.next].min_cost = nodes[i].min_cost + adj.cost;\\n                    q.push(adj.next);\\n                }\\n            }\\n        }\\n    }\\n\\n    // DFS-search\\n    void search(vector<node_t> & nodes, int i, int w, int max_time, int & result) {\\n        bool visited = nodes[i].visited;\\n        nodes[i].visited = true;\\n        if (!visited) {\\n            w += nodes[i].value;\\n        }\\n        if (i == 0) {\\n            result = max(result, w);\\n        }\\n        for (auto & adj : nodes[i].adjs) {\\n            if (nodes[adj.next].min_cost + adj.cost > max_time) {\\n                continue;\\n            }\\n            search(nodes, adj.next, w, max_time - adj.cost, result);\\n        }\\n        nodes[i].visited = visited;\\n    }\\n\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int max_time) {\\n        int n = values.size();\\n        vector<node_t> nodes(n);\\n        for (int i = 0; i < values.size(); ++i) {\\n            nodes[i].value = values[i];\\n        }\\n        for (auto & edge : edges) {\\n            nodes[edge[0]].adjs.push_back({edge[1], edge[2]});\\n            nodes[edge[1]].adjs.push_back({edge[0], edge[2]});\\n        }\\n        \\n        generate_min_paths(nodes);\\n\\n        int result = 0;\\n        search(nodes, 0, 0, max_time, result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\nstruct edge_t {\\n    int next;\\n    int cost;\\n};\\nstruct node_t {\\n    int value;\\n    int min_cost{numeric_limits<int>::max()};\\n    bool visited{};\\n    vector<edge_t> adjs;\\n};\\n\\nclass Solution {\\n    // Dijkstra\\'s Algorithm\\n    void generate_min_paths(vector<node_t> & nodes) {\\n        priority_queue q{[&](int l, int r){\\n            return nodes[l].min_cost > nodes[r].min_cost;\\n        }, vector<int>()};\\n        nodes[0].min_cost = 0;\\n        q.push(0);\\n        while (!q.empty()) {\\n            int i = q.top();\\n            q.pop();\\n            for (auto & adj : nodes[i].adjs) {\\n                if (nodes[i].min_cost + adj.cost < nodes[adj.next].min_cost) {\\n                    nodes[adj.next].min_cost = nodes[i].min_cost + adj.cost;\\n                    q.push(adj.next);\\n                }\\n            }\\n        }\\n    }\\n\\n    // DFS-search\\n    void search(vector<node_t> & nodes, int i, int w, int max_time, int & result) {\\n        bool visited = nodes[i].visited;\\n        nodes[i].visited = true;\\n        if (!visited) {\\n            w += nodes[i].value;\\n        }\\n        if (i == 0) {\\n            result = max(result, w);\\n        }\\n        for (auto & adj : nodes[i].adjs) {\\n            if (nodes[adj.next].min_cost + adj.cost > max_time) {\\n                continue;\\n            }\\n            search(nodes, adj.next, w, max_time - adj.cost, result);\\n        }\\n        nodes[i].visited = visited;\\n    }\\n\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int max_time) {\\n        int n = values.size();\\n        vector<node_t> nodes(n);\\n        for (int i = 0; i < values.size(); ++i) {\\n            nodes[i].value = values[i];\\n        }\\n        for (auto & edge : edges) {\\n            nodes[edge[0]].adjs.push_back({edge[1], edge[2]});\\n            nodes[edge[1]].adjs.push_back({edge[0], edge[2]});\\n        }\\n        \\n        generate_min_paths(nodes);\\n\\n        int result = 0;\\n        search(nodes, 0, 0, max_time, result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104423,
                "title": "limited-premium-exclusive-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values, E, maxTime):\\n        G = defaultdict(list)\\n        for x, y, w in E:\\n            G[x].append((y, w))\\n            G[y].append((x, w))\\n            \\n        def dfs(node, visited, gain, cost):\\n            if node == 0: self.ans = max(self.ans, gain)\\n            for neib, w in G[node]:\\n                if w <= cost:\\n                    dfs(neib, visited | set([neib]), gain + (neib not in visited) * values[neib], cost - w)\\n\\n        self.ans = 0\\n        dfs(0, set([0]), values[0], maxTime)\\n        return self.ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values, E, maxTime):\\n        G = defaultdict(list)\\n        for x, y, w in E:\\n            G[x].append((y, w))\\n            G[y].append((x, w))\\n            \\n        def dfs(node, visited, gain, cost):\\n            if node == 0: self.ans = max(self.ans, gain)\\n            for neib, w in G[node]:\\n                if w <= cost:\\n                    dfs(neib, visited | set([neib]), gain + (neib not in visited) * values[neib], cost - w)\\n\\n        self.ans = 0\\n        dfs(0, set([0]), values[0], maxTime)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052101,
                "title": "simple-java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        int n = values.length;\\n        for (int i = 0; i < n; i++) map.put(i, new HashMap<>());\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).put(edge[1], edge[2]);\\n            map.get(edge[1]).put(edge[0], edge[2]);\\n        }\\n        Map<Integer, Integer> visited = new HashMap<Integer, Integer>();\\n        visited.put(0, 1);\\n        dfs(0, maxTime, values[0], visited, values, map);\\n        return res;\\n    }\\n\\n    public void dfs(int cur, int time, int value, Map<Integer, Integer> visited, int[] values, Map<Integer, Map<Integer, Integer>> map) {\\n        if (cur == 0) {\\n            res = Math.max(res, value);\\n        }\\n        for (Map.Entry<Integer, Integer> entry : map.get(cur).entrySet()) {\\n            if (time < entry.getValue()) continue;\\n            if (!visited.containsKey(entry.getKey())) value += values[entry.getKey()];\\n            visited.put(entry.getKey(), visited.getOrDefault(entry.getKey(), 0) + 1);\\n            dfs(entry.getKey(), time - entry.getValue(), value, visited, values, map);\\n            visited.put(entry.getKey(), visited.getOrDefault(entry.getKey(), 0) - 1);\\n            if (visited.get(entry.getKey()) == 0) {\\n                visited.remove(entry.getKey());\\n                value -= values[entry.getKey()];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        int n = values.length;\\n        for (int i = 0; i < n; i++) map.put(i, new HashMap<>());\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).put(edge[1], edge[2]);\\n            map.get(edge[1]).put(edge[0], edge[2]);\\n        }\\n        Map<Integer, Integer> visited = new HashMap<Integer, Integer>();\\n        visited.put(0, 1);\\n        dfs(0, maxTime, values[0], visited, values, map);\\n        return res;\\n    }\\n\\n    public void dfs(int cur, int time, int value, Map<Integer, Integer> visited, int[] values, Map<Integer, Map<Integer, Integer>> map) {\\n        if (cur == 0) {\\n            res = Math.max(res, value);\\n        }\\n        for (Map.Entry<Integer, Integer> entry : map.get(cur).entrySet()) {\\n            if (time < entry.getValue()) continue;\\n            if (!visited.containsKey(entry.getKey())) value += values[entry.getKey()];\\n            visited.put(entry.getKey(), visited.getOrDefault(entry.getKey(), 0) + 1);\\n            dfs(entry.getKey(), time - entry.getValue(), value, visited, values, map);\\n            visited.put(entry.getKey(), visited.getOrDefault(entry.getKey(), 0) - 1);\\n            if (visited.get(entry.getKey()) == 0) {\\n                visited.remove(entry.getKey());\\n                value -= values[entry.getKey()];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916945,
                "title": "easy-to-understand-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    using vpi = vector<vector<pair<int,int>>>;\\n    int result = 0;\\n    void helper(vector<int>&values, int node, vpi &adj, int maxTime, long int curTime, int curTotal, vector<int> &visited) {\\n        // if overshooting the current time backtrack\\n        if (curTime > maxTime) {\\n            return;\\n        }\\n        // if node visited first time just add the value\\n        if (visited[node] == 0) {\\n            curTotal += values[node];\\n        }\\n        visited[node]++;\\n        // Everytime we reach node 0 just capture the total cost\\n        if (node == 0)\\n            result = max(result,curTotal);\\n        \\n        // iterate all the paths from given node\\n        for (auto &n : adj[node]) {\\n            auto[next,cost] = n;\\n            helper(values,next,adj,maxTime,curTime + cost, curTotal,visited);\\n        }\\n        // node done just reduce the frqeuency\\n        visited[node]--;\\n        // if node is done take out its weight from the total\\n        if (visited[node] == 0) {\\n            curTotal -= values[node];\\n        }\\n    }\\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        vector<int> visited(n,0);\\n        vpi adj(n);\\n        for (auto &e : edges) {\\n            adj[e[0]].push_back({e[1],e[2]});\\n            adj[e[1]].push_back({e[0],e[2]});\\n        }\\n        helper(values,0,adj,maxTime,0,0,visited);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using vpi = vector<vector<pair<int,int>>>;\\n    int result = 0;\\n    void helper(vector<int>&values, int node, vpi &adj, int maxTime, long int curTime, int curTotal, vector<int> &visited) {\\n        // if overshooting the current time backtrack\\n        if (curTime > maxTime) {\\n            return;\\n        }\\n        // if node visited first time just add the value\\n        if (visited[node] == 0) {\\n            curTotal += values[node];\\n        }\\n        visited[node]++;\\n        // Everytime we reach node 0 just capture the total cost\\n        if (node == 0)\\n            result = max(result,curTotal);\\n        \\n        // iterate all the paths from given node\\n        for (auto &n : adj[node]) {\\n            auto[next,cost] = n;\\n            helper(values,next,adj,maxTime,curTime + cost, curTotal,visited);\\n        }\\n        // node done just reduce the frqeuency\\n        visited[node]--;\\n        // if node is done take out its weight from the total\\n        if (visited[node] == 0) {\\n            curTotal -= values[node];\\n        }\\n    }\\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        vector<int> visited(n,0);\\n        vpi adj(n);\\n        for (auto &e : edges) {\\n            adj[e[0]].push_back({e[1],e[2]});\\n            adj[e[1]].push_back({e[0],e[2]});\\n        }\\n        helper(values,0,adj,maxTime,0,0,visited);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864487,
                "title": "java-djikstra-s-dfs-explanation",
                "content": "I thought this was a pretty fun problem so I wanted to post my attempt at the solution (as I thought Djikstras algorithm would be handy for this problem).\\nI did not catch the fact that an acceptable solution would just be to use DFS, and I immediately thought I would have to prune the graph somehow.\\nThis led me to coming up with the following plan:\\n\\t1. Create a graph that includes the edges with time (I have a preference of this on many graph problems as I think it\\'s a cleaner solution to interviewers to see a HashMap<Integer, Node> graph;) O(V+E)\\n\\t2.  Use Djikstras algorithm to get the shortest path from a nodes back to the root node, this will help us ensure that when we are searching through the graph we are only heading to nodes that can travel back to the root node under the maximum time. O(V+E)\\n\\t3.  Use DFS to explore the valid nodes and calculate the maximum valid path. We will utilize the computations we did for Djikstra\\'s algorithm to prune the graph. (Not sure about the big O notation here)\\n\\nResults:\\nRuntime: 276 ms, faster than 75.18% of Java online submissions for Maximum Path Quality of a Graph.\\nMemory Usage: 43.5 MB, less than 86.17% of Java online submissions for Maximum Path Quality of a Graph.\\n\\n```\\nclass Node {\\n    int idx;\\n    // Mapping of neighbor id -> time to neighbor\\n    HashMap<Integer, Integer> neighbors;\\n    \\n    public Node(int idx) {\\n        this.idx = idx;\\n        this.neighbors = new HashMap<>();\\n    }\\n}\\n\\n\\nclass Solution {\\n    private int maxPath;\\n    \\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        // Step 1: Create a graph that includes the edges with time\\n        HashMap<Integer, Node> graph = new HashMap<>();\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            graph.put(i, new Node(i));\\n        }\\n        \\n        for (int[] edge : edges) {\\n            int i = edge[0];\\n            int j = edge[1];\\n            int time = edge[2];\\n            \\n            Node nodeI = graph.get(i);\\n            Node nodeJ = graph.get(j);\\n            // Add i -> j and j -> i edges with the cost in time\\n            nodeI.neighbors.put(j, time);\\n            nodeJ.neighbors.put(i, time);\\n        }\\n\\n        // Step 2: Create graph of shortest distance from nodes to root node (0)\\n        // Utilizing Djikstras algorithm is handy because we can stop finding the shortest distance when we get past (maxTime / 2)\\n        // as Djikstras will guarantee we find the shortest path back to the root node.\\n        // I thought to use this pathBack Map to help prune the tree when we are actually looking for the maximum valid path.\\n        HashMap<Integer, Integer> pathBack = new HashMap<>();\\n        boolean[] visited = new boolean[values.length];\\n        \\n        PriorityQueue<Pair<Node, Integer>> pq = new PriorityQueue<>(new Comparator<Pair<Node, Integer>>() {\\n            public int compare(Pair<Node, Integer> p1, Pair<Node, Integer> p2) {\\n                return p1.getValue() - p2.getValue();\\n            }\\n        });\\n        \\n        pq.offer(new Pair<Node, Integer>(graph.get(0), 0));\\n        visited[0] = true;\\n        \\n        while (!pq.isEmpty()) {\\n            Pair<Node, Integer> current = pq.poll();\\n            \\n            Node n = current.getKey();\\n            Integer currentTime = current.getValue();\\n            \\n            if (currentTime > maxTime) break;\\n            \\n            pathBack.put(n.idx, currentTime);\\n            \\n            for (Map.Entry<Integer, Integer> entry : n.neighbors.entrySet()) {\\n                Integer idx = entry.getKey();\\n                Integer travelTime = entry.getValue();\\n                \\n                if (visited[idx]) continue;\\n                \\n                int nextTime = currentTime + travelTime;\\n\\t\\t\\t\\t// During Djikstra\\'s don\\'t bother adding the shortest path for nodes which we cannot travel back to 0 from\\n                if (nextTime <= (maxTime / 2) + 1) {\\n                    pq.offer(new Pair<Node, Integer>(graph.get(idx), currentTime + travelTime));\\n                    visited[idx] = true;\\n                }\\n            }\\n        }\\n        \\n        // Step 3: Dfs through valid paths\\n        this.maxPath = values[0];\\n        \\n        dfs(0, 0, 0, maxTime, new int[values.length], graph, pathBack, values);\\n        \\n        return this.maxPath;\\n    }\\n    \\n    private void dfs(int node, int timeSpent, int score, int maxTime, int[] visited, HashMap<Integer, Node> graph, HashMap<Integer, Integer> pathBack, int[] values) {\\n        if (timeSpent > maxTime) return;\\n        \\n        // I was stuck on this bit and I had to search up how to handle the visited portion\\n        // From other solutions, it\\'s handy to use a int[] visited array since we only want to add to the score the first time we visit a node.\\n        if (visited[node] == 0) score += values[node];\\n        \\n        // A valid path has to end up on the root node, so this is the only time where we can update the maxPath\\n        if (node == 0) this.maxPath = Math.max(this.maxPath, score);\\n        \\n        visited[node]++;\\n        \\n        for (Map.Entry<Integer, Integer> neighbor : graph.get(node).neighbors.entrySet()) {\\n            Integer neighborId = neighbor.getKey();\\n            Integer neighborDistance = neighbor.getValue();\\n            \\n            // Prune the graph by only traversing to nodes which we can get back to the 0th idx\\n            if (!pathBack.containsKey(neighborId)) continue;\\n            \\n            // Furthur prune the graph by only traversing to nodes which will not go over the maxTime (after visiting)\\n            if (timeSpent + pathBack.get(neighborId) > maxTime) continue;\\n            \\n            // We have now pruned the graph to ensure the nodes we are expanding to will create a valid path\\n            dfs(neighborId, timeSpent + neighborDistance, score, maxTime, visited, graph, pathBack, values);\\n        }\\n        \\n        visited[node]--;\\n    }    \\n        \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Node {\\n    int idx;\\n    // Mapping of neighbor id -> time to neighbor\\n    HashMap<Integer, Integer> neighbors;\\n    \\n    public Node(int idx) {\\n        this.idx = idx;\\n        this.neighbors = new HashMap<>();\\n    }\\n}\\n\\n\\nclass Solution {\\n    private int maxPath;\\n    \\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        // Step 1: Create a graph that includes the edges with time\\n        HashMap<Integer, Node> graph = new HashMap<>();\\n        \\n        for (int i = 0; i < values.length; i++) {\\n            graph.put(i, new Node(i));\\n        }\\n        \\n        for (int[] edge : edges) {\\n            int i = edge[0];\\n            int j = edge[1];\\n            int time = edge[2];\\n            \\n            Node nodeI = graph.get(i);\\n            Node nodeJ = graph.get(j);\\n            // Add i -> j and j -> i edges with the cost in time\\n            nodeI.neighbors.put(j, time);\\n            nodeJ.neighbors.put(i, time);\\n        }\\n\\n        // Step 2: Create graph of shortest distance from nodes to root node (0)\\n        // Utilizing Djikstras algorithm is handy because we can stop finding the shortest distance when we get past (maxTime / 2)\\n        // as Djikstras will guarantee we find the shortest path back to the root node.\\n        // I thought to use this pathBack Map to help prune the tree when we are actually looking for the maximum valid path.\\n        HashMap<Integer, Integer> pathBack = new HashMap<>();\\n        boolean[] visited = new boolean[values.length];\\n        \\n        PriorityQueue<Pair<Node, Integer>> pq = new PriorityQueue<>(new Comparator<Pair<Node, Integer>>() {\\n            public int compare(Pair<Node, Integer> p1, Pair<Node, Integer> p2) {\\n                return p1.getValue() - p2.getValue();\\n            }\\n        });\\n        \\n        pq.offer(new Pair<Node, Integer>(graph.get(0), 0));\\n        visited[0] = true;\\n        \\n        while (!pq.isEmpty()) {\\n            Pair<Node, Integer> current = pq.poll();\\n            \\n            Node n = current.getKey();\\n            Integer currentTime = current.getValue();\\n            \\n            if (currentTime > maxTime) break;\\n            \\n            pathBack.put(n.idx, currentTime);\\n            \\n            for (Map.Entry<Integer, Integer> entry : n.neighbors.entrySet()) {\\n                Integer idx = entry.getKey();\\n                Integer travelTime = entry.getValue();\\n                \\n                if (visited[idx]) continue;\\n                \\n                int nextTime = currentTime + travelTime;\\n\\t\\t\\t\\t// During Djikstra\\'s don\\'t bother adding the shortest path for nodes which we cannot travel back to 0 from\\n                if (nextTime <= (maxTime / 2) + 1) {\\n                    pq.offer(new Pair<Node, Integer>(graph.get(idx), currentTime + travelTime));\\n                    visited[idx] = true;\\n                }\\n            }\\n        }\\n        \\n        // Step 3: Dfs through valid paths\\n        this.maxPath = values[0];\\n        \\n        dfs(0, 0, 0, maxTime, new int[values.length], graph, pathBack, values);\\n        \\n        return this.maxPath;\\n    }\\n    \\n    private void dfs(int node, int timeSpent, int score, int maxTime, int[] visited, HashMap<Integer, Node> graph, HashMap<Integer, Integer> pathBack, int[] values) {\\n        if (timeSpent > maxTime) return;\\n        \\n        // I was stuck on this bit and I had to search up how to handle the visited portion\\n        // From other solutions, it\\'s handy to use a int[] visited array since we only want to add to the score the first time we visit a node.\\n        if (visited[node] == 0) score += values[node];\\n        \\n        // A valid path has to end up on the root node, so this is the only time where we can update the maxPath\\n        if (node == 0) this.maxPath = Math.max(this.maxPath, score);\\n        \\n        visited[node]++;\\n        \\n        for (Map.Entry<Integer, Integer> neighbor : graph.get(node).neighbors.entrySet()) {\\n            Integer neighborId = neighbor.getKey();\\n            Integer neighborDistance = neighbor.getValue();\\n            \\n            // Prune the graph by only traversing to nodes which we can get back to the 0th idx\\n            if (!pathBack.containsKey(neighborId)) continue;\\n            \\n            // Furthur prune the graph by only traversing to nodes which will not go over the maxTime (after visiting)\\n            if (timeSpent + pathBack.get(neighborId) > maxTime) continue;\\n            \\n            // We have now pruned the graph to ensure the nodes we are expanding to will create a valid path\\n            dfs(neighborId, timeSpent + neighborDistance, score, maxTime, visited, graph, pathBack, values);\\n        }\\n        \\n        visited[node]--;\\n    }    \\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861924,
                "title": "python-dfs-brute-force-till-you-exhaust-maxtime",
                "content": "# Intuition\\nGiven the source node and destination node is same (0) and you can traverse the node infinite times, Dijkshtra\\'s shortest path will not work here. So brute force dfs till you exhaust the `maxTime`. Find out the the path with max values of nodes that ends at 0.\\n\\n# Approach\\n1. Start dfs at 0th node\\n2. If time taken by dfs path exceeds max limit then stop exploring (base condition)\\n3. If you have traversed back to 0th node update the result as `max(result, pathValue)` where `pathValue` is total of all values of node\\n4. Keep exploring further path with new set of visited nodes. Each set is exclusive for the path traversed.\\n\\n# Complexity\\n- Time complexity: Given base condition is `maxTime` we might end up traversing the all possible paths multiple times. Let\\'s say we end up traversing the adjList n times before exhaustion then time complexity can be stated as O(n*(v + e)) where v is no of vertices and e is no of edges.\\n\\n\\n- Space complexity: 0(v+e) for adj List and O(v*2) for all visited sets\\n\\n# Code\\n```\\nclass Solution:\\n    def dfs(self, node, visited, pathValue, pathTime):\\n        if pathTime > self.maxTime:\\n            return\\n        if node == 0:\\n            self.result = max(self.result, pathValue)\\n        for childNode, childTime in self.adjList[node]:\\n            newVisited = {_ for _ in visited}\\n            newPathValue = pathValue\\n            if childNode not in newVisited:\\n                newPathValue = pathValue + self.values[childNode]\\n                newVisited.add(childNode)\\n            self.dfs(childNode, newVisited, newPathValue, pathTime + childTime)\\n\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        self.adjList = {i:set() for i in range(len(values))}\\n        self.maxTime = maxTime\\n        self.values = values\\n        self.result = values[0]\\n        for source, dest, time in edges:\\n            self.adjList[source].add((dest, time))\\n            self.adjList[dest].add((source, time))\\n        visited = set()\\n        visited.add(0)\\n        self.dfs(0, visited, values[0], 0)\\n        return self.result\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, node, visited, pathValue, pathTime):\\n        if pathTime > self.maxTime:\\n            return\\n        if node == 0:\\n            self.result = max(self.result, pathValue)\\n        for childNode, childTime in self.adjList[node]:\\n            newVisited = {_ for _ in visited}\\n            newPathValue = pathValue\\n            if childNode not in newVisited:\\n                newPathValue = pathValue + self.values[childNode]\\n                newVisited.add(childNode)\\n            self.dfs(childNode, newVisited, newPathValue, pathTime + childTime)\\n\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        self.adjList = {i:set() for i in range(len(values))}\\n        self.maxTime = maxTime\\n        self.values = values\\n        self.result = values[0]\\n        for source, dest, time in edges:\\n            self.adjList[source].add((dest, time))\\n            self.adjList[dest].add((source, time))\\n        visited = set()\\n        visited.add(0)\\n        self.dfs(0, visited, values[0], 0)\\n        return self.result\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842290,
                "title": "c-dfs-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    void dfs(vector<int>& values,vector<pair<int,int>> adj[],int& maxTime,int currTime,unordered_map<int,int>& frequency,int node,int sum){\\n          sum+=values[node];\\n        if(node==0){     ///if we reach 0 means we have valid path starts at 0 and ends at 0\\n           ans=max(ans,sum);  \\n        }\\n        int temp=values[node];\\n         values[node]=0;\\n         for(auto child:adj[node]){\\n            if(currTime+child.second<=maxTime)\\n                 dfs(values,adj,maxTime,currTime+child.second,frequency,child.first,sum);   \\n         }\\n         values[node]=temp;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<pair<int,int>> adj[n];\\n        for(auto a:edges){\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});\\n        }\\n        unordered_map<int,int> frequency;\\n        dfs(values,adj,maxTime,0,frequency,0,0);\\n        return ans;\\n    }\\n    };\\n```\\n**If Helpful PLease Like Or Upvoke**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    void dfs(vector<int>& values,vector<pair<int,int>> adj[],int& maxTime,int currTime,unordered_map<int,int>& frequency,int node,int sum){\\n          sum+=values[node];\\n        if(node==0){     ///if we reach 0 means we have valid path starts at 0 and ends at 0\\n           ans=max(ans,sum);  \\n        }\\n        int temp=values[node];\\n         values[node]=0;\\n         for(auto child:adj[node]){\\n            if(currTime+child.second<=maxTime)\\n                 dfs(values,adj,maxTime,currTime+child.second,frequency,child.first,sum);   \\n         }\\n         values[node]=temp;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<pair<int,int>> adj[n];\\n        for(auto a:edges){\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});\\n        }\\n        unordered_map<int,int> frequency;\\n        dfs(values,adj,maxTime,0,frequency,0,0);\\n        return ans;\\n    }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841507,
                "title": "c-dfs",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N*N)+O(N)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\nlong long ans=0;\\n  void rec(int node,int time,int maxTime,long long sum,map<int,int> &mp, vector<vector<pair<int,int>>> &graph,vector<int> &values)\\n  {\\n      if(node==0)\\n      {\\n         if(time>maxTime)return;\\n         ans=max(ans,sum);\\n         if(time==maxTime)return;\\n         \\n      }\\n      if(time>=maxTime)return;\\n     for(auto g:graph[node])\\n     {\\n         int n1=g.first;\\n         int t=g.second;\\n         if(mp[n1]==0)\\n         {\\n             mp[n1]++;\\n             sum+=values[n1];\\n             rec(n1,time+t,maxTime,sum,mp,graph,values);\\n             sum-=values[n1];\\n             mp[n1]--;\\n         }\\n         else\\n         {   \\n             rec(n1,time+t,maxTime,sum,mp,graph,values);\\n         }\\n     }\\n  }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n           int n=values.size();\\n           vector<vector<pair<int,int>>>graph(n);\\n           for(int i=0;i<edges.size();i++)\\n           {\\n               graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n               graph[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n\\n           }\\n           map<int,int>mp;\\n           mp[0]=1;\\n           rec(0,0,maxTime,values[0],mp,graph,values);\\n           return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nlong long ans=0;\\n  void rec(int node,int time,int maxTime,long long sum,map<int,int> &mp, vector<vector<pair<int,int>>> &graph,vector<int> &values)\\n  {\\n      if(node==0)\\n      {\\n         if(time>maxTime)return;\\n         ans=max(ans,sum);\\n         if(time==maxTime)return;\\n         \\n      }\\n      if(time>=maxTime)return;\\n     for(auto g:graph[node])\\n     {\\n         int n1=g.first;\\n         int t=g.second;\\n         if(mp[n1]==0)\\n         {\\n             mp[n1]++;\\n             sum+=values[n1];\\n             rec(n1,time+t,maxTime,sum,mp,graph,values);\\n             sum-=values[n1];\\n             mp[n1]--;\\n         }\\n         else\\n         {   \\n             rec(n1,time+t,maxTime,sum,mp,graph,values);\\n         }\\n     }\\n  }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n           int n=values.size();\\n           vector<vector<pair<int,int>>>graph(n);\\n           for(int i=0;i<edges.size();i++)\\n           {\\n               graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n               graph[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n\\n           }\\n           map<int,int>mp;\\n           mp[0]=1;\\n           rec(0,0,maxTime,values[0],mp,graph,values);\\n           return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830948,
                "title": "java-simple-solution-using-dfs-backtracking-integer-visited-array",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public void helper(int[] values, int maxTime, int node, Map<Integer, List<Pair>> adjMap, int[] visited, int curr) {\\n        visited[node]++;\\n        if(visited[node]==1)\\n            curr += values[node];\\n        if(node == 0)\\n            ans = Math.max(ans, curr);\\n        for(Pair next: adjMap.get(node)) {\\n            if(next.time <= maxTime)\\n                helper(values, maxTime-next.time, next.to, adjMap, visited, curr);\\n        }\\n        visited[node]--; // backtrack\\n    }\\n    \\n    public void formAdjMap(int[][] edges, Map<Integer, List<Pair>> adjMap) {\\n        for(var edge: edges) {\\n            adjMap.get(edge[0]).add(new Pair(edge[1], edge[2]));\\n            adjMap.get(edge[1]).add(new Pair(edge[0], edge[2]));\\n        }\\n    }\\n    \\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        int[] visited = new int[n];\\n        Map<Integer, List<Pair>> adjMap = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n            adjMap.put(i, new ArrayList<>());\\n        formAdjMap(edges, adjMap);\\n        helper(values, maxTime, 0, adjMap, visited, 0);\\n        return ans;\\n    }\\n    class Pair {\\n        int to, time;\\n        public Pair(int to, int time) {\\n            this.to = to;\\n            this.time = time;\\n        }\\n        \\n        public String toString() {\\n            return \"<\"+this.to+\", \"+this.time+\">\";\\n        }\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public void helper(int[] values, int maxTime, int node, Map<Integer, List<Pair>> adjMap, int[] visited, int curr) {\\n        visited[node]++;\\n        if(visited[node]==1)\\n            curr += values[node];\\n        if(node == 0)\\n            ans = Math.max(ans, curr);\\n        for(Pair next: adjMap.get(node)) {\\n            if(next.time <= maxTime)\\n                helper(values, maxTime-next.time, next.to, adjMap, visited, curr);\\n        }\\n        visited[node]--; // backtrack\\n    }\\n    \\n    public void formAdjMap(int[][] edges, Map<Integer, List<Pair>> adjMap) {\\n        for(var edge: edges) {\\n            adjMap.get(edge[0]).add(new Pair(edge[1], edge[2]));\\n            adjMap.get(edge[1]).add(new Pair(edge[0], edge[2]));\\n        }\\n    }\\n    \\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        int[] visited = new int[n];\\n        Map<Integer, List<Pair>> adjMap = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n            adjMap.put(i, new ArrayList<>());\\n        formAdjMap(edges, adjMap);\\n        helper(values, maxTime, 0, adjMap, visited, 0);\\n        return ans;\\n    }\\n    class Pair {\\n        int to, time;\\n        public Pair(int to, int time) {\\n            this.to = to;\\n            this.time = time;\\n        }\\n        \\n        public String toString() {\\n            return \"<\"+this.to+\", \"+this.time+\">\";\\n        }\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830713,
                "title": "kotlin-easy-to-understand",
                "content": "# Code\\n```\\n  import kotlin.math.max\\n  class Solution {\\n       inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\\n            var sum: Int = 0.toInt()\\n            for (element in this) {\\n                sum += selector(element)\\n            }\\n            return sum\\n        }\\n\\n        fun maximalPathQuality(values: IntArray, edges: Array<IntArray>, maxTime: Int): Int {\\n            var map = HashMap<Int, ArrayList<Pair<Int, Int>>>()\\n            for(i in values.indices)\\n                map[i] = ArrayList()\\n            for (e in edges) {\\n                map[e[0]]!!.add(Pair(e[1], e[2]))\\n                map[e[1]]!!.add(Pair(e[0], e[2]))\\n            }\\n            return maximalPathQuality(values, map, maxTime, listOf(0), values[0])\\n        }\\n        fun maximalPathQuality(values: IntArray, edges: HashMap<Int, ArrayList<Pair<Int, Int>>>, maxTime: Int, list: List<Int> = listOf(0), sum: Int = values[0]): Int {\\n            var nodeEdges = edges[list.last()]!!\\n            var max = if (list.last() == 0) sum else 0\\n            for (edge in nodeEdges) {\\n                var otherNode = edge.first\\n                if (maxTime - edge.second < 0)\\n                    continue\\n                var nList = list.plusElement(otherNode)\\n                max = max(maximalPathQuality(values, edges, maxTime - edge.second, nList, if (list.contains(otherNode)) sum else sum + values[otherNode]), max)\\n            }\\n            return max\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n  import kotlin.math.max\\n  class Solution {\\n       inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\\n            var sum: Int = 0.toInt()\\n            for (element in this) {\\n                sum += selector(element)\\n            }\\n            return sum\\n        }\\n\\n        fun maximalPathQuality(values: IntArray, edges: Array<IntArray>, maxTime: Int): Int {\\n            var map = HashMap<Int, ArrayList<Pair<Int, Int>>>()\\n            for(i in values.indices)\\n                map[i] = ArrayList()\\n            for (e in edges) {\\n                map[e[0]]!!.add(Pair(e[1], e[2]))\\n                map[e[1]]!!.add(Pair(e[0], e[2]))\\n            }\\n            return maximalPathQuality(values, map, maxTime, listOf(0), values[0])\\n        }\\n        fun maximalPathQuality(values: IntArray, edges: HashMap<Int, ArrayList<Pair<Int, Int>>>, maxTime: Int, list: List<Int> = listOf(0), sum: Int = values[0]): Int {\\n            var nodeEdges = edges[list.last()]!!\\n            var max = if (list.last() == 0) sum else 0\\n            for (edge in nodeEdges) {\\n                var otherNode = edge.first\\n                if (maxTime - edge.second < 0)\\n                    continue\\n                var nList = list.plusElement(otherNode)\\n                max = max(maximalPathQuality(values, edges, maxTime - edge.second, nList, if (list.contains(otherNode)) sum else sum + values[otherNode]), max)\\n            }\\n            return max\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812642,
                "title": "python-bfs-pruning-with-dijktra",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = defaultdict(list)\\n        for outgoing, incoming, distance in edges:\\n            graph[outgoing].append((incoming, distance))\\n            graph[incoming].append((outgoing, distance))\\n        # At each node, we have at most four possible moves\\n        # dp[loc][maxTime] = max(*[dp[adj][maxTime - dist(adj)] for adj in adjs], value[loc])\\n\\n        # as many unique nodes as possible..\\n        # able to return to start\\n        # maximize value\\n\\n        # compute shortest path from all nodes to 0\\n        # dijktra\\n        distance_to_origin = defaultdict(lambda: inf)\\n        distance_to_origin[0] = 0\\n        visited = set()\\n        to_visit = [(0, 0)]\\n        while len(to_visit) > 0:\\n            dist, cur = heappop(to_visit)\\n            if cur in visited or dist != distance_to_origin[cur]:\\n                continue\\n            for neighbor, distance in graph[cur]:\\n                if distance_to_origin[cur] + distance < distance_to_origin[neighbor]:\\n                    distance_to_origin[neighbor] = distance_to_origin[cur] + distance\\n                    heappush(to_visit, (distance_to_origin[neighbor], neighbor))\\n            visited.add(cur)\\n\\n        #  start from 0, reach out (how to determine returnability?)\\n        # with the shortest path map, we can prune branches that cannot return to the start\\n        d = deque([(0, maxTime, set(), 0)])\\n        best = values[0]\\n        while len(d) > 0:\\n            for _ in range(len(d)):\\n                cur, time, unique, val = d.popleft()\\n                if cur == 0:\\n                    best = max(best, val)\\n                if distance_to_origin[cur] > time:\\n                    # no way home\\n                    continue\\n                for to, distance in graph[cur]:\\n                    if distance > time:\\n                        continue\\n                    new_val = values[to] + val if to not in unique else val\\n                    # Conditionally copy the unique set\\n                    new_unique = set(unique) | set([to]) if to not in unique else unique\\n                    d.append((to, time - distance, new_unique, new_val))\\n        return best\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = defaultdict(list)\\n        for outgoing, incoming, distance in edges:\\n            graph[outgoing].append((incoming, distance))\\n            graph[incoming].append((outgoing, distance))\\n        # At each node, we have at most four possible moves\\n        # dp[loc][maxTime] = max(*[dp[adj][maxTime - dist(adj)] for adj in adjs], value[loc])\\n\\n        # as many unique nodes as possible..\\n        # able to return to start\\n        # maximize value\\n\\n        # compute shortest path from all nodes to 0\\n        # dijktra\\n        distance_to_origin = defaultdict(lambda: inf)\\n        distance_to_origin[0] = 0\\n        visited = set()\\n        to_visit = [(0, 0)]\\n        while len(to_visit) > 0:\\n            dist, cur = heappop(to_visit)\\n            if cur in visited or dist != distance_to_origin[cur]:\\n                continue\\n            for neighbor, distance in graph[cur]:\\n                if distance_to_origin[cur] + distance < distance_to_origin[neighbor]:\\n                    distance_to_origin[neighbor] = distance_to_origin[cur] + distance\\n                    heappush(to_visit, (distance_to_origin[neighbor], neighbor))\\n            visited.add(cur)\\n\\n        #  start from 0, reach out (how to determine returnability?)\\n        # with the shortest path map, we can prune branches that cannot return to the start\\n        d = deque([(0, maxTime, set(), 0)])\\n        best = values[0]\\n        while len(d) > 0:\\n            for _ in range(len(d)):\\n                cur, time, unique, val = d.popleft()\\n                if cur == 0:\\n                    best = max(best, val)\\n                if distance_to_origin[cur] > time:\\n                    # no way home\\n                    continue\\n                for to, distance in graph[cur]:\\n                    if distance > time:\\n                        continue\\n                    new_val = values[to] + val if to not in unique else val\\n                    # Conditionally copy the unique set\\n                    new_unique = set(unique) | set([to]) if to not in unique else unique\\n                    d.append((to, time - distance, new_unique, new_val))\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773925,
                "title": "bfs",
                "content": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = defaultdict(list)\\n        \\n        for u,v,time in edges:\\n            graph[u].append([v,time])\\n            graph[v].append([u,time])\\n            \\n        seen = set()\\n        seen.add(0)\\n        queue = deque([(0,0,seen)])\\n        answer = values[0]\\n        memo = {}\\n        while queue:\\n            time, node, seen = queue.popleft()\\n            currPoints = sum(values[i] for i in seen)\\n            if node in memo:\\n                prevTime, prevPoints = memo[node]\\n                if prevTime <= time and prevPoints > currPoints:\\n                    continue\\n            memo[node] = (time, currPoints)\\n            \\n            if time > maxTime:\\n                continue\\n            if node == 0:\\n                answer = max(answer, currPoints)\\n                \\n            for nei,val in graph[node]:\\n                queue.append((time+val,nei,seen | {nei}))\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = defaultdict(list)\\n        \\n        for u,v,time in edges:\\n            graph[u].append([v,time])\\n            graph[v].append([u,time])\\n            \\n        seen = set()\\n        seen.add(0)\\n        queue = deque([(0,0,seen)])\\n        answer = values[0]\\n        memo = {}\\n        while queue:\\n            time, node, seen = queue.popleft()\\n            currPoints = sum(values[i] for i in seen)\\n            if node in memo:\\n                prevTime, prevPoints = memo[node]\\n                if prevTime <= time and prevPoints > currPoints:\\n                    continue\\n            memo[node] = (time, currPoints)\\n            \\n            if time > maxTime:\\n                continue\\n            if node == 0:\\n                answer = max(answer, currPoints)\\n                \\n            for nei,val in graph[node]:\\n                queue.append((time+val,nei,seen | {nei}))\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762999,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n     vector<vector<pair<int,int>>> graph;\\n    \\n     vector<int> visited;\\n    \\n     int res;\\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        \\n        int n = values.size();\\n        \\n        graph.resize(n);\\n        \\n        visited.resize(n,0);\\n        \\n         res = values[0];\\n       \\n        for(auto &x: edges)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            \\n            graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n       \\n        dfs( values,0, 0, 0, maxTime);\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& values,int node, int score, int time, int& maxTime)\\n    {\\n        if(time > maxTime)\\n            return;\\n        \\n        if(visited[node] == 0)\\n            score += values[node];\\n        \\n        visited[node]++;\\n\\t\\t\\n      \\n        if(node == 0)\\n            res = max(res, score);\\n        \\n        for(auto it : graph[node])\\n        {\\n            int neigh = it.first;\\n            int newTime = time + it.second;\\n            \\n            dfs(values, neigh, score, newTime, maxTime);\\n        }\\n        \\n        visited[node]--;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n     vector<vector<pair<int,int>>> graph;\\n    \\n     vector<int> visited;\\n    \\n     int res;\\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        \\n        int n = values.size();\\n        \\n        graph.resize(n);\\n        \\n        visited.resize(n,0);\\n        \\n         res = values[0];\\n       \\n        for(auto &x: edges)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]}",
                "codeTag": "Java"
            },
            {
                "id": 2733724,
                "title": "java-dfs-solution-with-explanation-and-detailed-comments",
                "content": "Logic\\n1. Keep a data structure to represent a node\\n2. Build graph: using adjeacency list representation\\n3. explore all the paths using DFS\\n\\t- **Important: Early pruning**: if the remaining time is less than the time to visit the next node; skip that edge and go to the next node\\n4. **Note: don\\'t use visited set to keep track of the nodes added in the path** because it will mess up the quality calculation for duplicate node calculation.\\n\\n```\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int[] result = new int[]{0};\\n        int length = values.length;\\n        // adjacency list based graph representation\\n        Map<Integer, Node> graph = new HashMap<>();\\n        // note: can\\'t use visited set for tracking duplicates, because when we backtrack we have to just reduce the \\n        // count of visited note. It is possible that we the node is still part of the path, just that it\\'s visit \\n        // count is more than 1. If we use set, we only know if it has been visited or not, we can\\'t know it\\'s visit \\n        // count. This is problematic when we return from DFS, we have to remove from the visited set, so we have to \\n        // keep track of the visited count. Set only allows the element to add or remove, can\\'t keep track of the count.\\n        \\n        // Set<Integer> visited = new HashSet<>();\\n        // avoid counting duplicate nodes in the dfs sum\\n        int[] seen = new int[length];\\n\\n        // create graph and assign weights\\n        for (int index = 0; index < length; index++){\\n            graph.put(index, new Node(values[index]));\\n        }\\n\\n        // add edges to the map nodes\\n        for (int[] edge : edges){\\n            int from = edge[0], to = edge[1], time = edge[2];\\n            graph.get(from).edges.add(new int[]{to, time});\\n            graph.get(to).edges.add(new int[]{from, time});\\n        }\\n\\n        seen[0]++;\\n        dfs(graph, seen, 0, values, maxTime, values[0], result);\\n        return result[0];\\n    }\\n\\n    private void dfs(Map<Integer, Node> graph, int[] seen, int start, int[] values,\\n                     int remainingTime, int currentQuality, int[] result){\\n        if (start == 0){\\n            result[0] = Math.max(result[0], currentQuality);\\n        }\\n\\n        if (remainingTime < 0){\\n            return;\\n        }\\n\\n        for (int[] edge : graph.get(start).edges){\\n            int dest = edge[0], time = edge[1];\\n            // if time to visit this edge is more than the remaining time, skip it\\n            if (remainingTime < time){\\n                continue;\\n            }\\n            // continue the DFS\\n\\n            // is this the first time we are adding this destination, if yes (true) then we can count this, if not\\n            // (false) that means this destination was already counted, so skip counting, but you can continue to\\n            // traverse\\n//            boolean countDestination = visited.add(dest);\\n            seen[dest]++;\\n\\n//            int newQualitySum = currentQuality + (countDestination ? values[dest] : 0);\\n            int newQualitySum = currentQuality + ((seen[dest] == 1) ? values[dest] : 0);\\n//            dfs(graph, visited, seen, dest, values, (remainingTime - time), newQualitySum, result);\\n            dfs(graph, seen, dest, values, (remainingTime - time), newQualitySum, result);\\n\\n            // remove the dest from visited so that it can be counted in another path\\n//            visited.remove(dest);\\n            seen[dest]--;\\n        }\\n    }\\n\\n        static class Node {\\n        int weight;\\n        // list of edges; each int[]: {destinationNode, time}\\n        List<int[]> edges;\\n\\n        public Node(int weight) {\\n            this.weight = weight;\\n            this.edges = new LinkedList<>();\\n        }\\n    }\\n```\\n\\nCredit: I was initially using set to keep track of the visited note and was failing a few test cases. Looked at [this solution](https://leetcode.com/problems/maximum-path-quality-of-a-graph/discuss/1564001/Java-DFS-O(220)-with-explanation) to get the idea to keep track of visited count.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int[] result = new int[]{0};\\n        int length = values.length;\\n        // adjacency list based graph representation\\n        Map<Integer, Node> graph = new HashMap<>();\\n        // note: can\\'t use visited set for tracking duplicates, because when we backtrack we have to just reduce the \\n        // count of visited note. It is possible that we the node is still part of the path, just that it\\'s visit \\n        // count is more than 1. If we use set, we only know if it has been visited or not, we can\\'t know it\\'s visit \\n        // count. This is problematic when we return from DFS, we have to remove from the visited set, so we have to \\n        // keep track of the visited count. Set only allows the element to add or remove, can\\'t keep track of the count.\\n        \\n        // Set<Integer> visited = new HashSet<>();\\n        // avoid counting duplicate nodes in the dfs sum\\n        int[] seen = new int[length];\\n\\n        // create graph and assign weights\\n        for (int index = 0; index < length; index++){\\n            graph.put(index, new Node(values[index]));\\n        }\\n\\n        // add edges to the map nodes\\n        for (int[] edge : edges){\\n            int from = edge[0], to = edge[1], time = edge[2];\\n            graph.get(from).edges.add(new int[]{to, time});\\n            graph.get(to).edges.add(new int[]{from, time});\\n        }\\n\\n        seen[0]++;\\n        dfs(graph, seen, 0, values, maxTime, values[0], result);\\n        return result[0];\\n    }\\n\\n    private void dfs(Map<Integer, Node> graph, int[] seen, int start, int[] values,\\n                     int remainingTime, int currentQuality, int[] result){\\n        if (start == 0){\\n            result[0] = Math.max(result[0], currentQuality);\\n        }\\n\\n        if (remainingTime < 0){\\n            return;\\n        }\\n\\n        for (int[] edge : graph.get(start).edges){\\n            int dest = edge[0], time = edge[1];\\n            // if time to visit this edge is more than the remaining time, skip it\\n            if (remainingTime < time){\\n                continue;\\n            }\\n            // continue the DFS\\n\\n            // is this the first time we are adding this destination, if yes (true) then we can count this, if not\\n            // (false) that means this destination was already counted, so skip counting, but you can continue to\\n            // traverse\\n//            boolean countDestination = visited.add(dest);\\n            seen[dest]++;\\n\\n//            int newQualitySum = currentQuality + (countDestination ? values[dest] : 0);\\n            int newQualitySum = currentQuality + ((seen[dest] == 1) ? values[dest] : 0);\\n//            dfs(graph, visited, seen, dest, values, (remainingTime - time), newQualitySum, result);\\n            dfs(graph, seen, dest, values, (remainingTime - time), newQualitySum, result);\\n\\n            // remove the dest from visited so that it can be counted in another path\\n//            visited.remove(dest);\\n            seen[dest]--;\\n        }\\n    }\\n\\n        static class Node {\\n        int weight;\\n        // list of edges; each int[]: {destinationNode, time}\\n        List<int[]> edges;\\n\\n        public Node(int weight) {\\n            this.weight = weight;\\n            this.edges = new LinkedList<>();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717585,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    vi(vi(pi))g;\\n    vi(ll)vis;\\n    ll ans=0;\\n    void func(ll nd, ll par, ll sum, ll rem, const vi(int)&val){\\n        if(rem<0){\\n            return;\\n        }\\n        if(!vis[nd]){\\n            sum+=val[nd];\\n        }\\n        ++vis[nd];\\n        if(nd==0){\\n            ans=max(ans, sum);\\n        }\\n        for(const pi&child:g[nd]){\\n            func(child.first, nd, sum, rem-child.second, val);\\n        }\\n        --vis[nd];\\n    }\\n    int maximalPathQuality(vector<int>&val, vector<vector<int>>&e, int t) {\\n        g.resize(val.size());\\n        for(const auto&edge:e){\\n            g[edge[0]].pb({edge[1], edge[2]}), g[edge[1]].pb({edge[0], edge[2]});\\n        }\\n        vis.assign(val.size(), 0);\\n        func(0, -1, 0, t, val);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    vi(vi(pi))g;\\n    vi(ll)vis;\\n    ll ans=0;\\n    void func(ll nd, ll par, ll sum, ll rem, const vi(int)&val){\\n        if(rem<0){\\n            return;\\n        }\\n        if(!vis[nd]){\\n            sum+=val[nd];\\n        }\\n        ++vis[nd];\\n        if(nd==0){\\n            ans=max(ans, sum);\\n        }\\n        for(const pi&child:g[nd]){\\n            func(child.first, nd, sum, rem-child.second, val);\\n        }\\n        --vis[nd];\\n    }\\n    int maximalPathQuality(vector<int>&val, vector<vector<int>>&e, int t) {\\n        g.resize(val.size());\\n        for(const auto&edge:e){\\n            g[edge[0]].pb({edge[1], edge[2]}), g[edge[1]].pb({edge[0], edge[2]});\\n        }\\n        vis.assign(val.size(), 0);\\n        func(0, -1, 0, t, val);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686469,
                "title": "python-simple-dfs",
                "content": "\\n    def maximalPathQuality(self, values, edges, maxTime):\\n        n, dict1 = len(values), defaultdict(list)\\n        \\n        for i,j,k in edges:\\n            dict1[i].append((j,k))\\n            dict1[j].append((i,k))\\n        \\n        visited, self.max_len = [0]*n, 0\\n    \\n    \\n        def dfs(node, cur_time, total):\\n            if cur_time > maxTime:\\n                return\\n            \\n            if visited[node] == 0:\\n                total += values[node]\\n                \\n            if node == 0:\\n                self.max_len = max(self.max_len,total)\\n                \\n            visited[node] += 1\\n            \\n            for neighbor in dict1[node]:\\n                dfs(neighbor[0],cur_time+neighbor[1],total)\\n            \\n            visited[node] -= 1\\n            \\n            \\n        dfs(0, 0, 0)\\n        \\n        return self.max_len",
                "solutionTags": [],
                "code": "\\n    def maximalPathQuality(self, values, edges, maxTime):\\n        n, dict1 = len(values), defaultdict(list)\\n        \\n        for i,j,k in edges:\\n            dict1[i].append((j,k))\\n            dict1[j].append((i,k))\\n        \\n        visited, self.max_len = [0]*n, 0\\n    \\n    \\n        def dfs(node, cur_time, total):\\n            if cur_time > maxTime:\\n                return\\n            \\n            if visited[node] == 0:\\n                total += values[node]\\n                \\n            if node == 0:\\n                self.max_len = max(self.max_len,total)\\n                \\n            visited[node] += 1\\n            \\n            for neighbor in dict1[node]:\\n                dfs(neighbor[0],cur_time+neighbor[1],total)\\n            \\n            visited[node] -= 1\\n            \\n            \\n        dfs(0, 0, 0)\\n        \\n        return self.max_len",
                "codeTag": "Python3"
            },
            {
                "id": 2685438,
                "title": "c-solution-using-bfs-dp",
                "content": "The queue starts from node 0 and visits it\\'s neighbour and pushes into queue. We can use dp to store the max value at each node for time t. We will push the node into queue iff the we are getting higher value at that node.\\n```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size(),ans=0;\\n        vector<vector<pair<int,int>>> adj(n);\\n        vector<vector<int>> dp(n,vector<int>(maxTime+1,0));//using dp to avoid repetition\\n        for(auto a:edges){\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});\\n        }\\n        \\n        //queue elemet storing current value, and time remaining alaong with visited nodes\\n        queue<pair<vector<int>,unordered_set<int>>> q;\\n        \\n        //initialize\\n        q.push({{values[0],0,maxTime},{0}});\\n        dp[0][maxTime]=values[0];\\n        \\n        while(q.size()){\\n            auto [x,y]=q.front();\\n            q.pop();\\n            if(x[1]==0)//end case\\n                ans=max(x[0],ans);\\n            for(auto [a,b]:adj[x[1]]){\\n                if(x[2]>=b){//possibility of taking a edge\\n                    unordered_set<int> s=y;\\n                    int z=x[0];\\n                    if(y.find(a)==y.end()){\\n                        s.insert(a);\\n                        z+=values[a];\\n                    }\\n                    if(dp[a][x[2]-b]<=z){//if it is not true then we need not consider this path\\n                        dp[a][x[2]-b]=z;\\n                        q.push({{z,a,x[2]-b},s});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size(),ans=0;\\n        vector<vector<pair<int,int>>> adj(n);\\n        vector<vector<int>> dp(n,vector<int>(maxTime+1,0));//using dp to avoid repetition\\n        for(auto a:edges){\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});\\n        }\\n        \\n        //queue elemet storing current value, and time remaining alaong with visited nodes\\n        queue<pair<vector<int>,unordered_set<int>>> q;\\n        \\n        //initialize\\n        q.push({{values[0],0,maxTime},{0}});\\n        dp[0][maxTime]=values[0];\\n        \\n        while(q.size()){\\n            auto [x,y]=q.front();\\n            q.pop();\\n            if(x[1]==0)//end case\\n                ans=max(x[0],ans);\\n            for(auto [a,b]:adj[x[1]]){\\n                if(x[2]>=b){//possibility of taking a edge\\n                    unordered_set<int> s=y;\\n                    int z=x[0];\\n                    if(y.find(a)==y.end()){\\n                        s.insert(a);\\n                        z+=values[a];\\n                    }\\n                    if(dp[a][x[2]-b]<=z){//if it is not true then we need not consider this path\\n                        dp[a][x[2]-b]=z;\\n                        q.push({{z,a,x[2]-b},s});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674167,
                "title": "java-simple-dfs-explained-in-detail-tc-sc-explained",
                "content": "// A simple DFS would work here and will not give TLE because it is given that:\\n// 1. At any node, there are a MAX of 4 adjacent nodes (so 4 options to go from currNode)\\n// 2. 10 <= time, maxTime <= 100 (time taken between any 2 nodes is MIN be 10) so if lets say ALL the times are 10 (worst case) and maxTime is MAX 100, then we only need to HOP 10 nodes (100/10)\\n// So in total time taken would be O(4^10) OR O(2^20)\\n\\n// In any Graph question, best practise is to start with Adjacency Matrix to perform DFS\\n\\n// TC : O(4^10)\\n// SC : O(N); N = edges.length\\n```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        int[] res = new int[1]; \\n        int[] visited = new int[n]; // this is int[] and not boolean[] beacuse we can visit a node multiple times but we can add its values only ONCE\\n        Map<Integer, List<Neighbor>> adjMap = new HashMap<>(); // Neighbor contains the adhacent node and time\\n        \\n        // this will make sure that EVERY node has an entry in the MAP even it is present or not in the EDGE[][]\\n        // this is because there are few edge cases with either NO \\'0\\' node, or empty edge[][]\\n        for(int i = 0; i < n; i++) {\\n            adjMap.put(i, new ArrayList<>());\\n        }\\n        \\n        // make adjacency map\\n        for(int[] edge : edges) {\\n            int curr = edge[0], neighbor = edge[1], time = edge[2];\\n            \\n            adjMap.get(curr).add(new Neighbor(neighbor, time));\\n            adjMap.get(neighbor).add(new Neighbor(curr, time));\\n        }\\n                \\n        visited[0]++;\\n        helper(values, visited, adjMap, res, 0, maxTime, values[0]);\\n        \\n        return res[0];\\n    }\\n    \\n    private void helper(int[] values, int[] visited, Map<Integer, List<Neighbor>> adjMap, int[] res, int currNode, int maxTimeLeft, int currSum) {\\n        if(currNode == 0) { // potential answer since the path should always end at 0\\n            res[0] = Math.max(res[0], currSum); \\n        }\\n        \\n        // if we have completely utilized the maxTime, return\\n        if(maxTimeLeft < 0) return;\\n        \\n        // for ALL the neighbors of currNode (DFS)\\n        for(Neighbor n : adjMap.get(currNode)) {\\n            int adjNode = n.neighbor, time = n.time;\\n            if(maxTimeLeft - time < 0) continue; // if we go to next node whose time surpasses the remaining maxTime, we cannot use it\\n            visited[adjNode]++; // mark adjNode as visited\\n            \\n            // recursion with currNode as adjNode\\n            // NOTE : we only need to add the values[currNode] if it is the FIRST time we are visiting it\\n            helper(values, visited, adjMap, res, adjNode, maxTimeLeft - time, currSum + (visited[adjNode] == 1 ? values[adjNode] : 0));\\n            \\n            // backtrack\\n            visited[adjNode]--;\\n        }\\n    }\\n}\\n\\nclass Neighbor {\\n    int neighbor;\\n    int time;\\n    \\n    public Neighbor(int n, int t) {\\n        this.neighbor = n;\\n        this.time = t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        int[] res = new int[1]; \\n        int[] visited = new int[n]; // this is int[] and not boolean[] beacuse we can visit a node multiple times but we can add its values only ONCE\\n        Map<Integer, List<Neighbor>> adjMap = new HashMap<>(); // Neighbor contains the adhacent node and time\\n        \\n        // this will make sure that EVERY node has an entry in the MAP even it is present or not in the EDGE[][]\\n        // this is because there are few edge cases with either NO \\'0\\' node, or empty edge[][]\\n        for(int i = 0; i < n; i++) {\\n            adjMap.put(i, new ArrayList<>());\\n        }\\n        \\n        // make adjacency map\\n        for(int[] edge : edges) {\\n            int curr = edge[0], neighbor = edge[1], time = edge[2];\\n            \\n            adjMap.get(curr).add(new Neighbor(neighbor, time));\\n            adjMap.get(neighbor).add(new Neighbor(curr, time));\\n        }\\n                \\n        visited[0]++;\\n        helper(values, visited, adjMap, res, 0, maxTime, values[0]);\\n        \\n        return res[0];\\n    }\\n    \\n    private void helper(int[] values, int[] visited, Map<Integer, List<Neighbor>> adjMap, int[] res, int currNode, int maxTimeLeft, int currSum) {\\n        if(currNode == 0) { // potential answer since the path should always end at 0\\n            res[0] = Math.max(res[0], currSum); \\n        }\\n        \\n        // if we have completely utilized the maxTime, return\\n        if(maxTimeLeft < 0) return;\\n        \\n        // for ALL the neighbors of currNode (DFS)\\n        for(Neighbor n : adjMap.get(currNode)) {\\n            int adjNode = n.neighbor, time = n.time;\\n            if(maxTimeLeft - time < 0) continue; // if we go to next node whose time surpasses the remaining maxTime, we cannot use it\\n            visited[adjNode]++; // mark adjNode as visited\\n            \\n            // recursion with currNode as adjNode\\n            // NOTE : we only need to add the values[currNode] if it is the FIRST time we are visiting it\\n            helper(values, visited, adjMap, res, adjNode, maxTimeLeft - time, currSum + (visited[adjNode] == 1 ? values[adjNode] : 0));\\n            \\n            // backtrack\\n            visited[adjNode]--;\\n        }\\n    }\\n}\\n\\nclass Neighbor {\\n    int neighbor;\\n    int time;\\n    \\n    public Neighbor(int n, int t) {\\n        this.neighbor = n;\\n        this.time = t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672521,
                "title": "tc-97-dp-bitmasking-bfs-python",
                "content": "The problem can be uniquely captured using 3 parameters: (visited, c_node, c_time)\\n\\nLooking at the contraints of the problem, each edge will take at least 10 seconds, and maxTime is 100 seconds. So max number of nodes you can visit is 10. Ofcourse there might be multiple set of 10 nodes. But this gives you a rough idea.\\n\\nBitmasking is better than using set for visited because you will be caching visited.\\nThe noncaching version is slow. Can take anywhere from 3000ms -> 7000ms depending your pruning and how you sum and add nodes to visited.\\nDP took around 400ms.\\n\\n```\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n    \\n    graph = defaultdict(dict)\\n    for u,v,time in edges:\\n        graph[u][v] = time\\n        graph[v][u] = time\\n\\n    ans = c_sum = values[0]\\n    @lru_cache(None)\\n    def dp(visited, c_node, time_left):\\n        nonlocal ans; nonlocal c_sum\\n        \\n        if time_left < 0: return \\n        \\n        if c_node == 0: ans = max(ans, c_sum)\\n\\n        for neigh,time in graph[c_node].items():\\n            notPresent = (1<<neigh)&visited == 0\\n\\n            if notPresent: c_sum += values[neigh]\\n            dp(visited|(1<<neigh), neigh, time_left - time)\\n            if notPresent: c_sum -= values[neigh]\\n\\n    dp(1, 0, maxTime)\\n    return ans\\n```\\n\\nYou can also do a BFS approach with semi-caching. This took 470ms\\n```\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        \\n    graph = defaultdict(dict)\\n    for u,v,time in edges:\\n        graph[u][v] = time\\n        graph[v][u] = time \\n        \\n    cache = dict()\\n    que = deque([[0, 0, 1, values[0]]])\\n    ans = values[0]\\n    while que:\\n        c_node, c_time, visited, c_score = que.popleft()\\n        if c_node == 0: ans = max(ans, c_score)\\n        if c_node in cache:\\n            prev_time, prev_points = cache[c_node]\\n            if prev_time <= c_time and prev_points > c_score:\\n                continue\\n        cache[c_node] = [c_time, c_score]\\n        \\n        for neigh,travelTime in graph[c_node].items():\\n            if travelTime + c_time <= maxTime:\\n                neigh_score = c_score\\n                if visited&(1<<neigh) == 0: neigh_score += values[neigh]\\n                que.append([neigh, c_time + travelTime, visited|(1<<neigh), neigh_score])\\n    \\n    return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Bitmask"
                ],
                "code": "```\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n    \\n    graph = defaultdict(dict)\\n    for u,v,time in edges:\\n        graph[u][v] = time\\n        graph[v][u] = time\\n\\n    ans = c_sum = values[0]\\n    @lru_cache(None)\\n    def dp(visited, c_node, time_left):\\n        nonlocal ans; nonlocal c_sum\\n        \\n        if time_left < 0: return \\n        \\n        if c_node == 0: ans = max(ans, c_sum)\\n\\n        for neigh,time in graph[c_node].items():\\n            notPresent = (1<<neigh)&visited == 0\\n\\n            if notPresent: c_sum += values[neigh]\\n            dp(visited|(1<<neigh), neigh, time_left - time)\\n            if notPresent: c_sum -= values[neigh]\\n\\n    dp(1, 0, maxTime)\\n    return ans\\n```\n```\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        \\n    graph = defaultdict(dict)\\n    for u,v,time in edges:\\n        graph[u][v] = time\\n        graph[v][u] = time \\n        \\n    cache = dict()\\n    que = deque([[0, 0, 1, values[0]]])\\n    ans = values[0]\\n    while que:\\n        c_node, c_time, visited, c_score = que.popleft()\\n        if c_node == 0: ans = max(ans, c_score)\\n        if c_node in cache:\\n            prev_time, prev_points = cache[c_node]\\n            if prev_time <= c_time and prev_points > c_score:\\n                continue\\n        cache[c_node] = [c_time, c_score]\\n        \\n        for neigh,travelTime in graph[c_node].items():\\n            if travelTime + c_time <= maxTime:\\n                neigh_score = c_score\\n                if visited&(1<<neigh) == 0: neigh_score += values[neigh]\\n                que.append([neigh, c_time + travelTime, visited|(1<<neigh), neigh_score])\\n    \\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2652808,
                "title": "simple-dfs-java-beats-93-64-and-90-memory-trick-to-avoid-tle-included",
                "content": "Idea is to do simple DFS without any visited checks. We know the DFS will terminate when the time is used up. But we need to be careful to add the value to result only if the node was not visited before. So we need to maintain the visited set.\\nThe Trick to avoid TLE here is to use the Adjacency list rather than 2D matrix as the test case is sparse graph which avoid uncessary children interation on 2D matrix graph.\\n```\\nclass Solution {\\n    int n;\\n    List<Pair<Integer, Integer>>[] graph;\\n    int maxTime;\\n    int[] values;\\n    int[] set;\\n    int ans;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        \\n        this.n = values.length;\\n        this.values = values;\\n        this.graph = new List[n];\\n        this.set = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] edge : edges)\\n        {\\n            int x = edge[0];\\n            int y = edge[1];\\n            int val = edge[2];\\n            \\n            List<Pair<Integer, Integer>> p1 = graph[x];\\n            p1.add(new Pair(y, val));\\n            \\n            List<Pair<Integer, Integer>> p2 = graph[y];\\n            p2.add(new Pair(x, val));\\n        }\\n        dfs(0, maxTime, 0);\\n        return ans;\\n    }\\n    \\n    public void dfs(int node, int timePassed, int sum)\\n    {\\n        int valToAdd = set[node] == 0 ? values[node] : 0;\\n        sum += valToAdd;\\n        if(node == 0)\\n        {\\n            ans = Math.max(ans, sum);\\n        }\\n        set[node]++;\\n        for(Pair<Integer, Integer> child : graph[node])\\n        {\\n            int time = child.getValue();\\n            int node1 = child.getKey();\\n            if(timePassed - time >=0)\\n            {\\n                dfs(node1, timePassed-time, sum);\\n            }\\n        }\\n        set[node]--;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    List<Pair<Integer, Integer>>[] graph;\\n    int maxTime;\\n    int[] values;\\n    int[] set;\\n    int ans;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        \\n        this.n = values.length;\\n        this.values = values;\\n        this.graph = new List[n];\\n        this.set = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] edge : edges)\\n        {\\n            int x = edge[0];\\n            int y = edge[1];\\n            int val = edge[2];\\n            \\n            List<Pair<Integer, Integer>> p1 = graph[x];\\n            p1.add(new Pair(y, val));\\n            \\n            List<Pair<Integer, Integer>> p2 = graph[y];\\n            p2.add(new Pair(x, val));\\n        }\\n        dfs(0, maxTime, 0);\\n        return ans;\\n    }\\n    \\n    public void dfs(int node, int timePassed, int sum)\\n    {\\n        int valToAdd = set[node] == 0 ? values[node] : 0;\\n        sum += valToAdd;\\n        if(node == 0)\\n        {\\n            ans = Math.max(ans, sum);\\n        }\\n        set[node]++;\\n        for(Pair<Integer, Integer> child : graph[node])\\n        {\\n            int time = child.getValue();\\n            int node1 = child.getKey();\\n            if(timePassed - time >=0)\\n            {\\n                dfs(node1, timePassed-time, sum);\\n            }\\n        }\\n        set[node]--;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636382,
                "title": "short-concise-dfs-solution-w-comments-java",
                "content": "\\tclass Solution {\\n\\t\\tprivate HashMap<Integer, ArrayList<Integer[]>> graph; // Weighted undirected graph\\n\\t\\tprivate int[] counts; // Keeps track of the occurences of each node\\n\\t\\tprivate int[] values; // Stores the values of each node\\n\\t\\tprivate int maxQuality; // Keeps track of the maximum quality found\\n\\n\\t\\tpublic int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n\\t\\t\\tgraph = constructGraph(edges, values.length);\\n\\t\\t\\tcounts = new int[values.length];\\n\\n\\t\\t\\tthis.values = values;\\n\\t\\t\\tsolve(maxTime, 0, 0);\\n\\t\\t\\treturn maxQuality;\\n\\t\\t}\\n\\n\\t\\tprivate void solve(int remainingTime, int node, int quality) {\\n\\t\\t\\t// When you exceed the maximum time allowed, return up the callstack\\n\\t\\t\\tif (remainingTime < 0) return;\\n\\t\\t\\t// Before adding the quality to the sum, check that the node is unique\\n\\t\\t\\tif (counts[node] == 0) quality += values[node];\\n\\n\\t\\t\\t// Before updating the maximum quality result, check that we are at node \\'0\\' (as stated in the problem)\\n\\t\\t\\tif (node == 0) maxQuality = Math.max(quality, maxQuality);\\n\\t\\t\\tcounts[node]++; // Increment the occurence of node\\n\\n\\t\\t\\tfor (Integer[] neighbor : graph.get(node)) {\\n\\t\\t\\t\\t// Recurse down each neighbor until the maximum time is exceeded\\n\\t\\t\\t\\tsolve(remainingTime - neighbor[1], neighbor[0], quality);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Decrement occurence of node as you return up the callstack \\n\\t\\t\\t// as the node is no longer used in the path\\n\\t\\t\\tcounts[node]--;\\n\\t\\t}\\n\\n\\t\\tprivate HashMap<Integer, ArrayList<Integer[]>> constructGraph(int[][] edges, int n) {\\n\\t\\t\\tHashMap<Integer, ArrayList<Integer[]>> graph = new HashMap<>(); // Construct weighted adjacency list\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\t// Assign an empty arraylist to each node\\n\\t\\t\\t\\tgraph.put(i, new ArrayList<>());\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\t\\t// Create edge from \\'u\\' to \\'v\\' -> with weight \\'w\\'\\n\\t\\t\\t\\tgraph.get(edge[0]).add(new Integer[] {edge[1], edge[2]}); \\n\\t\\t\\t\\t// Create edge from \\'v\\' to \\'u\\' -> with weight \\'w\\'\\n\\t\\t\\t\\tgraph.get(edge[1]).add(new Integer[] {edge[0], edge[2]});\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn graph;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tprivate HashMap<Integer, ArrayList<Integer[]>> graph; // Weighted undirected graph\\n\\t\\tprivate int[] counts; // Keeps track of the occurences of each node\\n\\t\\tprivate int[] values; // Stores the values of each node\\n\\t\\tprivate int maxQuality; // Keeps track of the maximum quality found\\n\\n\\t\\tpublic int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n\\t\\t\\tgraph = constructGraph(edges, values.length);\\n\\t\\t\\tcounts = new int[values.length];\\n\\n\\t\\t\\tthis.values = values;\\n\\t\\t\\tsolve(maxTime, 0, 0);\\n\\t\\t\\treturn maxQuality;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2626623,
                "title": "java-dfs-simple-solution-with-comments",
                "content": "```\\n  class Node {\\n        int dest, time, value;\\n        Node(int d, int t, int v) {\\n            this.dest = d;\\n            this.time = t;\\n            this.value = v;\\n        }\\n    }\\n    Map<Integer, List<Node>> map;\\n    int ans;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n       map = new HashMap<>();\\n       for(int i = 0 ; i < edges.length ; i ++ ) {\\n           int src = edges[i][0], dest = edges[i][1], time = edges[i][2];\\n           map.computeIfAbsent(src, x->new ArrayList<>()).add(new Node(dest, time, values[src]));\\n           map.computeIfAbsent(dest, x->new ArrayList<>()).add(new Node(src, time, values[src]));\\n       } \\n        dfs(0, values, new int[values.length], maxTime, 0, 0);\\n        return ans;\\n    }\\n    \\n    void dfs (int src, int[] values, int[] visit, int maxTime, int runningTime, int value) { \\n        // base: return if time is crossed the limit\\n        if(runningTime > maxTime) return;\\n\\t\\t//only include value once\\n        if(visit[src] == 0) {\\n            value+= values[src];\\n        }\\n\\t\\t//check for max ans, once reached at start point (e.g. 0)\\n        if(src == 0) {\\n            ans = Math.max(ans, value);\\n        }\\n        visit[src]++;\\n        for(Node node : map.getOrDefault(src, new ArrayList<>())) {\\n            dfs(node.dest, values, visit, maxTime, node.time + runningTime, value);\\n        }\\n\\t\\t//backtrack\\n        visit[src]--;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n  class Node {\\n        int dest, time, value;\\n        Node(int d, int t, int v) {\\n            this.dest = d;\\n            this.time = t;\\n            this.value = v;\\n        }\\n    }\\n    Map<Integer, List<Node>> map;\\n    int ans;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n       map = new HashMap<>();\\n       for(int i = 0 ; i < edges.length ; i ++ ) {\\n           int src = edges[i][0], dest = edges[i][1], time = edges[i][2];\\n           map.computeIfAbsent(src, x->new ArrayList<>()).add(new Node(dest, time, values[src]));\\n           map.computeIfAbsent(dest, x->new ArrayList<>()).add(new Node(src, time, values[src]));\\n       } \\n        dfs(0, values, new int[values.length], maxTime, 0, 0);\\n        return ans;\\n    }\\n    \\n    void dfs (int src, int[] values, int[] visit, int maxTime, int runningTime, int value) { \\n        // base: return if time is crossed the limit\\n        if(runningTime > maxTime) return;\\n\\t\\t//only include value once\\n        if(visit[src] == 0) {\\n            value+= values[src];\\n        }\\n\\t\\t//check for max ans, once reached at start point (e.g. 0)\\n        if(src == 0) {\\n            ans = Math.max(ans, value);\\n        }\\n        visit[src]++;\\n        for(Node node : map.getOrDefault(src, new ArrayList<>())) {\\n            dfs(node.dest, values, visit, maxTime, node.time + runningTime, value);\\n        }\\n\\t\\t//backtrack\\n        visit[src]--;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605307,
                "title": "c-simple-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCur = 0; \\n    void dfs(vector<int>& values, \\n             vector<vector<pair<int,int>>>& graph, \\n             int maxTime, \\n             int i, int score, \\n             int time) \\n    {\\n        if (time > maxTime)\\n            return;\\n       \\n        score += values[i];\\n        // consume value \\n        int restoreVal = values[i];\\n        values[i] = 0;\\n        \\n        if (i == 0) \\n            maxCur = max(maxCur, score);\\n        \\n        for (auto & edge: graph[i]) {\\n            dfs(values, graph, maxTime, edge.first, score, time+edge.second);\\n        }\\n        // backtrack value\\n        values[i] = restoreVal;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        vector<vector<pair<int,int>>> graph(values.size());\\n        for (auto & edge : edges) {\\n            graph[edge[0]].push_back({edge[1], edge[2]});\\n            graph[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        dfs(values, graph, maxTime, 0, 0, 0);\\n        return maxCur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCur = 0; \\n    void dfs(vector<int>& values, \\n             vector<vector<pair<int,int>>>& graph, \\n             int maxTime, \\n             int i, int score, \\n             int time) \\n    {\\n        if (time > maxTime)\\n            return;\\n       \\n        score += values[i];\\n        // consume value \\n        int restoreVal = values[i];\\n        values[i] = 0;\\n        \\n        if (i == 0) \\n            maxCur = max(maxCur, score);\\n        \\n        for (auto & edge: graph[i]) {\\n            dfs(values, graph, maxTime, edge.first, score, time+edge.second);\\n        }\\n        // backtrack value\\n        values[i] = restoreVal;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        vector<vector<pair<int,int>>> graph(values.size());\\n        for (auto & edge : edges) {\\n            graph[edge[0]].push_back({edge[1], edge[2]});\\n            graph[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        dfs(values, graph, maxTime, 0, 0, 0);\\n        return maxCur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589494,
                "title": "python-clean-dfs-with-backtracking",
                "content": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:        \\n        adjList=defaultdict(list)       \\n        for u,v,w in edges:\\n            adjList[u].append((v,w))\\n            adjList[v].append((u,w))\\n        \\n        maxPathSum=0    \\n        \\n        def dfs(node, currSum, currTime, visited):\\n            nonlocal maxPathSum\\n            \\n            if currTime>maxTime:\\n                return\\n\\n            if node==0:\\n                maxPathSum=max(maxPathSum, currSum)\\n            \\n            for nbr,time in adjList[node]:\\n                if nbr not in visited:\\n                    visited.add(nbr)\\n                    dfs(nbr, currSum+values[nbr], currTime+time, visited)\\n                    visited.discard(nbr)\\n                else:\\n                    dfs(nbr, currSum, currTime+time, visited)\\n        \\n        visited=set()   \\n        visited.add(0)\\n        dfs(0,values[0],0,visited)\\n        return maxPathSum",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:        \\n        adjList=defaultdict(list)       \\n        for u,v,w in edges:\\n            adjList[u].append((v,w))\\n            adjList[v].append((u,w))\\n        \\n        maxPathSum=0    \\n        \\n        def dfs(node, currSum, currTime, visited):\\n            nonlocal maxPathSum\\n            \\n            if currTime>maxTime:\\n                return\\n\\n            if node==0:\\n                maxPathSum=max(maxPathSum, currSum)\\n            \\n            for nbr,time in adjList[node]:\\n                if nbr not in visited:\\n                    visited.add(nbr)\\n                    dfs(nbr, currSum+values[nbr], currTime+time, visited)\\n                    visited.discard(nbr)\\n                else:\\n                    dfs(nbr, currSum, currTime+time, visited)\\n        \\n        visited=set()   \\n        visited.add(0)\\n        dfs(0,values[0],0,visited)\\n        return maxPathSum",
                "codeTag": "Java"
            },
            {
                "id": 2569333,
                "title": "java-backtrack",
                "content": "```\\nclass Solution {\\n    int result = 0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        List<int[]>[] graph = new LinkedList[n];\\n        for (int i = 0; i < n; ++i) {\\n            graph[i] = new LinkedList<>();\\n        }\\n        for (int i = 0; i < edges.length; ++i) {\\n            int from = edges[i][0];\\n            int to = edges[i][1];\\n            int time = edges[i][2];\\n            graph[from].add(new int[]{to, time});\\n            graph[to].add(new int[]{from, time});\\n        }\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        int curVal = values[0];\\n        backtrack(graph, visited, values, maxTime, 0, curVal, 0);\\n        return result;\\n    }\\n    \\n    public void backtrack(List<int[]>[] graph, boolean[] visited, int[] values, int maxTime, int curTime, int curVal, int curNode) {\\n        if (curTime > maxTime) {\\n            return;\\n        }\\n        \\n        if (curNode == 0) {\\n            result = Math.max(curVal, result);\\n        }\\n        \\n        for (int[] nei : graph[curNode]) {\\n            int nextNode = nei[0];\\n            int time = nei[1];\\n            if (!visited[nextNode]) {\\n                visited[nextNode] = true;\\n                backtrack(graph, visited, values, maxTime, curTime + time, curVal + values[nextNode], nextNode);\\n                visited[nextNode] = false;\\n            } else {\\n                backtrack(graph, visited, values, maxTime, curTime + time, curVal, nextNode);\\n            }\\n            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        List<int[]>[] graph = new LinkedList[n];\\n        for (int i = 0; i < n; ++i) {\\n            graph[i] = new LinkedList<>();\\n        }\\n        for (int i = 0; i < edges.length; ++i) {\\n            int from = edges[i][0];\\n            int to = edges[i][1];\\n            int time = edges[i][2];\\n            graph[from].add(new int[]{to, time});\\n            graph[to].add(new int[]{from, time});\\n        }\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        int curVal = values[0];\\n        backtrack(graph, visited, values, maxTime, 0, curVal, 0);\\n        return result;\\n    }\\n    \\n    public void backtrack(List<int[]>[] graph, boolean[] visited, int[] values, int maxTime, int curTime, int curVal, int curNode) {\\n        if (curTime > maxTime) {\\n            return;\\n        }\\n        \\n        if (curNode == 0) {\\n            result = Math.max(curVal, result);\\n        }\\n        \\n        for (int[] nei : graph[curNode]) {\\n            int nextNode = nei[0];\\n            int time = nei[1];\\n            if (!visited[nextNode]) {\\n                visited[nextNode] = true;\\n                backtrack(graph, visited, values, maxTime, curTime + time, curVal + values[nextNode], nextNode);\\n                visited[nextNode] = false;\\n            } else {\\n                backtrack(graph, visited, values, maxTime, curTime + time, curVal, nextNode);\\n            }\\n            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552416,
                "title": "c-easy-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    void dfs(int src,int curt,int curval,\\n             int mt,vector<int>&val,vector<pair<int,int>>adj[]){\\n        if(curt > mt) return ;\\n        curval+=val[src];\\n        if(src == 0)\\n            ans=max(ans , curval);\\n        int tem = val[src];\\n        val[src]=0;\\n        for(auto it : adj[src])\\n            dfs(it.first,curt+it.second,curval,mt,val,adj);\\n        val[src]=tem;\\n    }\\n    int maximalPathQuality(vector<int>& val, vector<vector<int>>& ed, int mt) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = val.size();\\n        // Create a weithed adjacency list\\n        vector<pair<int,int>>adj[n];\\n        for(int i=0;i<ed.size();i++){\\n            int u=ed[i][0];\\n            int v=ed[i][1];\\n            int t=ed[i][2];\\n            adj[u].push_back({v,t});\\n            adj[v].push_back({u,t});\\n        }\\n        //calling dfs\\n        dfs(0,0,0,mt,val,adj);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    void dfs(int src,int curt,int curval,\\n             int mt,vector<int>&val,vector<pair<int,int>>adj[]){\\n        if(curt > mt) return ;\\n        curval+=val[src];\\n        if(src == 0)\\n            ans=max(ans , curval);\\n        int tem = val[src];\\n        val[src]=0;\\n        for(auto it : adj[src])\\n            dfs(it.first,curt+it.second,curval,mt,val,adj);\\n        val[src]=tem;\\n    }\\n    int maximalPathQuality(vector<int>& val, vector<vector<int>>& ed, int mt) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = val.size();\\n        // Create a weithed adjacency list\\n        vector<pair<int,int>>adj[n];\\n        for(int i=0;i<ed.size();i++){\\n            int u=ed[i][0];\\n            int v=ed[i][1];\\n            int t=ed[i][2];\\n            adj[u].push_back({v,t});\\n            adj[v].push_back({u,t});\\n        }\\n        //calling dfs\\n        dfs(0,0,0,mt,val,adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548915,
                "title": "dfs-c-easy-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int time; //saving the max time allowed\\n    int ans = 0; //saving the final ans\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        time = maxTime;\\n        int n = values.size();\\n        vector<pair<int,int>>adj[n];   //adjacency list\\n        for(auto &i : edges){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        dfs(0,0,0,values,adj);\\n        return ans;\\n    }\\n    void dfs(int node, int currTime, int currVal , vector<int>& val , vector<pair<int,int>>adj[]){\\n        if(currTime > time) return; //if time exceeds max time this is not a valid path\\n        currVal += val[node]; //adding node\\'s value as we reach that node\\n        if(node == 0){\\n            ans = max(ans,currVal); // if we reach 0 again comparing values we goth from path and saving max here\\n        }\\n        int temp = val[node];  //saving the val of node, why? check next line\\n        val[node] = 0; //setting value of the visited node to 0 so that we dont add it back while returning to 0\\n        for(auto &edge : adj[node]){\\n            dfs(edge.first,currTime+edge.second,currVal,val,adj);\\n        }\\n        val[node] = temp; //backtracking, giving node it\\'s value back\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int time; //saving the max time allowed\\n    int ans = 0; //saving the final ans\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        time = maxTime;\\n        int n = values.size();\\n        vector<pair<int,int>>adj[n];   //adjacency list\\n        for(auto &i : edges){\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        dfs(0,0,0,values,adj);\\n        return ans;\\n    }\\n    void dfs(int node, int currTime, int currVal , vector<int>& val , vector<pair<int,int>>adj[]){\\n        if(currTime > time) return; //if time exceeds max time this is not a valid path\\n        currVal += val[node]; //adding node\\'s value as we reach that node\\n        if(node == 0){\\n            ans = max(ans,currVal); // if we reach 0 again comparing values we goth from path and saving max here\\n        }\\n        int temp = val[node];  //saving the val of node, why? check next line\\n        val[node] = 0; //setting value of the visited node to 0 so that we dont add it back while returning to 0\\n        for(auto &edge : adj[node]){\\n            dfs(edge.first,currTime+edge.second,currVal,val,adj);\\n        }\\n        val[node] = temp; //backtracking, giving node it\\'s value back\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528762,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph, taken, ans = [[] for _ in range(len(values))], [0 for _ in range(len(values))], 0\\n        for edge in edges:\\n            graph[edge[0]].append((edge[1], edge[2]))\\n            graph[edge[1]].append((edge[0], edge[2]))\\n        \\n        def helper(values: List[int], maxTime: int, curNode: int, curTime: int, curValue: int) -> None:\\n            nonlocal graph, taken, ans\\n            if curTime > maxTime:\\n                return\\n            taken[curNode] += 1\\n            if taken[curNode] == 1:\\n                curValue += values[curNode]\\n            if curNode == 0:\\n                ans = max(ans, curValue)\\n            for neighbour, time in graph[curNode]:\\n                helper(values, maxTime, neighbour, curTime + time, curValue)\\n            taken[curNode] -= 1\\n            \\n        helper(values, maxTime, 0, 0, 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph, taken, ans = [[] for _ in range(len(values))], [0 for _ in range(len(values))], 0\\n        for edge in edges:\\n            graph[edge[0]].append((edge[1], edge[2]))\\n            graph[edge[1]].append((edge[0], edge[2]))\\n        \\n        def helper(values: List[int], maxTime: int, curNode: int, curTime: int, curValue: int) -> None:\\n            nonlocal graph, taken, ans\\n            if curTime > maxTime:\\n                return\\n            taken[curNode] += 1\\n            if taken[curNode] == 1:\\n                curValue += values[curNode]\\n            if curNode == 0:\\n                ans = max(ans, curValue)\\n            for neighbour, time in graph[curNode]:\\n                helper(values, maxTime, neighbour, curTime + time, curValue)\\n            taken[curNode] -= 1\\n            \\n        helper(values, maxTime, 0, 0, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520270,
                "title": "go-backtracking",
                "content": "```\\nfunc maximalPathQuality(values []int, edges [][]int, maxTime int) int {\\n\\t\\n\\ttype Edge struct {\\n\\t\\tu int\\n\\t\\tv int\\n\\t\\ttime int\\n\\t}\\n\\n\\ttype State struct {\\n\\t\\ttimeSpent int\\n\\t\\tvisited []int\\n\\t\\tquality int\\n\\t}\\n\\n\\tadjustmentMap := make(map[int][]Edge)\\n\\tfor _, e := range edges {\\n\\t\\tadjustmentMap[e[0]] = append(adjustmentMap[e[0]], Edge{e[0], e[1], e[2]})\\n\\t\\tadjustmentMap[e[1]] = append(adjustmentMap[e[1]], Edge{e[1], e[0], e[2]})\\n\\t}\\n\\n\\tmaxQuality := 0\\n\\tvar backtracking func(state State, edge int) \\n\\t\\n\\tbacktracking = func(state State, edge int) {\\n\\t\\tif state.timeSpent > maxTime {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif edge == 0 && state.quality > maxQuality {\\n\\t\\t\\tmaxQuality = state.quality\\n\\t\\t}\\n\\t\\n\\t\\tneighbours := adjustmentMap[edge]\\n\\t\\tfor _, nei := range neighbours {\\n\\t\\t\\tneiVisited := state.visited[nei.v]\\n\\t\\t\\tstate.visited[nei.v] = 1\\n\\t\\t\\tqualityDelta := 0\\n\\t\\t\\tif neiVisited == 0 {\\n\\t\\t\\t\\tqualityDelta += values[nei.v]\\n\\t\\t\\t}\\n\\t\\t\\tstate.quality += qualityDelta\\n\\t\\t\\tstate.timeSpent += nei.time\\n\\t\\t\\tbacktracking(state, nei.v)\\t\\n\\t\\t\\tstate.visited[nei.v] = neiVisited\\n\\t\\t\\tstate.quality -= qualityDelta\\n\\t\\t\\tstate.timeSpent -= nei.time\\n\\t\\t}\\n\\t}\\n\\n\\tvisited := make([]int, len(values))\\n\\tvisited[0] = 1\\n\\tbacktracking(State{0, visited, values[0]}, 0)\\n\\treturn maxQuality\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc maximalPathQuality(values []int, edges [][]int, maxTime int) int {\\n\\t\\n\\ttype Edge struct {\\n\\t\\tu int\\n\\t\\tv int\\n\\t\\ttime int\\n\\t}\\n\\n\\ttype State struct {\\n\\t\\ttimeSpent int\\n\\t\\tvisited []int\\n\\t\\tquality int\\n\\t}\\n\\n\\tadjustmentMap := make(map[int][]Edge)\\n\\tfor _, e := range edges {\\n\\t\\tadjustmentMap[e[0]] = append(adjustmentMap[e[0]], Edge{e[0], e[1], e[2]})\\n\\t\\tadjustmentMap[e[1]] = append(adjustmentMap[e[1]], Edge{e[1], e[0], e[2]})\\n\\t}\\n\\n\\tmaxQuality := 0\\n\\tvar backtracking func(state State, edge int) \\n\\t\\n\\tbacktracking = func(state State, edge int) {\\n\\t\\tif state.timeSpent > maxTime {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif edge == 0 && state.quality > maxQuality {\\n\\t\\t\\tmaxQuality = state.quality\\n\\t\\t}\\n\\t\\n\\t\\tneighbours := adjustmentMap[edge]\\n\\t\\tfor _, nei := range neighbours {\\n\\t\\t\\tneiVisited := state.visited[nei.v]\\n\\t\\t\\tstate.visited[nei.v] = 1\\n\\t\\t\\tqualityDelta := 0\\n\\t\\t\\tif neiVisited == 0 {\\n\\t\\t\\t\\tqualityDelta += values[nei.v]\\n\\t\\t\\t}\\n\\t\\t\\tstate.quality += qualityDelta\\n\\t\\t\\tstate.timeSpent += nei.time\\n\\t\\t\\tbacktracking(state, nei.v)\\t\\n\\t\\t\\tstate.visited[nei.v] = neiVisited\\n\\t\\t\\tstate.quality -= qualityDelta\\n\\t\\t\\tstate.timeSpent -= nei.time\\n\\t\\t}\\n\\t}\\n\\n\\tvisited := make([]int, len(values))\\n\\tvisited[0] = 1\\n\\tbacktracking(State{0, visited, values[0]}, 0)\\n\\treturn maxQuality\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2513388,
                "title": "backtracking",
                "content": "very easy and simple approch \\n\\n  class Solution {\\npublic:\\n    vector<vector<pair<int,int>>> v;\\n    vector<int>taken;\\n    int ans=0;\\n    void solve(vector<int>& values,int maxTime,int curnode,int curtime,int curvalue){\\n        if(curtime>maxTime)\\n            return;\\n        taken[curnode]++;\\n        if(taken[curnode]==1)\\n            curvalue+=values[curnode];\\n        if(curnode==0)\\n            ans=max(ans,curvalue);\\n        for(int i=0;i<v[curnode].size();i++){\\n            solve(values,maxTime,v[curnode][i].first,curtime+v[curnode][i].second,curvalue);\\n        }\\n        taken[curnode]--;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        v.resize(values.size());\\n        taken.resize(values.size(),0);\\n        for(int i=0;i<edges.size();i++){\\n            v[edges[i][0]].push_back(make_pair(edges[i][1],edges[i][2]));\\n            v[edges[i][1]].push_back(make_pair(edges[i][0],edges[i][2]));\\n        }\\n             solve(values,maxTime,0,0,0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<pair<int,int>>> v;\\n    vector<int>taken;\\n    int ans=0;\\n    void solve(vector<int>& values,int maxTime,int curnode,int curtime,int curvalue){\\n        if(curtime>maxTime)\\n            return;\\n        taken[curnode]++;\\n        if(taken[curnode]==1)\\n            curvalue+=values[curnode];\\n        if(curnode==0)\\n            ans=max(ans,curvalue);\\n        for(int i=0;i<v[curnode].size();i++){\\n            solve(values,maxTime,v[curnode][i].first,curtime+v[curnode][i].second,curvalue);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2510068,
                "title": "concise-dfs-java-backtracking",
                "content": "```\\nclass Solution {\\n    public class Pair{\\n        int node ;\\n        int path ;\\n        Pair(int node , int path){\\n            this.node = node ;\\n            this.path = path ;\\n        }\\n    }\\n    \\n    int ans =0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        \\n        ArrayList<ArrayList<Pair>> graph = new ArrayList<>();\\n        \\n        for(int i=0;i<values.length;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            graph.get(edges[i][0]).add(new Pair(edges[i][1],edges[i][2]));\\n            graph.get(edges[i][1]).add(new Pair(edges[i][0],edges[i][2]));\\n        }\\n        \\n        int [] visited  = new int [values.length];\\n        visited[0]=1;\\n        backtrack(0,graph,values[0],0,maxTime,values, visited);\\n        return ans ;     \\n    }\\n    public void backtrack(int src ,ArrayList<ArrayList<Pair>> graph , int collections,int time ,int mt,int[] values , int [] visited ){\\n        if(time<=mt){\\n          if(src==0){\\n            ans = Math.max(collections,ans);\\n          }\\n        \\n          for(Pair p :graph.get(src)){\\n            visited[p.node]++;\\n            time+=p.path;\\n            backtrack(p.node,graph,collections+(visited[p.node]==1?values[p.node]:0),time,mt,values,visited);\\n            time-=p.path;\\n            visited[p.node]--;\\n          }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair{\\n        int node ;\\n        int path ;\\n        Pair(int node , int path){\\n            this.node = node ;\\n            this.path = path ;\\n        }\\n    }\\n    \\n    int ans =0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        \\n        ArrayList<ArrayList<Pair>> graph = new ArrayList<>();\\n        \\n        for(int i=0;i<values.length;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            graph.get(edges[i][0]).add(new Pair(edges[i][1],edges[i][2]));\\n            graph.get(edges[i][1]).add(new Pair(edges[i][0],edges[i][2]));\\n        }\\n        \\n        int [] visited  = new int [values.length];\\n        visited[0]=1;\\n        backtrack(0,graph,values[0],0,maxTime,values, visited);\\n        return ans ;     \\n    }\\n    public void backtrack(int src ,ArrayList<ArrayList<Pair>> graph , int collections,int time ,int mt,int[] values , int [] visited ){\\n        if(time<=mt){\\n          if(src==0){\\n            ans = Math.max(collections,ans);\\n          }\\n        \\n          for(Pair p :graph.get(src)){\\n            visited[p.node]++;\\n            time+=p.path;\\n            backtrack(p.node,graph,collections+(visited[p.node]==1?values[p.node]:0),time,mt,values,visited);\\n            time-=p.path;\\n            visited[p.node]--;\\n          }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446519,
                "title": "easy-faster-90-efficient-java-soln-simple-dfs",
                "content": "```\\nclass Solution {\\n    private class Edge{\\n        int dest;\\n        int time;\\n        int wt;\\n        \\n        Edge(){\\n            \\n        }\\n        \\n        Edge(int dest, int time, int wt){\\n            this.dest = dest;\\n            this.time = time;\\n            this.wt = wt;\\n        }\\n    }\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        HashMap<Integer, List<Edge>> graph = new HashMap<>();\\n        for(int i = 0; i < values.length; i++){\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for(int i = 0; i < edges.length; i++){\\n            int [] edge = edges[i];\\n            int src = edge[0];\\n            int dest = edge[1];\\n            int time = edge[2];\\n            int weight = values[src];\\n            \\n            List<Edge> al = graph.get(src);\\n            al.add(new Edge(dest, time, weight));\\n            graph.put(src, al);\\n            al = graph.get(dest);\\n            al.add(new Edge(src, time, values[dest]));\\n            graph.put(dest, al);\\n        }\\n        ans = 0;\\n        int [] visited = new int[values.length];\\n        dfs(graph, values, 0, 0, maxTime, 0, visited);\\n        return ans;\\n    }\\n    \\n    int ans;\\n    \\n    private void dfs(HashMap<Integer, List<Edge>> graph, int[] values, int src, int time, int maxtime, int score, int [] visited){\\n        if(time > maxtime){\\n            return;\\n        }\\n        if(visited[src] == 0){\\n            score += values[src];\\n        }\\n        if(src == 0){\\n            ans = Math.max(ans, score);\\n        }\\n        List<Edge> al = graph.get(src);\\n        \\n        visited[src]++;\\n        for(Edge e : al){\\n            \\n            dfs(graph, values, e.dest, e.time + time, maxtime, score, visited);\\n        }\\n        visited[src]--;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private class Edge{\\n        int dest;\\n        int time;\\n        int wt;\\n        \\n        Edge(){\\n            \\n        }\\n        \\n        Edge(int dest, int time, int wt){\\n            this.dest = dest;\\n            this.time = time;\\n            this.wt = wt;\\n        }\\n    }\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        HashMap<Integer, List<Edge>> graph = new HashMap<>();\\n        for(int i = 0; i < values.length; i++){\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for(int i = 0; i < edges.length; i++){\\n            int [] edge = edges[i];\\n            int src = edge[0];\\n            int dest = edge[1];\\n            int time = edge[2];\\n            int weight = values[src];\\n            \\n            List<Edge> al = graph.get(src);\\n            al.add(new Edge(dest, time, weight));\\n            graph.put(src, al);\\n            al = graph.get(dest);\\n            al.add(new Edge(src, time, values[dest]));\\n            graph.put(dest, al);\\n        }\\n        ans = 0;\\n        int [] visited = new int[values.length];\\n        dfs(graph, values, 0, 0, maxTime, 0, visited);\\n        return ans;\\n    }\\n    \\n    int ans;\\n    \\n    private void dfs(HashMap<Integer, List<Edge>> graph, int[] values, int src, int time, int maxtime, int score, int [] visited){\\n        if(time > maxtime){\\n            return;\\n        }\\n        if(visited[src] == 0){\\n            score += values[src];\\n        }\\n        if(src == 0){\\n            ans = Math.max(ans, score);\\n        }\\n        List<Edge> al = graph.get(src);\\n        \\n        visited[src]++;\\n        for(Edge e : al){\\n            \\n            dfs(graph, values, e.dest, e.time + time, maxtime, score, visited);\\n        }\\n        visited[src]--;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433023,
                "title": "c-simple-dfs-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<pair<int,int>>> al;\\n    vector<int> taken;\\n    int ans=0;\\n    \\n    void dfs(vector<int>& values,int node,int ct,int mt,int cc){\\n        if(ct>mt) return;\\n        \\n        // acquire node\\n        taken[node]++;\\n        if(taken[node]==1)  cc+=values[node];\\n        \\n        // record the value\\n        if(node==0) ans=max(ans,cc);\\n        \\n        // recur\\n        for(auto i=0;i<al[node].size();i++) {\\n            dfs(values,al[node][i].first,al[node][i].second+ct,mt,cc);\\n        }\\n        \\n        // release node\\n        taken[node]--;\\n    }\\n    \\n    int maximalPathQuality(vector<int>& values,vector<vector<int>>& edges, int maxTime) {\\n        taken.resize(values.size(),0);\\n        al=vector<vector<pair<int,int>>> (values.size());\\n        \\n        // create adjacency list\\n        for(auto i=0;i<edges.size();i++) {\\n            int u=edges[i][0];int v=edges[i][1]; int t=edges[i][2];\\n            al[u].push_back(make_pair(v,t)); \\n            al[v].push_back(make_pair(u,t)); \\n        }\\n        \\n        //dfs\\n        dfs(values,0,0,maxTime,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<pair<int,int>>> al;\\n    vector<int> taken;\\n    int ans=0;\\n    \\n    void dfs(vector<int>& values,int node,int ct,int mt,int cc){\\n        if(ct>mt) return;\\n        \\n        // acquire node\\n        taken[node]++;\\n        if(taken[node]==1)  cc+=values[node];\\n        \\n        // record the value\\n        if(node==0) ans=max(ans,cc);\\n        \\n        // recur\\n        for(auto i=0;i<al[node].size();i++) {\\n            dfs(values,al[node][i].first,al[node][i].second+ct,mt,cc);\\n        }\\n        \\n        // release node\\n        taken[node]--;\\n    }\\n    \\n    int maximalPathQuality(vector<int>& values,vector<vector<int>>& edges, int maxTime) {\\n        taken.resize(values.size(),0);\\n        al=vector<vector<pair<int,int>>> (values.size());\\n        \\n        // create adjacency list\\n        for(auto i=0;i<edges.size();i++) {\\n            int u=edges[i][0];int v=edges[i][1]; int t=edges[i][2];\\n            al[u].push_back(make_pair(v,t)); \\n            al[v].push_back(make_pair(u,t)); \\n        }\\n        \\n        //dfs\\n        dfs(values,0,0,maxTime,0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424416,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int ans = 0;\\n    void dfs(int i, vector<vector<int>> graph[], vector<int>& values, int maxTime, int val)\\n    {\\n        if(maxTime < 0)\\n            return;\\n        val += values[i]; \\n        if(i == 0)\\n        {\\n            ans = max(ans, val);\\n        }\\n        int tmp = values[i];\\n        values[i] = 0;\\n        for(auto &v : graph[i])\\n            dfs(v[0], graph, values, maxTime-v[1], val);\\n        values[i] = tmp;\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        vector<vector<int>> graph[n];\\n        for(vector<int> &vec : edges)\\n        {\\n            graph[vec[0]].push_back({vec[1],vec[2]});\\n            graph[vec[1]].push_back({vec[0],vec[2]});\\n        }\\n        dfs(0, graph, values, maxTime, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    void dfs(int i, vector<vector<int>> graph[], vector<int>& values, int maxTime, int val)\\n    {\\n        if(maxTime < 0)\\n            return;\\n        val += values[i]; \\n        if(i == 0)\\n        {\\n            ans = max(ans, val);\\n        }\\n        int tmp = values[i];\\n        values[i] = 0;\\n        for(auto &v : graph[i])\\n            dfs(v[0], graph, values, maxTime-v[1], val);\\n        values[i] = tmp;\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        vector<vector<int>> graph[n];\\n        for(vector<int> &vec : edges)\\n        {\\n            graph[vec[0]].push_back({vec[1],vec[2]});\\n            graph[vec[1]].push_back({vec[0],vec[2]});\\n        }\\n        dfs(0, graph, values, maxTime, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419044,
                "title": "c-dfs-easy-solution",
                "content": "```\\nclass Solution {\\n    vector<vector<pair<int,int>>> grp;\\n    int ans;\\n    void dfs(int u,int cost,int gain,vector<int>& values,vector<int> &vis){\\n        if(!vis[u]) gain+=values[u];\\n        if(u==0) ans=max(ans,gain);\\n        vis[u]++;    \\n        for(auto j:grp[u])\\n            if(j.second<=cost) dfs(j.first,cost-j.second,gain,values,vis);\\n        vis[u]--;\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        grp.clear();\\n        ans=0;\\n        grp=vector<vector<pair<int,int>>> (n);\\n        for(auto &i:edges){\\n            grp[i[0]].push_back({i[1],i[2]});\\n            grp[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int> vis(n,0);\\n        dfs(0,maxTime,0,values,vis);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<pair<int,int>>> grp;\\n    int ans;\\n    void dfs(int u,int cost,int gain,vector<int>& values,vector<int> &vis){\\n        if(!vis[u]) gain+=values[u];\\n        if(u==0) ans=max(ans,gain);\\n        vis[u]++;    \\n        for(auto j:grp[u])\\n            if(j.second<=cost) dfs(j.first,cost-j.second,gain,values,vis);\\n        vis[u]--;\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        grp.clear();\\n        ans=0;\\n        grp=vector<vector<pair<int,int>>> (n);\\n        for(auto &i:edges){\\n            grp[i[0]].push_back({i[1],i[2]});\\n            grp[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int> vis(n,0);\\n        dfs(0,maxTime,0,values,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406952,
                "title": "python-backtracking-simple",
                "content": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        \\n        n=len(values)\\n        g=defaultdict(lambda: dict())\\n        visited=[0 for _ in range(len(values))]\\n        for e in edges:\\n            g[e[0]][e[1]]=g[e[1]][e[0]]=e[2]\\n        \\n        ans=[0]\\n        \\n        def dfs(node, val, time_taken):\\n            visited[node]+=1\\n            if node==0:\\n                ans[0]=max(ans[0], val)\\n            for ch, v in g[node].items():\\n                if v==0:\\n                    continue\\n                if v<=time_taken and visited[ch]==0:\\n                    dfs(ch, val+values[ch], time_taken-v)\\n                elif v<=time_taken and visited[ch]>0:\\n                    dfs(ch, val, time_taken-v)\\n            visited[node]-=1\\n        \\n        dfs(0, values[0], maxTime)\\n        return ans[0]\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        \\n        n=len(values)\\n        g=defaultdict(lambda: dict())\\n        visited=[0 for _ in range(len(values))]\\n        for e in edges:\\n            g[e[0]][e[1]]=g[e[1]][e[0]]=e[2]\\n        \\n        ans=[0]\\n        \\n        def dfs(node, val, time_taken):\\n            visited[node]+=1\\n            if node==0:\\n                ans[0]=max(ans[0], val)\\n            for ch, v in g[node].items():\\n                if v==0:\\n                    continue\\n                if v<=time_taken and visited[ch]==0:\\n                    dfs(ch, val+values[ch], time_taken-v)\\n                elif v<=time_taken and visited[ch]>0:\\n                    dfs(ch, val, time_taken-v)\\n            visited[node]-=1\\n        \\n        dfs(0, values[0], maxTime)\\n        return ans[0]\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396182,
                "title": "javascript-backtracking-with-explanation-159ms",
                "content": "**Intuition:**\\nApparently we need to traverse all neighbours for a given node, but be cautious that **a node won\\'t be traversed twice from the same node** during this process.\\n\\nFor each edge `(u, v)` of a giving node `u`,  we could add another flag to indicate whehter it has been traversed before:\\n```js\\n[u, v, 0] // u->v hasn\\'t been traversed\\n[u, v, 1] // u->v has been traversed\\n```\\n\\nThe example 1 with its dfs tree shows below.\\n\\nYou can see clearly that a possible solution is the sum of values belonged to each node on the path which is starting from the root node `0` and ending up with another node `0`, e.g `0->1->0`, `0->1->0->3->0`, etc.\\n\\nThe node with red background color means we shall not traverse to that node from its parent since **it has been traversed already**, otherwise it may lead to infinite loop.\\n\\n![image](https://assets.leetcode.com/users/images/1f08b5f0-0748-445c-9e98-e304ccee87d4_1659701015.248961.png)\\n\\n**Code**:\\n\\n```ts\\nfunction maximalPathQuality(values: number[], edges: number[][], maxTime: number): number {\\n  const n = values.length;\\n  if (n < 1) {\\n    return 0;\\n  }\\n  // build adjacent list according to edges\\n  const adjacentList = buildAdjacentList(n, edges);\\n  const visited: boolean[] = new Array(n).fill(false);\\n  visited[0] = true;\\n  const result = { ans: 0 };\\n  backtrack(0, values, adjacentList, visited, 0, maxTime, values[0], result);\\n  return result.ans;\\n};\\n\\nfunction buildAdjacentList(n: number, edges: number[][]) {\\n  // mark whether v->u has been traversed because we wont stop by it twice\\n  // adjacentList[0] = [ [1, 10, 0], [3, 10, 1] ] which means 0---10--->1(visited=0),  0---10--->3(visited=1)\\n  const adjacentList: (number[][])[] = new Array(n).fill(undefined);\\n  for (let i = 0, l = edges.length; i < l; i++) {\\n    const [u, v, w] = edges[i];\\n    if (!adjacentList[u]) {\\n      adjacentList[u] = [];\\n    }\\n    if (!adjacentList[v]) {\\n      adjacentList[v] = [];\\n    }\\n    adjacentList[u].push([v, w, 0]);\\n    adjacentList[v].push([u, w, 0]);\\n  }\\n  return adjacentList;\\n}\\n\\nfunction backtrack(currentNode: number, values: number[], adjacentList: number[][][], visited: boolean[], currentTime: number, maxTime: number, currentSum: number, result: { ans: number }) {\\n  // each time we encounter node 0, try to update answer\\n  if (currentNode === 0) {\\n    result.ans = Math.max(result.ans, currentSum);\\n  }\\n\\n  // maybe there\\'s no edges connected to current node\\n  const adjacentNodes = adjacentList[currentNode];\\n  if (adjacentNodes === undefined) {\\n    return;\\n  }\\n\\n  // for each node that is adjacent to current node, traverse it until maxTime exceeds\\n  for (let i = 0, l = adjacentNodes.length; i < l; i++) {\\n    const [adjacentNode, weight, isVisitedByCurrentNode] = adjacentNodes[i];\\n    if (isVisitedByCurrentNode === 1) {\\n      continue;\\n    }\\n\\n    if (maxTime < weight + currentTime) {\\n      continue;\\n    }\\n\\n    const isAlreadyVisitedByOtherNode = visited[adjacentNode];\\n    const newSum = isAlreadyVisitedByOtherNode ? currentSum : (currentSum + values[adjacentNode]);\\n\\n    // mark currentNode to adjacentNode as visited so that we won\\'t traverse this directed edge again\\n    adjacentNodes[i][2] = 1;\\n    visited[adjacentNode] = true;\\n    backtrack(adjacentNode, values, adjacentList, visited, currentTime + weight, maxTime, newSum, result);\\n    !isAlreadyVisitedByOtherNode && (visited[adjacentNode] = false);\\n    adjacentNodes[i][2] = 0; // for symmetry, we shall reset it since we are going to try next adjacent node\\n  }\\n\\n}\\n```\\n\\nMaybe there\\'s still optimization could be made, please point it out. Thanks in advance.",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```js\\n[u, v, 0] // u->v hasn\\'t been traversed\\n[u, v, 1] // u->v has been traversed\\n```\n```ts\\nfunction maximalPathQuality(values: number[], edges: number[][], maxTime: number): number {\\n  const n = values.length;\\n  if (n < 1) {\\n    return 0;\\n  }\\n  // build adjacent list according to edges\\n  const adjacentList = buildAdjacentList(n, edges);\\n  const visited: boolean[] = new Array(n).fill(false);\\n  visited[0] = true;\\n  const result = { ans: 0 };\\n  backtrack(0, values, adjacentList, visited, 0, maxTime, values[0], result);\\n  return result.ans;\\n};\\n\\nfunction buildAdjacentList(n: number, edges: number[][]) {\\n  // mark whether v->u has been traversed because we wont stop by it twice\\n  // adjacentList[0] = [ [1, 10, 0], [3, 10, 1] ] which means 0---10--->1(visited=0),  0---10--->3(visited=1)\\n  const adjacentList: (number[][])[] = new Array(n).fill(undefined);\\n  for (let i = 0, l = edges.length; i < l; i++) {\\n    const [u, v, w] = edges[i];\\n    if (!adjacentList[u]) {\\n      adjacentList[u] = [];\\n    }\\n    if (!adjacentList[v]) {\\n      adjacentList[v] = [];\\n    }\\n    adjacentList[u].push([v, w, 0]);\\n    adjacentList[v].push([u, w, 0]);\\n  }\\n  return adjacentList;\\n}\\n\\nfunction backtrack(currentNode: number, values: number[], adjacentList: number[][][], visited: boolean[], currentTime: number, maxTime: number, currentSum: number, result: { ans: number }) {\\n  // each time we encounter node 0, try to update answer\\n  if (currentNode === 0) {\\n    result.ans = Math.max(result.ans, currentSum);\\n  }\\n\\n  // maybe there\\'s no edges connected to current node\\n  const adjacentNodes = adjacentList[currentNode];\\n  if (adjacentNodes === undefined) {\\n    return;\\n  }\\n\\n  // for each node that is adjacent to current node, traverse it until maxTime exceeds\\n  for (let i = 0, l = adjacentNodes.length; i < l; i++) {\\n    const [adjacentNode, weight, isVisitedByCurrentNode] = adjacentNodes[i];\\n    if (isVisitedByCurrentNode === 1) {\\n      continue;\\n    }\\n\\n    if (maxTime < weight + currentTime) {\\n      continue;\\n    }\\n\\n    const isAlreadyVisitedByOtherNode = visited[adjacentNode];\\n    const newSum = isAlreadyVisitedByOtherNode ? currentSum : (currentSum + values[adjacentNode]);\\n\\n    // mark currentNode to adjacentNode as visited so that we won\\'t traverse this directed edge again\\n    adjacentNodes[i][2] = 1;\\n    visited[adjacentNode] = true;\\n    backtrack(adjacentNode, values, adjacentList, visited, currentTime + weight, maxTime, newSum, result);\\n    !isAlreadyVisitedByOtherNode && (visited[adjacentNode] = false);\\n    adjacentNodes[i][2] = 0; // for symmetry, we shall reset it since we are going to try next adjacent node\\n  }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379857,
                "title": "c-soln",
                "content": "```\\n    void dfs(int curr, vector<int>&values, int& res, int node, string& vis, vector<pair<int, int>>adj[], int maxTime, int time){\\n        if(time > maxTime) return;\\n        \\n        for(auto it: adj[node]){\\n            if(vis[it.first] - \\'0\\'){\\n                if(it.first == 0 && time + it.second <= maxTime){\\n                    res = max(res, curr);\\n                    dfs(curr, values, res, it.first, vis, adj, maxTime, time + it.second);\\n                }\\n                else{\\n                    dfs(curr, values, res, it.first, vis, adj, maxTime, time + it.second);\\n                }\\n            }\\n            else{\\n                vis[it.first] = \\'1\\';\\n                dfs(curr + values[it.first], values, res, it.first, vis, adj, maxTime, time + it.second);\\n                vis[it.first] = \\'0\\';\\n            }\\n        }\\n    }\\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime){\\n        int res = values[0];\\n        int n = values.size();\\n        string vis = \"\";\\n        for(int i=0;i<n;i++)\\n            vis.push_back(\\'0\\');\\n        \\n        vis[0] = \\'1\\';\\n        \\n        vector<pair<int, int>>adj[n];\\n        \\n        for(int i=0;i<edges.size();i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            \\n            int t = edges[i][2];\\n            \\n            adj[a].push_back({b, t});\\n            adj[b].push_back({a, t});\\n        }\\n        \\n        dfs(values[0], values, res, 0, vis, adj, maxTime, 0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    void dfs(int curr, vector<int>&values, int& res, int node, string& vis, vector<pair<int, int>>adj[], int maxTime, int time){\\n        if(time > maxTime) return;\\n        \\n        for(auto it: adj[node]){\\n            if(vis[it.first] - \\'0\\'){\\n                if(it.first == 0 && time + it.second <= maxTime){\\n                    res = max(res, curr);\\n                    dfs(curr, values, res, it.first, vis, adj, maxTime, time + it.second);\\n                }\\n                else{\\n                    dfs(curr, values, res, it.first, vis, adj, maxTime, time + it.second);\\n                }\\n            }\\n            else{\\n                vis[it.first] = \\'1\\';\\n                dfs(curr + values[it.first], values, res, it.first, vis, adj, maxTime, time + it.second);\\n                vis[it.first] = \\'0\\';\\n            }\\n        }\\n    }\\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime){\\n        int res = values[0];\\n        int n = values.size();\\n        string vis = \"\";\\n        for(int i=0;i<n;i++)\\n            vis.push_back(\\'0\\');\\n        \\n        vis[0] = \\'1\\';\\n        \\n        vector<pair<int, int>>adj[n];\\n        \\n        for(int i=0;i<edges.size();i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            \\n            int t = edges[i][2];\\n            \\n            adj[a].push_back({b, t});\\n            adj[b].push_back({a, t});\\n        }\\n        \\n        dfs(values[0], values, res, 0, vis, adj, maxTime, 0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2368178,
                "title": "c-dfs",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>adj[1001];\\n    int visited[1001];\\n    int maxx;\\n    void dfs(vector<int>&val,int src,int time,int curr){\\n        if(!visited[src]) curr+=val[src]; \\n        visited[src]++;\\n        if(src==0) maxx=max(maxx,curr);\\n        for(auto edge:adj[src]){\\n            if(time-edge.second>=0) dfs(val,edge.first,time-edge.second,curr);\\n        }\\n        visited[src]--;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        for(auto x:edges){\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        dfs(values,0,maxTime,0);\\n        return maxx;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<pair<int,int>>adj[1001];\\n    int visited[1001];\\n    int maxx;\\n    void dfs(vector<int>&val,int src,int time,int curr){\\n        if(!visited[src]) curr+=val[src]; \\n        visited[src]++;\\n        if(src==0) maxx=max(maxx,curr);\\n        for(auto edge:adj[src]){\\n            if(time-edge.second>=0) dfs(val,edge.first,time-edge.second,curr);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2365915,
                "title": "python-dfs-intuitive",
                "content": "Note:\\n     each edge time at least 10 and maxtime 100, so it is doable to try all possibilities.\\n\\t \\n```\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        g=defaultdict(list)\\n        for u,v,t in edges:\\n            g[u].append([v,t])\\n            g[v].append([u,t])\\n        visited=[0]*len(values)\\n        res=0\\n        visited[0]=1\\n        def backtrack(nd, score, budget):\\n            nonlocal res\\n            if budget<0:return\\n            if nd==0:\\n                res=max(res, score)\\n            for node,t in g[nd]:\\n                visited[node]+=1\\n                backtrack(node, score+(values[node] if visited[node]==1 else 0), budget-t)\\n                visited[node]-=1\\n            return\\n        backtrack(0,values[0],maxTime)\\n                \\n        return res\\n",
                "solutionTags": [],
                "code": "Note:\\n     each edge time at least 10 and maxtime 100, so it is doable to try all possibilities.\\n\\t \\n```\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        g=defaultdict(list)\\n        for u,v,t in edges:\\n            g[u].append([v,t])\\n            g[v].append([u,t])\\n        visited=[0]*len(values)\\n        res=0\\n        visited[0]=1\\n        def backtrack(nd, score, budget):\\n            nonlocal res\\n            if budget<0:return\\n            if nd==0:\\n                res=max(res, score)\\n            for node,t in g[nd]:\\n                visited[node]+=1\\n                backtrack(node, score+(values[node] if visited[node]==1 else 0), budget-t)\\n                visited[node]-=1\\n            return\\n        backtrack(0,values[0],maxTime)\\n                \\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2364970,
                "title": "backtracking-based-solution-c",
                "content": "``` \\nclass Solution {\\npublic:\\n    \\n    using pii = pair<int, int>;\\n    const int INF = (int)1e8;\\n    \\n    int n;\\n    int mxTime;\\n    vector<pii> g[1010];\\n    int values[1010];\\n    bool used[1010];\\n    int ans;\\n    \\n    void rec(int cur, int len, int &cur_time, int &cur_sum) {\\n        // If the current node is 0, and the time is still less than mxTime, then update ans\\n        if (cur == 0 && cur_time <= mxTime) {\\n            ans = max(ans, cur_sum);\\n        } \\n        \\n        bool notused = 0;\\n        \\n        // If not used, then add the value to the sum\\n        if (!used[cur]) {\\n            notused = 1;\\n            cur_sum += values[cur];\\n            used[cur] = 1;\\n        }\\n        \\n        // Go over all neighbours which can be reached in time <= mxTime \\n        for (auto x: g[cur]) {\\n            if (cur_time + x.second <= mxTime) {\\n                // update cur_time, call recursion and reset it\\n                cur_time += x.second;\\n                rec(x.first, len + 1, cur_time, cur_sum);\\n                cur_time -= x.second;\\n            }\\n        }\\n        \\n        // reset values only if not used\\n        if (notused) {\\n            cur_sum -= values[cur];\\n            used[cur] = 0;\\n        }\\n    }\\n    \\n    int maximalPathQuality(vector<int>& v, vector<vector<int>>& edges, int maxTime) {\\n        n = v.size();\\n        mxTime = maxTime;\\n        ans = -1;\\n        \\n        for (int i = 0; i < n; ++i)\\n            values[i] = v[i];\\n        \\n        for (auto &e: edges) {\\n            g[e[0]].push_back({e[1], e[2]});\\n            g[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        int cur_time = 0, cur_sum = values[0];\\n        used[0] = 1;\\n        rec(0, 0, cur_time, cur_sum);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Graph"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    \\n    using pii = pair<int, int>;\\n    const int INF = (int)1e8;\\n    \\n    int n;\\n    int mxTime;\\n    vector<pii> g[1010];\\n    int values[1010];\\n    bool used[1010];\\n    int ans;\\n    \\n    void rec(int cur, int len, int &cur_time, int &cur_sum) {\\n        // If the current node is 0, and the time is still less than mxTime, then update ans\\n        if (cur == 0 && cur_time <= mxTime) {\\n            ans = max(ans, cur_sum);\\n        } \\n        \\n        bool notused = 0;\\n        \\n        // If not used, then add the value to the sum\\n        if (!used[cur]) {\\n            notused = 1;\\n            cur_sum += values[cur];\\n            used[cur] = 1;\\n        }\\n        \\n        // Go over all neighbours which can be reached in time <= mxTime \\n        for (auto x: g[cur]) {\\n            if (cur_time + x.second <= mxTime) {\\n                // update cur_time, call recursion and reset it\\n                cur_time += x.second;\\n                rec(x.first, len + 1, cur_time, cur_sum);\\n                cur_time -= x.second;\\n            }\\n        }\\n        \\n        // reset values only if not used\\n        if (notused) {\\n            cur_sum -= values[cur];\\n            used[cur] = 0;\\n        }\\n    }\\n    \\n    int maximalPathQuality(vector<int>& v, vector<vector<int>>& edges, int maxTime) {\\n        n = v.size();\\n        mxTime = maxTime;\\n        ans = -1;\\n        \\n        for (int i = 0; i < n; ++i)\\n            values[i] = v[i];\\n        \\n        for (auto &e: edges) {\\n            g[e[0]].push_back({e[1], e[2]});\\n            g[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        int cur_time = 0, cur_sum = values[0];\\n        used[0] = 1;\\n        rec(0, 0, cur_time, cur_sum);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296819,
                "title": "simple-java-solution-explained",
                "content": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        // construct edge map\\n        Map<Integer, Map<Integer, Integer>> edgeMap = new HashMap();\\n        for (int[] edge : edges) {\\n            if (!edgeMap.containsKey(edge[0])) {\\n                edgeMap.put(edge[0], new HashMap());\\n            }\\n            edgeMap.get(edge[0]).put(edge[1],edge[2]);\\n            if (!edgeMap.containsKey(edge[1])) {\\n                edgeMap.put(edge[1], new HashMap());\\n            }\\n            edgeMap.get(edge[1]).put(edge[0],edge[2]);\\n        }\\n        \\n    \\n        int maxQuality = values[0];\\n        boolean[] visited = new boolean[values.length]; // use this to track if the value has been visited\\n        visited[0] = true;\\n        \\n        if (!edgeMap.containsKey(0)) {\\n            return maxQuality;\\n        }\\n        for (Integer e : edgeMap.get(0).keySet()) {\\n            maxQuality = Math.max(maxQuality, backtracking(edgeMap, values, 0, e, maxTime, visited) + values[0]);\\n        }\\n        return maxQuality;\\n    }\\n    \\n    private int backtracking(Map<Integer, Map<Integer, Integer>> edgeMap, int[] values, int i1, int i2, int maxTime, boolean[] visited) {\\n        maxTime -= edgeMap.get(i1).get(i2);\\n        \\n        // we need to stop at i1 if current edge is more than remaining time\\n        if (maxTime < 0) {\\n            if (i1 == 0) return 0; // if i1 is 0, the path is valid\\n            return Integer.MIN_VALUE; // return MIN_VALUE when path is invalid\\n        }\\n        \\n        // we need to stop at i2 if current edge used up all time\\n        if (maxTime == 0) {\\n            if (i2 == 0) return 0; // if t2 is 0, the path is valid\\n            return Integer.MIN_VALUE; // return MIN_VALUE when path is invalid\\n        }\\n        \\n        // next recursion\\n        int maxValue = Integer.MIN_VALUE;\\n        // technically you can stop here if i2 is 0\\n        if (i2 == 0) {\\n            maxValue = 0; // set maxValue to 0 since index 0 is already visited\\n        }\\n        if (!edgeMap.containsKey(i2)) {\\n            return maxValue;\\n        }\\n        \\n        // now try to find next valid path\\n        // save the current value if i2 has not been visited\\n        int currValue = visited[i2] ?  0 : values[i2];\\n        Map<Integer, Integer> edges = edgeMap.get(i2);\\n        for (Integer next : edges.keySet()) {\\n            if (edges.get(next) > maxTime) {\\n                continue;\\n            }\\n            boolean isVisited = visited[i2];\\n            visited[i2] = true; // set i2 to visited\\n            int nextVal = backtracking(edgeMap, values, i2, next, maxTime, visited);\\n            if (nextVal != Integer.MIN_VALUE) {// meaning a valid path is found\\n                maxValue = Math.max(maxValue, nextVal + currValue);\\n            }\\n            visited[i2] = isVisited;\\n        }\\n        return maxValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        // construct edge map\\n        Map<Integer, Map<Integer, Integer>> edgeMap = new HashMap();\\n        for (int[] edge : edges) {\\n            if (!edgeMap.containsKey(edge[0])) {\\n                edgeMap.put(edge[0], new HashMap());\\n            }\\n            edgeMap.get(edge[0]).put(edge[1],edge[2]);\\n            if (!edgeMap.containsKey(edge[1])) {\\n                edgeMap.put(edge[1], new HashMap());\\n            }\\n            edgeMap.get(edge[1]).put(edge[0],edge[2]);\\n        }\\n        \\n    \\n        int maxQuality = values[0];\\n        boolean[] visited = new boolean[values.length]; // use this to track if the value has been visited\\n        visited[0] = true;\\n        \\n        if (!edgeMap.containsKey(0)) {\\n            return maxQuality;\\n        }\\n        for (Integer e : edgeMap.get(0).keySet()) {\\n            maxQuality = Math.max(maxQuality, backtracking(edgeMap, values, 0, e, maxTime, visited) + values[0]);\\n        }\\n        return maxQuality;\\n    }\\n    \\n    private int backtracking(Map<Integer, Map<Integer, Integer>> edgeMap, int[] values, int i1, int i2, int maxTime, boolean[] visited) {\\n        maxTime -= edgeMap.get(i1).get(i2);\\n        \\n        // we need to stop at i1 if current edge is more than remaining time\\n        if (maxTime < 0) {\\n            if (i1 == 0) return 0; // if i1 is 0, the path is valid\\n            return Integer.MIN_VALUE; // return MIN_VALUE when path is invalid\\n        }\\n        \\n        // we need to stop at i2 if current edge used up all time\\n        if (maxTime == 0) {\\n            if (i2 == 0) return 0; // if t2 is 0, the path is valid\\n            return Integer.MIN_VALUE; // return MIN_VALUE when path is invalid\\n        }\\n        \\n        // next recursion\\n        int maxValue = Integer.MIN_VALUE;\\n        // technically you can stop here if i2 is 0\\n        if (i2 == 0) {\\n            maxValue = 0; // set maxValue to 0 since index 0 is already visited\\n        }\\n        if (!edgeMap.containsKey(i2)) {\\n            return maxValue;\\n        }\\n        \\n        // now try to find next valid path\\n        // save the current value if i2 has not been visited\\n        int currValue = visited[i2] ?  0 : values[i2];\\n        Map<Integer, Integer> edges = edgeMap.get(i2);\\n        for (Integer next : edges.keySet()) {\\n            if (edges.get(next) > maxTime) {\\n                continue;\\n            }\\n            boolean isVisited = visited[i2];\\n            visited[i2] = true; // set i2 to visited\\n            int nextVal = backtracking(edgeMap, values, i2, next, maxTime, visited);\\n            if (nextVal != Integer.MIN_VALUE) {// meaning a valid path is found\\n                maxValue = Math.max(maxValue, nextVal + currValue);\\n            }\\n            visited[i2] = isVisited;\\n        }\\n        return maxValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279321,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        Map<Integer, List<int[] >> map = new HashMap<>();\\n        \\n        // organize the graph: node -> List<[nextNode, cost]>\\n        for (int[] e: edges) {\\n            map.putIfAbsent(e[0], new ArrayList<>());\\n            map.putIfAbsent(e[1], new ArrayList<>());\\n            map.get(e[0]).add(new int[] {\\n                e[1], e[2]\\n            });\\n            map.get(e[1]).add(new int[] {\\n                e[0], e[2]\\n            });\\n        }\\n\\n        int[] res = new int[1]; \\n        boolean[] visited = new boolean[values.length];\\n        visited[0] = true;\\n        dfs(0, maxTime, values[0], res, map, values, visited);\\n        return res[0];\\n    }\\n\\n    private void dfs(int cur, int time, int qua, int[] res, Map<Integer, List<int[] >> graph, int[] values, boolean[] visited) {\\n        //no more time\\n        if (time<0) {\\n            return;\\n        }\\n        \\n        // back to 0\\n        if (cur == 0) {\\n            res[0] = Math.max(res[0], qua);\\n        }\\n\\n        for (int[] next: graph.getOrDefault(cur, new ArrayList<>())) {\\n\\n            int cost = next[1];\\n            int nextNode = next[0];\\n            int gain = values[nextNode];\\n            \\n            // next node\\'s cur status\\n            boolean curStatus = visited[nextNode];\\n            // if you can gain based on status\\n            int nextQ = curStatus ? qua : qua + gain;\\n            \\n            // backtracking\\n            visited[nextNode] = true;\\n            dfs(nextNode, time - cost, nextQ, res, graph, values, visited);\\n            visited[nextNode] = curStatus;\\n\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        Map<Integer, List<int[] >> map = new HashMap<>();\\n        \\n        // organize the graph: node -> List<[nextNode, cost]>\\n        for (int[] e: edges) {\\n            map.putIfAbsent(e[0], new ArrayList<>());\\n            map.putIfAbsent(e[1], new ArrayList<>());\\n            map.get(e[0]).add(new int[] {\\n                e[1], e[2]\\n            });\\n            map.get(e[1]).add(new int[] {\\n                e[0], e[2]\\n            });\\n        }\\n\\n        int[] res = new int[1]; \\n        boolean[] visited = new boolean[values.length];\\n        visited[0] = true;\\n        dfs(0, maxTime, values[0], res, map, values, visited);\\n        return res[0];\\n    }\\n\\n    private void dfs(int cur, int time, int qua, int[] res, Map<Integer, List<int[] >> graph, int[] values, boolean[] visited) {\\n        //no more time\\n        if (time<0) {\\n            return;\\n        }\\n        \\n        // back to 0\\n        if (cur == 0) {\\n            res[0] = Math.max(res[0], qua);\\n        }\\n\\n        for (int[] next: graph.getOrDefault(cur, new ArrayList<>())) {\\n\\n            int cost = next[1];\\n            int nextNode = next[0];\\n            int gain = values[nextNode];\\n            \\n            // next node\\'s cur status\\n            boolean curStatus = visited[nextNode];\\n            // if you can gain based on status\\n            int nextQ = curStatus ? qua : qua + gain;\\n            \\n            // backtracking\\n            visited[nextNode] = true;\\n            dfs(nextNode, time - cost, nextQ, res, graph, values, visited);\\n            visited[nextNode] = curStatus;\\n\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276851,
                "title": "c-backtracking-on-graph",
                "content": "```\\nclass Solution {\\nprivate:\\n    void dfs(int &ans,int vertex,int quality,int maxTime,vector<vector<pair<int,int>>>&graph,vector<bool>&seen,vector<int>&values){\\n        if(maxTime<0){\\n            return;\\n        } else {\\n            bool isTrue=seen[vertex];\\n            if(!seen[vertex]){\\n                quality+=values[vertex];\\n            }\\n            seen[vertex]=true;\\n            if(vertex==0){\\n                ans=max(ans,quality);\\n            }\\n            for(pair<int,int>edge:graph[vertex]){\\n                int neighbour=edge.first;\\n                int time=edge.second;\\n                dfs(ans,neighbour,quality,maxTime-time,graph,seen,values);\\n            }\\n            seen[vertex]=isTrue;\\n        }\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n=values.size();\\n        vector<vector<pair<int,int>>>graph(n);\\n        for(vector<int>edge:edges){\\n            graph[edge[0]].push_back(make_pair(edge[1],edge[2]));\\n            graph[edge[1]].push_back(make_pair(edge[0],edge[2]));\\n        }\\n        int ans=-1;\\n        vector<bool>seen(n,false);\\n        dfs(ans,0,0,maxTime,graph,seen,values);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\nprivate:\\n    void dfs(int &ans,int vertex,int quality,int maxTime,vector<vector<pair<int,int>>>&graph,vector<bool>&seen,vector<int>&values){\\n        if(maxTime<0){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2251287,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int backTrack(vector<int>& values, vector<vector<int>>& edges, vector<vector<int>>& indices, int curNode, int maxTime, int curTime, int qualitySum, vector<int>& added) {\\n        int maxQuality = 0;\\n        \\n        // Invalid.\\n        if (curTime > maxTime)\\n            return 0;\\n        \\n        if (curNode == 0)\\n            maxQuality = max(maxQuality, qualitySum);\\n        \\n        if (qualitySum > maxQuality && curTime * 2 <= maxTime)\\n            maxQuality = max(maxQuality, qualitySum);\\n        \\n        for (int i = 0; i < indices[curNode].size(); i++) {\\n            int index = indices[curNode][i];\\n            \\n            if (!added[edges[index][1]]) {\\n                added[edges[index][1]] = 1;\\n                maxQuality = max(maxQuality, backTrack(values, edges, indices, edges[index][1], maxTime, curTime + edges[index][2], qualitySum + values[edges[index][1]], added));\\n                added[edges[index][1]] = 0;\\n            } else {\\n                maxQuality = max(maxQuality, backTrack(values, edges, indices, edges[index][1], maxTime, curTime + edges[index][2], qualitySum, added));\\n            }\\n        }\\n                \\n        return maxQuality;\\n    }\\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        vector<int> added(values.size());\\n        vector<vector<int>> indices(values.size(), vector<int>({}));\\n        \\n        int firstNode = values[0];\\n        int length = edges.size();\\n        \\n        for (int i = 0; i < length; i++) {\\n            indices[edges[i][0]].push_back(i);\\n            indices[edges[i][1]].push_back(i+length);\\n            edges.push_back({edges[i][1], edges[i][0], edges[i][2]});\\n        }\\n        \\n        return max(firstNode, backTrack(values, edges, indices, 0, maxTime, 0, 0, added));\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int backTrack(vector<int>& values, vector<vector<int>>& edges, vector<vector<int>>& indices, int curNode, int maxTime, int curTime, int qualitySum, vector<int>& added) {\\n        int maxQuality = 0;\\n        \\n        // Invalid.\\n        if (curTime > maxTime)\\n            return 0;\\n        \\n        if (curNode == 0)\\n            maxQuality = max(maxQuality, qualitySum);\\n        \\n        if (qualitySum > maxQuality && curTime * 2 <= maxTime)\\n            maxQuality = max(maxQuality, qualitySum);\\n        \\n        for (int i = 0; i < indices[curNode].size(); i++) {\\n            int index = indices[curNode][i];\\n            \\n            if (!added[edges[index][1]]) {\\n                added[edges[index][1]] = 1;\\n                maxQuality = max(maxQuality, backTrack(values, edges, indices, edges[index][1], maxTime, curTime + edges[index][2], qualitySum + values[edges[index][1]], added));\\n                added[edges[index][1]] = 0;\\n            } else {\\n                maxQuality = max(maxQuality, backTrack(values, edges, indices, edges[index][1], maxTime, curTime + edges[index][2], qualitySum, added));\\n            }\\n        }\\n                \\n        return maxQuality;\\n    }\\n    \\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        vector<int> added(values.size());\\n        vector<vector<int>> indices(values.size(), vector<int>({}));\\n        \\n        int firstNode = values[0];\\n        int length = edges.size();\\n        \\n        for (int i = 0; i < length; i++) {\\n            indices[edges[i][0]].push_back(i);\\n            indices[edges[i][1]].push_back(i+length);\\n            edges.push_back({edges[i][1], edges[i][0], edges[i][2]});\\n        }\\n        \\n        return max(firstNode, backTrack(values, edges, indices, 0, maxTime, 0, 0, added));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240306,
                "title": "bfs-solution-c-tle-for-learning",
                "content": "**the solution gives TLE because of use of structure which increases runtime**\\n\\n```\\nclass Solution {\\nstruct p{\\n    int node;\\n    int val;\\n    int time;\\n    unordered_set<int>s;\\n};\\n\\npublic:\\n    int maximalPathQuality(vector<int>& value, vector<vector<int>>& edges, int maxtime) {\\n        int n=value.size();\\n        \\n        vector<vector<pair<int,int>>>a(n);\\n    \\n        for(auto x: edges){\\n            a[x[0]].push_back({x[1],x[2]});\\n            a[x[1]].push_back({x[0],x[2]});\\n        }\\n\\n        queue<p>q;\\n        unordered_set<int>s;\\n        s.insert(0);\\n        p x={0,value[0],0,s};\\n        q.push(x); //currv , sum, time ,path\\n        \\n        unordered_map<int,pair<int,int>>mp; //prevtim,prvval\\n        \\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            auto [u,val,time,set]=q.front();q.pop();\\n            \\n            if(mp.find(u)!=mp.end() and mp[u].first<=time and mp[u].second>val) continue;\\n\\n            if(time>maxtime) continue;\\n            \\n            if(u==0) ans=max(ans,val);\\n            \\n            for(auto [v,nxttime]: a[u]){\\n                \\n                if(set.find(v)!=set.end())\\n                    q.push({v,val,time+nxttime,set});\\n                \\n                else{\\n                unordered_set<int> nxtset=set;\\n                    nxtset.insert(v);    \\n                q.push({v,val+value[v],time+nxttime,nxtset});\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\nstruct p{\\n    int node;\\n    int val;\\n    int time;\\n    unordered_set<int>s;\\n};\\n\\npublic:\\n    int maximalPathQuality(vector<int>& value, vector<vector<int>>& edges, int maxtime) {\\n        int n=value.size();\\n        \\n        vector<vector<pair<int,int>>>a(n);\\n    \\n        for(auto x: edges){\\n            a[x[0]].push_back({x[1],x[2]});\\n            a[x[1]].push_back({x[0],x[2]});\\n        }\\n\\n        queue<p>q;\\n        unordered_set<int>s;\\n        s.insert(0);\\n        p x={0,value[0],0,s};\\n        q.push(x); //currv , sum, time ,path\\n        \\n        unordered_map<int,pair<int,int>>mp; //prevtim,prvval\\n        \\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            auto [u,val,time,set]=q.front();q.pop();\\n            \\n            if(mp.find(u)!=mp.end() and mp[u].first<=time and mp[u].second>val) continue;\\n\\n            if(time>maxtime) continue;\\n            \\n            if(u==0) ans=max(ans,val);\\n            \\n            for(auto [v,nxttime]: a[u]){\\n                \\n                if(set.find(v)!=set.end())\\n                    q.push({v,val,time+nxttime,set});\\n                \\n                else{\\n                unordered_set<int> nxtset=set;\\n                    nxtset.insert(v);    \\n                q.push({v,val+value[v],time+nxttime,nxtset});\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237892,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    int result = 0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        int[] visited = new int[n];\\n        \\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        \\n        for(int[] e: edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            int t = e[2];\\n            \\n            map.putIfAbsent(u, new ArrayList<>());\\n            map.putIfAbsent(v, new ArrayList<>());\\n            \\n            map.get(u).add(new int[]{v, t});\\n            map.get(v).add(new int[]{u, t});\\n        }\\n        \\n        int start = 0;\\n        int total = values[start];\\n        visited[start]++;\\n        dfs(values, visited, map, maxTime, total, start);\\n        return result;\\n    }\\n    \\n    private void dfs(int[] values, int[] visited, Map<Integer, List<int[]>> map, int maxTime, int total, int start) {\\n        if(start == 0) {\\n            result = Math.max(result, total);\\n        }\\n        \\n        if(map.get(start) == null) {\\n            return;\\n        }\\n        \\n        for(int[] i: map.get(start)) {\\n            int dest = i[0];\\n            int time = i[1];\\n            int newTime = maxTime - time;\\n            if(newTime < 0) {\\n                continue;\\n            }\\n            \\n            visited[dest]++;\\n            int newValue = total + (visited[dest] != 1 ? 0 : values[dest]);\\n            dfs(values, visited, map, newTime, newValue, dest);\\n            visited[dest]--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        int[] visited = new int[n];\\n        \\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        \\n        for(int[] e: edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            int t = e[2];\\n            \\n            map.putIfAbsent(u, new ArrayList<>());\\n            map.putIfAbsent(v, new ArrayList<>());\\n            \\n            map.get(u).add(new int[]{v, t});\\n            map.get(v).add(new int[]{u, t});\\n        }\\n        \\n        int start = 0;\\n        int total = values[start];\\n        visited[start]++;\\n        dfs(values, visited, map, maxTime, total, start);\\n        return result;\\n    }\\n    \\n    private void dfs(int[] values, int[] visited, Map<Integer, List<int[]>> map, int maxTime, int total, int start) {\\n        if(start == 0) {\\n            result = Math.max(result, total);\\n        }\\n        \\n        if(map.get(start) == null) {\\n            return;\\n        }\\n        \\n        for(int[] i: map.get(start)) {\\n            int dest = i[0];\\n            int time = i[1];\\n            int newTime = maxTime - time;\\n            if(newTime < 0) {\\n                continue;\\n            }\\n            \\n            visited[dest]++;\\n            int newValue = total + (visited[dest] != 1 ? 0 : values[dest]);\\n            dfs(values, visited, map, newTime, newValue, dest);\\n            visited[dest]--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234606,
                "title": "what-if-maxtime-is-big",
                "content": "maxTime is 100 and min time consumption is 10, at most 10 steps. Brute force dfs without caching will work.\\nBut what if maxTime is big? What will be the optimal solution under such condition?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2188146,
                "title": "python-dfs-bitmask",
                "content": "```\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        n = len(values)\\n        graph = defaultdict(dict)\\n        \\n        for a, b, t in edges:\\n            graph[a][b] = t\\n            graph[b][a] = t\\n        \\n        self.maxi = 0\\n        \\n        def dfs(time, node, value, mask):\\n            if time > maxTime:\\n                return\\n            if node == 0:\\n                self.maxi = max(self.maxi, value)\\n\\n            for neigh in graph[node]:\\n                if time + graph[node][neigh] <= maxTime:\\n                    dfs(\\n                        time + graph[node][neigh],\\n                        neigh,\\n                        value + (values[neigh] if not ((mask >> neigh) & 1) else 0),\\n                        (1 << neigh) | mask\\n                    )\\n        \\n        dfs(0, 0, values[0], 1)\\n        \\n        return self.maxi",
                "solutionTags": [],
                "code": "```\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        n = len(values)\\n        graph = defaultdict(dict)\\n        \\n        for a, b, t in edges:\\n            graph[a][b] = t\\n            graph[b][a] = t\\n        \\n        self.maxi = 0\\n        \\n        def dfs(time, node, value, mask):\\n            if time > maxTime:\\n                return\\n            if node == 0:\\n                self.maxi = max(self.maxi, value)\\n\\n            for neigh in graph[node]:\\n                if time + graph[node][neigh] <= maxTime:\\n                    dfs(\\n                        time + graph[node][neigh],\\n                        neigh,\\n                        value + (values[neigh] if not ((mask >> neigh) & 1) else 0),\\n                        (1 << neigh) | mask\\n                    )\\n        \\n        dfs(0, 0, values[0], 1)\\n        \\n        return self.maxi",
                "codeTag": "Python3"
            },
            {
                "id": 2180428,
                "title": "dijkstra-dfs-93ms-95-speed-java",
                "content": "- We can optimize this a bit by running Dijkstra to find the shortest distance from all the nodes back to 0 first. \\n\\n- Terminate the DFS branch whenever it wanders too far and can\\'t get back to 0 according to the shortest dist calculated above.\\n\\n- Set `values[i]` to 0 when we take its value and set it back right before we return.\\n\\n```Java\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for (int[] e : edges){\\n            map.computeIfAbsent(e[0], o -> new ArrayList<>()).add(new int[]{e[1], e[2]});\\n            map.computeIfAbsent(e[1], o -> new ArrayList<>()).add(new int[]{e[0], e[2]});\\n        }\\n        int[] dist = new int[values.length];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[0]=0;\\n        PriorityQueue<int[]> minheap = new PriorityQueue<>(Comparator.comparingInt(o -> o[0]));\\n        minheap.offer(new int[]{0, 0});\\n        while(!minheap.isEmpty()){\\n            int[] cur = minheap.poll();\\n            int d = cur[0];\\n            int u = cur[1];\\n            if (d!=dist[u]){\\n                continue;\\n            }\\n            for (int[] info : map.getOrDefault(u, List.of())){\\n                int w = info[1];\\n                int v = info[0];\\n                if (d + w < dist[v]){\\n                    dist[v] = d+w;\\n                    minheap.offer(new int[]{dist[v], v});\\n                }\\n            }\\n        }\\n\\n        return solve(0, maxTime, values, dist, map);\\n    }\\n\\n    private int solve(int i, int remainT, int[] values, int[] dist, Map<Integer, List<int[]>> map){\\n        if (remainT < dist[i]) // wander too far\\n            return 0;\\n        int tmp = values[i];\\n        int ans = 0;\\n        values[i] = 0;\\n        for (int[] next : map.getOrDefault(i, List.of())){\\n            ans = Math.max(ans, solve(next[0], remainT - next[1], values, dist, map));\\n        }\\n        values[i] = tmp;\\n        return ans+tmp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```Java\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for (int[] e : edges){\\n            map.computeIfAbsent(e[0], o -> new ArrayList<>()).add(new int[]{e[1], e[2]});\\n            map.computeIfAbsent(e[1], o -> new ArrayList<>()).add(new int[]{e[0], e[2]});\\n        }\\n        int[] dist = new int[values.length];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[0]=0;\\n        PriorityQueue<int[]> minheap = new PriorityQueue<>(Comparator.comparingInt(o -> o[0]));\\n        minheap.offer(new int[]{0, 0});\\n        while(!minheap.isEmpty()){\\n            int[] cur = minheap.poll();\\n            int d = cur[0];\\n            int u = cur[1];\\n            if (d!=dist[u]){\\n                continue;\\n            }\\n            for (int[] info : map.getOrDefault(u, List.of())){\\n                int w = info[1];\\n                int v = info[0];\\n                if (d + w < dist[v]){\\n                    dist[v] = d+w;\\n                    minheap.offer(new int[]{dist[v], v});\\n                }\\n            }\\n        }\\n\\n        return solve(0, maxTime, values, dist, map);\\n    }\\n\\n    private int solve(int i, int remainT, int[] values, int[] dist, Map<Integer, List<int[]>> map){\\n        if (remainT < dist[i]) // wander too far\\n            return 0;\\n        int tmp = values[i];\\n        int ans = 0;\\n        values[i] = 0;\\n        for (int[] next : map.getOrDefault(i, List.of())){\\n            ans = Math.max(ans, solve(next[0], remainT - next[1], values, dist, map));\\n        }\\n        values[i] = tmp;\\n        return ans+tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163351,
                "title": "simple-dfs-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(int src,int curval,int curT,int mxT,vector<pair<int,int>> adj[],vector<int> &values){\\n        if(curT>mxT) return;\\n        curval+=values[src];\\n        int temp=values[src];\\n        if(src==0){\\n            ans=max(ans,curval);\\n        }\\n        values[src]=0;\\n        for(auto &child : adj[src]){\\n            dfs(child.first,curval,curT+child.second,mxT,adj,values);\\n        }\\n        values[src]=temp;\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        ans=0;\\n        int n=values.size();\\n        vector<pair<int,int>> adj[n];\\n        for(auto &e:edges){\\n            adj[e[0]].push_back({e[1],e[2]});\\n            adj[e[1]].push_back({e[0],e[2]});\\n        }\\n        dfs(0,0,0,maxTime,adj,values);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    void dfs(int src,int curval,int curT,int mxT,vector<pair<int,int>> adj[],vector<int> &values){\\n        if(curT>mxT) return;\\n        curval+=values[src];\\n        int temp=values[src];\\n        if(src==0){\\n            ans=max(ans,curval);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2144958,
                "title": "python-bfs-with-thought-process-when-being-asked-during-interviews",
                "content": "### BFS + Shortest Path\\nMy first intuition is to run BFS for each possible path and update the maximum quality when the current `node` is `0`. In order not to run the repeat path, I store the tuple of each path in a hashtable.\\nBesides, we need to guarantee the total time is less than `maxTime`, so for each next node, we only enqueue all nodes that arriving time plus moving time is less than or equal to `maxTime`.\\nThis is a standard BFS approach, however it leads to `TLE`. \\nAlright let\\'s improve it. \\nNote there is a really important condition we need to consider, that is only the quality arriving at node `0` is taken into consideration. So we don\\'t need to visit any node that we know we never can return to node `0` after visiting it. \\nThen how we can know it? we can get the minimum time traveling from node `0` to all other nodes, which is also the minimum time we need to return from each node to `0` because of undirected graph.\\nHow to get the minimum arriving time for each node? dijkstra shorted path algorithm. \\nThen make a minor change to our standard BFS, which is considering the return time as well. If the arriving time at the next node plus the minimum (shortest) time is larger than `maxTime`, we don\\'t proceed futher because there is no way to get back.\\n\\n```python\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n\\tgraph = defaultdict(list)\\n\\tfor u, v, t in edges:\\n\\t\\tgraph[u].append((v, t))\\n\\t\\tgraph[v].append((u, t))\\n            \\n\\ttimes = [float(\\'inf\\')] * len(values)      \\n\\tdef dfs():\\n\\t\\theap = [(0, 0)]\\n\\t\\ttimes[0] = 0\\n\\t\\twhile heap:\\n\\t\\t\\ttime, node = heapq.heappop(heap)\\n\\t\\t\\tfor nei, t in graph[node]:\\n\\t\\t\\t\\tif time + t < times[nei]: \\n\\t\\t\\t\\t\\ttimes[nei] = time + t\\n\\t\\t\\t\\t\\theapq.heappush(heap, (times[nei], nei))\\n                \\n\\tdfs()    \\n\\tmax_quality = 0\\n\\tseen = {(0)}\\n\\tqueue = deque([(0, [0], 0)])\\n\\twhile queue:\\n\\t\\tnode, path, time = queue.popleft()\\n\\t\\tif node == 0:\\n\\t\\t\\tmax_quality = max(max_quality, sum(values[num] for num in set(path)))\\n\\t\\tfor nei, t in graph[node]: \\n\\t\\t\\tif t + time + times[nei] <= maxTime and tuple(path + [nei]) not in seen: \\n\\t\\t\\t\\tseen.add(tuple(path + [nei]))\\n\\t\\t\\t\\tqueue.append((nei, path + [nei], t + time))\\n\\treturn max_quality\\n```\\n\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```python\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n\\tgraph = defaultdict(list)\\n\\tfor u, v, t in edges:\\n\\t\\tgraph[u].append((v, t))\\n\\t\\tgraph[v].append((u, t))\\n            \\n\\ttimes = [float(\\'inf\\')] * len(values)      \\n\\tdef dfs():\\n\\t\\theap = [(0, 0)]\\n\\t\\ttimes[0] = 0\\n\\t\\twhile heap:\\n\\t\\t\\ttime, node = heapq.heappop(heap)\\n\\t\\t\\tfor nei, t in graph[node]:\\n\\t\\t\\t\\tif time + t < times[nei]: \\n\\t\\t\\t\\t\\ttimes[nei] = time + t\\n\\t\\t\\t\\t\\theapq.heappush(heap, (times[nei], nei))\\n                \\n\\tdfs()    \\n\\tmax_quality = 0\\n\\tseen = {(0)}\\n\\tqueue = deque([(0, [0], 0)])\\n\\twhile queue:\\n\\t\\tnode, path, time = queue.popleft()\\n\\t\\tif node == 0:\\n\\t\\t\\tmax_quality = max(max_quality, sum(values[num] for num in set(path)))\\n\\t\\tfor nei, t in graph[node]: \\n\\t\\t\\tif t + time + times[nei] <= maxTime and tuple(path + [nei]) not in seen: \\n\\t\\t\\t\\tseen.add(tuple(path + [nei]))\\n\\t\\t\\t\\tqueue.append((nei, path + [nei], t + time))\\n\\treturn max_quality\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2128619,
                "title": "fast-python-dfs",
                "content": "```\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        g = defaultdict(list)\\n        for x, y, c in edges:\\n            g[x].append((y,c))\\n            g[y].append((x,c))\\n        maxp = values[0]\\n        def dfs(n, cp, v):\\n            nonlocal maxp\\n            if cp > maxTime:\\n                return\\n            if n == 0 and len(v) > 1:\\n                maxp = max(maxp,sum([values[x] for x in v if v[x] > 0]))\\n            for ne , t in g[n]:\\n                v[ne] += 1\\n                dfs(ne,cp + t, v)\\n                v[ne] -= 1\\n        v = defaultdict(int)\\n        v[0] = 1\\n        dfs(0,0,v)\\n        return maxp\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        g = defaultdict(list)\\n        for x, y, c in edges:\\n            g[x].append((y,c))\\n            g[y].append((x,c))\\n        maxp = values[0]\\n        def dfs(n, cp, v):\\n            nonlocal maxp\\n            if cp > maxTime:\\n                return\\n            if n == 0 and len(v) > 1:\\n                maxp = max(maxp,sum([values[x] for x in v if v[x] > 0]))\\n            for ne , t in g[n]:\\n                v[ne] += 1\\n                dfs(ne,cp + t, v)\\n                v[ne] -= 1\\n        v = defaultdict(int)\\n        v[0] = 1\\n        dfs(0,0,v)\\n        return maxp\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2124477,
                "title": "python3-dfs",
                "content": "```\\n\"\"\"https://leetcode.com/problems/maximum-path-quality-of-a-graph/\"\"\"\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.max_path_quality = 0\\n\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], max_time: int) -> int:\\n        def dfs(node, visited, gain, cost):\\n            if node == 0:\\n                self.max_path_quality = max(self.max_path_quality, gain)\\n            for neighbor, w in graph[node]:\\n                if w <= cost:\\n                    # add neighbor to visited set\\n                    # add only the values of the unique nodes\\n                    dfs(neighbor, visited | {neighbor}, gain + (neighbor not in visited) * values[neighbor], cost - w)\\n\\n        graph = defaultdict(list)\\n        for u, v, w in edges:\\n            graph[u].append((v, w))\\n            graph[v].append((u, w))\\n\\n        dfs(0, {0}, values[0], max_time)\\n        return self.max_path_quality\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def __init__(self):\\n        self.max_path_quality = 0\\n\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], max_time: int) -> int:\\n        def dfs(node, visited, gain, cost):\\n            if node == 0:\\n                self.max_path_quality = max(self.max_path_quality, gain)\\n            for neighbor, w in graph[node]:\\n                if w <= cost:\\n                    # add neighbor to visited set\\n                    # add only the values of the unique nodes\\n                    dfs(neighbor, visited | {neighbor}",
                "codeTag": "Java"
            },
            {
                "id": 2098035,
                "title": "c-dfs-backtracking-simple-solution",
                "content": "```\\nclass Solution {\\n    int ans;\\n    void solve(vector<int>& values, unordered_map<int, vector<pair<int, int>>> &graph, int &maxTime, vector<int> &isVisited, int node, int time, int sum){\\n        if(time>maxTime)\\n            return;\\n        if(!isVisited[node])\\n            sum+=values[node];\\n        isVisited[node]++;\\n        if(node==0)\\n            ans=max(ans,sum);\\n        for(auto [child, timeChild]: graph[node])\\n            solve(values, graph, maxTime, isVisited, child, time+timeChild, sum);\\n        isVisited[node]--;\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        unordered_map<int, vector<pair<int, int>>> graph;//<node, time>\\n        for(auto e: edges){ \\n            graph[e[0]].push_back({e[1],e[2]});\\n            graph[e[1]].push_back({e[0],e[2]});\\n        }\\n        ans=0;\\n        vector<int> isVisited(values.size(),0);\\n        solve(values, graph, maxTime, isVisited, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    void solve(vector<int>& values, unordered_map<int, vector<pair<int, int>>> &graph, int &maxTime, vector<int> &isVisited, int node, int time, int sum){\\n        if(time>maxTime)\\n            return;\\n        if(!isVisited[node])\\n            sum+=values[node];\\n        isVisited[node]++;\\n        if(node==0)\\n            ans=max(ans,sum);\\n        for(auto [child, timeChild]: graph[node])\\n            solve(values, graph, maxTime, isVisited, child, time+timeChild, sum);\\n        isVisited[node]--;\\n    }\\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        unordered_map<int, vector<pair<int, int>>> graph;//<node, time>\\n        for(auto e: edges){ \\n            graph[e[0]].push_back({e[1],e[2]});\\n            graph[e[1]].push_back({e[0],e[2]});\\n        }\\n        ans=0;\\n        vector<int> isVisited(values.size(),0);\\n        solve(values, graph, maxTime, isVisited, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079759,
                "title": "c-dfs-backtracking",
                "content": "```\\nclass Solution {\\nprivate:\\n    int max_quality = 0;\\n    vector<vector<pair<int, int>>> graph;\\n    \\n    void dfs(int u, int currValue, int currTime, int maxTime, vector<int> &values) {\\n        if(currTime > maxTime)\\n            return;\\n        \\n        currValue += values[u];\\n        if(u == 0) \\n            max_quality = max(max_quality, currValue);\\n        \\n        int tmp = values[u];\\n        values[u] = 0;\\n        \\n        for(auto it: graph[u]) {\\n            int v = it.first;\\n            int time = it.second;\\n            dfs(v, currValue, currTime + time, maxTime, values);\\n        }\\n        \\n        // restore value of u\\n        values[u] = tmp;\\n    }\\n    \\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        graph.resize(n);\\n        \\n        // build graph\\n        for(auto it: edges) {\\n            int u = it[0];\\n            int v = it[1];\\n            int time = it[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        \\n        // backtracking by dfs\\n        dfs(0, 0, 0, maxTime, values);\\n        \\n        return max_quality;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int max_quality = 0;\\n    vector<vector<pair<int, int>>> graph;\\n    \\n    void dfs(int u, int currValue, int currTime, int maxTime, vector<int> &values) {\\n        if(currTime > maxTime)\\n            return;\\n        \\n        currValue += values[u];\\n        if(u == 0) \\n            max_quality = max(max_quality, currValue);\\n        \\n        int tmp = values[u];\\n        values[u] = 0;\\n        \\n        for(auto it: graph[u]) {\\n            int v = it.first;\\n            int time = it.second;\\n            dfs(v, currValue, currTime + time, maxTime, values);\\n        }\\n        \\n        // restore value of u\\n        values[u] = tmp;\\n    }\\n    \\npublic:\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) {\\n        int n = values.size();\\n        graph.resize(n);\\n        \\n        // build graph\\n        for(auto it: edges) {\\n            int u = it[0];\\n            int v = it[1];\\n            int time = it[2];\\n            graph[u].push_back({v, time});\\n            graph[v].push_back({u, time});\\n        }\\n        \\n        // backtracking by dfs\\n        dfs(0, 0, 0, maxTime, values);\\n        \\n        return max_quality;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033239,
                "title": "easy-to-understand-dfs-beats-60",
                "content": "```\\nclass Solution {\\n    public static int maxPath = 0;\\n    \\n    class Edge {\\n        int end; \\n        int weight; \\n        \\n        Edge(int end, int weight) {\\n            this.end = end; \\n            this.weight = weight;\\n        }\\n    }\\n    \\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        \\n        maxPath = 0;\\n        int[] seen = new int[values.length+1];\\n        \\n        //build the graph\\n        HashMap<Integer, ArrayList<Edge>> graph = new HashMap<Integer, ArrayList<Edge>>(); \\n        for(int pos = 0; pos < edges.length; pos++)  {\\n            int start = edges[pos][0]; \\n            int end = edges[pos][1]; \\n            int time = edges[pos][2];\\n            if(graph.get(start) == null) {\\n                graph.put(start, new ArrayList<Edge>()); \\n            }\\n            if(graph.get(end) == null) {\\n                graph.put(end, new ArrayList<Edge>());\\n            }\\n            graph.get(start).add(new Edge(end,time));\\n            graph.get(end).add(new Edge(start,time));\\n        }\\n        \\n        dfs(values,maxTime,0,0,0,graph,seen);\\n        \\n        \\n        return maxPath;\\n        \\n    }\\n    \\n    public void dfs(int[] values, int maxTime, \\n                    int curTime, int curSum, int curNode, HashMap<Integer, ArrayList<Edge>> graph, int[] seen) {\\n        if(curTime > maxTime) {\\n            return; \\n        }\\n        int newSum = curSum; \\n        if(seen[curNode] == 0) {\\n            newSum += values[curNode];\\n        }\\n        if(curNode == 0) {\\n            maxPath = Math.max(maxPath, newSum); //if we back at origin\\n        }\\n        \\n        seen[curNode]++;\\n        \\n        if(graph.get(curNode) != null) {\\n            for(Edge trav: graph.get(curNode)) {\\n                dfs(values,maxTime,curTime+trav.weight,newSum,trav.end,graph,seen);\\n            }\\n        }\\n        \\n        if(curNode != 0) {\\n            seen[curNode]--; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int maxPath = 0;\\n    \\n    class Edge {\\n        int end; \\n        int weight; \\n        \\n        Edge(int end, int weight) {\\n            this.end = end; \\n            this.weight = weight;\\n        }\\n    }\\n    \\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        \\n        maxPath = 0;\\n        int[] seen = new int[values.length+1];\\n        \\n        //build the graph\\n        HashMap<Integer, ArrayList<Edge>> graph = new HashMap<Integer, ArrayList<Edge>>(); \\n        for(int pos = 0; pos < edges.length; pos++)  {\\n            int start = edges[pos][0]; \\n            int end = edges[pos][1]; \\n            int time = edges[pos][2];\\n            if(graph.get(start) == null) {\\n                graph.put(start, new ArrayList<Edge>()); \\n            }\\n            if(graph.get(end) == null) {\\n                graph.put(end, new ArrayList<Edge>());\\n            }\\n            graph.get(start).add(new Edge(end,time));\\n            graph.get(end).add(new Edge(start,time));\\n        }\\n        \\n        dfs(values,maxTime,0,0,0,graph,seen);\\n        \\n        \\n        return maxPath;\\n        \\n    }\\n    \\n    public void dfs(int[] values, int maxTime, \\n                    int curTime, int curSum, int curNode, HashMap<Integer, ArrayList<Edge>> graph, int[] seen) {\\n        if(curTime > maxTime) {\\n            return; \\n        }\\n        int newSum = curSum; \\n        if(seen[curNode] == 0) {\\n            newSum += values[curNode];\\n        }\\n        if(curNode == 0) {\\n            maxPath = Math.max(maxPath, newSum); //if we back at origin\\n        }\\n        \\n        seen[curNode]++;\\n        \\n        if(graph.get(curNode) != null) {\\n            for(Edge trav: graph.get(curNode)) {\\n                dfs(values,maxTime,curTime+trav.weight,newSum,trav.end,graph,seen);\\n            }\\n        }\\n        \\n        if(curNode != 0) {\\n            seen[curNode]--; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974647,
                "title": "backtracking-if-maxtime",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getPath(self, node, graph, visited, time, values, maxTime):\\n        if node == 0:\\n            currQuality = sum([values[i] for i in visited])\\n            if currQuality >= self.maxQuality:\\n                self.maxQuality = currQuality\\n        for j, t in graph[node]:\\n            if time + t <= maxTime:\\n                self.getPath(j, graph, visited.union({j}), time + t, values, maxTime)\\n    \\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        self.maxQuality = float(\\'-inf\\')\\n        graph = defaultdict(list)\\n        for a, b, t in edges:\\n            graph[a].append((b, t))\\n            graph[b].append((a, t))\\n        self.getPath(0, graph, {0}, 0, values, maxTime)\\n        return self.maxQuality\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getPath(self, node, graph, visited, time, values, maxTime):\\n        if node == 0:\\n            currQuality = sum([values[i] for i in visited])\\n            if currQuality >= self.maxQuality:\\n                self.maxQuality = currQuality\\n        for j, t in graph[node]:\\n            if time + t <= maxTime:\\n                self.getPath(j, graph, visited.union({j}), time + t, values, maxTime)\\n    \\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        self.maxQuality = float(\\'-inf\\')\\n        graph = defaultdict(list)\\n        for a, b, t in edges:\\n            graph[a].append((b, t))\\n            graph[b].append((a, t))\\n        self.getPath(0, graph, {0}, 0, values, maxTime)\\n        return self.maxQuality\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948104,
                "title": "python-easy-to-understand-and-beats-95-runtime-and-64-memory",
                "content": "Let\\'s start with the general idea: \\n* we start from node 0 to any node if time permits and keep track of the scores of unique nodes. \\n* We stop if the remaining time is not enough for us to travel to a new node then return to node 0. \\n\\nThis can be illustrated as following expression:\\nIf the time spent to visit the next node (call it `travel_time`) and the time already spent (call it `prev_time`) is less than the shortest time for the next node to return to node 0 (call this `shortest_time`), then we cannot move. \\n```\\nif travel_time + prev_time <= shortest_time:\\n    # move_to_next_node\\n```\\n\\nSo this problem can be easily solved with a combination of two algorithms:\\n1. Shortest path\\n2. Back tracking\\n\\nFirst of all, we use `shortest path` algorithm to find the shortest time consumption for each node to get back to node 0.\\n\\nThen we use `back tracking` to go from node 0 and try each possible node.\\n\\nCode:\\n```python\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        size = len(values)\\n        graph = [[] for _ in range(size)] # build graph\\n        for u, v, time in edges:\\n            graph[u].append((v, time))\\n            graph[v].append((u, time))\\n\\t\\t\\t\\n\\t\\t# shortest path\\n        import heapq\\n        shortest_paths = [float(\\'inf\\')] * size\\n        heap = [(0, 0)]\\n        while heap: # Dijkstra\\'s algorithm\\n            time, node = heapq.heappop(heap)\\n            if shortest_paths[node] <= time: continue\\n            shortest_paths[node] = time\\n            for next_node, travel_time in graph[node]:\\n                if shortest_paths[next_node] > time + travel_time:\\n                    heapq.heappush(heap, (time + travel_time, next_node))\\n\\t\\t\\t\\t\\t\\n\\t\\t# back tracking\\n        def max_quality(node, time, visited):\\n            if time < shortest_paths[node]: \\n                return 0\\n            score = 0\\n            for next_node, travel_time in graph[node]: # try each node\\n                if travel_time + shortest_paths[next_node] > time: \\n\\t\\t\\t\\t\\t# if time is not enough to travel to the next node then return to node 0\\n\\t\\t\\t\\t\\tcontinue \\n                base_score = 0 if visited[next_node] else values[next_node] # no score if visited\\n                visited[next_node] += 1 # keep track of how many times we visited a node\\n                remaining = max_quality(next_node, time - travel_time, visited)\\n                visited[next_node] -= 1\\n                score = max(score, base_score + remaining)\\n            return score\\n        from collections import defaultdict\\n        return values[0] + max_quality(0, maxTime, defaultdict(int, {0: 1}))\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nif travel_time + prev_time <= shortest_time:\\n    # move_to_next_node\\n```\n```python\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        size = len(values)\\n        graph = [[] for _ in range(size)] # build graph\\n        for u, v, time in edges:\\n            graph[u].append((v, time))\\n            graph[v].append((u, time))\\n\\t\\t\\t\\n\\t\\t# shortest path\\n        import heapq\\n        shortest_paths = [float(\\'inf\\')] * size\\n        heap = [(0, 0)]\\n        while heap: # Dijkstra\\'s algorithm\\n            time, node = heapq.heappop(heap)\\n            if shortest_paths[node] <= time: continue\\n            shortest_paths[node] = time\\n            for next_node, travel_time in graph[node]:\\n                if shortest_paths[next_node] > time + travel_time:\\n                    heapq.heappush(heap, (time + travel_time, next_node))\\n\\t\\t\\t\\t\\t\\n\\t\\t# back tracking\\n        def max_quality(node, time, visited):\\n            if time < shortest_paths[node]: \\n                return 0\\n            score = 0\\n            for next_node, travel_time in graph[node]: # try each node\\n                if travel_time + shortest_paths[next_node] > time: \\n\\t\\t\\t\\t\\t# if time is not enough to travel to the next node then return to node 0\\n\\t\\t\\t\\t\\tcontinue \\n                base_score = 0 if visited[next_node] else values[next_node] # no score if visited\\n                visited[next_node] += 1 # keep track of how many times we visited a node\\n                remaining = max_quality(next_node, time - travel_time, visited)\\n                visited[next_node] -= 1\\n                score = max(score, base_score + remaining)\\n            return score\\n        from collections import defaultdict\\n        return values[0] + max_quality(0, maxTime, defaultdict(int, {0: 1}))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939503,
                "title": "dijkstra-with-pruning-distance-from-0-and-time-remaining-faster-than-100",
                "content": "```\\nimport heapq\\nimport copy\\n\\nclass PQ:\\n    def __init__(self):\\n        self.arr = []\\n        \\n    def push(self, key, val):\\n        heapq.heappush(self.arr, (key, val))\\n        \\n    def pop(self):\\n        return heapq.heappop(self.arr)\\n    \\n    def __len__(self):\\n        return len(self.arr)\\n    \\nclass Solution(object):\\n    def maximalPathQuality(self, values, edges, maxTime):\\n        \"\"\"\\n        :type values: List[int]\\n        :type edges: List[List[int]]\\n        :type maxTime: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(values)\\n        graph = {}\\n        for u, v, t in edges:\\n            if u not in graph:\\n                graph[u] = {}\\n            if v not in graph:\\n                graph[v] = {}\\n            graph[u][v] = t\\n            graph[v][u] = t\\n            \\n        def find_minimum_distances_from_0():\\n            q = PQ()\\n            \\n            distances = [None for i in range(n)]\\n            q.push(0, 0)\\n            \\n            while len(q) > 0:\\n                time, x = q.pop()\\n                \\n                if distances[x] is not None:\\n                    continue\\n\\n                distances[x] = time\\n                for v, t in graph.get(x, {}).items():\\n                    if distances[v] is not None:\\n                        continue\\n                    q.push(time + t, v)\\n            return distances\\n        \\n        distances_from_0 = find_minimum_distances_from_0()\\n        \\n        class State:\\n            def __init__(self):\\n                self.pos = 0\\n                self.score = 0\\n                self.visited = set()\\n                self.time_remaining = maxTime\\n                \\n            def get_key(self):\\n                return (self.pos, tuple(sorted(list(self.visited))))\\n        \\n        maximum_score = 0\\n        \\n        # oreder by (score, time_remaining)\\n        q = PQ()\\n        \\n        init = State()\\n        init.score = values[0]\\n        init.visited = {0}\\n        \\n        q.push((0, -maxTime), init)\\n        \\n        cache = {}\\n        \\n        while len(q) > 0:\\n            _, s = q.pop()\\n            \\n            if s.time_remaining < 0:\\n                continue\\n                \\n            if s.pos == 0:\\n                maximum_score = max(maximum_score, s.score)\\n                \\n            key = s.get_key()\\n            cache[key] = max(cache.get(key, -float(\\'inf\\')), s.time_remaining)\\n            \\n            for v, t in graph.get(s.pos, {}).items():\\n                next_s = State()\\n                \\n                next_s.pos = v\\n                next_s.score = s.score + (values[v] if v not in s.visited else 0)\\n                next_s.visited = s.visited | {v}\\n                next_s.time_remaining = s.time_remaining - t\\n                \\n                if next_s.time_remaining < distances_from_0[v]:\\n                    continue\\n                    \\n                key = next_s.get_key()\\n                if next_s.time_remaining < cache.get(key, -float(\\'inf\\')):\\n                    continue\\n                q.push((-next_s.score, -next_s.time_remaining), next_s)\\n        return maximum_score\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nimport copy\\n\\nclass PQ:\\n    def __init__(self):\\n        self.arr = []\\n        \\n    def push(self, key, val):\\n        heapq.heappush(self.arr, (key, val))\\n        \\n    def pop(self):\\n        return heapq.heappop(self.arr)\\n    \\n    def __len__(self):\\n        return len(self.arr)\\n    \\nclass Solution(object):\\n    def maximalPathQuality(self, values, edges, maxTime):\\n        \"\"\"\\n        :type values: List[int]\\n        :type edges: List[List[int]]\\n        :type maxTime: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(values)\\n        graph = {}\\n        for u, v, t in edges:\\n            if u not in graph:\\n                graph[u] = {}\\n            if v not in graph:\\n                graph[v] = {}\\n            graph[u][v] = t\\n            graph[v][u] = t\\n            \\n        def find_minimum_distances_from_0():\\n            q = PQ()\\n            \\n            distances = [None for i in range(n)]\\n            q.push(0, 0)\\n            \\n            while len(q) > 0:\\n                time, x = q.pop()\\n                \\n                if distances[x] is not None:\\n                    continue\\n\\n                distances[x] = time\\n                for v, t in graph.get(x, {}).items():\\n                    if distances[v] is not None:\\n                        continue\\n                    q.push(time + t, v)\\n            return distances\\n        \\n        distances_from_0 = find_minimum_distances_from_0()\\n        \\n        class State:\\n            def __init__(self):\\n                self.pos = 0\\n                self.score = 0\\n                self.visited = set()\\n                self.time_remaining = maxTime\\n                \\n            def get_key(self):\\n                return (self.pos, tuple(sorted(list(self.visited))))\\n        \\n        maximum_score = 0\\n        \\n        # oreder by (score, time_remaining)\\n        q = PQ()\\n        \\n        init = State()\\n        init.score = values[0]\\n        init.visited = {0}\\n        \\n        q.push((0, -maxTime), init)\\n        \\n        cache = {}\\n        \\n        while len(q) > 0:\\n            _, s = q.pop()\\n            \\n            if s.time_remaining < 0:\\n                continue\\n                \\n            if s.pos == 0:\\n                maximum_score = max(maximum_score, s.score)\\n                \\n            key = s.get_key()\\n            cache[key] = max(cache.get(key, -float(\\'inf\\')), s.time_remaining)\\n            \\n            for v, t in graph.get(s.pos, {}).items():\\n                next_s = State()\\n                \\n                next_s.pos = v\\n                next_s.score = s.score + (values[v] if v not in s.visited else 0)\\n                next_s.visited = s.visited | {v}\\n                next_s.time_remaining = s.time_remaining - t\\n                \\n                if next_s.time_remaining < distances_from_0[v]:\\n                    continue\\n                    \\n                key = next_s.get_key()\\n                if next_s.time_remaining < cache.get(key, -float(\\'inf\\')):\\n                    continue\\n                q.push((-next_s.score, -next_s.time_remaining), next_s)\\n        return maximum_score\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915078,
                "title": "this-question-does-not-feel-like-it-is-on-the-point",
                "content": "Yes this question can be solved by simple DFS, right. But it just feels like as a Hard problem, the solution should include something that can prune the search tree to make it faster. For example, my observation is\\n\\n> You should never visit an edge twice\\n\\nFor example on your DFS search path, if you have went from A to B, then when you get to another point where you need to go from A to B again, you should stop because it is guarantted if you do this you will not make result better. (But you do can go from B to A).\\n\\nA->B->C->B->A- (X) ->B. A -> B edge has been visited, so we should stop the current search at the 2nd A->B edge.\\n\\nHowever, most solutions do not include this yet they can still get to ~50%.\\n\\nActually, at least in C++ if I want to implement such \"edge memorization\", i will have to use hash map (`unordered_set` and some sort) and this will make the solution slower (~10%, C++\\'s undered_set/map can be accssed by constant time but it is still slower than vector).\\n\\nDo you feel this question deserve to be Hard? Do you feel its test cases should be designed such that it favors solutions with pruning and optimation more?\\n\\nJust throwing my point here, really want to hear what everyone thinks about this...\\n\\nCorrect me if you think i am wrong...",
                "solutionTags": [],
                "code": "Yes this question can be solved by simple DFS, right. But it just feels like as a Hard problem, the solution should include something that can prune the search tree to make it faster. For example, my observation is\\n\\n> You should never visit an edge twice\\n\\nFor example on your DFS search path, if you have went from A to B, then when you get to another point where you need to go from A to B again, you should stop because it is guarantted if you do this you will not make result better. (But you do can go from B to A).\\n\\nA->B->C->B->A- (X) ->B. A -> B edge has been visited, so we should stop the current search at the 2nd A->B edge.\\n\\nHowever, most solutions do not include this yet they can still get to ~50%.\\n\\nActually, at least in C++ if I want to implement such \"edge memorization\", i will have to use hash map (`unordered_set` and some sort) and this will make the solution slower (~10%, C++\\'s undered_set/map can be accssed by constant time but it is still slower than vector).\\n\\nDo you feel this question deserve to be Hard? Do you feel its test cases should be designed such that it favors solutions with pruning and optimation more?\\n\\nJust throwing my point here, really want to hear what everyone thinks about this...\\n\\nCorrect me if you think i am wrong...",
                "codeTag": "Unknown"
            },
            {
                "id": 1818481,
                "title": "python-dfs-djikstra-faster-than-88-89-1095ms",
                "content": "<img src=\"https://assets.leetcode.com/users/images/bb7aefdf-d5d7-41c9-aaaf-db4c06ea122c_1646382126.413069.png\" alt=\"drawing\" width=\"400\"/>\\n\\n\\nThis is 2-stage solution.\\n1. Calcuates **Djikstra shortest path** from node 0 to every nodes. -> So we can get shortest path for **R2B**(Return to Base; node 0).\\n2. **DFS** knowing the cost of R2B\\n\\n<img src=\"https://assets.leetcode.com/users/images/e89df381-eb69-424d-9669-d677658b3cf1_1646383374.2364216.png\" alt=\"drawing\" width=\"718\"/>\\n<hr>\\n\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = defaultdict(list)\\n        dist = defaultdict(int)\\n        parent = defaultdict(int)\\n        R2Bpath = defaultdict(list)\\n        for u, v, w in edges:\\n            graph[u].append( (v, w) )\\n            graph[v].append( (u, w) )\\n        \\n        ## calc Djik: Q[ (time, node, parent) ]\\n        Q = [ (0, 0, -1) ]\\n        while Q:\\n            time, node, par = heapq.heappop(Q)\\n            if node not in dist:\\n                dist[node] = time\\n                parent[node] = par\\n                for v, w in graph[node]:\\n                    alt = time + w\\n                    heapq.heappush(Q, (alt, v, node) )\\n        \\n        ## get ancesters of each nodes\\n        for node in range(len(values)):\\n            if node in dist:\\n                curr = node\\n                while curr != -1:\\n                    R2Bpath[node].append(curr)\\n                    curr = parent[curr]\\n        \\n        \\n        def get_score(ancesters: List[int]) -> int:\\n            score = 0\\n            for node in set(ancesters):\\n                score += values[node]\\n            return score\\n        \\n        self.maxScore = 0\\n        def dfs(curr=0, cost=0, path=[0]):\\n            self.maxScore = max( self.maxScore, get_score(path+R2Bpath[curr]) )\\n            for v, time in graph[curr]:\\n                if cost+time+dist[v] <= maxTime:\\n                    dfs(v, cost+time, path+[v])\\n                        \\n        dfs()\\n        return self.maxScore\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        graph = defaultdict(list)\\n        dist = defaultdict(int)\\n        parent = defaultdict(int)\\n        R2Bpath = defaultdict(list)\\n        for u, v, w in edges:\\n            graph[u].append( (v, w) )\\n            graph[v].append( (u, w) )\\n        \\n        ## calc Djik: Q[ (time, node, parent) ]\\n        Q = [ (0, 0, -1) ]\\n        while Q:\\n            time, node, par = heapq.heappop(Q)\\n            if node not in dist:\\n                dist[node] = time\\n                parent[node] = par\\n                for v, w in graph[node]:\\n                    alt = time + w\\n                    heapq.heappush(Q, (alt, v, node) )\\n        \\n        ## get ancesters of each nodes\\n        for node in range(len(values)):\\n            if node in dist:\\n                curr = node\\n                while curr != -1:\\n                    R2Bpath[node].append(curr)\\n                    curr = parent[curr]\\n        \\n        \\n        def get_score(ancesters: List[int]) -> int:\\n            score = 0\\n            for node in set(ancesters):\\n                score += values[node]\\n            return score\\n        \\n        self.maxScore = 0\\n        def dfs(curr=0, cost=0, path=[0]):\\n            self.maxScore = max( self.maxScore, get_score(path+R2Bpath[curr]) )\\n            for v, time in graph[curr]:\\n                if cost+time+dist[v] <= maxTime:\\n                    dfs(v, cost+time, path+[v])\\n                        \\n        dfs()\\n        return self.maxScore\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801247,
                "title": "java-regular-backtrack-with-explanation",
                "content": "This is a regular backtrack problem in a graph dfs background. Hopefully the code + explanation is straightforward.\\n\\nUsing the problem constraint `10 <= time[j], maxTime <= 100`, there will be at most 10 nodes visited before maxTime is used up, and time complexity under that is O(4^10). The 4 means each node has at most 4 edges to neighboring nodes per problem constraint. \\n\\nIf assuming a more generic scenario where maxTime is large enough to allow visiting all nodes, and graph is fully connected, then total number of edges m = n(n-1)/2, time to build graph is O(m)=O(n^2), which is smaller than the time to backtrack, so the overall TC will be O(4^n).\\n\\nJust let me know if you have any improvement suggestions or if you see any issues, I will address.\\n\\n```\\nclass Solution {\\n    // Method1 - Backtrack: TC=O(4^10), SC=O(m+n)\\n    // n = number of nodes, m = number of edges\\n    int res = 0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        // SC=O(n)\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        // build graph, TC=O(m), SC=O(m)\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(new int[]{edge[1], edge[2]});\\n            graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(new int[]{edge[0], edge[2]});\\n        }\\n        // backtrack with initial state\\n        backtrack(graph, values, visited, 0, values[0], maxTime);\\n        return res;\\n    }\\n    \\n    // TC=O(4^10)\\n    private void backtrack(Map<Integer, List<int[]>> graph, int[] values, boolean[] visited, int idx, int quality, int remainTime) {\\n        // base case: back to 0, update res\\n        if (idx == 0) {res = Math.max(res, quality);}\\n        \\n        // dfs neighbors\\n        // special case: isolated node\\n        if (!graph.containsKey(idx)) {return;}\\n        for (int[] nei : graph.get(idx)) {\\n            int nextIdx = nei[0];\\n            int nextTime = nei[1];\\n            // check time remaining and see whether can reach neighbor node\\n            if (remainTime - nextTime < 0) {continue;}\\n            \\n            // visited before, don\\'t add val\\n            if (visited[nextIdx]) {\\n                backtrack(graph, values, visited, nextIdx, quality, remainTime - nextTime);\\n            }\\n            // not visted before, add val\\n            else {\\n                visited[nextIdx] = true;\\n                backtrack(graph, values, visited, nextIdx, quality + values[nextIdx], remainTime - nextTime);\\n                // backtrack for next path\\n                visited[nextIdx] = false;\\n            }\\n        }        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    // Method1 - Backtrack: TC=O(4^10), SC=O(m+n)\\n    // n = number of nodes, m = number of edges\\n    int res = 0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        // SC=O(n)\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        // build graph, TC=O(m), SC=O(m)\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(new int[]{edge[1], edge[2]});\\n            graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(new int[]{edge[0], edge[2]});\\n        }\\n        // backtrack with initial state\\n        backtrack(graph, values, visited, 0, values[0], maxTime);\\n        return res;\\n    }\\n    \\n    // TC=O(4^10)\\n    private void backtrack(Map<Integer, List<int[]>> graph, int[] values, boolean[] visited, int idx, int quality, int remainTime) {\\n        // base case: back to 0, update res\\n        if (idx == 0) {res = Math.max(res, quality);}\\n        \\n        // dfs neighbors\\n        // special case: isolated node\\n        if (!graph.containsKey(idx)) {return;}\\n        for (int[] nei : graph.get(idx)) {\\n            int nextIdx = nei[0];\\n            int nextTime = nei[1];\\n            // check time remaining and see whether can reach neighbor node\\n            if (remainTime - nextTime < 0) {continue;}\\n            \\n            // visited before, don\\'t add val\\n            if (visited[nextIdx]) {\\n                backtrack(graph, values, visited, nextIdx, quality, remainTime - nextTime);\\n            }\\n            // not visted before, add val\\n            else {\\n                visited[nextIdx] = true;\\n                backtrack(graph, values, visited, nextIdx, quality + values[nextIdx], remainTime - nextTime);\\n                // backtrack for next path\\n                visited[nextIdx] = false;\\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766153,
                "title": "python-faster-than-79-25-2021ms-typical-backtracking",
                "content": "Used one visited set and keep updating it, instead of creating a new set every time going to the next recursion.\\n\\n```\\nclass Solution(object):\\n    def maximalPathQuality(self, values, edges, maxTime):\\n        next_map = defaultdict(dict)\\n        for edge in edges:\\n            next_map[edge[0]][edge[1]] = next_map[edge[1]][edge[0]] = edge[2]\\n        self.max_qlt = 0\\n        self.backtracking(0, maxTime, values[0], set([0]), next_map, values)\\n        return self.max_qlt\\n        \\n    def backtracking(self, cur_node, time_left, cur_qlt, cur_path, next_map, values):\\n        if cur_node == 0 and cur_qlt > self.max_qlt:\\n            self.max_qlt = cur_qlt\\n        \\n        for next_node, cost in next_map[cur_node].items():\\n            if cost > time_left:\\n                continue\\n            visited_next_node = False\\n            if next_node in cur_path:\\n                visited_next_node = True\\n                \\n            if visited_next_node:\\n                next_qlt = cur_qlt\\n            else:\\n                next_qlt = cur_qlt + values[next_node]\\n                cur_path.add(next_node)\\n            self.backtracking(next_node, time_left - cost, next_qlt, cur_path, next_map, values)\\n            if not visited_next_node:\\n                cur_path.remove(next_node)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximalPathQuality(self, values, edges, maxTime):\\n        next_map = defaultdict(dict)\\n        for edge in edges:\\n            next_map[edge[0]][edge[1]] = next_map[edge[1]][edge[0]] = edge[2]\\n        self.max_qlt = 0\\n        self.backtracking(0, maxTime, values[0], set([0]), next_map, values)\\n        return self.max_qlt\\n        \\n    def backtracking(self, cur_node, time_left, cur_qlt, cur_path, next_map, values):\\n        if cur_node == 0 and cur_qlt > self.max_qlt:\\n            self.max_qlt = cur_qlt\\n        \\n        for next_node, cost in next_map[cur_node].items():\\n            if cost > time_left:\\n                continue\\n            visited_next_node = False\\n            if next_node in cur_path:\\n                visited_next_node = True\\n                \\n            if visited_next_node:\\n                next_qlt = cur_qlt\\n            else:\\n                next_qlt = cur_qlt + values[next_node]\\n                cur_path.add(next_node)\\n            self.backtracking(next_node, time_left - cost, next_qlt, cur_path, next_map, values)\\n            if not visited_next_node:\\n                cur_path.remove(next_node)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755676,
                "title": "java-dfs",
                "content": "Thank you @Byte_Walker for posting your solution and explaining it!\\n\\nhttps://leetcode.com/problems/maximum-path-quality-of-a-graph/discuss/1563770/Simple-DFS-solution-(C%2B%2B)\\n\\n```\\nclass Solution {\\n  \\n  Map<Integer, List<int[]>> graph;\\n  \\n  public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n    graph = getGraph(edges);\\n    \\n    //we can visit a node multiple times, thus the int[] and not boolean[] type\\n    int[] visited = new int[values.length];\\n    int[] max = new int[1];\\n    \\n    dfs(0, 0, 0, max, maxTime, values, visited);\\n    \\n    return max[0];\\n  }\\n  \\n  private void dfs(int node, int value, int time, int[] max, int maxTime, int[] values, int[] visited) {\\n    if (time > maxTime) {\\n      return;\\n    }\\n    \\n    //we add the value only when we visit the node the first time\\n    if (visited[node] == 0) {\\n      value += values[node];\\n    }\\n    \\n    //the valid path ends with 0\\n    if (node == 0) {\\n      max[0] = Math.max(max[0], value);\\n    }\\n    \\n    if (graph.get(node) == null) {\\n      return;\\n    }\\n    \\n    visited[node]++;\\n    \\n    for (int[] next : graph.get(node)) {\\n      int nextTime = time + next[1];\\n      dfs(next[0], value, nextTime, max, maxTime, values, visited);\\n    }\\n    \\n    visited[node]--;\\n  }\\n  \\n  private Map<Integer, List<int[]>> getGraph(int[][] edges) {\\n    Map<Integer, List<int[]>> result = new HashMap<>();\\n    \\n    for (int[] edge : edges) {\\n      int from = edge[0];\\n      int to = edge[1];\\n      int time = edge[2];\\n      result.putIfAbsent(from, new ArrayList<>());\\n      result.putIfAbsent(to, new ArrayList<>());\\n      result.get(from).add(new int[] {to, time});\\n      result.get(to).add(new int[] {from, time});\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  \\n  Map<Integer, List<int[]>> graph;\\n  \\n  public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n    graph = getGraph(edges);\\n    \\n    //we can visit a node multiple times, thus the int[] and not boolean[] type\\n    int[] visited = new int[values.length];\\n    int[] max = new int[1];\\n    \\n    dfs(0, 0, 0, max, maxTime, values, visited);\\n    \\n    return max[0];\\n  }\\n  \\n  private void dfs(int node, int value, int time, int[] max, int maxTime, int[] values, int[] visited) {\\n    if (time > maxTime) {\\n      return;\\n    }\\n    \\n    //we add the value only when we visit the node the first time\\n    if (visited[node] == 0) {\\n      value += values[node];\\n    }\\n    \\n    //the valid path ends with 0\\n    if (node == 0) {\\n      max[0] = Math.max(max[0], value);\\n    }\\n    \\n    if (graph.get(node) == null) {\\n      return;\\n    }\\n    \\n    visited[node]++;\\n    \\n    for (int[] next : graph.get(node)) {\\n      int nextTime = time + next[1];\\n      dfs(next[0], value, nextTime, max, maxTime, values, visited);\\n    }\\n    \\n    visited[node]--;\\n  }\\n  \\n  private Map<Integer, List<int[]>> getGraph(int[][] edges) {\\n    Map<Integer, List<int[]>> result = new HashMap<>();\\n    \\n    for (int[] edge : edges) {\\n      int from = edge[0];\\n      int to = edge[1];\\n      int time = edge[2];\\n      result.putIfAbsent(from, new ArrayList<>());\\n      result.putIfAbsent(to, new ArrayList<>());\\n      result.get(from).add(new int[] {to, time});\\n      result.get(to).add(new int[] {from, time});\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704402,
                "title": "backtracking-java",
                "content": "Simple Code \\n```\\nclass Solution {\\n    class Node{\\n        int n;\\n        int t;\\n        Node(int n,int t){\\n            this.n = n;\\n            this.t = t;\\n        }\\n    }\\n    int ans = 0;\\n    int[] values;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        this.values = values;\\n        List<List<Node>> graph = new ArrayList<>();\\n        for(int i=0;i<values.length;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            graph.get(edges[i][0]).add(new Node(edges[i][1],edges[i][2]));\\n            graph.get(edges[i][1]).add(new Node(edges[i][0],edges[i][2]));\\n        }\\n        boolean[] visit = new boolean[values.length];\\n        visit[0] = true;\\n        solve(graph,maxTime,0,visit,values[0]);\\n        return ans;\\n    }\\n    private void solve(List<List<Node>> graph,int maxTime,int node,boolean[] visit,int val){\\n        if(node==0){\\n            ans = Math.max(ans,val);\\n        }\\n        for(Node i:graph.get(node)){\\n            if(maxTime-i.t<0){\\n                continue;\\n            }\\n            if(!visit[i.n]){\\n                visit[i.n] = true;\\n                solve(graph,maxTime-i.t,i.n,visit,val+values[i.n]);\\n                visit[i.n] = false;\\n            }else{\\n                solve(graph,maxTime-i.t,i.n,visit,val);\\n            }\\n        }\\n    }\\n}\\n```\\nPlease UpVote",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        int n;\\n        int t;\\n        Node(int n,int t){\\n            this.n = n;\\n            this.t = t;\\n        }\\n    }\\n    int ans = 0;\\n    int[] values;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        this.values = values;\\n        List<List<Node>> graph = new ArrayList<>();\\n        for(int i=0;i<values.length;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            graph.get(edges[i][0]).add(new Node(edges[i][1],edges[i][2]));\\n            graph.get(edges[i][1]).add(new Node(edges[i][0],edges[i][2]));\\n        }\\n        boolean[] visit = new boolean[values.length];\\n        visit[0] = true;\\n        solve(graph,maxTime,0,visit,values[0]);\\n        return ans;\\n    }\\n    private void solve(List<List<Node>> graph,int maxTime,int node,boolean[] visit,int val){\\n        if(node==0){\\n            ans = Math.max(ans,val);\\n        }\\n        for(Node i:graph.get(node)){\\n            if(maxTime-i.t<0){\\n                continue;\\n            }\\n            if(!visit[i.n]){\\n                visit[i.n] = true;\\n                solve(graph,maxTime-i.t,i.n,visit,val+values[i.n]);\\n                visit[i.n] = false;\\n            }else{\\n                solve(graph,maxTime-i.t,i.n,visit,val);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700827,
                "title": "dp-backtracing-dijkstra",
                "content": "The limits of t[j]>=10 and maxTime<=100 ensures that the brute force DP solution will work just fine.\\nSo we simply code the problem as a DP+Backtracking. We make use of Dijkstra algorithm for pruning the recursion tree. and we use a binary string to keep track of the nodes which have been reached and only take the value of the node into our summation if that node is being reached the 1st time.\\n\\n\\n```\\n#define ll long long int\\nclass Solution {\\n    vector<int> dis,a;\\n    vector<vector<unordered_map<string,ll>>> dp;\\n    vector<vector<vector<int>>> g;\\npublic:\\n    void dijkstra(int u){\\n        set<vector<int>> st;\\n        st.insert({0,u});\\n        \\n        while(st.size()){\\n            auto it=st.begin();\\n            vector<int> v=*it;\\n            st.erase(it);\\n            u=v[1];\\n            int d=v[0];\\n            \\n            for(auto node:g[u]){\\n                if(dis[node[0]]>(d+node[1])){\\n                    auto it=st.find({dis[node[0]],node[0]});\\n                    if(it!=st.end())\\n                        st.erase(it);\\n                    dis[node[0]]=d+node[1];\\n                    st.insert({dis[node[0]],node[0]});\\n                }\\n            }\\n        }\\n    }\\n    \\n    ll solver(int t,int s,string state){\\n        if(dis[s]>t)\\n            return INT_MIN;\\n        \\n        if(dp[t][s].find(state)!=dp[t][s].end())\\n            return dp[t][s][state];\\n        \\n        ll curr=0;\\n        for(auto v:g[s]){\\n            if(state[v[0]]==\\'0\\'){\\n                state[v[0]]=\\'1\\';\\n                if(t>=v[1])\\n                    curr=max(curr,a[v[0]]+solver(t-v[1],v[0],state));\\n                state[v[0]]=\\'0\\';\\n            }\\n            else\\n                curr=max(curr,solver(t-v[1],v[0],state));\\n        }\\n        return dp[t][s][state]=curr;\\n    }\\n    \\n    int maximalPathQuality(vector<int>& val,vector<vector<int>>& edges, int maxTime) {\\n        int i,n=val.size();\\n        g.resize(n+2);\\n        a=val;\\n        dis.resize(n+2,INT_MAX);\\n        \\n        for(auto v:edges){\\n            g[v[0]].push_back({v[1],v[2]});\\n            g[v[1]].push_back({v[0],v[2]});\\n        }\\n        \\n        dis[0]=0;\\n        dijkstra(0);\\n        \\n    \\n        dp.resize(maxTime+2,vector<unordered_map<string,ll>>(n+2));\\n        \\n        string state;\\n        while(state.length()<n)\\n            state.push_back(\\'0\\');\\n        \\n        state[0]=\\'1\\';\\n        return a[0]+solver(maxTime,0,state);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    vector<int> dis,a;\\n    vector<vector<unordered_map<string,ll>>> dp;\\n    vector<vector<vector<int>>> g;\\npublic:\\n    void dijkstra(int u){\\n        set<vector<int>> st;\\n        st.insert({0,u});\\n        \\n        while(st.size()){\\n            auto it=st.begin();\\n            vector<int> v=*it;\\n            st.erase(it);\\n            u=v[1];\\n            int d=v[0];\\n            \\n            for(auto node:g[u]){\\n                if(dis[node[0]]>(d+node[1])){\\n                    auto it=st.find({dis[node[0]],node[0]});\\n                    if(it!=st.end())\\n                        st.erase(it);\\n                    dis[node[0]]=d+node[1];\\n                    st.insert({dis[node[0]],node[0]});\\n                }\\n            }\\n        }\\n    }\\n    \\n    ll solver(int t,int s,string state){\\n        if(dis[s]>t)\\n            return INT_MIN;\\n        \\n        if(dp[t][s].find(state)!=dp[t][s].end())\\n            return dp[t][s][state];\\n        \\n        ll curr=0;\\n        for(auto v:g[s]){\\n            if(state[v[0]]==\\'0\\'){\\n                state[v[0]]=\\'1\\';\\n                if(t>=v[1])\\n                    curr=max(curr,a[v[0]]+solver(t-v[1],v[0],state));\\n                state[v[0]]=\\'0\\';\\n            }\\n            else\\n                curr=max(curr,solver(t-v[1],v[0],state));\\n        }\\n        return dp[t][s][state]=curr;\\n    }\\n    \\n    int maximalPathQuality(vector<int>& val,vector<vector<int>>& edges, int maxTime) {\\n        int i,n=val.size();\\n        g.resize(n+2);\\n        a=val;\\n        dis.resize(n+2,INT_MAX);\\n        \\n        for(auto v:edges){\\n            g[v[0]].push_back({v[1],v[2]});\\n            g[v[1]].push_back({v[0],v[2]});\\n        }\\n        \\n        dis[0]=0;\\n        dijkstra(0);\\n        \\n    \\n        dp.resize(maxTime+2,vector<unordered_map<string,ll>>(n+2));\\n        \\n        string state;\\n        while(state.length()<n)\\n            state.push_back(\\'0\\');\\n        \\n        state[0]=\\'1\\';\\n        return a[0]+solver(maxTime,0,state);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692961,
                "title": "easy-bt-solution-30-less-recursive-calls-vs-regular-brute-force",
                "content": "```    \\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], _edges: List[List[int]], maxTime: int) -> int:\\n        \\n        g = defaultdict(dict) # node: neighbors: time\\n        \\n        for i, j, time in _edges:\\n            g[i][j] = time\\n            g[j][i] = time\\n        \\n        max_quality = -math.inf\\n        seen = [0]\\n        def helper(visited_edge, node, so_far_quality, so_far_time_taken):\\n            \\n            nonlocal max_quality, seen\\n            if node == 0:\\n                max_quality = max(max_quality, so_far_quality)\\n            \\n            for neighbor in g[node].keys():\\n                if (\\n                    g[node][neighbor]+so_far_time_taken <= maxTime and \\n                    visited_edge[(node, neighbor)] < 2\\n                ):\\n                    added = False\\n                    visited_edge[(node,neighbor)]+=1\\n                    visited_edge[(neighbor,node)]+=1\\n                    if neighbor not in seen: \\n\\t\\t\\t\\t\\t\\tadded = True\\n\\t\\t\\t\\t\\t\\tso_far_quality+=values[neighbor]\\n\\t\\t\\t\\t\\t\\tseen.append(neighbor)\\n                    so_far_time_taken+=g[node][neighbor]\\n                    helper(visited_edge, neighbor, so_far_quality, so_far_time_taken)\\n                    visited_edge[(node,neighbor)]-=1\\n                    visited_edge[(neighbor,node)]-=1\\n                    if added: \\n\\t\\t\\t\\t\\t\\tseen.pop()\\n\\t\\t\\t\\t\\t\\tso_far_quality-=values[neighbor]\\n                    so_far_time_taken-=g[node][neighbor]\\n            \\n        helper(defaultdict(int), 0, values[0], 0)\\n        return max_quality   \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```    \\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], _edges: List[List[int]], maxTime: int) -> int:\\n        \\n        g = defaultdict(dict) # node: neighbors: time\\n        \\n        for i, j, time in _edges:\\n            g[i][j] = time\\n            g[j][i] = time\\n        \\n        max_quality = -math.inf\\n        seen = [0]\\n        def helper(visited_edge, node, so_far_quality, so_far_time_taken):\\n            \\n            nonlocal max_quality, seen\\n            if node == 0:\\n                max_quality = max(max_quality, so_far_quality)\\n            \\n            for neighbor in g[node].keys():\\n                if (\\n                    g[node][neighbor]+so_far_time_taken <= maxTime and \\n                    visited_edge[(node, neighbor)] < 2\\n                ):\\n                    added = False\\n                    visited_edge[(node,neighbor)]+=1\\n                    visited_edge[(neighbor,node)]+=1\\n                    if neighbor not in seen: \\n\\t\\t\\t\\t\\t\\tadded = True\\n\\t\\t\\t\\t\\t\\tso_far_quality+=values[neighbor]\\n\\t\\t\\t\\t\\t\\tseen.append(neighbor)\\n                    so_far_time_taken+=g[node][neighbor]\\n                    helper(visited_edge, neighbor, so_far_quality, so_far_time_taken)\\n                    visited_edge[(node,neighbor)]-=1\\n                    visited_edge[(neighbor,node)]-=1\\n                    if added: \\n\\t\\t\\t\\t\\t\\tseen.pop()\\n\\t\\t\\t\\t\\t\\tso_far_quality-=values[neighbor]\\n                    so_far_time_taken-=g[node][neighbor]\\n            \\n        helper(defaultdict(int), 0, values[0], 0)\\n        return max_quality   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673452,
                "title": "java-dfs-backtracking",
                "content": "```\\n    int ans = 0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        List<Integer>[] graph = new ArrayList[n];\\n        int[][] dist = new int[n][n];\\n\\n        for(int i=0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n        \\n        for(int[] edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].add(v);\\n            graph[v].add(u);\\n            dist[u][v] = edge[2];\\n            dist[v][u] = edge[2];\\n        }\\n        ans = values[0];        \\n        dfs(0, graph, dist, new int[n], maxTime, 0, values[0], values);\\n        return ans;\\n    }\\n    \\n    \\n    public void dfs(int current, List<Integer>[] graph, int[][] dist, int[] visited, int maxTime, int currTime, int quality, int[] values) {\\n        if(currTime > maxTime)\\n            return;\\n                        \\n        if(current == 0)\\n            ans = Math.max(ans, quality);\\n        \\n        visited[current]++;\\n        for(int node: graph[current]) {\\n            dfs(node, graph, dist, visited, maxTime, currTime + dist[node][current], visited[node] == 0 ? quality + values[node]: quality, values);\\n        }\\n        visited[current]--;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int ans = 0;\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        int n = values.length;\\n        List<Integer>[] graph = new ArrayList[n];\\n        int[][] dist = new int[n][n];\\n\\n        for(int i=0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n        \\n        for(int[] edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            graph[u].add(v);\\n            graph[v].add(u);\\n            dist[u][v] = edge[2];\\n            dist[v][u] = edge[2];\\n        }\\n        ans = values[0];        \\n        dfs(0, graph, dist, new int[n], maxTime, 0, values[0], values);\\n        return ans;\\n    }\\n    \\n    \\n    public void dfs(int current, List<Integer>[] graph, int[][] dist, int[] visited, int maxTime, int currTime, int quality, int[] values) {\\n        if(currTime > maxTime)\\n            return;\\n                        \\n        if(current == 0)\\n            ans = Math.max(ans, quality);\\n        \\n        visited[current]++;\\n        for(int node: graph[current]) {\\n            dfs(node, graph, dist, visited, maxTime, currTime + dist[node][current], visited[node] == 0 ? quality + values[node]: quality, values);\\n        }\\n        visited[current]--;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1664929,
                "title": "java-dfs-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        HashMap<Integer, List<int[]>> adjList = new HashMap<>();\\n        \\n        for (int[] edge : edges) {\\n            adjList.computeIfAbsent(edge[0], (k) -> new LinkedList<>()).add(new int[]{edge[1], edge[2]});\\n            adjList.computeIfAbsent(edge[1], (k) -> new LinkedList<>()).add(new int[]{edge[0], edge[2]});\\n        }\\n        \\n        return Math.max(values[0], dfs(values, adjList, maxTime, 0, new int[values.length]));\\n    }\\n    \\n    public int dfs(int[] values, HashMap<Integer, List<int[]>> adjList, int maxTime, int curr, int[] visited) {\\n        if (maxTime < 0) return -1;\\n        int ans = -1;\\n        \\n        visited[curr]++;\\n        if (adjList.containsKey(curr)) {\\n            for (int[] edge : adjList.get(curr)) {\\n            \\n                int pathQuality = dfs(values, adjList, maxTime - edge[1], edge[0], visited);\\n\\n                if (pathQuality != -1) {\\n                    int valueAddedHere = visited[curr] > 1 ? 0 : values[curr];\\n                    ans = Math.max(ans, valueAddedHere + pathQuality);\\n                }\\n            }\\n        }\\n        \\n        visited[curr]--;\\n        \\n        if (curr == 0 && visited[curr] > 0) {\\n            return Math.max(0, ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n        HashMap<Integer, List<int[]>> adjList = new HashMap<>();\\n        \\n        for (int[] edge : edges) {\\n            adjList.computeIfAbsent(edge[0], (k) -> new LinkedList<>()).add(new int[]{edge[1], edge[2]});\\n            adjList.computeIfAbsent(edge[1], (k) -> new LinkedList<>()).add(new int[]{edge[0], edge[2]});\\n        }\\n        \\n        return Math.max(values[0], dfs(values, adjList, maxTime, 0, new int[values.length]));\\n    }\\n    \\n    public int dfs(int[] values, HashMap<Integer, List<int[]>> adjList, int maxTime, int curr, int[] visited) {\\n        if (maxTime < 0) return -1;\\n        int ans = -1;\\n        \\n        visited[curr]++;\\n        if (adjList.containsKey(curr)) {\\n            for (int[] edge : adjList.get(curr)) {\\n            \\n                int pathQuality = dfs(values, adjList, maxTime - edge[1], edge[0], visited);\\n\\n                if (pathQuality != -1) {\\n                    int valueAddedHere = visited[curr] > 1 ? 0 : values[curr];\\n                    ans = Math.max(ans, valueAddedHere + pathQuality);\\n                }\\n            }\\n        }\\n        \\n        visited[curr]--;\\n        \\n        if (curr == 0 && visited[curr] > 0) {\\n            return Math.max(0, ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660401,
                "title": "kind-of-brute-force-dfs-golang-solution",
                "content": "I have split some of the code into seperate functions.\\n\\n```\\ntype key struct {\\n    n int // node value\\n    t int // time\\n}\\n\\ntype key2 struct {\\n    c int // total cost\\n    n int // node value\\n    t int // time\\n    v map[int] bool // whether we have already visited a node.\\n}\\n\\nfunc edgesIntoMap(edges [][]int) map[int] []key {\\n    /*\\n    Make edges into a map\\n    */\\n    \\n    m := make(map[int] []key)\\n    \\n    for _, edge := range edges { // putting all edges into a map\\n        m[edge[0]] = append(m[edge[0]], key{ edge[1], edge[2] })\\n        m[edge[1]] = append(m[edge[1]], key{ edge[0], edge[2] })\\n    }\\n    \\n    return m\\n}\\n\\nfunc remakeMap(oldMap map[int] bool) map[int] bool {\\n    /*\\n    We can make a new map which is the same as the old map,\\n    so when we mutate this new map it doesn\\'t change the old one\\n    */\\n    \\n    newMap := make(map[int] bool)\\n    \\n    for k,v := range oldMap { \\n        newMap[k] = v \\n    }\\n    \\n    return newMap\\n}\\n\\nfunc maximalPathQuality(values []int, edges [][]int, maxTime int) int {\\n    max := values[0]\\n    m := edgesIntoMap(edges)\\n    \\n    stack := []key2{ key2{ values[0], 0, 0, map[int] bool{} } }\\n    \\n    for len(stack) != 0 {\\n        pop := stack[len(stack) - 1]\\n        stack = stack[:len(stack) - 1]\\n        \\n        if pop.n == 0 && pop.c > max { \\n            // We have come back to the zero node, so we can remake max\\n            max = pop.c\\n        }\\n        \\n        for _, connection := range m[pop.n] {\\n            if pop.t + connection.t <= maxTime {\\n                // We only add the value to our result if we have not already been to the node.\\n                \\n                cost := pop.c\\n                if !pop.v[connection.n] { \\n                    cost += values[connection.n] \\n                }\\n                \\n                newMap := remakeMap(pop.v)\\n                newMap[pop.n] = true\\n                \\n                // Pushing to the stack\\n                \\n                stack = append(stack, key2{ \\n                    cost,\\n                    connection.n, \\n                    pop.t + connection.t,\\n                    newMap,\\n                })\\n                \\n            }\\n        }\\n    }\\n    \\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype key struct {\\n    n int // node value\\n    t int // time\\n}\\n\\ntype key2 struct {\\n    c int // total cost\\n    n int // node value\\n    t int // time\\n    v map[int] bool // whether we have already visited a node.\\n}\\n\\nfunc edgesIntoMap(edges [][]int) map[int] []key {\\n    /*\\n    Make edges into a map\\n    */\\n    \\n    m := make(map[int] []key)\\n    \\n    for _, edge := range edges { // putting all edges into a map\\n        m[edge[0]] = append(m[edge[0]], key{ edge[1], edge[2] })\\n        m[edge[1]] = append(m[edge[1]], key{ edge[0], edge[2] })\\n    }\\n    \\n    return m\\n}\\n\\nfunc remakeMap(oldMap map[int] bool) map[int] bool {\\n    /*\\n    We can make a new map which is the same as the old map,\\n    so when we mutate this new map it doesn\\'t change the old one\\n    */\\n    \\n    newMap := make(map[int] bool)\\n    \\n    for k,v := range oldMap { \\n        newMap[k] = v \\n    }\\n    \\n    return newMap\\n}\\n\\nfunc maximalPathQuality(values []int, edges [][]int, maxTime int) int {\\n    max := values[0]\\n    m := edgesIntoMap(edges)\\n    \\n    stack := []key2{ key2{ values[0], 0, 0, map[int] bool{} } }\\n    \\n    for len(stack) != 0 {\\n        pop := stack[len(stack) - 1]\\n        stack = stack[:len(stack) - 1]\\n        \\n        if pop.n == 0 && pop.c > max { \\n            // We have come back to the zero node, so we can remake max\\n            max = pop.c\\n        }\\n        \\n        for _, connection := range m[pop.n] {\\n            if pop.t + connection.t <= maxTime {\\n                // We only add the value to our result if we have not already been to the node.\\n                \\n                cost := pop.c\\n                if !pop.v[connection.n] { \\n                    cost += values[connection.n] \\n                }\\n                \\n                newMap := remakeMap(pop.v)\\n                newMap[pop.n] = true\\n                \\n                // Pushing to the stack\\n                \\n                stack = append(stack, key2{ \\n                    cost,\\n                    connection.n, \\n                    pop.t + connection.t,\\n                    newMap,\\n                })\\n                \\n            }\\n        }\\n    }\\n    \\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1651755,
                "title": "python-dfs",
                "content": "Simple DFS soltuion, not fast enough though. \\n\\n```\\nclass Solution:\\n    def maximalPathQuality(self, vals: List[int], edges: List[List[int]], maxTime: int) -> int:\\n     \\n        if len(vals)==0: return 0\\n        if len(edges)==0: return vals[0]\\n\\t\\t\\n\\t\\t# time complexity: O(|E|)\\n        graph={}\\n        for u,v,t in edges:\\n            graph[u]=graph.get(u, set())\\n            graph[u].add((v,t))\\n            \\n            graph[v]=graph.get(v, set())\\n            graph[v].add((u,t))\\n\\n        stack=[[0,0,[]]]\\n        maxVal=vals[0]\\n\\t\\t\\n\\t\\t# time complexity: O(|V|)\\n        while stack:\\n            node,time,path=stack.pop()\\n            if time>maxTime: continue\\n            if node==0: \\n                curval=sum([vals[p] for p in set(path)])\\n                maxVal=max(maxVal, curval)\\n                \\n            if not graph.get(node):continue\\n            for a,t in graph[node]:\\n                stack.append([a,time+t,path+[a]])\\n        \\n        return maxVal",
                "solutionTags": [],
                "code": "class Solution:\\n    def maximalPathQuality(self, vals: List[int], edges: List[List[int]], maxTime: int) -> int:\\n     \\n        if len(vals)==0: return 0\\n        if len(edges)==0: return vals[0]\\n\\t\\t\\n\\t\\t# time complexity: O(|E|)\\n        graph={}",
                "codeTag": "Java"
            },
            {
                "id": 1651704,
                "title": "python-by-dfs-pruning-w-hint",
                "content": "**Hint & Pruning strategy**:\\n\\nDuring DFS, **if current node** is **start node**, but **remain time** is **not long enough for us to go back** after visting neighbor, then **skip** this neighbor.\\n\\n[Note: this kind of traversal has no chance to go back start node]\\n\\n---\\n\\nDuring DFS, **if current node** is **other nodes**, but **remain time** is **not long enough for us to go next neighbor**, then **skip** this neighbor.\\n\\n[Note: this kind of traversal run out of time on the way to next neighbor]\\n\\n---\\n\\nFinally, after all DFS is completed, we **only accept this kinds of traversal path**:\\n**start** -> ... -> ... -> ... -> **start**, and yield corresponding path quality for max value comparison.\\n\\n\\n---\\n\\n**Implementation** by DFS + pruning in Python\\n\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        \\n        \\n        # represent graph in temrs of adjacency matrix\\n        graph = defaultdict( list )\\n        \\n        # update graph wiht input edges with time cost\\n        for u, v, cost in edges:\\n            graph[u].append( (v, cost) )\\n            graph[v].append( (u, cost) )\\n        \\n        \\n        # record of visited node\\n        visited = set()\\n        \\n        # Start node, defined by description\\n        START = 0\\n        # -------------------------------------\\n        def dfs(cur, remain, quality, visit):\\n            \\n            \\n            # add quality if it is first time to visit current node\\n            if cur not in visit:\\n                quality += values[cur]\\n\\n                \\n            # visit neighbor in DFS with lowerbound on remain\\n            for neighbor, cost in graph[cur]:\\n                \\n                if cur == START and remain >= 2*cost:\\n                    \\n                    # Traverse from start node, if cannot go back to start node later, then don\\'t go to this neighbor\\n                    yield from dfs( neighbor, remain - cost, quality,visit | {cur})\\n                    \\n                    \\n                elif cur != START and remain >= cost:\\n                    \\n                    # Traverse from other nodes, if remaing time is not enough for travel, then don\\'t go to this neighbor\\n                    yield from dfs( neighbor, remain - cost, quality,visit | {cur})\\n\\n            # --------------------------------------------------------------\\n            # all valid DFS traversal is completed after this line\\n            \\n            if cur == START:\\n                # If we go back to source node finally, then output quality of current traversal\\n                yield quality\\n\\n            return\\n        \\n        # ----------------------------------\\n        \\n        # Compute maximum path quality in DFS\\n        return max( dfs(cur=0, remain=maxTime, quality=0, visit=visited) ) \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        \\n        \\n        # represent graph in temrs of adjacency matrix\\n        graph = defaultdict( list )\\n        \\n        # update graph wiht input edges with time cost\\n        for u, v, cost in edges:\\n            graph[u].append( (v, cost) )\\n            graph[v].append( (u, cost) )\\n        \\n        \\n        # record of visited node\\n        visited = set()\\n        \\n        # Start node, defined by description\\n        START = 0\\n        # -------------------------------------\\n        def dfs(cur, remain, quality, visit):\\n            \\n            \\n            # add quality if it is first time to visit current node\\n            if cur not in visit:\\n                quality += values[cur]\\n\\n                \\n            # visit neighbor in DFS with lowerbound on remain\\n            for neighbor, cost in graph[cur]:\\n                \\n                if cur == START and remain >= 2*cost:\\n                    \\n                    # Traverse from start node, if cannot go back to start node later, then don\\'t go to this neighbor\\n                    yield from dfs( neighbor, remain - cost, quality,visit | {cur})\\n                    \\n                    \\n                elif cur != START and remain >= cost:\\n                    \\n                    # Traverse from other nodes, if remaing time is not enough for travel, then don\\'t go to this neighbor\\n                    yield from dfs( neighbor, remain - cost, quality,visit | {cur})\\n\\n            # --------------------------------------------------------------\\n            # all valid DFS traversal is completed after this line\\n            \\n            if cur == START:\\n                # If we go back to source node finally, then output quality of current traversal\\n                yield quality\\n\\n            return\\n        \\n        # ----------------------------------\\n        \\n        # Compute maximum path quality in DFS\\n        return max( dfs(cur=0, remain=maxTime, quality=0, visit=visited) ) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646257,
                "title": "python-bfs",
                "content": "```\\nimport heapq as hq\\n\\nclass Solution:\\n    class QueueNode(tuple):\\n        def __lt__(self, other):\\n            time1, lst1, val1 = self\\n            time2, lst2, val2 = other\\n            if time1 == time2:\\n                return val1 > val2 \\n            else:\\n                return time1 < time2\\n    \\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        m, n = len(values), len(edges)\\n        \\n        adj = [[] for _ in range(m)]\\n        for u, v, time in edges:\\n            adj[u].append((v, time))\\n            adj[v].append((u, time))\\n        \\n        # construct the memo, this memorizes the max values accumulated\\n        dp = [0] * m\\n        \\n        queue = [Solution.QueueNode((0, [0], values[0]))]\\n        \\n        while queue:\\n            time, lst, val = hq.heappop(queue)\\n            \\n            if time > maxTime:\\n                break\\n            \\n            lastNode = lst[-1]\\n            # # decide if we want to push inqueue\\n            if dp[lastNode] > val:\\n                pass #continue\\n            else:\\n                dp[lastNode] = val\\n            \\n            # other wise go through its neighbors and update\\n            for node, time_delta in adj[lastNode]:\\n                next_time = time + time_delta\\n                next_list = lst[:] + [node]\\n                val = sum([values[i] for i in set(next_list)])\\n                if val > dp[node]:\\n                    hq.heappush(queue, Solution.QueueNode((next_time, next_list, val)))\\n\\n        return dp[0]",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq as hq\\n\\nclass Solution:\\n    class QueueNode(tuple):\\n        def __lt__(self, other):\\n            time1, lst1, val1 = self\\n            time2, lst2, val2 = other\\n            if time1 == time2:\\n                return val1 > val2 \\n            else:\\n                return time1 < time2\\n    \\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        m, n = len(values), len(edges)\\n        \\n        adj = [[] for _ in range(m)]\\n        for u, v, time in edges:\\n            adj[u].append((v, time))\\n            adj[v].append((u, time))\\n        \\n        # construct the memo, this memorizes the max values accumulated\\n        dp = [0] * m\\n        \\n        queue = [Solution.QueueNode((0, [0], values[0]))]\\n        \\n        while queue:\\n            time, lst, val = hq.heappop(queue)\\n            \\n            if time > maxTime:\\n                break\\n            \\n            lastNode = lst[-1]\\n            # # decide if we want to push inqueue\\n            if dp[lastNode] > val:\\n                pass #continue\\n            else:\\n                dp[lastNode] = val\\n            \\n            # other wise go through its neighbors and update\\n            for node, time_delta in adj[lastNode]:\\n                next_time = time + time_delta\\n                next_list = lst[:] + [node]\\n                val = sum([values[i] for i in set(next_list)])\\n                if val > dp[node]:\\n                    hq.heappush(queue, Solution.QueueNode((next_time, next_list, val)))\\n\\n        return dp[0]",
                "codeTag": "Java"
            },
            {
                "id": 1628580,
                "title": "c-dfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    #define p pair<int,int>\\n    vector<int>vis;\\n    vector<vector<p>>adj;\\n    int res=0;\\n    int dfs(int u,vector<int>& values,int ct,int t)\\n    {\\n        if(ct>t)\\n            return INT_MIN;\\n        int res=0,ans=INT_MIN;\\n        if(vis[u]==0)\\n            res+=values[u];\\n        vis[u]++;\\n        for(auto v:adj[u])\\n        {\\n            ans=max(ans,res+dfs(v.first,values,ct+v.second,t));\\n        }\\n        vis[u]--;\\n        if(u!=0)\\n            return ans;\\n        return max(res,ans);\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) \\n    {\\n        int n=values.size();\\n        adj.resize(n);\\n        for(auto &v:edges)\\n        {\\n            adj[v[0]].push_back({v[1],v[2]});\\n            adj[v[1]].push_back({v[0],v[2]});\\n        }\\n        vis.resize(n,0);\\n        return dfs(0,values,0,maxTime);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define p pair<int,int>\\n    vector<int>vis;\\n    vector<vector<p>>adj;\\n    int res=0;\\n    int dfs(int u,vector<int>& values,int ct,int t)\\n    {\\n        if(ct>t)\\n            return INT_MIN;\\n        int res=0,ans=INT_MIN;\\n        if(vis[u]==0)\\n            res+=values[u];\\n        vis[u]++;\\n        for(auto v:adj[u])\\n        {\\n            ans=max(ans,res+dfs(v.first,values,ct+v.second,t));\\n        }\\n        vis[u]--;\\n        if(u!=0)\\n            return ans;\\n        return max(res,ans);\\n    }\\n    int maximalPathQuality(vector<int>& values, vector<vector<int>>& edges, int maxTime) \\n    {\\n        int n=values.size();\\n        adj.resize(n);\\n        for(auto &v:edges)\\n        {\\n            adj[v[0]].push_back({v[1],v[2]});\\n            adj[v[1]].push_back({v[0],v[2]});\\n        }\\n        vis.resize(n,0);\\n        return dfs(0,values,0,maxTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627606,
                "title": "c-solution",
                "content": "Any suggestions for improvement are appreicated. In the end it only worked when I used a global variable and I am not sure why it only returns 0 without one\\n```\\npublic class Solution {\\n    int r = 0;\\n    public int MaximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n\\t\\n\\t\\t// Create Adjacency List with costs\\n        Dictionary<int, Dictionary<int, int>> g = new Dictionary<int, Dictionary<int, int>>();\\n        foreach (int[] edge in edges) {\\n            if (!g.ContainsKey(edge[0])) {\\n                g.Add(edge[0], new Dictionary<int, int>());\\n                g[edge[0]].Add(edge[1], edge[2]);\\n            } else {\\n                g[edge[0]].Add(edge[1], edge[2]);\\n            }\\n            \\n            if (!g.ContainsKey(edge[1])) {\\n                g.Add(edge[1], new Dictionary<int, int>());\\n                g[edge[1]].Add(edge[0], edge[2]);\\n            } else {\\n                g[edge[1]].Add(edge[0], edge[2]);\\n            }\\n        }\\n        \\n\\t\\t// Without connections from 0 return the 0th node\\'s value\\n        if (!g.ContainsKey(0)) return values[0];\\n        \\n\\t\\t// Initial DFS call\\n        MaxPath(g, 0, 0, maxTime, new HashSet<int>(), values);\\n        \\n        return r;\\n    }\\n    \\n    public int MaxPath(Dictionary<int, Dictionary<int, int>> g, int n, int t, int mt, HashSet<int> vn, int[] values) { \\n\\t\\t// Add current node to visited hash set\\n        vn.Add(n);\\n\\t\\t// get the next nodes for traversal\\n        Dictionary<int, int> nn = g[n];\\n        \\n\\t\\t// check to see if there are moves left to make\\n        bool ml = false;\\n        foreach (KeyValuePair<int, int> nx in nn) {\\n            if (t + nx.Value <= mt) ml = true;\\n        }\\n        \\n\\t\\t// Calculate current path\\'s value up to and including the current node\\n        int cv = 0;\\n        foreach (int nv in vn) cv += values[nv];\\n        \\n\\t\\t// If there are moves left to make, recursively call the DFS function again adding the max value of the valid paths making it back to 0th node within maxTime\\n        if (ml) {\\n            int max = 0;\\n            foreach (KeyValuePair<int, int> nx in nn) {\\n                max = Math.Max(max, MaxPath(g, nx.Key, t + nx.Value, mt, new HashSet<int>(vn), values));\\n            }\\n            \\n            cv += max;\\n        }\\n        \\n\\t\\t// Set global variable to new max value\\n        r = Math.Max(r, n == 0 && t <= mt ? cv : 0);\\n        return n == 0 && t <= mt ? cv : 0;\\n    }\\n}\\n```\\n\\nSecond Solution\\n```\\npublic class Solution {\\n    public int MaximalPathQuality(int[] vals, int[][] edges, int mt) {\\n        Dictionary<int, Dictionary<int, int>> g = new Dictionary<int, Dictionary<int, int>>();\\n        for (int i = 0; i < vals.Length; ++i) g.Add(i, new Dictionary<int, int>());\\n        foreach (int[] edge in edges) {\\n            g[edge[0]].Add(edge[1], edge[2]);\\n            g[edge[1]].Add(edge[0], edge[2]);\\n        }\\n        \\n        int[] r = new int[1];\\n        int[] s = new int[vals.Length];\\n        s[0]++;\\n        \\n        MaxPath(g, 0, vals, mt, s, r, vals[0]);\\n        \\n        return r[0];\\n    }\\n    \\n    // DFS Traverse all the way to the breaking case and do res calc there\\n    public void MaxPath(Dictionary<int, Dictionary<int, int>> g, int src, int[] vals, int t, int[] s, int[] r, int sum) { \\n        if (src == 0) \\n            r[0] = Math.Max(r[0], sum);\\n        \\n        if (t < 0) \\n            return;\\n        \\n        foreach (KeyValuePair<int, int> nx in g[src]) {\\n            if (t - nx.Value >= 0) {\\n                s[nx.Key]++;\\n                MaxPath(g, nx.Key, vals, t - nx.Value, s, r, sum + (s[nx.Key] == 1 ? vals[nx.Key] : 0));\\n                s[nx.Key]--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int r = 0;\\n    public int MaximalPathQuality(int[] values, int[][] edges, int maxTime) {\\n\\t\\n\\t\\t// Create Adjacency List with costs\\n        Dictionary<int, Dictionary<int, int>> g = new Dictionary<int, Dictionary<int, int>>();\\n        foreach (int[] edge in edges) {\\n            if (!g.ContainsKey(edge[0])) {\\n                g.Add(edge[0], new Dictionary<int, int>());\\n                g[edge[0]].Add(edge[1], edge[2]);\\n            } else {\\n                g[edge[0]].Add(edge[1], edge[2]);\\n            }\\n            \\n            if (!g.ContainsKey(edge[1])) {\\n                g.Add(edge[1], new Dictionary<int, int>());\\n                g[edge[1]].Add(edge[0], edge[2]);\\n            } else {\\n                g[edge[1]].Add(edge[0], edge[2]);\\n            }\\n        }\\n        \\n\\t\\t// Without connections from 0 return the 0th node\\'s value\\n        if (!g.ContainsKey(0)) return values[0];\\n        \\n\\t\\t// Initial DFS call\\n        MaxPath(g, 0, 0, maxTime, new HashSet<int>(), values);\\n        \\n        return r;\\n    }\\n    \\n    public int MaxPath(Dictionary<int, Dictionary<int, int>> g, int n, int t, int mt, HashSet<int> vn, int[] values) { \\n\\t\\t// Add current node to visited hash set\\n        vn.Add(n);\\n\\t\\t// get the next nodes for traversal\\n        Dictionary<int, int> nn = g[n];\\n        \\n\\t\\t// check to see if there are moves left to make\\n        bool ml = false;\\n        foreach (KeyValuePair<int, int> nx in nn) {\\n            if (t + nx.Value <= mt) ml = true;\\n        }\\n        \\n\\t\\t// Calculate current path\\'s value up to and including the current node\\n        int cv = 0;\\n        foreach (int nv in vn) cv += values[nv];\\n        \\n\\t\\t// If there are moves left to make, recursively call the DFS function again adding the max value of the valid paths making it back to 0th node within maxTime\\n        if (ml) {\\n            int max = 0;\\n            foreach (KeyValuePair<int, int> nx in nn) {\\n                max = Math.Max(max, MaxPath(g, nx.Key, t + nx.Value, mt, new HashSet<int>(vn), values));\\n            }\\n            \\n            cv += max;\\n        }\\n        \\n\\t\\t// Set global variable to new max value\\n        r = Math.Max(r, n == 0 && t <= mt ? cv : 0);\\n        return n == 0 && t <= mt ? cv : 0;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaximalPathQuality(int[] vals, int[][] edges, int mt) {\\n        Dictionary<int, Dictionary<int, int>> g = new Dictionary<int, Dictionary<int, int>>();\\n        for (int i = 0; i < vals.Length; ++i) g.Add(i, new Dictionary<int, int>());\\n        foreach (int[] edge in edges) {\\n            g[edge[0]].Add(edge[1], edge[2]);\\n            g[edge[1]].Add(edge[0], edge[2]);\\n        }\\n        \\n        int[] r = new int[1];\\n        int[] s = new int[vals.Length];\\n        s[0]++;\\n        \\n        MaxPath(g, 0, vals, mt, s, r, vals[0]);\\n        \\n        return r[0];\\n    }\\n    \\n    // DFS Traverse all the way to the breaking case and do res calc there\\n    public void MaxPath(Dictionary<int, Dictionary<int, int>> g, int src, int[] vals, int t, int[] s, int[] r, int sum) { \\n        if (src == 0) \\n            r[0] = Math.Max(r[0], sum);\\n        \\n        if (t < 0) \\n            return;\\n        \\n        foreach (KeyValuePair<int, int> nx in g[src]) {\\n            if (t - nx.Value >= 0) {\\n                s[nx.Key]++;\\n                MaxPath(g, nx.Key, vals, t - nx.Value, s, r, sum + (s[nx.Key] == 1 ? vals[nx.Key] : 0));\\n                s[nx.Key]--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611682,
                "title": "python-memoized-dfs",
                "content": "Like many other solutions, in order to memoize the backtracking, we can use a bitmask, i.e. an int holding (2**n)-1 bits. I write out as functions what we need to do to a bitmask in order to run the DFS successfully\\n\\n```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n\\n        n = len(values)\\n        #values is values of ith node\\n        graph = defaultdict(list)\\n        for src, dest, time in edges:\\n            graph[src].append((dest,time))\\n            graph[dest].append((src, time))\\n\\n        self.ansr = 0\\n        # let\\'s make visited a bitmask...\\n        # bitmask will be 2**n-1\\n        #bitmask starts at one\\n        def set_ith_bit(x, i):\\n            return (1<<i)|x\\n        \\n        def unset_ith_bit(x, i):\\n            return ~(1<<i) & x\\n        \\n        def check_ith_bit(x,i):\\n            return (x >> i) & 1\\n        \\n        @lru_cache(None)\\n        def backtrack(node = 0, curTime = 0, visited = 1, curval = values[0]):\\n            if(curTime > maxTime):\\n                return\\n            for v,time in graph[node]:\\n                if(curTime+time<=maxTime):    \\n                    \\n                    backtrack(v, curTime+time, set_ith_bit(visited, v), curval+values[v] if not check_ith_bit(visited,v) else curval)\\n            if(node == 0):\\n                \\n                self.ansr = max(self.ansr, curval)#max(self.ansr, (sum([values[i] for i in range(n) if visited[i]>0])))\\n                #print(self.ansr)\\n            return\\n        backtrack()\\n        return self.ansr\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n\\n        n = len(values)\\n        #values is values of ith node\\n        graph = defaultdict(list)\\n        for src, dest, time in edges:\\n            graph[src].append((dest,time))\\n            graph[dest].append((src, time))\\n\\n        self.ansr = 0\\n        # let\\'s make visited a bitmask...\\n        # bitmask will be 2**n-1\\n        #bitmask starts at one\\n        def set_ith_bit(x, i):\\n            return (1<<i)|x\\n        \\n        def unset_ith_bit(x, i):\\n            return ~(1<<i) & x\\n        \\n        def check_ith_bit(x,i):\\n            return (x >> i) & 1\\n        \\n        @lru_cache(None)\\n        def backtrack(node = 0, curTime = 0, visited = 1, curval = values[0]):\\n            if(curTime > maxTime):\\n                return\\n            for v,time in graph[node]:\\n                if(curTime+time<=maxTime):    \\n                    \\n                    backtrack(v, curTime+time, set_ith_bit(visited, v), curval+values[v] if not check_ith_bit(visited,v) else curval)\\n            if(node == 0):\\n                \\n                self.ansr = max(self.ansr, curval)#max(self.ansr, (sum([values[i] for i in range(n) if visited[i]>0])))\\n                #print(self.ansr)\\n            return\\n        backtrack()\\n        return self.ansr\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607056,
                "title": "python-faster-than-83-dijkstra-dfs",
                "content": "```\\nfrom queue import PriorityQueue\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        visited = [0] * len(values)\\n        distance = [0] + [float(\\'inf\\')] * (len(values) - 1)\\n        graph = defaultdict(list)\\n        for i,j,k in edges:\\n            graph[i].append((j,k))\\n            graph[j].append((i,k))\\n\\n        q = PriorityQueue()\\n        q.put((0, 0))\\n        \\n        while not q.empty():\\n            dist, n = q.get()\\n            if visited[n]:\\n                continue\\n                \\n            visited[n] = 1\\n            for m, weight in graph[n]:\\n                if visited[m]:\\n                    continue\\n                d = dist + weight\\n                if d < distance[m]:\\n                    distance[m] = d\\n                    q.put((d, m))\\n\\n        def dfs(n, visited_set, remainTime):\\n            if distance[n] > remainTime: return 0\\n            else:\\n                best = 0\\n                new_visited_set = visited_set.union({n})\\n                for node, weight in graph[n]:\\n                    cur_best = dfs(node, new_visited_set, remainTime-weight)\\n                    if cur_best > best: best = cur_best\\n                if  n in visited_set: return best\\n                else: return best + values[n]\\n\\n        return dfs(0, set(), maxTime)\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nfrom queue import PriorityQueue\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        visited = [0] * len(values)\\n        distance = [0] + [float(\\'inf\\')] * (len(values) - 1)\\n        graph = defaultdict(list)\\n        for i,j,k in edges:\\n            graph[i].append((j,k))\\n            graph[j].append((i,k))\\n\\n        q = PriorityQueue()\\n        q.put((0, 0))\\n        \\n        while not q.empty():\\n            dist, n = q.get()\\n            if visited[n]:\\n                continue\\n                \\n            visited[n] = 1\\n            for m, weight in graph[n]:\\n                if visited[m]:\\n                    continue\\n                d = dist + weight\\n                if d < distance[m]:\\n                    distance[m] = d\\n                    q.put((d, m))\\n\\n        def dfs(n, visited_set, remainTime):\\n            if distance[n] > remainTime: return 0\\n            else:\\n                best = 0\\n                new_visited_set = visited_set.union({n})\\n                for node, weight in graph[n]:\\n                    cur_best = dfs(node, new_visited_set, remainTime-weight)\\n                    if cur_best > best: best = cur_best\\n                if  n in visited_set: return best\\n                else: return best + values[n]\\n\\n        return dfs(0, set(), maxTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592035,
                "title": "python3-99-84-time-170ms-bitmasking",
                "content": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        heap = []\\n        heappush(heap, (0, 0, 1, values[0])) # time, current node, visited bitmask, score\\n        maxScore = values[0]\\n        bestScores = [0] * len(values)\\n        \\n        edgeList = defaultdict(list)\\n        for a, b, time in edges:\\n            edgeList[a].append((b, time))\\n            edgeList[b].append((a, time))\\n            \\n        minDistToZero = [math.inf] * len(values)\\n        \\n        while heap:\\n            curTime, curNode, visited, score = heappop(heap)\\n            minDistToZero[curNode] = min(minDistToZero[curNode], curTime)\\n            if curTime + minDistToZero[curNode] > maxTime:\\n                continue\\n            bestScores[curNode] = max(bestScores[curNode], score)\\n            if curNode == 0:\\n                maxScore = max(maxScore, score)\\n            for neighbor, time in edgeList[curNode]:\\n                mask = 1 << neighbor\\n                newScore = score + (values[neighbor] if (mask & visited == 0) else 0)\\n                if newScore >= bestScores[neighbor] and curTime + time <= maxTime:\\n                    newVisit = visited | mask\\n                    heappush(heap, (curTime + time, neighbor, newVisit, newScore))\\n        \\n        return maxScore\\n```",
                "solutionTags": [
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        heap = []\\n        heappush(heap, (0, 0, 1, values[0])) # time, current node, visited bitmask, score\\n        maxScore = values[0]\\n        bestScores = [0] * len(values)\\n        \\n        edgeList = defaultdict(list)\\n        for a, b, time in edges:\\n            edgeList[a].append((b, time))\\n            edgeList[b].append((a, time))\\n            \\n        minDistToZero = [math.inf] * len(values)\\n        \\n        while heap:\\n            curTime, curNode, visited, score = heappop(heap)\\n            minDistToZero[curNode] = min(minDistToZero[curNode], curTime)\\n            if curTime + minDistToZero[curNode] > maxTime:\\n                continue\\n            bestScores[curNode] = max(bestScores[curNode], score)\\n            if curNode == 0:\\n                maxScore = max(maxScore, score)\\n            for neighbor, time in edgeList[curNode]:\\n                mask = 1 << neighbor\\n                newScore = score + (values[neighbor] if (mask & visited == 0) else 0)\\n                if newScore >= bestScores[neighbor] and curTime + time <= maxTime:\\n                    newVisit = visited | mask\\n                    heappush(heap, (curTime + time, neighbor, newVisit, newScore))\\n        \\n        return maxScore\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580518,
                "title": "one-optimization-for-the-dfs-applying-same-idea-as-two-way-bfs",
                "content": "I was using a priority queue of this node type:\\n```\\nstruct node {\\n    int time;\\n    int vertex;\\n    unordered_set<int> path;\\n};\\n```\\nWhich got TLE [Node: I don\\'t really need a priority queue. A regular queue should do. I tried both]. I then read the discussions and see most used DFS. I am not sure the big difference between these two (BFS vs DFS) approach other than in my BFS, I have to maintail the \"path\" for each node, which may be very time consuming and is the reason why I got TLE.\\n\\nIn an effort of trying to get my sumbit accepted, I tried an idea similar to two-way BFS: I calculate the shortest distance between each node and node 0. Having this data, we can cut a lot steps, using \"current_accumuted_time + distance[i] > timeLimit\" as the filter. This will cut the path length by half in most cases, just like two way BFS does.\\n\\nI applied this idea to my BFS/queue/priority_queue approach. My original submit got 58/61 passed. This optimization got 61/61 passed but reported TLE anyway.\\n\\nTried this idea with [Byte_Walker\\'s C++ code](https://leetcode.com/problems/maximum-path-quality-of-a-graph/discuss/1563770/Simple-DFS-solution-(C%2B%2B)). Without this optimization, I got 172ms (65%). With this I got 72ms (99%).",
                "solutionTags": [],
                "code": "```\\nstruct node {\\n    int time;\\n    int vertex;\\n    unordered_set<int> path;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2049991,
                "content": [
                    {
                        "username": "aglakshya02",
                        "content": "I think this is a bad question. if you don\\' t observe the constraints b/w time and maxtime carefully, you won\\'t be able to solve it."
                    },
                    {
                        "username": "koushik15",
                        "content": "how to choose between Bfs and dfs in this scenerio\\n"
                    },
                    {
                        "username": "jyothikasama",
                        "content": "can any one write c code for this\\n"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "Should be medium difficulty."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "I was not able to solve \\uD83D\\uDE1E\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1927804,
                "content": [
                    {
                        "username": "aglakshya02",
                        "content": "I think this is a bad question. if you don\\' t observe the constraints b/w time and maxtime carefully, you won\\'t be able to solve it."
                    },
                    {
                        "username": "koushik15",
                        "content": "how to choose between Bfs and dfs in this scenerio\\n"
                    },
                    {
                        "username": "jyothikasama",
                        "content": "can any one write c code for this\\n"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "Should be medium difficulty."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "I was not able to solve \\uD83D\\uDE1E\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1682080,
                "content": [
                    {
                        "username": "aglakshya02",
                        "content": "I think this is a bad question. if you don\\' t observe the constraints b/w time and maxtime carefully, you won\\'t be able to solve it."
                    },
                    {
                        "username": "koushik15",
                        "content": "how to choose between Bfs and dfs in this scenerio\\n"
                    },
                    {
                        "username": "jyothikasama",
                        "content": "can any one write c code for this\\n"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "Should be medium difficulty."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "I was not able to solve \\uD83D\\uDE1E\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1853767,
                "content": [
                    {
                        "username": "aglakshya02",
                        "content": "I think this is a bad question. if you don\\' t observe the constraints b/w time and maxtime carefully, you won\\'t be able to solve it."
                    },
                    {
                        "username": "koushik15",
                        "content": "how to choose between Bfs and dfs in this scenerio\\n"
                    },
                    {
                        "username": "jyothikasama",
                        "content": "can any one write c code for this\\n"
                    },
                    {
                        "username": "akhiilgupta",
                        "content": "Should be medium difficulty."
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "I was not able to solve \\uD83D\\uDE1E\\uD83D\\uDE2D"
                    }
                ]
            }
        ]
    }
]