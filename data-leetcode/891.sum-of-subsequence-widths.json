[
    {
        "title": "Sum of Subsequence Widths",
        "question_content": "The width of a sequence is the difference between the maximum and minimum elements in the sequence.\nGiven an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7.\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n&nbsp;\nExample 1:\n\nInput: nums = [2,1,3]\nOutput: 6\nExplanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].\nThe corresponding widths are 0, 0, 0, 1, 1, 2, 2.\nThe sum of these widths is 6.\n\nExample 2:\n\nInput: nums = [2]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 161267,
                "title": "java-c-python-sort-and-one-pass",
                "content": "# **Explanation**\\nThe order in initial arrays doesn\\'t matter,\\nmy first intuition is to sort the array.\\n\\nFor each number `A[i]`:\\n\\n1. There are `i` smaller numbers,\\nso there are `2 ^ i` sequences in which `A[i]` is maximum.\\nwe should do `res += A[i] * 2^i`\\n\\n2. There are `n - i - 1` bigger numbers,\\nso there are `2 ^ (n - i - 1)` sequences in which `A[i]` is minimum.\\nwe should do `res -= A[i] * 2^(n - i - 1)`\\n\\nDone.\\n<br>\\n\\n# **Time Complexity**:\\nTime `O(NlogN)`\\nSpace `O(1)`\\n<br>\\n\\n\\n# **FAQ**\\n**Q. why do we plus mod before return?**\\n**A** In Cpp and Java, mod on negative number will still get a negative number.\\n<br>\\n\\n**Java:**\\n```java\\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n```\\n**C++:**\\n```cpp\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n```\\n**1-line Python:**\\n```py\\n    def sumSubseqWidths(self, A):\\n        return sum(((1 << i) - (1 << len(A) - i - 1)) * a for i, a in enumerate(sorted(A))) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n```\n```cpp\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n```\n```py\\n    def sumSubseqWidths(self, A):\\n        return sum(((1 << i) - (1 << len(A) - i - 1)) * a for i, a in enumerate(sorted(A))) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161263,
                "title": "c-solution-o-n-log-n-sort-o-n-calculate",
                "content": "We only care about the subsequences and max/min values, so the order of the elements does not matter. Therefore, we sort the array at first.\\n\\nFor a sorted subarray A=[p,......,q], there are 2^(len(A)-2) subsequences which has min value=p, and max value=q. Because we can choose any numbers between p and q, there are 2^(len(A)-2) ways to choose.\\n\\nFor example, a given array is `[0,1,3,4,7]`.\\nFor the subarray `[1,3,4,7]`, there are 2^2 subsequences which has min value=1 and max value=7.\\n\\nThen we got an O(N^2) solution:\\nthe answer is `sum((max(Ai)-min(Ai))\\xD72^(len(Ai)-2))`, for all subarrays `Ai` where `len(Ai) > 1`.  \\nFor the example above, it is:\\n\\n```\\n1*2^0+3*2^1+4*2^2+7*2^3       // = x0\\n     +2*2^0+3*2^1+6*2^2       // = x1\\n           +1*2^0+4*2^1       // = x2\\n                 +3*2^0       // = x3\\n```\\n\\n***\\nOf course the efficiency is not enough. Observe the table above\\u2191, we can find that\\n\\n```\\nx0-1*(2^0+2^1+2^2+2^3)=x1*2\\nx1-2*(2^0+2^1+2^2)=x2*2\\nx2-1*(2^0+2^1)=x3*2\\nx3-3*(2^0)=0\\n```\\n\\nwe can then calculate x3, x2, x1, x0 one by one: \\n\\n```\\nx4=0;\\nx3=x4*2 + (A4-A3)*(2^0)\\nx2=x3*2 + (A3-A2)*(2^0+2^1)\\nx1=x2*2 + (A2-A1)*(2^0+2^1+2^2)\\nx0=x1*2 + (A1-A0)*(2^0+2^1+2^2+2^3)\\n\\nresult=x4+x3+x2+x1+x0\\n```\\n\\nHere is my code:\\n\\n```cpp\\n#define M 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        vector<ll> diff;\\n        for (int i = 0; i < A.size() - 1; i++) diff.push_back(A[i + 1] - A[i]);\\n        ll result = 0;\\n        ll x = 0;\\n        ll sum2 = 1;\\n        int len = diff.size();\\n        reverse(diff.begin(), diff.end());\\n        for (int i = 0; i < len; i++) {\\n            x <<= 1;\\n            x += sum2 * diff[i];\\n            x %= M;\\n            sum2 <<= 1;\\n            sum2++;\\n            sum2 %= M;\\n            result += x;\\n            result %= M;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1*2^0+3*2^1+4*2^2+7*2^3       // = x0\\n     +2*2^0+3*2^1+6*2^2       // = x1\\n           +1*2^0+4*2^1       // = x2\\n                 +3*2^0       // = x3\\n```\n```\\nx0-1*(2^0+2^1+2^2+2^3)=x1*2\\nx1-2*(2^0+2^1+2^2)=x2*2\\nx2-1*(2^0+2^1)=x3*2\\nx3-3*(2^0)=0\\n```\n```\\nx4=0;\\nx3=x4*2 + (A4-A3)*(2^0)\\nx2=x3*2 + (A3-A2)*(2^0+2^1)\\nx1=x2*2 + (A2-A1)*(2^0+2^1+2^2)\\nx0=x1*2 + (A1-A0)*(2^0+2^1+2^2+2^3)\\n\\nresult=x4+x3+x2+x1+x0\\n```\n```cpp\\n#define M 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        vector<ll> diff;\\n        for (int i = 0; i < A.size() - 1; i++) diff.push_back(A[i + 1] - A[i]);\\n        ll result = 0;\\n        ll x = 0;\\n        ll sum2 = 1;\\n        int len = diff.size();\\n        reverse(diff.begin(), diff.end());\\n        for (int i = 0; i < len; i++) {\\n            x <<= 1;\\n            x += sum2 * diff[i];\\n            x %= M;\\n            sum2 <<= 1;\\n            sum2++;\\n            sum2 %= M;\\n            result += x;\\n            result %= M;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456511,
                "title": "c-o-nlogn-approach-sum-of-subsequence-widths",
                "content": "**Logic -**\\n**Observations 1**: Order doesn\\'t matter \\n**Observations 2**: Every numbers contribute based on its index in the sorted array.\\n\\n**Mathematical Derivations -**\\nConsider that there are total (n) number in a sorted array, then (i) numbers will be <= nums[i] and (n-i-1) numbers will be >= A[i]\\n\\nA[i] will be upper bound of (2^i) subsequences         <-------- when A[i] as maxm value\\nA[i] will be lower bound of (2^(n-i-1)) subsequences <-------- when A[i] as minm value\\n\\n```\\nso, contribution of A[i] = upper - lower = A[i]*(2^i) - A[i]*(2^(n-i-1))\\n                                          \\nAns  = Sum{A[i]* 2^i - A[i] * 2^(n-i-1)}  , for 0 <= i < n \\n     = (A[0]*2^0 - A[0]*2^(n-1) + (A[1]*2^1 - A[1]*2^(n-2) + ... \\n       + (A[i]*2^i - A[i]*2^(n-i-1) + ...  + (A[n-i-1]*2^(n-i-1) - A[n-i-1]*2^i + ... + (A[n-1] * 2^(n-1) - A[n-1]*2^0)\\n        \\n\\t\\t//some of the terms in above expression will cancel each other,\\n\\t\\t\\nAns = Sum{A[i] * 2^i - A[n-i-1]* 2^i} ..........on taking 2^(i) common, the sum can be re-written as \\n     =Sum{ (A[i] - A[n-i-1]) * 2^(i)  }\\n\\n```\\n\\n**Now,**\\n**Step 1 :** Sort the array first,\\n**Step 2 :** Once array is sorted, Calculate the result by summation of above derived results.\\n\\n```\\nint sumSubseqWidths(vector<int>& nums) {\\n\\n    int n = nums.size();\\n    int ans = 0; \\n\\n    // sort the array\\n    sort(nums.begin(),nums.end());                        // O(nlogn)\\n\\n    // create the vector to store power terms\\n    vector<long> exp(n, 0);\\n    exp[0] = 1;\\n\\n    // Pre-Calculate the value of exp for each (i) so need not to do again. \\n\\t// Note- Divide by mod to keep the answer in range. \\n    for (int i = 1; i < n; i++) {\\n        exp[i] = exp[i - 1] * 2 % mod;\\n    }\\n\\n    // Iterate the array and calculate the sum using above mathematical expression\\n    for(int i=0;i<n;i++){\\n        ans = ( ans + exp[i]*(nums[i] - nums[n-i-1])) %mod;\\n    }    \\n    return ans; \\n}\\n\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nso, contribution of A[i] = upper - lower = A[i]*(2^i) - A[i]*(2^(n-i-1))\\n                                          \\nAns  = Sum{A[i]* 2^i - A[i] * 2^(n-i-1)}  , for 0 <= i < n \\n     = (A[0]*2^0 - A[0]*2^(n-1) + (A[1]*2^1 - A[1]*2^(n-2) + ... \\n       + (A[i]*2^i - A[i]*2^(n-i-1) + ...  + (A[n-i-1]*2^(n-i-1) - A[n-i-1]*2^i + ... + (A[n-1] * 2^(n-1) - A[n-1]*2^0)\\n        \\n\\t\\t//some of the terms in above expression will cancel each other,\\n\\t\\t\\nAns = Sum{A[i] * 2^i - A[n-i-1]* 2^i} ..........on taking 2^(i) common, the sum can be re-written as \\n     =Sum{ (A[i] - A[n-i-1]) * 2^(i)  }\\n\\n```\n```\\nint sumSubseqWidths(vector<int>& nums) {\\n\\n    int n = nums.size();\\n    int ans = 0; \\n\\n    // sort the array\\n    sort(nums.begin(),nums.end());                        // O(nlogn)\\n\\n    // create the vector to store power terms\\n    vector<long> exp(n, 0);\\n    exp[0] = 1;\\n\\n    // Pre-Calculate the value of exp for each (i) so need not to do again. \\n\\t// Note- Divide by mod to keep the answer in range. \\n    for (int i = 1; i < n; i++) {\\n        exp[i] = exp[i - 1] * 2 % mod;\\n    }\\n\\n    // Iterate the array and calculate the sum using above mathematical expression\\n    for(int i=0;i<n;i++){\\n        ans = ( ans + exp[i]*(nums[i] - nums[n-i-1])) %mod;\\n    }    \\n    return ans; \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2361648,
                "title": "c-sum-of-subsequence-widths",
                "content": "After solving this ques, go for this ques https://www.codechef.com/problems/DECOSUB \\n\\nThe approach to the solution can be started by observing max and min(max-min) value of all subsequence and then go for simple maths as shown below:\\n\\n![image](https://assets.leetcode.com/users/images/237be303-4f7e-4146-8a64-a6d2c7c504d2_1659301276.4129994.jpeg)\\n\\nHere is my code for the approach.....\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& a) {\\n        \\n        int n=a.size(),i,j=n-1;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        long long int p=1;\\n        \\n        long long int ans=0;\\n        \\n        long long int mod=1000000007;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            ans=(ans+p*a[i]-p*a[j])%mod;\\n            \\n            p=(p*2)%mod;\\n            \\n            j--;\\n        }\\n        return (int)ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& a) {\\n        \\n        int n=a.size(),i,j=n-1;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        long long int p=1;\\n        \\n        long long int ans=0;\\n        \\n        long long int mod=1000000007;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            ans=(ans+p*a[i]-p*a[j])%mod;\\n            \\n            p=(p*2)%mod;\\n            \\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 162318,
                "title": "o-nlogn-solution",
                "content": "Sort the array cost <code>O(nlogn)</code>;\\nThe number of subset that fixed <code>A[i]</code> as minimum element and <code>A[j]</code> as maximum element (<code>i<j</code>) is <code>2^{j-i-1}</code>:\\n\\n1. when <code>j-i=1</code>, we can get <code>T_{1}=(A[2]-A[1])*2^{0} + (A[3]-A[2])*2^{0} + ...+(A[n]-A[n-1])*2^{0} = (A[n]-A[1])*2^{0}</code>\\n2. when <code>j-i=2</code>, we can get <code>T_{2}=(A[3]-A[1])*2^{1} + (A[4]-A[2])*2^{1} + ...+(A[n]-A[n-2])*2^{1} = (A[n]+A[n-1]-A[2]-A[1])*2^{1}</code>\\n3. when <code>j-i=3</code>, we can get <code>T_{3}=(A[4]-A[1])*2^{2} + (A[5]-A[2])*2^{2} + ...+(A[n]-A[n-3])*2^{2} = (A[n]+A[n-1]+A[n-2]-A[3]-A[2]-A[1])*2^{2}</code>\\n4. when <code>j-i=k</code>, we can get <code>T_{k}=(sum[n-k+1][n] - sum[1][k])*2^{k-1}</code>\\n5. Finally, <code>ans=T_{1}+T_{2}+...+T_{k}</code>\\n\\nIn my code, <code>lsum</code> referred to <code>sum[1][k]</code>, <code>rsum</code> referred to <code>sum[n-k+1][n]</code>, and <code>d</code> referred to <code>2^{k-1}</code>\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int l = 0, r = A.size()-1;\\n        int lsum = 0, rsum = 0;\\n        long long d = 1, ans = 0, mod = 1000000007;\\n        while(l < A.size()){\\n            lsum += A[l++];\\n            rsum += A[r--];\\n            ans += (rsum-lsum)*d;\\n            ans %= mod;\\n            d = d * 2 % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int l = 0, r = A.size()-1;\\n        int lsum = 0, rsum = 0;\\n        long long d = 1, ans = 0, mod = 1000000007;\\n        while(l < A.size()){\\n            lsum += A[l++];\\n            rsum += A[r--];\\n            ans += (rsum-lsum)*d;\\n            ans %= mod;\\n            d = d * 2 % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161327,
                "title": "leetcode-weekly-contest-98-screencast",
                "content": "https://www.youtube.com/watch?v=KpPDMI02LVQ\\n\\nDid a really bad job this time. One out-of-boundary issue bite me and I was thinking there must be some LC bug all the time until I stopped screencast.",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=KpPDMI02LVQ\\n\\nDid a really bad job this time. One out-of-boundary issue bite me and I was thinking there must be some LC bug all the time until I stopped screencast.",
                "codeTag": "Unknown"
            },
            {
                "id": 881805,
                "title": "c-simple-sol-with-comments-beats-88",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        long power = 1, res = 0, mod = 1e9+7,n = arr.size();\\n        \\n        //adding maximums\\n        //number of times this item will be maximum\\n        for(int i=0;i<n;i++){\\n            res = (res + arr[i]*power)%mod;\\n            power = (power*2)%mod;\\n        }\\n        \\n        //subtracting minimums\\n        //number of times this item will be minimum\\n        power = 1;\\n        for(int i=n-1;i>=0;i--){\\n            res = (res - arr[i]*power +mod)%mod;\\n            power = (power*2)%mod;\\n        }\\n        return (res+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        long power = 1, res = 0, mod = 1e9+7,n = arr.size();\\n        \\n        //adding maximums\\n        //number of times this item will be maximum\\n        for(int i=0;i<n;i++){\\n            res = (res + arr[i]*power)%mod;\\n            power = (power*2)%mod;\\n        }\\n        \\n        //subtracting minimums\\n        //number of times this item will be minimum\\n        power = 1;\\n        for(int i=n-1;i>=0;i--){\\n            res = (res - arr[i]*power +mod)%mod;\\n            power = (power*2)%mod;\\n        }\\n        return (res+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161318,
                "title": "pythonic-o-nlogn-sorting",
                "content": "First, the brute force solution is to check every index `(i, j)` pair. The total number of of subsequence with `i` the smallest and `j` the largest value is `2^(j-i-1)`. Time complexity is `O(n^2)`, which gets TLE.\\n```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res=0\\n        A.sort()\\n        for i in range(len(A)):\\n            for j in range(i+1, len(A)):\\n                res+=2**(j-i-1)*(A[j]-A[i])\\n                res%=10**9+7\\n        return res\\n```\\nThen to optimize, we find that for the same difference of index `i`, `j` (say `k=j-i`), their sum would be:\\n`2^(k-1)*(A[k]-A[0]+A[k+1]-A[1]+A[k+2]-A[2]+....+A[len(A)-1]-A[len(A)-1-k])=2^(k-1)*(sum of last k numbers in A - sum of first k numbers in A)`\\nWe can use a `preSum` and a `postSum` array to calculate the difference above. Building both arrays take O(n), final counting part is also O(n), sorting is O(nlogn), total would be O(nlogn).\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        l=len(A)\\n        preSum, postSum=[A[0]]*l, [A[-1]]*l\\n        for i in range(1, l):\\n            preSum[i]=preSum[i-1]+A[i]\\n            postSum[i]=postSum[i-1]+A[l-1-i]\\n        s=0\\n        for i in range(len(A)-1):\\n            s+=(1<<i)*(postSum[i]-preSum[i])\\n            s%=10**9+7\\n        return s\\n```\\nA more pythonic solution to add to the result only one pass:\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        res=0\\n        for i in range(len(A)):\\n            res*=2\\n            res-=A[i]\\n            res+=A[~i]\\n            res%=10**9+7\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res=0\\n        A.sort()\\n        for i in range(len(A)):\\n            for j in range(i+1, len(A)):\\n                res+=2**(j-i-1)*(A[j]-A[i])\\n                res%=10**9+7\\n        return res\\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        l=len(A)\\n        preSum, postSum=[A[0]]*l, [A[-1]]*l\\n        for i in range(1, l):\\n            preSum[i]=preSum[i-1]+A[i]\\n            postSum[i]=postSum[i-1]+A[l-1-i]\\n        s=0\\n        for i in range(len(A)-1):\\n            s+=(1<<i)*(postSum[i]-preSum[i])\\n            s%=10**9+7\\n        return s\\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        res=0\\n        for i in range(len(A)):\\n            res*=2\\n            res-=A[i]\\n            res+=A[~i]\\n            res%=10**9+7\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768402,
                "title": "python3-sort-and-1-pass-derived-from-dp-solution",
                "content": "I\\'m pretty happy to have found the solution to that one alone, so I would like to share here my line of thinking.\\n\\nFirst things first, we notice that we can sort the array without changing the problem, as the order of values in sub-sequences do not have importance.\\n\\nLet us suppose we have a sorted array. For example, `[1, 2, 2, 3, 4, 5, 5, 6, 9]`. What information do we need to find the answer while iterating over the array? For example, let us suppose we are considering the `4`, what information from `[1, 2, 2, 3]` do we need to find the answer for the array up to `4`?\\n\\nWe notice that the difference between min and max in that case is the difference between `4` and the first element of all previous sub-sequences. Therefore, to sum the differences for all subsequences, we must have the count of all subsequences in `[1, 2, 2, 3]` starting with any of its values.\\n\\nOnce we have that, we can:\\n* Update the total value by adding `(4 - value) * count` for each `value, count` pair existing,\\n* Update our table of counts by multiplying each existing value by `2` (each previous sub-sequence is split in two, one without and one with `4` appended), as well as adding one more for `4`, for the sub-sequence `[4]`.\\n\\nThis gives us the following code:\\n\\n```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        ans = 0\\n        dp = defaultdict(int)\\n        for right in A:\\n            for left, cnt in dp.items():\\n                ans = (ans + (right - left) * cnt) % self.BASE\\n                dp[left] = (cnt * 2) % self.BASE\\n            dp[right] += 1\\n        return ans\\n```\\n\\nThe problem is, although correct, this code is in `O(n^2)`, which is too slow. The main issue is the second loop inside, iterating over `dp`. Now, is it possible to write this loop as a single iteration?\\n\\nIf we rewrite our expression, we notice that it is equivalent to:\\n\\n```\\nans += sum(right * cnt_i) - sum(left_i * cnt_i) = right * sum(cnt_i) - sum(left_i * cnt_i)\\n```\\n\\nAs we multiply each `cnt_i` by 2 in the loop, and add `1` for `right` at the end of the loop, we can rewrite these expressions as standalone variables. I name `total_cnt = sum(cnt_i)` and `total_prod = sum(left_i * cnt_i)`.\\n\\n```\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        total_cnt = 0\\n        total_prod = 0\\n        ans = 0\\n        for num in A:\\n            ans = (ans + total_cnt * num - total_prod) % self.BASE\\n            total_cnt = (2 * total_cnt + 1) % self.BASE\\n            total_prod = (2 * total_prod + num) % self.BASE\\n        return ans\\n```\\n\\nThis solution is in `O(n log(n))` and `O(1)` space, and passes without TLE.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        ans = 0\\n        dp = defaultdict(int)\\n        for right in A:\\n            for left, cnt in dp.items():\\n                ans = (ans + (right - left) * cnt) % self.BASE\\n                dp[left] = (cnt * 2) % self.BASE\\n            dp[right] += 1\\n        return ans\\n```\n```\\nans += sum(right * cnt_i) - sum(left_i * cnt_i) = right * sum(cnt_i) - sum(left_i * cnt_i)\\n```\n```\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        total_cnt = 0\\n        total_prod = 0\\n        ans = 0\\n        for num in A:\\n            ans = (ans + total_cnt * num - total_prod) % self.BASE\\n            total_cnt = (2 * total_cnt + 1) % self.BASE\\n            total_prod = (2 * total_prod + num) % self.BASE\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708434,
                "title": "easy-explanation-with-example-java-o-nlogn",
                "content": "Let\\'s say,\\nThis is our array:\\n[3,1,2,4]\\n\\nSubsequences:\\n\\n\\t\\t\\t\\tmax - min\\n\\t3\\t\\t\\t3-3 = 0\\n\\t1\\t\\t\\t1-1 = 0\\n\\t2\\t\\t\\t2-2 = 0\\n\\t4\\t\\t\\t4-4 = 0\\n\\t3,1\\t\\t\\t3-1 = 2\\n\\t3,2\\t\\t\\t3-2 = 1\\n\\t3,4\\t\\t\\t4-3 = 1\\n\\t1,2\\t\\t\\t2-1 = 1\\n\\t1,4\\t\\t\\t4-1 = 3\\n\\t2,4\\t\\t\\t4-2 = 2\\n\\t3,1,2\\t\\t3-1 = 2\\n\\t3,1,4\\t\\t4-1 = 3\\n\\t3,2,4\\t\\t4-2 = 2\\n\\t1,2,4\\t\\t4-1 = 3\\n\\t3,1,2,4\\t\\t4-1 = 3\\n\\nanswer = 0+0+0+0+2+1+1+1+3+2+2+3+2+3+3 = 23 **-------------------- reference (1)**\\n\\nLet us calculate the total number of occurrences of maximum and minimum elements from these subsequence .\\n\\nMaximum side occurrences: **-------------------- reference (2)**\\n\\'3\\' occurred 4 times\\n\\'1\\' occurred 1 times\\n\\'2\\' occurred 2 times\\n\\'4\\' occurred 8 times\\n\\nMinimum side occurrences:  **-------------------- reference (3)**\\n\\'3\\' occurred 2 times\\n\\'1\\' occurred 8 times\\n\\'2\\' occurred 4 times\\n\\'4\\' occurred 1 times\\n\\nultimately the effective frequencies of elements would be:\\n\\'4\\' occurred 8-1 = 7 times\\n\\'3\\' occurred 4-2 = 2 times\\n\\'2\\' occurred 2-4 = -2 times\\n\\'1\\' occurred 1-8 = -7 times\\n\\nanswer would be:\\n(7 * 4) + (2 * 3) + (-2 * 2) + (-7 * 1) = 28+6-4-7 = 23\\nsame answer right? (**reference (1)**)\\n\\nNow let us get a detailed view of the maximum side occurrences of **4**:\\n\\n\\t4\\t\\t\\t4-4 = 0\\n\\t3,4\\t\\t\\t4-3 = 1\\n\\t1,4\\t\\t\\t4-1 = 3\\n\\t2,4\\t\\t\\t4-2 = 2\\n\\t3,1,4\\t\\t4-1 = 3\\n\\t3,2,4\\t\\t4-2 = 2\\n\\t1,2,4\\t\\t4-1 = 3\\n\\t3,1,2,4\\t\\t4-1 = 3\\n\\nsubsequence  with \\nlength 4 occurred 1 times\\nlength 3 occurred 3 times\\nlength 2 occurred 3 times\\nlength 1 occurred 1 times\\n\\nLet us sort the array in ascending order,\\n[1,2,3,4]\\n\\nSo, to generate subsequence with length 4 we need to include 3 elements from the remaining 3 elements = 3C3 \\t= 1\\nto generate subsequence with length 3 we need to include 2 elements from the remaining 3 elements = 3C2\\t\\t= 3\\nto generate subsequence with length 2 we need to include 1 elements from the remaining 3 elements = 3C1\\t\\t= 3\\nto generate subsequence with length 1 we need to include 0 elements from the remaining 3 elements = 3C0\\t\\t= 1\\n\\nSo, total occurrence of 4:\\n3C3 + 3C2 + 3C1 + 3C0 = 2^3 = 8 (nC0 + nC1 + nC2 + ... + nCn = 2^n)\\n\\nSimilarly, for the whole array,\\n[1,2,3,4]\\n\\n4 -> 2^3 = 8\\n3 -> 2^2 = 4\\n2 -> 2^1 = 2\\n1 -> 2^0 = 1\\nBasically 2 to the power of remaining elements those are lesser than the current element.\\n\\nSimilarly to get the occurrences of minimum side:\\n[1,2,3,4]\\n\\n1 -> 2^3 = 8\\n2 -> 2^2 = 4\\n3 -> 2^1 = 2\\n4 -> 2^0 = 1\\n\\nTo get the effective frequencies we need to subtract the minimum side occurrence of each element from its maximum side occurrence.\\nThe answer would be:\\n((8-1)*4) + ((4-2)*3) + ((2-4)*2) + ((1-8)*1) = 28+6-4-7 = 23\\n\\nBasically, to get the effective frequencies, we need to generate the 2 power array, and reversed version of the 2 power array and then subtract each element.\\ni.e. \\n\\n\\t[8,4,2,1] - \\n\\t[1,2,4,8]\\n\\t= [8-1, 4-2, 2-4, 1-8]\\n\\t= [7, 2, -2, -7]\\n\\nAnd ultimately we multiply them with values of our sorted array ([1,2,3,4]).\\n\\nHere is the code:\\n\\n```\\npublic int sumSubseqWidths(int[] nums) {\\n       long twoPower [] =new long[nums.length];\\n       long mod = 1000000007L;\\n       twoPower[0] =1;\\n\\t   // generating 2 power array\\n       for (int i = 1; i< nums.length; i++){\\n           twoPower[i] = (twoPower[i-1]*2)%mod;\\n       }\\n       long effective[] = new long[nums.length];\\n\\t   // generating effective frequency array  by subtracting the 2 power array\\'s elements from its reverse view\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   effective[i] = (twoPower[i]- twoPower[nums.length- i-1]);\\n       }\\n       Arrays.sort(nums); // sorting the array\\n       long ans = 0;\\n\\t   // now, to get the answer we multiply the elements of the sorted array with the effective frequency array elements\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   ans = (ans+ effective[i]*nums[i])%mod;\\n       }\\n       return (int) ans;\\n   }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int sumSubseqWidths(int[] nums) {\\n       long twoPower [] =new long[nums.length];\\n       long mod = 1000000007L;\\n       twoPower[0] =1;\\n\\t   // generating 2 power array\\n       for (int i = 1; i< nums.length; i++){\\n           twoPower[i] = (twoPower[i-1]*2)%mod;\\n       }\\n       long effective[] = new long[nums.length];\\n\\t   // generating effective frequency array  by subtracting the 2 power array\\'s elements from its reverse view\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   effective[i] = (twoPower[i]- twoPower[nums.length- i-1]);\\n       }\\n       Arrays.sort(nums); // sorting the array\\n       long ans = 0;\\n\\t   // now, to get the answer we multiply the elements of the sorted array with the effective frequency array elements\\n       for (int i = 0; i< nums.length; i++) {\\n    \\t   ans = (ans+ effective[i]*nums[i])%mod;\\n       }\\n       return (int) ans;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1667728,
                "title": "python-sort-and-sum-the-contribution",
                "content": "My solution was largely inspired by [this solution for question 2104](https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624416/python3-stack/1203869). I happened to saw the question yesterday, and loved the idea there. Similar to that question, we can solve this question by counting the contribution to the max values and min values separately. The only difference is that [question 2104](https://leetcode.com/problems/sum-of-subarray-ranges/) is asking for sub arrays, but this one is asking for subsequences. But the general idea behind the solution is the same.\\n\\nThe core idea is, for each subsequence, we have one max and one min (can be the same), so when we have the `(max1-min1) + (max2 - min2) + ... + (max_n - min_n)`, we can just separate them to `max_val = max1 + max2 + ... + max_n` and `min_val = min1 + min2 + ... min_n`. The final answer if `max_val - min_val`. \\n\\nThe trick for finding the `max_val` and `min_val` lies in **the number of times a number `x` contributes to the `min_val` or `max_val`**.  Think about this, if we have a **sorted** array `[a, b, 1, c]`, we know `1` can be the max, if a subsequence containing only `1` and `a`, `b`. Similarly, any subsequence containing `1` and `c` will have `1` as `min_val`. \\n\\nLet\\'s do an example for `1` as `max_val`, we can have subsequence `[1]`, `[a, 1]`, `[b, 1]`, and `[a, b, 1]`. In another words, we are selecting elements from `a` and `b`. The number of subsequences with `1` as `max_val` is `choose(0, 2) + choose(1, 2) + choose(2, 2)` (`choose` is the function nCr or combination in math). Therefore, we know `1` contributes *4 times* to the `max_val`. \\n\\nUsing the same method, we can calculate the number of times a number contributes to the max and min. Then we have the answer.\\n\\nHere is the code:\\n```python\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        max_val = min_val = 0\\n        MOD = 10 ** 9 + 7\\n        size = len(nums)\\n        for index, num in enumerate(nums):\\n            max_val = (max_val + num * pow(2, index, MOD)) % MOD\\n            min_val = (min_val + num * pow(2, size - index - 1, MOD)) % MOD\\n        return (max_val - min_val) % MOD\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        max_val = min_val = 0\\n        MOD = 10 ** 9 + 7\\n        size = len(nums)\\n        for index, num in enumerate(nums):\\n            max_val = (max_val + num * pow(2, index, MOD)) % MOD\\n            min_val = (min_val + num * pow(2, size - index - 1, MOD)) % MOD\\n        return (max_val - min_val) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204444,
                "title": "solution-using-fenwick-tree-binary-indexed-tree",
                "content": "We can solve this problem without sorting, instead using\\n a Fenwick Tree (a.k.a. Binary Indexed Tree, BIT).\\n\\n\\n### How Fenwick Trees Work\\nFor those who have not heard of Fenwick Trees before, it would be helpful to take a look at https://en.wikipedia.org/wiki/Fenwick_tree .\\n\\nIn short, a Fenwick Tree is an array and provides two interfaces. Let `bit` be an array expressing a Fenwick Tree initialized by a certain **1-indexed** array `X`. it offers the following operations:\\n- `query_sum(bit, idx)` : returns `X[1] + ... + X[idx]`\\n- `add_sum(bit, idx, value)`: add `value` to `X[idx]`\\nLet N be `len(X)`. Both operations are done in O(logN) time. \\n\\nThe happy thing is that you can implement them very concisely:\\n\\n```Python\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\ndef add_sum(bit, idx, value):\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n```\\nNote again that this is 1-indexed.\\n\\n### My Solution\\nWe can create a Fenwick tree `bit`  such that `query_sum(bit, item)` returns how many items smaller than `item`  there are in `A`, namely each index of `bit` has the number of `item - 1\\n`s in `A` and you can calculate the total number of occurrances of `1, 2, .., item - 1` by `query(bit, item)` in O(lgW) time, where W is `max(A)`.\\nMy solution has mainly 3 parts:\\n1. initialize `bit` from `A`\\n2. Count the number of each item of `A`\\n3. For each `item` and its `count`,  calculate how many times it appears as the minimum or maximum value  of all the subarrays\\n    - We easily know how many items in ` A` are smaller or larger than `item` by:\\n\\t\\t- `num_smaller = query_sum(bit, item)`\\n\\t\\t- `num_larger = N - num_smaller - count`\\n    - The number of subarrays which have `item` as maximum is `(2**num_smaller - 1) * (2**count - 1)` . Likewise, the number of subarrays having `item` as minimum is `(2**num_larger - 1) * (2**count - 1)`\\n    - Add the total contribution of `(2**smaller - 2**larger) * item * (2**count - 1)` to `ans`\\n \\n **Python**\\n ```\\nfrom collections import defaultdict\\n\\n\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\n\\ndef add_sum(bit, idx, value):\\n    \"\"\"\\n    add value to a[i].\\n    \"\"\"\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n\\n\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MOD = 10**9 + 7\\n        N = len(A)\\n\\n        # 1, 2: initialize bit and count items in A\\n        max_item = max(A)\\n        bit = [0] * (max_item + 100)\\n        ans = 0\\n        counter_A = [0] * (max_item + 1)\\n        for item in A:\\n            add_sum(bit, item + 1, 1)\\n            counter_A[item] += 1\\n\\n        # trivial: it is faster to calculate pow(2, hoge) beforehand\\n        pows = [1]\\n        for _ in range(N):\\n            pows.append(pows[-1] * 2 % MOD)\\n        \\n        # 3: add up each contribution\\n        for item, count in enumerate(counter_A[1:], start=1):\\n            if count == 0: continue\\n            num_smallers = query_sum(bit, item)\\n            num_largers = N - num_smallers - count\\n            ans += (pows[num_smallers] - pows[num_largers]) * item * (pows[count] - 1)\\n            ans %= MOD\\n        return ans\\n ```\\n \\n **C++**\\n ```\\n#include <bits/stdc++.h>\\n#define ll long long\\nusing namespace std;\\n\\n\\nint query_sum(vector<int>& bit, int idx) {\\n    int sum_ = 0;\\n    while (idx > 0) {\\n        sum_ += bit.at(idx);\\n        idx -= idx & -idx;\\n    }\\n    return sum_;\\n}\\n\\nvoid add_sum(vector<int>& bit, int idx, int value) {\\n    while (idx <= bit.size()) {\\n        bit.at(idx) += value;\\n        idx += idx & -idx;\\n    }\\n    return;\\n}\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        const ll MOD = 1000000000 + 7;\\n        const int N = A.size();\\n        int max_A = 0;\\n        for (int i = 0; i < N; i++) {\\n            max_A = max(max_A, A.at(i));\\n        }\\n        vector<int> bit(max_A + 100, 0);\\n        vector<int> counter(max_A + 100, 0);\\n        for (int i = 0; i < N; i++) {\\n            int item = A.at(i);\\n            add_sum(bit, item + 1, 1);\\n            counter.at(item) += 1;\\n        }\\n\\n        vector<ll> pows(N + 1, 1);\\n        for (int i = 1; i < N + 1; i++) {\\n            ll prev_pow = pows.at(i - 1);\\n            pows.at(i) = prev_pow * 2 % MOD;\\n        }\\n\\n        ll ans = 0;\\n        for (int item = 1; item < max_A + 1; item++) {\\n            int count = counter.at(item);\\n            if (count == 0) continue;\\n            int num_smallers = query_sum(bit, item);\\n            int num_largers = N - num_smallers - count;\\n            ans += (pows.at(num_smallers) - pows.at(num_largers)) * item % MOD * (pows.at(count) - 1) % MOD;\\n            ans %= MOD;\\n        }\\n        return ans;\\n    }\\n};\\n ```\\nThe total time complexity is O(N + NlgW) and space complexity is O(N + W), where N and W are `len(A)` and `max(A)` respectively.\\nHope this will give you a new perspective!!",
                "solutionTags": [],
                "code": "```Python\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\ndef add_sum(bit, idx, value):\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n```\n```\\nfrom collections import defaultdict\\n\\n\\ndef query_sum(bit, idx):\\n    sum_ = 0\\n    while idx > 0:\\n        sum_ += bit[idx]\\n        idx -= idx & -idx\\n    return sum_\\n\\n\\ndef add_sum(bit, idx, value):\\n    \"\"\"\\n    add value to a[i].\\n    \"\"\"\\n    while idx <= len(bit):\\n        bit[idx] += value\\n        idx += idx & -idx\\n\\n\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MOD = 10**9 + 7\\n        N = len(A)\\n\\n        # 1, 2: initialize bit and count items in A\\n        max_item = max(A)\\n        bit = [0] * (max_item + 100)\\n        ans = 0\\n        counter_A = [0] * (max_item + 1)\\n        for item in A:\\n            add_sum(bit, item + 1, 1)\\n            counter_A[item] += 1\\n\\n        # trivial: it is faster to calculate pow(2, hoge) beforehand\\n        pows = [1]\\n        for _ in range(N):\\n            pows.append(pows[-1] * 2 % MOD)\\n        \\n        # 3: add up each contribution\\n        for item, count in enumerate(counter_A[1:], start=1):\\n            if count == 0: continue\\n            num_smallers = query_sum(bit, item)\\n            num_largers = N - num_smallers - count\\n            ans += (pows[num_smallers] - pows[num_largers]) * item * (pows[count] - 1)\\n            ans %= MOD\\n        return ans\\n ```\n```\\n#include <bits/stdc++.h>\\n#define ll long long\\nusing namespace std;\\n\\n\\nint query_sum(vector<int>& bit, int idx) {\\n    int sum_ = 0;\\n    while (idx > 0) {\\n        sum_ += bit.at(idx);\\n        idx -= idx & -idx;\\n    }\\n    return sum_;\\n}\\n\\nvoid add_sum(vector<int>& bit, int idx, int value) {\\n    while (idx <= bit.size()) {\\n        bit.at(idx) += value;\\n        idx += idx & -idx;\\n    }\\n    return;\\n}\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        const ll MOD = 1000000000 + 7;\\n        const int N = A.size();\\n        int max_A = 0;\\n        for (int i = 0; i < N; i++) {\\n            max_A = max(max_A, A.at(i));\\n        }\\n        vector<int> bit(max_A + 100, 0);\\n        vector<int> counter(max_A + 100, 0);\\n        for (int i = 0; i < N; i++) {\\n            int item = A.at(i);\\n            add_sum(bit, item + 1, 1);\\n            counter.at(item) += 1;\\n        }\\n\\n        vector<ll> pows(N + 1, 1);\\n        for (int i = 1; i < N + 1; i++) {\\n            ll prev_pow = pows.at(i - 1);\\n            pows.at(i) = prev_pow * 2 % MOD;\\n        }\\n\\n        ll ans = 0;\\n        for (int item = 1; item < max_A + 1; item++) {\\n            int count = counter.at(item);\\n            if (count == 0) continue;\\n            int num_smallers = query_sum(bit, item);\\n            int num_largers = N - num_smallers - count;\\n            ans += (pows.at(num_smallers) - pows.at(num_largers)) * item % MOD * (pows.at(count) - 1) % MOD;\\n            ans %= MOD;\\n        }\\n        return ans;\\n    }\\n};\\n ```",
                "codeTag": "C++"
            },
            {
                "id": 161299,
                "title": "this-is-bulls-2-xx-gives-me-tle-whereas-passed-seriously",
                "content": "I spent the last 40 minutes trying to come up w/ a better than O(nlonn) solution, which I don\\'t think exists. So I\\'m curious and waiting for smarter solution... And it turned out that the catch is the bit-wise opearting when computing power of 2s. \\n\\nIf you un-comment the code you will find that you get TLE... \\n\\nI understand bit-wise operator is faster than ** , but if this is the speed limit, I don\\'t think its fair. Plus who cares whether its ** or a more hacky << ? \\n\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        CONST = 10 ** 9 + 7\\n        A = sorted(A, key=lambda x: -x)\\n        n = len(A)\\n        ans = 0\\n        for i in range(n):\\n            ans += A[i] * (2 ** (n-i-1) - 2 ** i)         # <- This you get TLE \\n            # ans += A[i] * ((1 << (n-i-1)) - (1 << i))       # <- This you pass\\n        return ans % CONST\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        CONST = 10 ** 9 + 7\\n        A = sorted(A, key=lambda x: -x)\\n        n = len(A)\\n        ans = 0\\n        for i in range(n):\\n            ans += A[i] * (2 ** (n-i-1) - 2 ** i)         # <- This you get TLE \\n            # ans += A[i] * ((1 << (n-i-1)) - (1 << i))       # <- This you pass\\n        return ans % CONST\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961298,
                "title": "python3-a-much-easier-way-to-build-the-math-logic",
                "content": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, A: List[int]) -> int:\\n\\t\\t\\t# Note:  sub sequence, not sub array\\n\\t\\t\\t# after sorting, for each i \\n\\t\\t\\t# -  A[i] will serve as max for 2**i combinations with elements from A[:i], which makes additions to res\\n\\t\\t\\t# -  A[i] will serve as min for 2**(n-1-i) combinations with elements from A[i+1:n], which makes deductions to res\\n\\t\\t\\t# we just need to enumerate i, and update the res\\n\\n\\t\\t\\tA = sorted(A)\\n\\t\\t\\tM = 10**9 + 7\\n\\t\\t\\tP = [(2**i)%M for i in range(len(A))] \\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(A)):\\n\\t\\t\\t\\tadd = P[i] * A[i]\\n\\t\\t\\t\\tded = P[len(A)-1-i]* A[i]\\n\\t\\t\\t\\tres += (add - ded)%M\\n\\t\\t\\t\\tres = res%M\\n\\t\\t\\treturn res\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, A: List[int]) -> int:\\n\\t\\t\\t# Note:  sub sequence, not sub array\\n\\t\\t\\t# after sorting, for each i \\n\\t\\t\\t# -  A[i] will serve as max for 2**i combinations with elements from A[:i], which makes additions to res\\n\\t\\t\\t# -  A[i] will serve as min for 2**(n-1-i) combinations with elements from A[i+1:n], which makes deductions to res\\n\\t\\t\\t# we just need to enumerate i, and update the res\\n\\n\\t\\t\\tA = sorted(A)\\n\\t\\t\\tM = 10**9 + 7\\n\\t\\t\\tP = [(2**i)%M for i in range(len(A))] \\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(A)):\\n\\t\\t\\t\\tadd = P[i] * A[i]\\n\\t\\t\\t\\tded = P[len(A)-1-i]* A[i]\\n\\t\\t\\t\\tres += (add - ded)%M\\n\\t\\t\\t\\tres = res%M\\n\\t\\t\\treturn res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 161265,
                "title": "black-magic",
                "content": "```\\nA.sort()\\nlookup = [1] * len(A)\\nfor i in xrange(1, len(A)):\\n\\tlookup[i] = (lookup[i-1]) * 2 % 1000000007 \\nreturn sum([A[i] * (lookup[i] - lookup[len(A)-i-1]) for i in xrange(len(A))]) % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nA.sort()\\nlookup = [1] * len(A)\\nfor i in xrange(1, len(A)):\\n\\tlookup[i] = (lookup[i-1]) * 2 % 1000000007 \\nreturn sum([A[i] * (lookup[i] - lookup[len(A)-i-1]) for i in xrange(len(A))]) % 1000000007\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 162583,
                "title": "python-solution-with-detailed-steps",
                "content": "dp[i] represent A[:i+1]\\'s sum of subsequence widths.\\nobviously, dp[0] = 0(only A[0]), dp[1] = A[1]-A[0]\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/2017111303/image_1535013111.png)\\ncare about 2^i, it\\'s very large(i<20000), so we should mod 1e9+7 before we calculate the result!\\nI use rec[i] represent 2^i,as a global variable\\n\\n```python\\nrec,mod,s = [],10**9+7,1\\nfor i in range(20000):\\n    rec.append(s)\\n    s *= 2\\n    s %= mod\\n\\ndef sumSubseqWidths(A):\\n\\tA.sort()\\n\\tdp = [0] * len(A)\\n\\tdp[0],dp[1] = 0,A[1]-A[0]\\n\\tfor i in range(2,len(dp)):\\n\\t\\tdp[i] = (3*dp[i-1] - 2*dp[i-2] + (A[i]-A[i-1]) * (rec[i]-1)) % mod\\n\\treturn dp[-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\nrec,mod,s = [],10**9+7,1\\nfor i in range(20000):\\n    rec.append(s)\\n    s *= 2\\n    s %= mod\\n\\ndef sumSubseqWidths(A):\\n\\tA.sort()\\n\\tdp = [0] * len(A)\\n\\tdp[0],dp[1] = 0,A[1]-A[0]\\n\\tfor i in range(2,len(dp)):\\n\\t\\tdp[i] = (3*dp[i-1] - 2*dp[i-2] + (A[i]-A[i-1]) * (rec[i]-1)) % mod\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3963373,
                "title": "calculate-contribution-of-each-element",
                "content": "# Intuition\\nSince the contraints are very strict to try and go for brute force approach, we try to solve this question by calculating contribution of each element\\n\\n# Approach\\nSort the array firstly. Then at each index we have to calculate in how many subsequence will the current element be maximum and minimum.\\n1) Maximum case\\n   All the subsequences ending at current index will have the maximum  element as nums[i]. 2*i subsequences\\n2) Minimum case\\nAll the subsequences starting at current index will have minimum element as nums[i]. 2*(n-i-1) subsequences\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    #define ll long long\\n    int mod = 1e9+7;\\n    int power(ll x, ll y) {\\n        int res = 1;  \\n        x = x % mod; \\n        if (x == 0) return 0;\\n    \\n        while (y > 0) {\\n            if (y & 1)\\n                res = (res*x) % mod;\\n    \\n            y = y>>1; \\n            x = (x*x) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ll ans = 0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0 ; i<n ; ++i) {\\n            ans = (ans + nums[i]*1ll*power(2,i))%mod;\\n            ans = (ans - nums[i]*1ll*power(2,n-i-1))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\n    int mod = 1e9+7;\\n    int power(ll x, ll y) {\\n        int res = 1;  \\n        x = x % mod; \\n        if (x == 0) return 0;\\n    \\n        while (y > 0) {\\n            if (y & 1)\\n                res = (res*x) % mod;\\n    \\n            y = y>>1; \\n            x = (x*x) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ll ans = 0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0 ; i<n ; ++i) {\\n            ans = (ans + nums[i]*1ll*power(2,i))%mod;\\n            ans = (ans - nums[i]*1ll*power(2,n-i-1))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545992,
                "title": "c-891-sum-of-subsequence-widths",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size(), MOD = 1\\'000\\'000\\'007; \\n        vector<long> p(n, 1); \\n        for (int i = 1; i < n; ++i) p[i] = 2*p[i-1]%MOD; \\n        \\n        long ans = 0; \\n        sort(nums.begin(), nums.end()); \\n        for (int i = 0; i < n; ++i) \\n            ans = (ans + nums[i] * (p[i] - p[n-1-i])) % MOD; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size(), MOD = 1\\'000\\'000\\'007; \\n        vector<long> p(n, 1); \\n        for (int i = 1; i < n; ++i) p[i] = 2*p[i-1]%MOD; \\n        \\n        long ans = 0; \\n        sort(nums.begin(), nums.end()); \\n        for (int i = 0; i < n; ++i) \\n            ans = (ans + nums[i] * (p[i] - p[n-1-i])) % MOD; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550718,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int mod=1000000007;\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        long first=0;\\n        long second=0;\\n        long pow[]=new long[n+1];\\n        pow[0] = 1;\\n        for (int i = 1; i<n;i++){\\n            pow[i] = (pow[i-1] * 2) % mod;\\n        }    \\n        for(int i=1;i<nums.length;i++){\\n            long a=nums[i];\\n            long r=2;\\n            int len=i;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            first=(first+sum)%mod;\\n        }\\n         \\n        for(int j=0;j<nums.length-1;j++){\\n            long a=nums[j];\\n            long r=2;\\n            int len=n-j-1;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            second=(second+sum)%mod;\\n        }\\n        long res=first-second;\\n        if(res<0)res+=mod;\\n        return (int)(res);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int mod=1000000007;\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        long first=0;\\n        long second=0;\\n        long pow[]=new long[n+1];\\n        pow[0] = 1;\\n        for (int i = 1; i<n;i++){\\n            pow[i] = (pow[i-1] * 2) % mod;\\n        }    \\n        for(int i=1;i<nums.length;i++){\\n            long a=nums[i];\\n            long r=2;\\n            int len=i;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            first=(first+sum)%mod;\\n        }\\n         \\n        for(int j=0;j<nums.length-1;j++){\\n            long a=nums[j];\\n            long r=2;\\n            int len=n-j-1;\\n            long sum=((a*(pow[len]-1))/(r-1))%mod;\\n            second=(second+sum)%mod;\\n        }\\n        long res=first-second;\\n        if(res<0)res+=mod;\\n        return (int)(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511726,
                "title": "solution",
                "content": "```C++ []\\nconst long M=1e9+7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long sum=0, cnt=1;\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=0, j=n-1; i<n; sum=(sum+(nums[i++]-nums[j--])*cnt)%M, cnt=cnt*2%M) {}\\n        return sum;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n        nums.sort()\\n        ans, pow2 = 0, 1\\n        for x, y in zip(nums, reversed(nums)):\\n            ans += (x - y) * pow2\\n            pow2 = pow2 * 2 % mod\\n        return ans % mod\\n```\\n\\n```Java []\\nclass Solution {\\n\\tpublic int sumSubseqWidths(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tlong c = 1;\\n\\t\\tlong result = 0;\\n\\t\\tlong mod = 1000000007L;\\n\\t\\tfor (int i = 0, j = nums.length - 1; i < nums.length; i++, j--) {\\n\\t\\t\\tresult = (result + (nums[i] * c) - (nums[j] * c)) % mod;\\n\\t\\t\\tc = (c * 2) % mod;\\n\\t\\t}\\n\\t\\treturn (int) ((result + mod) % mod);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nconst long M=1e9+7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long sum=0, cnt=1;\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=0, j=n-1; i<n; sum=(sum+(nums[i++]-nums[j--])*cnt)%M, cnt=cnt*2%M) {}\\n        return sum;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = 10**9 + 7\\n        nums.sort()\\n        ans, pow2 = 0, 1\\n        for x, y in zip(nums, reversed(nums)):\\n            ans += (x - y) * pow2\\n            pow2 = pow2 * 2 % mod\\n        return ans % mod\\n```\n```Java []\\nclass Solution {\\n\\tpublic int sumSubseqWidths(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tlong c = 1;\\n\\t\\tlong result = 0;\\n\\t\\tlong mod = 1000000007L;\\n\\t\\tfor (int i = 0, j = nums.length - 1; i < nums.length; i++, j--) {\\n\\t\\t\\tresult = (result + (nums[i] * c) - (nums[j] * c)) % mod;\\n\\t\\t\\tc = (c * 2) % mod;\\n\\t\\t}\\n\\t\\treturn (int) ((result + mod) % mod);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791666,
                "title": "c-easy-shorts",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740307,
                "title": "golang-runtime-283-ms-faster-than-16-67",
                "content": "- Runtime: 283 ms, faster than 16.67% of Go online submissions for Sum of Subsequence Widths.\\n- Memory Usage: 8.4 MB, less than 100.00% of Go online submissions for Sum of Subsequence Widths.\\n```\\nfunc sumSubseqWidths(nums []int) int {\\n    sort.Ints(nums)\\n\\tres, mod, n, p := 0, 1000000007, len(nums), 1\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tres = (res + (nums[i]-nums[n-1-i])*p) % mod\\n\\t\\tp = (p << 1) % mod\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc sumSubseqWidths(nums []int) int {\\n    sort.Ints(nums)\\n\\tres, mod, n, p := 0, 1000000007, len(nums), 1\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tres = (res + (nums[i]-nums[n-1-i])*p) % mod\\n\\t\\tp = (p << 1) % mod\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2537337,
                "title": "magical-solution-true-for-all-complexity-nlogn",
                "content": "\\n![image](https://assets.leetcode.com/users/images/1ed44939-621b-4e4b-b1ac-6d9d638a9075_1662429184.0499213.png)\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "\\n![image](https://assets.leetcode.com/users/images/1ed44939-621b-4e4b-b1ac-6d9d638a9075_1662429184.0499213.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2350649,
                "title": "simple-easy-method-for-those-who-did-not-understand-c",
                "content": "In this question if we deeply try to think then we can able to understand that order of elements does not matter because we are actually choosing the all subsequences and take the difference of maximum and minimum values.\\nNow coming to max and min values, we wants to find the contribution of each array elements in thier subsequence they are part with where they are minimum and maximum.\\n1) There are 2 ^ i sequence are possible in which a[i]th element are maxmium. \\ne.g. [2, 3, 5] => here 2 is contibuting in sequnces [2], [2, 3] , [2, 5], [2, 3, 5] now we can easily see that 2 is maximum in only single sequnce which is [2].\\n2) Now whatever the sequence left i.e. 2 ^( n - i - 1) sequences are possible in which a[i]th element is minimum.\\n\\nNow the problem is solved , but some might get memory limit exceeded due to not perfom the mod operation in right way here we just use mod operation as simpe way and do addition first so that answer will always be positive so there will be no chance of mistake.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        vector < long long > pow(nums.size() ); \\n        pow[0] = 1;\\n          for(int i = 1 ; i<nums.size(); i++){ \\n             pow[i] = pow[i-1] * 2 % 1000000007; \\n          }\\n        sort(nums.begin() , nums.end()); \\n       long long ans = 0 ;   \\n        for(int i = 0 ; i<nums.size(); i++){ \\n              ans = (ans + pow[i]*nums[i]) % 1000000007; \\n               ans = (ans - pow[nums.size()-i-1] * (long long)nums[i] ) % 1000000007; \\n           \\n          } \\n        return ans; \\n    }\\n};\\n```\\n\\n```\\nwhile(1){ \\nif(likes == true){ \\n  upvotes +=1; \\n}\\nelse { \\nlike = true; \\ncontinue; \\n}\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        vector < long long > pow(nums.size() ); \\n        pow[0] = 1;\\n          for(int i = 1 ; i<nums.size(); i++){ \\n             pow[i] = pow[i-1] * 2 % 1000000007; \\n          }\\n        sort(nums.begin() , nums.end()); \\n       long long ans = 0 ;   \\n        for(int i = 0 ; i<nums.size(); i++){ \\n              ans = (ans + pow[i]*nums[i]) % 1000000007; \\n               ans = (ans - pow[nums.size()-i-1] * (long long)nums[i] ) % 1000000007; \\n           \\n          } \\n        return ans; \\n    }\\n};\\n```\n```\\nwhile(1){ \\nif(likes == true){ \\n  upvotes +=1; \\n}\\nelse { \\nlike = true; \\ncontinue; \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159982,
                "title": "py-3-sorting-no-comments-video-refrence",
                "content": "[ Credits PepCoding](https://www.youtube.com/watch?v=kSo8W6ZGYqw&list=PL-Jc9J83PIiE-TR27GB7V5TBLQRT5RnSl&index=50&ab_channel=Pepcoding)\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = 0\\n        for i in range(n):\\n            ans += nums[i] * 1<<i\\n            ans -= nums[i] * 1<<(n-i-1)\\n        return ans%(10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = 0\\n        for i in range(n):\\n            ans += nums[i] * 1<<i\\n            ans -= nums[i] * 1<<(n-i-1)\\n        return ans%(10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027479,
                "title": "2-line-python-sorting-subset-with-thought-process-when-being-asked-during-interviews",
                "content": "### Sorting + Subset\\nThis problem is similar with the [2104. Sum of Subarray Ranges](https://leetcode.com/problems/sum-of-subarray-ranges/), while the solution is significantly different. But the idea is similar, we just get the sum of maximum and sum of minimum respetively, then get the final answer by subtraction.\\n\\nInteresting tips:\\n * Use stack when seeing maximum/minimum of subarrays since order matters.\\n * Use sorting when seeing maximum/minimum of subsequences since order doesn\\'t matter with removal.\\n\\nThen the first step is that for each number `nums[i]`, we need calculate the sum of subsequences that the `nums[i]` is maximum. In order to have `nums[i]` maximum, we can only put the numbers that are smaller than `nums[i]`. For instance, `[1,2,3,4]`, we want to calculate the sum of subsequences for `3`, then only `[1, 2]` can be put into the subsequences, finally add `3`. \\n\\nSo the second step is that how many subsequences we can construct given list of numbers? It\\'s `2 ^ size of list`. Why?\\nBecause for each number, we have only 2 options to include it or not, if all included, it\\'s `[1,2]`, otherwise if all not included, it\\'s empty set/list `[]`. \\nThen the number of subsets/subsequences we can construct is `2 ^ size of list`.\\nFinally, it\\'s quite simply, we need to know the number of integers that are smaller than `nums[i]`, so sorting is the solution.\\nLet\\'s put it all together:\\n1. sort the `nums`\\n2. iterate each number and sum up of `nums[i] * ((1 << i) - (1 << n - i - 1))`\\n3. modulus the result.\\n\\nYou might find that you got TLE with this solution, because shifting bit is expensive when `n` is large. So we can modulus `M` whenever shifting bits. \\nAlternatively use `pow(2, i, M)`.\\n\\n```python\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t# 1Cn + 2Cn + 3Cn ... nCn\\n    # 1 * 2 ^ 0 + 2 * 2 ^ 1 + 3 * 2 ^ 2 = 1 + 4 + 12 = 17\\n    # 1 * 2 ^ 2 + 2 * 2 ^ 1 + 3 * 2 ^ 0 = 4 + 4 + 3 = 11\\n    # 2 ^ number of subsets        \\n    n, M = len(nums),10 ** 9 + 7\\n    return sum(nums[index] * (pow(2, i, M) - pow(2, n - i - 1, M)) for i, index in enumerate(sorted(range(n), key=lambda x: nums[x]))) % M\\n```\\n\\n*Time Complexity*= **O(NlgN)**\\n*Space Complexity*= **O(1)**\\n\\n\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```python\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t# 1Cn + 2Cn + 3Cn ... nCn\\n    # 1 * 2 ^ 0 + 2 * 2 ^ 1 + 3 * 2 ^ 2 = 1 + 4 + 12 = 17\\n    # 1 * 2 ^ 2 + 2 * 2 ^ 1 + 3 * 2 ^ 0 = 4 + 4 + 3 = 11\\n    # 2 ^ number of subsets        \\n    n, M = len(nums),10 ** 9 + 7\\n    return sum(nums[index] * (pow(2, i, M) - pow(2, n - i - 1, M)) for i, index in enumerate(sorted(range(n), key=lambda x: nums[x]))) % M\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1753530,
                "title": "c-solution-time-complexity-o-n-log-n-space-complexity-o-1",
                "content": "For each number we have 2 choices, whether to include it in our subsequence or not. So for any choosen subsequence we have 2 choices for every element except for min and max element. \\n\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        long long two=1;\\n        int i=0,j=nums.size()-1;\\n        long long left=0,right=0;\\n        while(j>=0){\\n            left=left+nums[i++];\\n            right=right+nums[j--];\\n            long long sum=((right-left)*two)%int(1e9+7);\\n            ans=(ans+sum)%int(1e9+7);\\n            two=(two*2)%int(1e9+7);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        long long two=1;\\n        int i=0,j=nums.size()-1;\\n        long long left=0,right=0;\\n        while(j>=0){\\n            left=left+nums[i++];\\n            right=right+nums[j--];\\n            long long sum=((right-left)*two)%int(1e9+7);\\n            ans=(ans+sum)%int(1e9+7);\\n            two=(two*2)%int(1e9+7);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694290,
                "title": "c-solution-math-combinatorics-explained",
                "content": "Observation: The answer will be sum of Max element of each subsequence - sum of Min elements of each subsequence\\n\\nLength of nums = N\\nLets consider and element X which occurs xn times, there are L numbers strictly less than X and G numbers strictly greater than X.\\n\\nTherefore,\\nnx + L + G = N\\n\\nthe number of subsequences where X is the minimum is (there is atleast one X):\\n\\t(number of X\\'s we can chhose from nx X\\'s ) * (number of susequences formed from the Greater G elements)\\n\\t\\n\\tsub_x_min = (nxC1 + nxC2 + ... nxCnx) * (GC0 + GC1 + GC2 + ... GCG)\\n\\tsub_x_min = ( 2 ^ (nx) - 1 ) * (2 ^ (G))\\nTherefore for every X in nums the sum of Min elements of each subsequence will be:\\n\\t= sum(sub_x_min*X) for every X\\n\\t\\nRepeat the same Process but find Sum of Max elements of each subsequence\\n\\nReturn the difference of these sums.\\n\\n```\\nclass Solution {\\npublic:\\n    int MAX = 1000000007;\\n    \\n    // function for modular exponentiation to find (2^n)%MAX\\n    long long expo(vector<int>& dp, int n){\\n        if(n < 2) return n+1;\\n        if(dp[n]) return dp[n];\\n        \\n        if(n % 2 == 0){\\n            long long temp = expo(dp, n/2) % MAX;\\n            dp[n] = (temp*temp) % MAX;\\n            return dp[n];\\n        } else{\\n            dp[n] = (2 * expo(dp, n-1)) % MAX;\\n            return dp[n];\\n        }\\n    }\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mpGreater;\\n        \\n        int resHigh = 0, resLow = 0;\\n        \\n        //count of each element\\n        for(int a : nums) mpGreater[a]++;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> dp(nums.size());\\n        \\n        for(auto current : mpGreater){\\n            // number of elements greater than current element\\n            int greater = nums.end() - upper_bound(nums.begin(), nums.end(), current.first); \\n            //elements strictly lesser than current\\n            int lesser = n - current.second - greater;\\n\\n            int temp1 = expo(dp, current.second)-1;\\n            resLow = (resLow + (((expo(dp, greater) * temp1) * current.first)%MAX)) % MAX;\\n            resHigh = (resHigh + (((expo(dp, lesser) * temp1) * current.first)%MAX))%MAX;\\n            \\n        }\\n        \\n        int res = resHigh%MAX - resLow%MAX;\\n        \\n        return res < 0 ? res % MAX + MAX : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MAX = 1000000007;\\n    \\n    // function for modular exponentiation to find (2^n)%MAX\\n    long long expo(vector<int>& dp, int n){\\n        if(n < 2) return n+1;\\n        if(dp[n]) return dp[n];\\n        \\n        if(n % 2 == 0){\\n            long long temp = expo(dp, n/2) % MAX;\\n            dp[n] = (temp*temp) % MAX;\\n            return dp[n];\\n        } else{\\n            dp[n] = (2 * expo(dp, n-1)) % MAX;\\n            return dp[n];\\n        }\\n    }\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mpGreater;\\n        \\n        int resHigh = 0, resLow = 0;\\n        \\n        //count of each element\\n        for(int a : nums) mpGreater[a]++;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> dp(nums.size());\\n        \\n        for(auto current : mpGreater){\\n            // number of elements greater than current element\\n            int greater = nums.end() - upper_bound(nums.begin(), nums.end(), current.first); \\n            //elements strictly lesser than current\\n            int lesser = n - current.second - greater;\\n\\n            int temp1 = expo(dp, current.second)-1;\\n            resLow = (resLow + (((expo(dp, greater) * temp1) * current.first)%MAX)) % MAX;\\n            resHigh = (resHigh + (((expo(dp, lesser) * temp1) * current.first)%MAX))%MAX;\\n            \\n        }\\n        \\n        int res = resHigh%MAX - resLow%MAX;\\n        \\n        return res < 0 ? res % MAX + MAX : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489381,
                "title": "c-with-explanation-93-solution",
                "content": "Take a simple example\\n```\\n\\t\\tnums = [3,1,2]\\n\\t\\tWe will have \"2\"  as a highest number in \"How many sub-sequence\" ?\\n\\t\\tAns. \\n\\t\\t\\tIf we sort nums = [1, 2, 3]\\n\\t\\t\\twe will have \"2 as a highest number in 2^1 sub-sequence \"\\n\\t\\t\\tNamely [1, 2] and [2]\\n\\t\\t\\tOr we can say 2^index number of subarrays\\n\\t\\tAs we have number of time in which a certain index will be the highest number \\n\\t\\twe need to find the lowest number in each of the sub-sequence\\n\\t\\t\\n\\t\\tNow think about index => 2 \\n\\t\\t[1 ,  2,  3]  => lowest 1\\n\\t    [1,        3] => lowest 1\\n\\t\\t\\t  [2,  3] => lowest 2\\n\\t\\t\\t       [3] => lowest 3\\n\\t\\tnumber of times 1 was smallest is equal to  \"2^( index_of_3 - index_of_1  - 1) == 2 ^ (2 - 0 - 1) = 2 \\n\\t\\tnumber of times 2 was smallest is equal to  \"2^( index_of_3 - index_of_2  - 1) == 2 ^ (2 - 1 - 1) = 1 \\n\\t\\t\\n\\t\\tNow 3 as a highest number will add \\n\\t\\t\\t\\t(3 - 1) + (3 - 1) + (3 - 2) + (3 - 3) ==  3 * (  (2 ^ index_of_3) - 1 ) - 1 * 2^( index_of_3 - index_of_1  - 1) - 2 * 2^( index_of_3 - index_of_2  - 1) \\n\\t\\t\\n\\t\\tSimilary do for the remaing element starting from 0 index\\n\\t\\t\\n```\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        int n = nums.size();\\n        \\n        long long ans = 0, last = 0, p = 1;\\n        \\n        long long mod = 1e9 + 7, temp;\\n        \\n        for(int i = 0 ; i < n ; ++i){\\n            \\n            temp = ((p-1ll)*nums[i] - last ) % mod;\\n            \\n            ans = (ans + temp ) % mod;\\n            \\n            p = (p*2ll) % mod;\\n            \\n            last = (2*last + 1ll*nums[i]) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tnums = [3,1,2]\\n\\t\\tWe will have \"2\"  as a highest number in \"How many sub-sequence\" ?\\n\\t\\tAns. \\n\\t\\t\\tIf we sort nums = [1, 2, 3]\\n\\t\\t\\twe will have \"2 as a highest number in 2^1 sub-sequence \"\\n\\t\\t\\tNamely [1, 2] and [2]\\n\\t\\t\\tOr we can say 2^index number of subarrays\\n\\t\\tAs we have number of time in which a certain index will be the highest number \\n\\t\\twe need to find the lowest number in each of the sub-sequence\\n\\t\\t\\n\\t\\tNow think about index => 2 \\n\\t\\t[1 ,  2,  3]  => lowest 1\\n\\t    [1,        3] => lowest 1\\n\\t\\t\\t  [2,  3] => lowest 2\\n\\t\\t\\t       [3] => lowest 3\\n\\t\\tnumber of times 1 was smallest is equal to  \"2^( index_of_3 - index_of_1  - 1) == 2 ^ (2 - 0 - 1) = 2 \\n\\t\\tnumber of times 2 was smallest is equal to  \"2^( index_of_3 - index_of_2  - 1) == 2 ^ (2 - 1 - 1) = 1 \\n\\t\\t\\n\\t\\tNow 3 as a highest number will add \\n\\t\\t\\t\\t(3 - 1) + (3 - 1) + (3 - 2) + (3 - 3) ==  3 * (  (2 ^ index_of_3) - 1 ) - 1 * 2^( index_of_3 - index_of_1  - 1) - 2 * 2^( index_of_3 - index_of_2  - 1) \\n\\t\\t\\n\\t\\tSimilary do for the remaing element starting from 0 index\\n\\t\\t\\n```\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        int n = nums.size();\\n        \\n        long long ans = 0, last = 0, p = 1;\\n        \\n        long long mod = 1e9 + 7, temp;\\n        \\n        for(int i = 0 ; i < n ; ++i){\\n            \\n            temp = ((p-1ll)*nums[i] - last ) % mod;\\n            \\n            ans = (ans + temp ) % mod;\\n            \\n            p = (p*2ll) % mod;\\n            \\n            last = (2*last + 1ll*nums[i]) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449195,
                "title": "python-two-o-nlogn-approaches",
                "content": "Let `n` be the length of `nums`. We need to first sort `nums`. For the element at index `i` (0-based) in sorted `nums`, there are `2^i` subsequences where that element is the maximum and there are `2^(n - i - 1)` subsequences where that element is the minimum. Then, we get the following solution.\\n\\nApproach 1:\\n`O(nlogn) + O(nlogn) = O(nlogn)`\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        return sum(n * (pow(2, i, mod) - pow(2, len(nums) - i - 1, mod)) for i,n in enumerate(sorted(nums))) % mod\\n```\\n\\nWe can optimize our second step by caluculating the powers of two as we go while adding and substracting the elements using the power of two at each step.\\n\\nApproach 2:\\n`O(nlogn) + O(n) = O(nlogn)`\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mod = int(1e9 + 7)\\n        res = 0\\n        cur_pow = 1\\n        for i in range(len(nums)):\\n            res = (res + cur_pow * (nums[i] - nums[len(nums) - i - 1])) % mod\\n            cur_pow = cur_pow * 2 % mod\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        return sum(n * (pow(2, i, mod) - pow(2, len(nums) - i - 1, mod)) for i,n in enumerate(sorted(nums))) % mod\\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mod = int(1e9 + 7)\\n        res = 0\\n        cur_pow = 1\\n        for i in range(len(nums)):\\n            res = (res + cur_pow * (nums[i] - nums[len(nums) - i - 1])) % mod\\n            cur_pow = cur_pow * 2 % mod\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104026,
                "title": "java-array-math-14ms-beats-96-t-c-o-nlogn-s-c-o-n",
                "content": "\\n    public int sumSubseqWidths(int[] A) {\\n        int len = A.length, mod = 1000000007;\\n\\t\\tlong sum = 0;\\n\\t\\tArrays.sort(A);\\n\\t\\tlong[] dp = new long[len];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tdp[i] = (dp[i - 1] * 2) % mod;\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tsum = (sum + (A[i] * (dp[i] - dp[len - 1 - i]))) % mod;\\n\\n\\t\\treturn (int) (sum % mod);\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int sumSubseqWidths(int[] A) {\\n        int len = A.length, mod = 1000000007;\\n\\t\\tlong sum = 0;\\n\\t\\tArrays.sort(A);\\n\\t\\tlong[] dp = new long[len];\\n\\t\\tdp[0] = 1;\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tdp[i] = (dp[i - 1] * 2) % mod;\\n\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\tsum = (sum + (A[i] * (dp[i] - dp[len - 1 - i]))) % mod;\\n\\n\\t\\treturn (int) (sum % mod);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1093550,
                "title": "c-o-n-log-n",
                "content": "```\\nconst int m=1e9+7;\\nclass Solution {\\npublic:\\n    vector<int>POW;\\n    void init(int n)\\n    {\\n        POW.clear();\\n        POW.push_back(1);\\n        for(int i=1;i<=n;i++){\\n            int temp=POW[i-1]*2;\\n            temp%=m;\\n            POW.push_back(temp);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            POW[i]=(POW[i-1]%m+POW[i]%m)%m;\\n        }\\n    }\\n    int mul(long long int a,long long int b)\\n    {\\n        return ((a%m)*(b%m))%m;\\n    }\\n    int sumSubseqWidths(vector<int>& A) {\\n        int n=A.size();\\n        init(n);\\n        sort(A.begin(),A.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int less=i-1;\\n            int more=n-i-2;\\n            int temp=0;\\n            if(less>=0)\\n            {\\n                temp=mul(POW[less],A[i]);\\n            }\\n            if(more>=0)\\n            {\\n                temp=(temp%m+((-1*mul(POW[more],A[i]))%m+m)%m)%m;\\n            }\\n            ans=(ans%m+temp%m)%m;            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nconst int m=1e9+7;\\nclass Solution {\\npublic:\\n    vector<int>POW;\\n    void init(int n)\\n    {\\n        POW.clear();\\n        POW.push_back(1);\\n        for(int i=1;i<=n;i++){\\n            int temp=POW[i-1]*2;\\n            temp%=m;\\n            POW.push_back(temp);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            POW[i]=(POW[i-1]%m+POW[i]%m)%m;\\n        }\\n    }\\n    int mul(long long int a,long long int b)\\n    {\\n        return ((a%m)*(b%m))%m;\\n    }\\n    int sumSubseqWidths(vector<int>& A) {\\n        int n=A.size();\\n        init(n);\\n        sort(A.begin(),A.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int less=i-1;\\n            int more=n-i-2;\\n            int temp=0;\\n            if(less>=0)\\n            {\\n                temp=mul(POW[less],A[i]);\\n            }\\n            if(more>=0)\\n            {\\n                temp=(temp%m+((-1*mul(POW[more],A[i]))%m+m)%m)%m;\\n            }\\n            ans=(ans%m+temp%m)%m;            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974489,
                "title": "java-o-n-logn",
                "content": "```\\nclass Solution {\\n    //1-6 (number of elements in between 1 and 6) = (6-1-1) = 4  \\n    //length of sub seq 2 -> 4C0 3 -> 4C1 ; 4 -> 4c2 ; 5 -> 4C3  6 -> 4C4  4c0 + 4c1 + 4c2 + 4c3 + 4c4 1+4+6+4+1=16\\n    //1-5 3c0 + 3c1 + 3c2 + 3c3  = 8 \\n    //1-4 2c0 + 2c1 2c2 = 4\\n    //1-3 1c0 + 1c1  = 2\\n    //1-2 1c0 = 1\\n    \\n    /*16+8+4+2+1(for 1 as min) 8+4+2+1(for 2 as min)  4+2+1(for 3 as min)  2+1(for 4 as min)  1(for 5 as min)  \\n    -1*nums[0]*31 + nums[1]*1 + nums[2]*2 + nums[3]*4 + nums[4]*8 + nums[5]*16\\n        -1*nums[1]*15 + nums[2]*1 +nums[3]*2 + nums[4]*4 + nums[5]*8\\n        -1*nums[2]*7 + nums[3]*1 + nums[4]*2 + nums[5]*4\\n        -1*nums[3]*3 + nums[4]*1 + nums[5]*2\\n        -1*nums[4]*1 + nums[5]*1\\n        \\n        -nums[0]*31 + -nums[1]*15 - nums[2]*7 - nums[3]*3 - nums[4]*1\\n        nums[1]*1 + nums[2]*3 + nums[3]*7 + nums[4]*15 + nums[5]*31\\n    \\n    (-1)*nums[0]*(pow[6-1-0]-1) + (-1)*nums[1]*(pow[6-1-1]-1) + (-1)*nums[2]*(pow[6-1-2]-1)\\n    ... (-1)* nums[5]*(pow[6-1-5]-1)  \\n    + nums[1]*(pow[1]-1) + nums[2]*(pow[2]-1) + .... + nums[5]*(pow[5]-1)\\n    \\n    (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1)        \\n*/\\n    public int sumSubseqWidths(int[] A) {\\n        int MOD = 1_000_000_007;\\n        Arrays.sort(A);\\n        int l = A.length;\\n        long[] pow = new long[l];\\n        pow[0]=1;\\n        for(int i=1;i<l;i++){\\n            pow[i]=pow[i-1]*2 % MOD;\\n        }\\n        long res = 0;\\n        for(int i=0;i<l;i++){\\n            res = (res + (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1))%MOD;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //1-6 (number of elements in between 1 and 6) = (6-1-1) = 4  \\n    //length of sub seq 2 -> 4C0 3 -> 4C1 ; 4 -> 4c2 ; 5 -> 4C3  6 -> 4C4  4c0 + 4c1 + 4c2 + 4c3 + 4c4 1+4+6+4+1=16\\n    //1-5 3c0 + 3c1 + 3c2 + 3c3  = 8 \\n    //1-4 2c0 + 2c1 2c2 = 4\\n    //1-3 1c0 + 1c1  = 2\\n    //1-2 1c0 = 1\\n    \\n    /*16+8+4+2+1(for 1 as min) 8+4+2+1(for 2 as min)  4+2+1(for 3 as min)  2+1(for 4 as min)  1(for 5 as min)  \\n    -1*nums[0]*31 + nums[1]*1 + nums[2]*2 + nums[3]*4 + nums[4]*8 + nums[5]*16\\n        -1*nums[1]*15 + nums[2]*1 +nums[3]*2 + nums[4]*4 + nums[5]*8\\n        -1*nums[2]*7 + nums[3]*1 + nums[4]*2 + nums[5]*4\\n        -1*nums[3]*3 + nums[4]*1 + nums[5]*2\\n        -1*nums[4]*1 + nums[5]*1\\n        \\n        -nums[0]*31 + -nums[1]*15 - nums[2]*7 - nums[3]*3 - nums[4]*1\\n        nums[1]*1 + nums[2]*3 + nums[3]*7 + nums[4]*15 + nums[5]*31\\n    \\n    (-1)*nums[0]*(pow[6-1-0]-1) + (-1)*nums[1]*(pow[6-1-1]-1) + (-1)*nums[2]*(pow[6-1-2]-1)\\n    ... (-1)* nums[5]*(pow[6-1-5]-1)  \\n    + nums[1]*(pow[1]-1) + nums[2]*(pow[2]-1) + .... + nums[5]*(pow[5]-1)\\n    \\n    (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1)        \\n*/\\n    public int sumSubseqWidths(int[] A) {\\n        int MOD = 1_000_000_007;\\n        Arrays.sort(A);\\n        int l = A.length;\\n        long[] pow = new long[l];\\n        pow[0]=1;\\n        for(int i=1;i<l;i++){\\n            pow[i]=pow[i-1]*2 % MOD;\\n        }\\n        long res = 0;\\n        for(int i=0;i<l;i++){\\n            res = (res + (-1)*A[i]*(pow[l-1-i]-1) + A[i]*(pow[i]-1))%MOD;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669883,
                "title": "java-my-solution-with-explanation-runs-in-o-n-log-n-time-fermat-s-little-theorem",
                "content": "Let\\'s fix `i`-th element and `j`-th element in array.  The difference is `max(A[i], A[j]) - min(A[i], A[j])`. How many times do we need to add it? If there exist such an element `A[k]` with property `min(A[i], A[j]) <= A[k] <= max(A[i], A[j])` then we can place it in between and our difference will remains the same.\\nLet\\'s sort the array. Then it can be proven that there exist exactly `2 ^ (j - i)` such selections of numbers `k` where `i < j` (we can decide to place number in between or not to place it. This gives us 2 possibilities per such `k`. If there exist `n` such `k` numbers then we have `2 ^ n` possibilities to place some set of them). Now our time complexity is `O(n ^ 2)`. But it\\'s now enought to solve it.\\nWe can express our computations as following: \\n* `answer = sum((a[j] - a[i]) * 2 ^ (j - i))`\\n* `answer = (2^j - 1) * a[j] - (a[j - 1] * 2 ^ 0 + a[j - 2] * 2 ^ 1 + a[j - 3] * 2 ^ 2) `\\n\\nLet `prefix[i] = a[0] * 2^ (n - 1) + a[1] * 2 ^ (n - 2) + a[2] * 2 ^ (n - 3) + ... + a[i] * 2 ^ (n - i - 1)`. We can transform `prefix[3]` to `a[0] * 2 ^ 2 + a[1] * 2 ^ 1 + a[2] * 2 ^ 0` by dividing `prefix[i]` on `2 ^ (n - i - 1)`.\\n\\n* `answer = (2^j - 1) * a[j] - prefix[j-1] / 2 ^ (n - j)`\\n\\nSuch division is possible on Python, Ruby, but in Java we can\\'t divide because all our numbers are remainder by division on `MOD`. Common solution to do the division is [Fermat\\'s little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem). \\n\\n* `2 ^ -(n - j) = 2 ^ (MOD - (n - j) - 1) % MOD`\\n\\n```\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        \\n        int n = A.length;\\n        int[] bitsMod = calculateBits(n);\\n        long[] prefixSum = new long[n];\\n        \\n        long answer = 0;\\n        long divisor = power(power(2, MOD - 2), n);\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i] = i == 0 ? 0 : prefixSum[i-1];\\n            prefixSum[i] = (prefixSum[i] + (long) bitsMod[n - i - 1] * A[i]) % MOD;\\n            \\n            if (i > 0) {\\n                long multiplier = bitsMod[i] - 1;\\n                if (multiplier < 0) multiplier = MOD - 1;\\n                \\n                long firstTerm = A[i] * multiplier % MOD;\\n                long secondTerm = prefixSum[i - 1] * divisor % MOD;\\n                answer = (answer + firstTerm - secondTerm) % MOD;\\n                \\n                if (answer < 0) {\\n                    answer += MOD;\\n                }\\n            }\\n            \\n            divisor = (divisor * 2) % MOD;\\n        }\\n        \\n        return (int) answer;\\n    }\\n    \\n    private int[] calculateBits(int n) {\\n        int[] bits = new int[n];\\n        bits[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            bits[i] = (bits[i-1] << 1) % MOD;\\n        }\\n        \\n        return bits;\\n    }\\n    \\n    private long power(long a, long b) {\\n        if (b == 0) {\\n            return 1;\\n        }\\n        \\n        if (b % 2 == 0) {\\n            return power(a * a % MOD, b / 2);\\n        } else {\\n            return a * power(a, b - 1) % MOD;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        \\n        int n = A.length;\\n        int[] bitsMod = calculateBits(n);\\n        long[] prefixSum = new long[n];\\n        \\n        long answer = 0;\\n        long divisor = power(power(2, MOD - 2), n);\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i] = i == 0 ? 0 : prefixSum[i-1];\\n            prefixSum[i] = (prefixSum[i] + (long) bitsMod[n - i - 1] * A[i]) % MOD;\\n            \\n            if (i > 0) {\\n                long multiplier = bitsMod[i] - 1;\\n                if (multiplier < 0) multiplier = MOD - 1;\\n                \\n                long firstTerm = A[i] * multiplier % MOD;\\n                long secondTerm = prefixSum[i - 1] * divisor % MOD;\\n                answer = (answer + firstTerm - secondTerm) % MOD;\\n                \\n                if (answer < 0) {\\n                    answer += MOD;\\n                }\\n            }\\n            \\n            divisor = (divisor * 2) % MOD;\\n        }\\n        \\n        return (int) answer;\\n    }\\n    \\n    private int[] calculateBits(int n) {\\n        int[] bits = new int[n];\\n        bits[0] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            bits[i] = (bits[i-1] << 1) % MOD;\\n        }\\n        \\n        return bits;\\n    }\\n    \\n    private long power(long a, long b) {\\n        if (b == 0) {\\n            return 1;\\n        }\\n        \\n        if (b % 2 == 0) {\\n            return power(a * a % MOD, b / 2);\\n        } else {\\n            return a * power(a, b - 1) % MOD;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451179,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        l=len(A)\\n        res=0\\n        for i in range(l):\\n            res+=(A[i]<<i)-(A[i]<<(l-i-1))\\n        return res%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        l=len(A)\\n        res=0\\n        for i in range(l):\\n            res+=(A[i]<<i)-(A[i]<<(l-i-1))\\n        return res%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374028,
                "title": "bucket-sort-o-n-max-a-detailed-intuition",
                "content": "I will first give the intuition, then the solution using Sort, and then the solution using bucket Sort.\\n\\nThe intuition for this problem is pretty much the same as [sum of subarray minimums](https://leetcode.com/problems/sum-of-subarray-minimums/), where we compute the contribution of each A[i] to the result. (No worries if you haven\\'t yet seen that problem)\\n\\nThe first idea is to notice that  `sumWidths = sum(max - min) = sumMaxs - sumMins`\\n\\nFor [2, 4, 3], we have these subsequences: `[2], [4], [3], [2, 3], [2, 4], [4, 3], [2, 4, 3]`.\\n`3` will show up as maximum in 2 subsequences: `[3], [2, 3]` => So We add `3`*2 to sumMaxs.\\nAnd then as minimum in 2 subsequences: `[3], [4, 3]` => We add `3`*2 to sumMins.\\n\\nNow we can focus on how we can efficiently compute the number of contributions of an A[i] to sumMins (computing sumMaxs is similar)\\n\\nFor example in [1, 2, 4, 3], 2 appears as minimum in these subsequences:\\n`{2}, {2, 3}, {2, 4}, {2, 4, 3}`\\n\\nDiscarding the 2 from these subsequences we get: `{}, {3}, {4}, {3, 4}`.\\nThese are the *subsets* of {3, 4} !\\n\\nThe number of appearances of 2 in sumMins = the number of subsets of the set of elements higher than it\\nThe number of subsets of a set with size N is 2^N.\\n\\nSimilarly, the number of appearances of 2 in sumMaxs = the number of subsets of the set of elements smaller than it.\\n\\nThere is a small detail with duplicates, for a subsequence like [2, 2, 3, 4] we need to make sure we add 2 *once and only once* to sumMins\\n\\nThe first attempt to compute the number of elements higher and less than A[i] is to iterate over A for each i. This will have O(N^2) time complexity.\\nIf we sort the array the number of elements greater than A[i] is len(A)-i-1 and the number of elements smaller is i, which are computed in constant time.\\n\\nOrdering the array doesn\\'t have any effect on the result because min(A) = min(Sorted(A)) and max(A) = max(Sorted(A))\\n\\nDuplicates will be handled automatically when we sort.\\n\\nSo the overall time complexity is O(NlogN)\\n\\n```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\tA.sort()\\n\\tsumWidths = 0\\n\\tfor i, num in enumerate(A):\\n\\t\\tsumWidths += nb_sets(i)*num - nb_sets(len(A)-i-1)*num\\n\\treturn sumWidths % 1000000007\\n```\\n\\nNow, because max(A) is in the order of N like mentioned in the description, we can use bucket sort instead !\\nIn each bucket i we have the number of occurences of i in A.\\nWe maintain a variable `nbSmallerElements` that cumulates the count of numbers.\\n\\n```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\t\\t\\n\\tbuckets = [0]*(max(A)+1)\\n\\tfor num in A:\\n\\t\\tbuckets[num] += 1\\n\\n\\tsumWidths, nbSmallerElements = 0, 0\\n\\tfor num in range(len(buckets)):\\n\\t\\tfor _ in range(buckets[num]):\\n\\t\\t\\tsumWidths += nb_sets(nbSmallerElements)*num - nb_sets(len(A)-nbSmallerElements-1)*num\\n\\t\\t\\tnbSmallerElements += 1\\n\\treturn sumWidths % 1000000007\\n```\\n\\nThe time complexity is O(N+max(A)).",
                "solutionTags": [],
                "code": "```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\tA.sort()\\n\\tsumWidths = 0\\n\\tfor i, num in enumerate(A):\\n\\t\\tsumWidths += nb_sets(i)*num - nb_sets(len(A)-i-1)*num\\n\\treturn sumWidths % 1000000007\\n```\n```python\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n\\tdef nb_sets(size):\\n\\t\\treturn 1<<size\\n\\t\\t\\n\\tbuckets = [0]*(max(A)+1)\\n\\tfor num in A:\\n\\t\\tbuckets[num] += 1\\n\\n\\tsumWidths, nbSmallerElements = 0, 0\\n\\tfor num in range(len(buckets)):\\n\\t\\tfor _ in range(buckets[num]):\\n\\t\\t\\tsumWidths += nb_sets(nbSmallerElements)*num - nb_sets(len(A)-nbSmallerElements-1)*num\\n\\t\\t\\tnbSmallerElements += 1\\n\\treturn sumWidths % 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161275,
                "title": "mathematical-sequence-problem-related-to-subsets",
                "content": "This is a mathematical sequence problem related to subsets. Obviously the order does not matter so we sort the numbers. Then for any two numbers with index i and j, ```0 <= i < j < n```, there are 2^(j-i-1) subsets with the same max-min difference. A naive approach to try all (i,j) pair would be O(N^2) time but we can optimize by calculating the coefficiences of each number linearly which leads to solution with O(N*log(N)) time complexcity.\\n\\nSpecifically by looking at all subsets with a[0] be the min/max number, the coefficient for a[0] is ```k[0] = -(2^0 + 2^1 + ... + 2^(n-2))=1-2^(n-1)```, by looking at all subsets with a[0] be the min/max number, coefficient for a[1] is ```k[1]=2^0-(2^0+2^1+...+2^(n-3)) = k[0]+2^0+2^(n-2)``` and in general ```k[i]=k[i-1]+2^(i-1)+2^(n-i-1)```. Code below:\\n\\n```\\n    public static int sumSubseqWidths(int[] A) {\\n        final long mod = 1000000007L;\\n        Arrays.sort(A);\\n        int n = A.length;\\n        // calculate power of 2 modular MOD\\n        long[] mp = new long[n];\\n        mp[0] = 1;\\n        for (int i = 1; i < n; i++) mp[i] = (mp[i-1] * 2) % mod;\\n        // calculate coefficients for each number\\n        long[] k = new long[n];\\n        k[0] = (1 + mod - mp[n-1]) % mod;\\n        for (int i = 1; i < n; i++) {\\n            k[i] = (k[i-1] + mp[i-1] + mp[n-i-1]) % mod;\\n        }\\n        // calculate total sum.\\n        long output = 0;\\n        for (int i = 0; i < n; i++) {\\n            output += k[i] * A[i];\\n        }\\n        return (int) (output % mod);\\n    }",
                "solutionTags": [],
                "code": "```0 <= i < j < n```\n```k[0] = -(2^0 + 2^1 + ... + 2^(n-2))=1-2^(n-1)```\n```k[1]=2^0-(2^0+2^1+...+2^(n-3)) = k[0]+2^0+2^(n-2)```\n```k[i]=k[i-1]+2^(i-1)+2^(n-i-1)```",
                "codeTag": "Unknown"
            },
            {
                "id": 161272,
                "title": "891-sum-of-subsequence-widths-c-sort-and-math-with-brief-explanation",
                "content": "1. Sort the array, because we need to know the largest number and smallest number for each pair.\\n2. \\tFor pair A[i] and A[j],they can have 2^(j - i - 1) different subsequence(s) in the array, which means that you can insert 2^(j - i - 1) possibilities and the largest and smallest values are A[j] and A[i].\\n3. \\tMath: For the length of k, k is the distance of max number A[j] and min number A[i]\\nand k = j - i\\nk = 1: A[1] - A[0], A[2] - A[1] ....., A[n-1] - A[n-2], sum all of them: which is just A[n-1] - A[0]\\nso: generally, for length k, the sum of withds are:\\nA[n-1] + A[n-2] + .... + A[n-k] - A[0] - A[1] - ... - A[k - 1]\\nso we can use S to store the sum at every step.\\n\\n\\n\\n\\t\\n\\t\\n\\n\\n\\n\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\t\\t\\t\\tint MOD = 1000000007;\\n\\t\\t\\t\\t\\t\\tsort(A.begin(), A.end());\\n\\t\\t\\t\\t\\t\\tint n = A.size();\\n\\t\\t\\t\\t\\t\\tvector<long> vec(n, 1);\\n\\t\\t\\t\\t\\t\\tfor(int i = 1; i < n; ++i){\\n\\t\\t\\t\\t\\t\\t\\t\\tvec[i] = vec[i-1]*2 % MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tint res = 0;\\n\\t\\t\\t\\t\\t\\tint i = n-1;\\n\\t\\t\\t\\t\\t\\tint S = 0;\\n\\t\\t\\t\\t\\t\\tfor(int len = 1; len < n; ++len){\\n\\t\\t\\t\\t\\t\\t\\t\\tS = S + A[i] - A[n - 1 - i];\\n\\t\\t\\t\\t\\t\\t\\t\\tres = (res + S * vec[len - 1] % MOD) % MOD;\\n\\t\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\t\\t\\t\\tint MOD = 1000000007;\\n\\t\\t\\t\\t\\t\\tsort(A.begin(), A.end());\\n\\t\\t\\t\\t\\t\\tint n = A.size();\\n\\t\\t\\t\\t\\t\\tvector<long> vec(n, 1);\\n\\t\\t\\t\\t\\t\\tfor(int i = 1; i < n; ++i){\\n\\t\\t\\t\\t\\t\\t\\t\\tvec[i] = vec[i-1]*2 % MOD;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4073740,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }\\n        return (int)width;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }\\n        return (int)width;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924148,
                "title": "python-solution-less-than-10-lines-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe input size is large so we find an approach that accumulates the answer at the position `i` with the information from the position `i-1`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort `nums` and compute the answer from the smallest to the largest. \\nAt `i` (`nums[0] < nums[1] < ... < nums[i]`), we define $$A_i$$ as the sum of widths of all the subsequences of `nums[0:i]` that ends at `i`. \\n\\n$$A_i = \\\\sum_{j=0}^{i-1}\\\\left( A_j + 2^j (\\\\textrm{nums}[i] - \\\\textrm{nums}[j])\\\\right) = A_{i-1} + \\\\delta_i$$\\n\\nwhere $$\\\\delta_i = \\\\sum_{j=0}^{i-1}2^j (\\\\textrm{nums}[i] - \\\\textrm{nums}[j])$$ that be defined in a recursive way as follows: \\n\\n$$ \\\\delta_i = \\\\delta_{i-1} + \\\\sum_{k=0}^{i-1}2^k (\\\\textrm{nums}[i] - \\\\textrm{nums}[i-1]) $$\\n\\nIn this way, we can maintain $$A_i$$ and $$\\\\delta_i$$ iteractively and obtain the final solution in linear time. \\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$ for sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Only $$O(1)$$ extra memory\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = delta = 0\\n        accu_k = k = 1\\n        for u, v in zip(nums, nums[1:]):\\n            delta = (delta + accu_k * (v - u)) % 1000000007 \\n            ans = (ans + ans + delta) % 1000000007\\n            k = (k * 2) % 1000000007\\n            accu_k = (accu_k + k) % 1000000007\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = delta = 0\\n        accu_k = k = 1\\n        for u, v in zip(nums, nums[1:]):\\n            delta = (delta + accu_k * (v - u)) % 1000000007 \\n            ans = (ans + ans + delta) % 1000000007\\n            k = (k * 2) % 1000000007\\n            accu_k = (accu_k + k) % 1000000007\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885067,
                "title": "cpp-amazon-most-asked-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n         sort(nums.begin(),nums.end());\\n    vector<long>p(n,0);\\n    p[0]=1;\\n    for(int i=1;i<n;i++){\\n        p[i]=(p[i-1]*2) % (1000000007);\\n    }\\n      \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(p[i]-p[n-i-1])) % (1000000007);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n         sort(nums.begin(),nums.end());\\n    vector<long>p(n,0);\\n    p[0]=1;\\n    for(int i=1;i<n;i++){\\n        p[i]=(p[i-1]*2) % (1000000007);\\n    }\\n      \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(p[i]-p[n-i-1])) % (1000000007);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866425,
                "title": "easy-to-understand-java-solution",
                "content": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        long mod=1000000007;\\n        int n=nums.length;\\n        long[] pow=new long[n];\\n        pow[0]=1;\\n\\n        for(int i=1;i<n;i++){\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            ans+=nums[i]*pow[i];\\n            ans-=nums[i]*pow[n-i-1];\\n            ans=ans%mod;\\n        }\\n\\n        return (int) ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        long mod=1000000007;\\n        int n=nums.length;\\n        long[] pow=new long[n];\\n        pow[0]=1;\\n\\n        for(int i=1;i<n;i++){\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3820577,
                "title": "dp",
                "content": "\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        mod = 10**9 + 7\\n\\n        # Calculate powers of 2 modulo mod\\n        powers_of_2 = [1]\\n        for i in range(1, n):\\n            powers_of_2.append((powers_of_2[-1] * 2) % mod)\\n\\n        # Calculate the sum of widths\\n        ans = 0\\n        for i in range(n):\\n            ans = (ans + nums[i] * (powers_of_2[i] - powers_of_2[n-i-1])) % mod\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        mod = 10**9 + 7\\n\\n        # Calculate powers of 2 modulo mod\\n        powers_of_2 = [1]\\n        for i in range(1, n):\\n            powers_of_2.append((powers_of_2[-1] * 2) % mod)\\n\\n        # Calculate the sum of widths\\n        ans = 0\\n        for i in range(n):\\n            ans = (ans + nums[i] * (powers_of_2[i] - powers_of_2[n-i-1])) % mod\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804670,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    int power(long long a,long long b){\\n        long long res = 1;\\n        while(b){\\n            if(b&1) res = (res * a) % mod;\\n            b = b >> 1;\\n            a = (a * a) % mod;\\n        }\\n        return res;\\n    }\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long> suffix(n);\\n        for(int i=0,weight=1;i<n;i++){\\n            suffix[i] = (weight*1LL*nums[i]) % mod;\\n            weight = (weight * 2LL) % mod;\\n        }\\n\\n        for(int i=n-2;i>=0;i--) suffix[i] = (suffix[i] + suffix[i+1]) % mod;\\n        \\n        long long expanse = 0LL;\\n        for(int i=0;i<n-1;i++){\\n            long long diff = ( (suffix[i+1]%mod) * power(power(2,i+1),mod-2)%mod) % mod - (nums[i]*1LL*(power(2,n-i-1)-1)%mod);\\n            expanse = (expanse + diff + mod) % mod;\\n        }\\n        return expanse;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626631,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def sumSubseqWidths(nums: Array[Int]): Int = {\\n      val twoPower = Array.ofDim[Long](nums.length)\\n      val mod = 1000000007L\\n      twoPower(0) = 1\\n      for (i <- 1 until nums.length) twoPower(i) = (twoPower(i - 1) * 2) % mod\\n      val effective = Array.ofDim[Long](nums.length)\\n      for (i <- nums.indices) effective(i) = twoPower(i) - twoPower(nums.length - i - 1)\\n      val sorted= nums.sorted\\n      var ans = 0L\\n      for (i <- nums.indices) ans = (ans + effective(i) * sorted(i)) % mod\\n      ans.toInt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def sumSubseqWidths(nums: Array[Int]): Int = {\\n      val twoPower = Array.ofDim[Long](nums.length)\\n      val mod = 1000000007L\\n      twoPower(0) = 1\\n      for (i <- 1 until nums.length) twoPower(i) = (twoPower(i - 1) * 2) % mod\\n      val effective = Array.ofDim[Long](nums.length)\\n      for (i <- nums.indices) effective(i) = twoPower(i) - twoPower(nums.length - i - 1)\\n      val sorted= nums.sorted\\n      var ans = 0L\\n      for (i <- nums.indices) ans = (ans + effective(i) * sorted(i)) % mod\\n      ans.toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3453393,
                "title": "easy-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nPhase-1-> ans=0+(1-3)*1\\n          ans=-2%kmod\\n          exp=1*2%kmod\\nPhase-2-> ans=(-2)+(2-2)*2\\n          ans=-2%kmod\\n          exp=2*2%kmod\\nPhase-3-> ans=(-2)+(3-1)*4\\n          ans=6%kmod\\n          exp=4*2%kmod \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        kMod = 10**9+7\\n        n = len(nums)\\n        ans = 0\\n        exp = 1\\n        nums.sort()\\n        for i in range(n):\\n            ans += (nums[i] - nums[n - i - 1]) * exp\\n            ans %= kMod\\n            exp = exp * 2 % kMod\\n        return ans\\n\\n\\n    # pass only 19 test cases occer TLE problem\\n         result = [[]]\\n         for i in nums:\\n             n = len(result)\\n             for j in range(n):\\n                 r = result[j] + [i]\\n                 result.append(r)        \\n         s=[]\\n         for i in result[1:]:\\n             a=max(i)\\n             b=min(i)\\n             s.append(a-b)\\n         return sum(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        kMod = 10**9+7\\n        n = len(nums)\\n        ans = 0\\n        exp = 1\\n        nums.sort()\\n        for i in range(n):\\n            ans += (nums[i] - nums[n - i - 1]) * exp\\n            ans %= kMod\\n            exp = exp * 2 % kMod\\n        return ans\\n\\n\\n    # pass only 19 test cases occer TLE problem\\n         result = [[]]\\n         for i in nums:\\n             n = len(result)\\n             for j in range(n):\\n                 r = result[j] + [i]\\n                 result.append(r)        \\n         s=[]\\n         for i in result[1:]:\\n             a=max(i)\\n             b=min(i)\\n             s.append(a-b)\\n         return sum(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393106,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        LL M = 1e9 + 7 ;\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        vector<LL>pow(n) ;\\n        pow[0] = 1 ;\\n        for(int i = 1; i < n; i++){\\n            pow[i] = (pow[i-1]*2) % M ;\\n        }\\n        \\n        LL sum = 0 ;\\n        for(int i = n-1; i >= 0; i--){\\n            sum = (sum + nums[i] * pow[i]%M) % M ;\\n            sum = (sum - nums[i] * pow[n-1-i]%M + M) % M ;\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        LL M = 1e9 + 7 ;\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        vector<LL>pow(n) ;\\n        pow[0] = 1 ;\\n        for(int i = 1; i < n; i++){\\n            pow[i] = (pow[i-1]*2) % M ;\\n        }\\n        \\n        LL sum = 0 ;\\n        for(int i = n-1; i >= 0; i--){\\n            sum = (sum + nums[i] * pow[i]%M) % M ;\\n            sum = (sum - nums[i] * pow[n-1-i]%M + M) % M ;\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384340,
                "title": "c-simple-and-explained-solution-o-n-log-n-sort-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nafter sorting we just have to figure out how many subsequences will be there in which a particular number will be maximum and other  minimum\\nhowever our final ans will be=diff1 x (no of subsequence whose width is this max and min are same) + diff2 x n2 + diff3 x n3+...\\nNow, this can be expanded into\\nans=max1(no. of subseq. in which max1 is maximum)+max2xn2+...-min1 x (n1) - min2*(n2)-...    ..eq 1(say)\\nas ...+diff(i)*(n)+..=...+(max(i)-min(i)) x (n)+..\\n=..+max(i)xn-min(i)xn+...\\nnow separating positive and negative terms will give us eqn 1.\\nnow in a sorted array\\narr[0],arr[1],...,arr[i],..arr[j],..arr[n-1]\\nstarting from arr[1]->arr[n-1] calculating how many subsequences can be there where these will be the maximum \\nno of subsequences in which arr[i] can be the maximum = no. of subsequences  that can end at arr[i] and containing zero or more elements smaller than this for ith index no of elements smaller than this i =c(i,0) + c(i,1)+c(i,2)+..+c(i,i)=2^i - 1\\nnow using this formula we can evaluate no of subsequences in which arr[i] will be maximum and add the max_i x (ni) to ans\\nand similarly for minimums in reverse fashion from n-2 -> 0 subsequences will contain elements afyer this ith element (>=arr[i])\\nans-=min_i*(n_i);\\nreturn this ans\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting + maths\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n x log(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n\\n**PLS UPVOTE IF IT HELPED**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        long long ans=0;\\n        int m=1e9+7;\\n        sort(nums.begin(),nums.end());\\n        long long pre=0;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans-=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        pre=0;\\n        for(int i=1;i<nums.size();i++){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans+=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        long long ans=0;\\n        int m=1e9+7;\\n        sort(nums.begin(),nums.end());\\n        long long pre=0;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans-=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        pre=0;\\n        for(int i=1;i<nums.size();i++){\\n            pre=2*pre+1;\\n            pre%=m;\\n            ans+=nums[i]*(pre);\\n            ans%=m;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294924,
                "title": "basic-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n= nums.size();\\n        int i;\\n        int j = n-1;\\n        sort(nums.begin(), nums.end());\\n        long long int m=1;\\n        long long int x = 1e9+7;\\n        int result =0;\\n        for(int i=0; i<n; i++)\\n        {\\n            result = (result + m*nums[i] - m*nums[j])%x;\\n            m = (m*2)%x;\\n            j--;\\n        }\\n        return (int)result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n= nums.size();\\n        int i;\\n        int j = n-1;\\n        sort(nums.begin(), nums.end());\\n        long long int m=1;\\n        long long int x = 1e9+7;\\n        int result =0;\\n        for(int i=0; i<n; i++)\\n        {\\n            result = (result + m*nums[i] - m*nums[j])%x;\\n            m = (m*2)%x;\\n            j--;\\n        }\\n        return (int)result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195161,
                "title": "o-max-time-complexity-counting-sort-python",
                "content": "Since the range of numbers are small, we can sort number in ```O(n)``` time complexity with counting sort.\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        mx = max(nums)\\n        cnt = [0] * (mx + 1)\\n        for num in nums:\\n            cnt[num] += 1\\n        \\n        smaller = [0] + list(accumulate(cnt))\\n        greater = list(accumulate(cnt[::-1]))[::-1] + [0]\\n\\n        ans = 0\\n        nums = set(nums)\\n        for num in nums:\\n            ans += (pow(2, smaller[num], mod) - pow(2, greater[num + 1], mod)) * (pow(2, cnt[num], mod) - 1) * num\\n            ans %= mod\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```O(n)```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod = int(1e9 + 7)\\n        mx = max(nums)\\n        cnt = [0] * (mx + 1)\\n        for num in nums:\\n            cnt[num] += 1\\n        \\n        smaller = [0] + list(accumulate(cnt))\\n        greater = list(accumulate(cnt[::-1]))[::-1] + [0]\\n\\n        ans = 0\\n        nums = set(nums)\\n        for num in nums:\\n            ans += (pow(2, smaller[num], mod) - pow(2, greater[num + 1], mod)) * (pow(2, cnt[num], mod) - 1) * num\\n            ans %= mod\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184377,
                "title": "java-current-element-effect",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    long[] power;\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        power = new long[len];\\n        initPower();\\n        long ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            ans = (ans + (nums[i] * effect(i, len)) % mod) % mod;\\n        }\\n        return (int)ans % mod;\\n    }\\n\\n    private long effect(int curr, int len) {\\n        long plus = power[curr];\\n        long minus = power[len - curr - 1];\\n        return (plus - minus + mod) % mod;\\n    }\\n    private void initPower() {\\n        power[0] = 1;\\n        for (int i = 1; i < power.length; i ++)\\n            power[i] = (2 * power[i-1]) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)1e9 + 7;\\n    long[] power;\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        power = new long[len];\\n        initPower();\\n        long ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            ans = (ans + (nums[i] * effect(i, len)) % mod) % mod;\\n        }\\n        return (int)ans % mod;\\n    }\\n\\n    private long effect(int curr, int len) {\\n        long plus = power[curr];\\n        long minus = power[len - curr - 1];\\n        return (plus - minus + mod) % mod;\\n    }\\n    private void initPower() {\\n        power[0] = 1;\\n        for (int i = 1; i < power.length; i ++)\\n            power[i] = (2 * power[i-1]) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178235,
                "title": "solve-on-paper-first-for-sorted-array",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(nums)\\n        nums.sort()\\n        res = 0\\n        powt = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            powt[i] = 2 * powt[i - 1]\\n            powt[i] %= M\\n        res = 0\\n        for i in range(n):\\n            res += nums[i] * (powt[i] - 1)\\n            res -= nums[i] * (powt[n - i - 1] - 1)\\n            res %= M\\n        return (M + res) % M\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        n = len(nums)\\n        nums.sort()\\n        res = 0\\n        powt = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            powt[i] = 2 * powt[i - 1]\\n            powt[i] %= M\\n        res = 0\\n        for i in range(n):\\n            res += nums[i] * (powt[i] - 1)\\n            res -= nums[i] * (powt[n - i - 1] - 1)\\n            res %= M\\n        return (M + res) % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166228,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExpression can  be broken down to\\n```\\nsum of widths of all subsequences = sum of maximuns of all subsequences - sum of minimums of all subsequences.\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounting contribution of each number to wanted expression, i.e. number of subsequences in which number is maximum or minimum.\\nOther details in code comments\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n  public int sumSubseqWidths(int[] nums) {\\n    // For N numbers there are 2^N subsequences (either take or don\\'t the next element for N elements)\\n    //\\n    // Rearranging wanted expression we get to:\\n    //    \\n    //    -> Sum of subsequence widths = Sum of subsequence max - (Sum of subsequence mins)\\n    //\\n    // For each number n in nums, find the number of subsequences in \\n    // which n is the maximum, and the number of subsequences in which\\n    // n is the minimum.\\n    //                                                   pows: [ 1, 2, 4]\\n    // E.g. nums = [3, -1, 7], sorting the array for easily counting: [-1, 3, 7]\\n    //\\n    // From the 2^3 = 8 subsequences, how -1 contributes? It is the maximum of 1 (2\\u2070) sequences,\\n    // and the minimum of 4 (2\\xB2)\\n    //\\n    // How 3 contribues? It is the maximum of 2 sequences (2\\xB9) and minimum of 2 sequences (2\\xB9)\\n    //\\n    // how 7 contributes? It is the maximum of 4 sequences (2\\xB2) and minimum of 1 (2\\u2070) \\n    //\\n    // Sum of maximums: -1 * 1 + 3 * 2 + 7 * 4\\n    // Sum of minimums: -1 * 4 + 3 * 2 + 7 * 1\\n    // ----------------------------------------\\n    //                  -1 * (-3) + 7 * 3         = 3 + 21 = 24 \\n    //\\n    //\\n    //\\n    //\\n    // Also notice some modulo properties:\\n    //\\n    // (a + b) % c = ((a % c) + b) % c\\n    // (a * b) % c = ((a % c) * b) % c\\n    //\\n    //\\n    long mod = 1000000007;\\n    int n = nums.length;\\n    long[] pow = new long[n];\\n    pow[0] = 1;\\n    for (int i = 1; i < n; i ++)\\n      pow[i] = (2 * pow[i-1]) % mod;\\n    Arrays.sort(nums);\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      // number of subsequences in which nums[i] is the maximum\\n      long largest = pow[i];\\n      // number of subsequences in which nums[i] is the minimum\\n      long smallest = pow[n-i-1];\\n      // Contribution of nums[i] = largest * nums[i] - smallest * nums[i]\\n      //                         = (largest - smallest) * nums[i]\\n      ans = (int) ((ans + (nums[i] * (largest - smallest) % mod) % mod) % mod);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nsum of widths of all subsequences = sum of maximuns of all subsequences - sum of minimums of all subsequences.\\n```\n```\\nclass Solution {\\n\\n\\n  public int sumSubseqWidths(int[] nums) {\\n    // For N numbers there are 2^N subsequences (either take or don\\'t the next element for N elements)\\n    //\\n    // Rearranging wanted expression we get to:\\n    //    \\n    //    -> Sum of subsequence widths = Sum of subsequence max - (Sum of subsequence mins)\\n    //\\n    // For each number n in nums, find the number of subsequences in \\n    // which n is the maximum, and the number of subsequences in which\\n    // n is the minimum.\\n    //                                                   pows: [ 1, 2, 4]\\n    // E.g. nums = [3, -1, 7], sorting the array for easily counting: [-1, 3, 7]\\n    //\\n    // From the 2^3 = 8 subsequences, how -1 contributes? It is the maximum of 1 (2\\u2070) sequences,\\n    // and the minimum of 4 (2\\xB2)\\n    //\\n    // How 3 contribues? It is the maximum of 2 sequences (2\\xB9) and minimum of 2 sequences (2\\xB9)\\n    //\\n    // how 7 contributes? It is the maximum of 4 sequences (2\\xB2) and minimum of 1 (2\\u2070) \\n    //\\n    // Sum of maximums: -1 * 1 + 3 * 2 + 7 * 4\\n    // Sum of minimums: -1 * 4 + 3 * 2 + 7 * 1\\n    // ----------------------------------------\\n    //                  -1 * (-3) + 7 * 3         = 3 + 21 = 24 \\n    //\\n    //\\n    //\\n    //\\n    // Also notice some modulo properties:\\n    //\\n    // (a + b) % c = ((a % c) + b) % c\\n    // (a * b) % c = ((a % c) * b) % c\\n    //\\n    //\\n    long mod = 1000000007;\\n    int n = nums.length;\\n    long[] pow = new long[n];\\n    pow[0] = 1;\\n    for (int i = 1; i < n; i ++)\\n      pow[i] = (2 * pow[i-1]) % mod;\\n    Arrays.sort(nums);\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      // number of subsequences in which nums[i] is the maximum\\n      long largest = pow[i];\\n      // number of subsequences in which nums[i] is the minimum\\n      long smallest = pow[n-i-1];\\n      // Contribution of nums[i] = largest * nums[i] - smallest * nums[i]\\n      //                         = (largest - smallest) * nums[i]\\n      ans = (int) ((ans + (nums[i] * (largest - smallest) % mod) % mod) % mod);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093598,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9+7\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9+7\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912273,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       public int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        long c = 1, res = 0, mod = (long)1e9 + 7;\\n        for (int i = 0, n = A.length; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (int)((res + mod) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864499,
                "title": "beats-95-6-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long a = 1;\\n        long res = 0;\\n        long mod = (long) 1e9 + 7;\\n        for(int i = 0; i < nums.length; ++i, a = (a * 2) % mod) res = (res + nums[i] * a - nums[nums.length - i - 1] * a) % mod;\\n        return (int) ((res + mod) % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long a = 1;\\n        long res = 0;\\n        long mod = (long) 1e9 + 7;\\n        for(int i = 0; i < nums.length; ++i, a = (a * 2) % mod) res = (res + nums[i] * a - nums[nums.length - i - 1] * a) % mod;\\n        return (int) ((res + mod) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839381,
                "title": "math-dp",
                "content": "# Code\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        nums.sort()\\n\\n        dp = [0] * n\\n\\n        p = 2\\n        temp = nums[0]\\n\\n        for i in range(1, n):\\n            dp[i] = ((dp[i-1] + ((p-1)*nums[i])%MOD)%MOD - temp)%MOD\\n            p = (2*p)%MOD\\n            temp = ((2*temp)%MOD + nums[i])%MOD\\n        \\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        nums.sort()\\n\\n        dp = [0] * n\\n\\n        p = 2\\n        temp = nums[0]\\n\\n        for i in range(1, n):\\n            dp[i] = ((dp[i-1] + ((p-1)*nums[i])%MOD)%MOD - temp)%MOD\\n            p = (2*p)%MOD\\n            temp = ((2*temp)%MOD + nums[i])%MOD\\n        \\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839218,
                "title": "rust-version",
                "content": "# Code\\nCredit: https://leetcode.com/problems/sum-of-subsequence-widths/solutions/2791666/c-easy-shorts/\\n```\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn sum_subseq_widths(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n\\n        let mut c = 1;\\n        let mut result: i64 = 0;\\n        let n = nums.len();\\n\\n        for i in 0..n {\\n            result = (result + nums[i] as i64 * c - nums[n - i - 1] as i64 * c) % MOD;\\n            c = c * 2 % MOD;\\n        }\\n\\n        ((result + MOD) % MOD) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn sum_subseq_widths(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n\\n        let mut c = 1;\\n        let mut result: i64 = 0;\\n        let n = nums.len();\\n\\n        for i in 0..n {\\n            result = (result + nums[i] as i64 * c - nums[n - i - 1] as i64 * c) % MOD;\\n            c = c * 2 % MOD;\\n        }\\n\\n        ((result + MOD) % MOD) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2825898,
                "title": "python-solution-math-property-faster-than-98-time-o-nlog-space-o-1",
                "content": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t\\t\\tk_mod = 10**9 + 7\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tnums_len = len(nums)\\n\\n\\t\\t\\tp = 2**0\\n\\t\\t\\tres = 0 \\n\\t\\t\\tfor i in range(nums_len): \\n\\t\\t\\t\\tres += (nums[i] - nums[nums_len-i-1])*p % k_mod\\n\\t\\t\\t\\tp = (p<<1) % k_mod\\n\\t\\t\\treturn res % k_mod        \\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sumSubseqWidths(self, nums: List[int]) -> int:\\n\\t\\t\\tk_mod = 10**9 + 7\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tnums_len = len(nums)\\n\\n\\t\\t\\tp = 2**0\\n\\t\\t\\tres = 0 \\n\\t\\t\\tfor i in range(nums_len): \\n\\t\\t\\t\\tres += (nums[i] - nums[nums_len-i-1])*p % k_mod\\n\\t\\t\\t\\tp = (p<<1) % k_mod\\n\\t\\t\\treturn res % k_mod        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2724415,
                "title": "javascript-sort-and-one-traversal",
                "content": "```\\nvar sumSubseqWidths = function(nums) {\\n    nums.sort((b, a) => b - a);\\n\\n    let sumOfWidths = 0, mod = 1000000007;\\n\\n    for (let i = 0, nCr = 1; i < nums.length; i++) {\\n        sumOfWidths = (sumOfWidths + nCr * (nums[i] - nums[nums.length - 1 - i]) % mod) % mod;\\n        nCr = (nCr << 1) % mod;\\n    }\\n\\n    return sumOfWidths;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sumSubseqWidths = function(nums) {\\n    nums.sort((b, a) => b - a);\\n\\n    let sumOfWidths = 0, mod = 1000000007;\\n\\n    for (let i = 0, nCr = 1; i < nums.length; i++) {\\n        sumOfWidths = (sumOfWidths + nCr * (nums[i] - nums[nums.length - 1 - i]) % mod) % mod;\\n        nCr = (nCr << 1) % mod;\\n    }\\n\\n    return sumOfWidths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589963,
                "title": "reminder-subsequences-with-same-elements-in-same-order-are-different",
                "content": "For [1,2,2], if we ignore the dublicate, here are all subsequences, [1], [2], [2], [1,2], [1,2], [1,2,2]. \\n0+0+0+1+1+1 = 3\\nWe get the answer is 3.\\n[1,2] and [1,2] are treated as different sequence in this problem.",
                "solutionTags": [],
                "code": "For [1,2,2], if we ignore the dublicate, here are all subsequences, [1], [2], [2], [1,2], [1,2], [1,2,2]. \\n0+0+0+1+1+1 = 3\\nWe get the answer is 3.\\n[1,2] and [1,2] are treated as different sequence in this problem.",
                "codeTag": "Unknown"
            },
            {
                "id": 2589520,
                "title": "c-the-most-complicated-solution",
                "content": "```cpp\\n#define all(x) begin(x), end(x)\\n#define has(c, x) (c.find(x) != c.end())\\n#define vec vector\\n#define umap unordered_map\\n#define uset unordered_set\\n#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)\\n\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\ntemplate <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }\\n\\nusing ll = long long;\\nusing pii = pair<int, int>;\\nusing pll = pair<ll, ll>;\\nusing vi = vec<int>;\\nusing vvi = vec<vec<int>>;\\nusing vvvi = vec<vec<vec<int>>>;\\nusing vl = vec<ll>;\\nusing vvl = vec<vec<ll>>;\\nusing vs = vec<string>;\\nusing vvs = vec<vec<string>>;\\nusing vpii = vec<pii>;\\nusing vvpii = vec<vec<pii>>;\\nusing tiii = tuple<int, int, int>;\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, -1, 1, 0, -1, 1, -1, 1};\\nconstexpr int MXN = (int)1e6;\\nconstexpr int INF = (int)1e9 + 15;\\nconstexpr ll INFL = ll(1e18) + 15;\\nconstexpr double EPS = 1e-9;\\nconstexpr int P = 31;\\nconstexpr int P2 = 33;\\nconstexpr int M = (int)1e9 + 7;\\nconstexpr int M2 = (int)1e9 + 9;\\n\\nconstexpr ll binpow(ll a, ll b, ll m) {\\n  a %= m;\\n  ll res = 1;\\n  while (b > 0) {\\n    if (b & 1)\\n      res = res * a % m;\\n    a = a * a % m;\\n    b >>= 1;\\n  }\\n  return res;\\n}\\nconstexpr int extended_gcd(int a, int b, int &x, int &y) {\\n  x = 1, y = 0;\\n  int x1 = 0, y1 = 1, a1 = a, b1 = b;\\n  while (b1) {\\n    int q = a1 / b1;\\n    tie(x, x1) = make_tuple(x1, x - q * x1);\\n    tie(y, y1) = make_tuple(y1, y - q * y1);\\n    tie(a1, b1) = make_tuple(b1, a1 - q * b1);\\n  }\\n  return a1;\\n}\\n\\nclass Solution {\\npublic:\\n  int sumSubseqWidths(vector<int> &nums) {\\n    map<int, int> mp;\\n    for (int v : nums) {\\n      mp[v]++;\\n    }\\n    vpii p(all(mp));\\n    int n = p.size();\\n\\n    ll ans = 0, res = 0, between_subsets = 1, subsets_cnt = 0;\\n    for (int i = 1; i < n; i++) {\\n      ll diff = p[i].first - p[0].first;\\n      ll left_subsets = binpow(2, p[0].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i].second, M) - 1;\\n      ll end_subsets = (left_subsets * right_subsets) % M;\\n\\n      res += (diff * (end_subsets * between_subsets) % M) % M;\\n      res %= M;\\n\\n      subsets_cnt += (end_subsets * between_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      between_subsets *= right_subsets + 1;\\n      between_subsets %= M;\\n    }\\n    for (int i = 0; i < n - 1; i++) {\\n      ans += res;\\n      ans %= M;\\n\\n      ll diff = p[i + 1].first - p[i].first;\\n      ll left_subsets = binpow(2, p[i].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i + 1].second, M) - 1;\\n\\n      res -= (diff * (left_subsets * right_subsets) % M) % M;\\n      res = (res % M + M) % M;\\n      subsets_cnt -= (left_subsets * right_subsets) % M;\\n      subsets_cnt = (subsets_cnt % M + M) % M;\\n\\n      ll k = n - i - 2;\\n      ll remove = (k * (left_subsets * (right_subsets + 1) % M) % M) % M;\\n      int inv_remove, y;\\n      extended_gcd(remove, M, inv_remove, y);\\n      inv_remove = (inv_remove % M + M) % M;\\n\\n      res *= inv_remove;\\n      res %= M;\\n      res *= (k * right_subsets) % M;\\n      res %= M;\\n\\n      subsets_cnt *= inv_remove;\\n      subsets_cnt %= M;\\n      subsets_cnt *= (k * right_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      res -= (subsets_cnt * diff) % M;\\n      res = (res % M + M) % M;\\n    }\\n    return ans;\\n  }\\n};\\n#endif\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```cpp\\n#define all(x) begin(x), end(x)\\n#define has(c, x) (c.find(x) != c.end())\\n#define vec vector\\n#define umap unordered_map\\n#define uset unordered_set\\n#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)\\n\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\ntemplate <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }\\n\\nusing ll = long long;\\nusing pii = pair<int, int>;\\nusing pll = pair<ll, ll>;\\nusing vi = vec<int>;\\nusing vvi = vec<vec<int>>;\\nusing vvvi = vec<vec<vec<int>>>;\\nusing vl = vec<ll>;\\nusing vvl = vec<vec<ll>>;\\nusing vs = vec<string>;\\nusing vvs = vec<vec<string>>;\\nusing vpii = vec<pii>;\\nusing vvpii = vec<vec<pii>>;\\nusing tiii = tuple<int, int, int>;\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, -1, 1, 0, -1, 1, -1, 1};\\nconstexpr int MXN = (int)1e6;\\nconstexpr int INF = (int)1e9 + 15;\\nconstexpr ll INFL = ll(1e18) + 15;\\nconstexpr double EPS = 1e-9;\\nconstexpr int P = 31;\\nconstexpr int P2 = 33;\\nconstexpr int M = (int)1e9 + 7;\\nconstexpr int M2 = (int)1e9 + 9;\\n\\nconstexpr ll binpow(ll a, ll b, ll m) {\\n  a %= m;\\n  ll res = 1;\\n  while (b > 0) {\\n    if (b & 1)\\n      res = res * a % m;\\n    a = a * a % m;\\n    b >>= 1;\\n  }\\n  return res;\\n}\\nconstexpr int extended_gcd(int a, int b, int &x, int &y) {\\n  x = 1, y = 0;\\n  int x1 = 0, y1 = 1, a1 = a, b1 = b;\\n  while (b1) {\\n    int q = a1 / b1;\\n    tie(x, x1) = make_tuple(x1, x - q * x1);\\n    tie(y, y1) = make_tuple(y1, y - q * y1);\\n    tie(a1, b1) = make_tuple(b1, a1 - q * b1);\\n  }\\n  return a1;\\n}\\n\\nclass Solution {\\npublic:\\n  int sumSubseqWidths(vector<int> &nums) {\\n    map<int, int> mp;\\n    for (int v : nums) {\\n      mp[v]++;\\n    }\\n    vpii p(all(mp));\\n    int n = p.size();\\n\\n    ll ans = 0, res = 0, between_subsets = 1, subsets_cnt = 0;\\n    for (int i = 1; i < n; i++) {\\n      ll diff = p[i].first - p[0].first;\\n      ll left_subsets = binpow(2, p[0].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i].second, M) - 1;\\n      ll end_subsets = (left_subsets * right_subsets) % M;\\n\\n      res += (diff * (end_subsets * between_subsets) % M) % M;\\n      res %= M;\\n\\n      subsets_cnt += (end_subsets * between_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      between_subsets *= right_subsets + 1;\\n      between_subsets %= M;\\n    }\\n    for (int i = 0; i < n - 1; i++) {\\n      ans += res;\\n      ans %= M;\\n\\n      ll diff = p[i + 1].first - p[i].first;\\n      ll left_subsets = binpow(2, p[i].second, M) - 1;\\n      ll right_subsets = binpow(2, p[i + 1].second, M) - 1;\\n\\n      res -= (diff * (left_subsets * right_subsets) % M) % M;\\n      res = (res % M + M) % M;\\n      subsets_cnt -= (left_subsets * right_subsets) % M;\\n      subsets_cnt = (subsets_cnt % M + M) % M;\\n\\n      ll k = n - i - 2;\\n      ll remove = (k * (left_subsets * (right_subsets + 1) % M) % M) % M;\\n      int inv_remove, y;\\n      extended_gcd(remove, M, inv_remove, y);\\n      inv_remove = (inv_remove % M + M) % M;\\n\\n      res *= inv_remove;\\n      res %= M;\\n      res *= (k * right_subsets) % M;\\n      res %= M;\\n\\n      subsets_cnt *= inv_remove;\\n      subsets_cnt %= M;\\n      subsets_cnt *= (k * right_subsets) % M;\\n      subsets_cnt %= M;\\n\\n      res -= (subsets_cnt * diff) % M;\\n      res = (res % M + M) % M;\\n    }\\n    return ans;\\n  }\\n};\\n#endif\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557241,
                "title": "c-solution-with-explanation",
                "content": "The idea is to count in how many subsets an element will be minimum and maximum, by summing all the values will give the answer.\\n\\nFor an elements A_i to be minimum in a subset, all the elements in the subset must be greater or equal to A_i, and for it to be maximum all the elements in the subset must be lesser or equal to A_i. \\n\\nTo obtain the number of subsets that are possible with A_i as minimum, we can sort the whole array, and if for any element index at i, all the numbers above will be greater and all the subsets that can be formed with those elements have minimum >= i_th element, if we add a_i to every set that is possible with the elements greater than a_i will always be minimum in those sets. And similarly we can do for i_th element to be maximum by looking at number of elements in below it. \\n\\nThus, the contribution of A_i(0-indexing), in a sorted array, to the whole sum is \\n (2^i)*A_i - 2^(n-i-1)*A_i\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mod = 1e9+7;\\n    ll power(ll x, ll y , ll mod) {\\n        ll ans = 1;\\n        while (y) {\\n            if (y&1) ans = (ans*x)%mod;\\n            x = (x*x)%mod;\\n            y/=2;\\n        }\\n        return ans;\\n    }\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        ll ans = 0, n = nums.size();\\n        for (int i = 0; i < n;i++) {\\n            ans = (ans + power(2, i,mod)*nums[i] - power(2,n-1-i,mod)*nums[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mod = 1e9+7;\\n    ll power(ll x, ll y , ll mod) {\\n        ll ans = 1;\\n        while (y) {\\n            if (y&1) ans = (ans*x)%mod;\\n            x = (x*x)%mod;\\n            y/=2;\\n        }\\n        return ans;\\n    }\\n    int sumSubseqWidths(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        ll ans = 0, n = nums.size();\\n        for (int i = 0; i < n;i++) {\\n            ans = (ans + power(2, i,mod)*nums[i] - power(2,n-1-i,mod)*nums[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553573,
                "title": "java-solution-runtime-734-ms-faster-than-5-21-of-java-online-submissions",
                "content": "class Solution {\\n     //inbuilt power function wont work for hard test so implement custom power function with Tc - logn\\n   static long pow(int A, int B, int C){\\n\\n    //Base condition for recursive call\\n        //Base condition for recursive call\\n        long num  = A;\\n        if(B == 0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n        long square_number = pow((int)num, B/2 , C);\\n\\t\\tlong power_square = (square_number  * square_number ) % C;\\n\\t\\tpower_square=(power_square+C)%C;\\n\\n        if(B % 2 == 0)\\n\\t\\t{\\n\\t\\t\\treturn power_square;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t    power_square=((num * power_square)+C)%C;\\n\\t\\t\\treturn (power_square);\\n\\t\\t}\\n\\n    }\\n    public int sumSubseqWidths(int[] nums) {\\n        \\n         int mod=1000000007;\\n        //Collections.sort(A);\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n\\n        long max = 0;\\n        long min = 0;\\n\\n        for(int i = 0 ; i < nums.length ; i++)\\n        {\\n            max = ((max + (long)nums[n-i-1] * pow(2 , n-i-1 , mod)) % mod);\\n            min = ((min + (long)nums[i] * pow(2 , n-i-1 , mod)) % mod);\\n        }\\n\\n        return (int)(max-min+mod)%mod; \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n     //inbuilt power function wont work for hard test so implement custom power function with Tc - logn\\n   static long pow(int A, int B, int C){\\n\\n    //Base condition for recursive call\\n        //Base condition for recursive call\\n        long num  = A;\\n        if(B == 0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2535420,
                "title": "c-math-problem",
                "content": "First sort the array. Then for each index i. \\narr[i] is the maximum number of any subsqeuence of [0, 1, ...i]\\narr[i] is the minimum number of any subsequence of [i, i+1,... n-1]\\nSo we just count the # of appearances of arr[i] as the minimum number and as the maximum number.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll big = 1e9 + 7;\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> pow(n+1, 1);\\n        for(int i=1; i<n+1; ++i) pow[i] = (pow[i-1] * 2) % big;\\n        \\n        sort(nums.begin(), nums.end());\\n        ll ans = 0;\\n        for(int i=0; i<n; ++i) {\\n            ll pos = pow[i] - 1, neg = pow[n-1-i] - 1;\\n            ans = (ans + (pos - neg) * nums[i]) % big; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll big = 1e9 + 7;\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> pow(n+1, 1);\\n        for(int i=1; i<n+1; ++i) pow[i] = (pow[i-1] * 2) % big;\\n        \\n        sort(nums.begin(), nums.end());\\n        ll ans = 0;\\n        for(int i=0; i<n; ++i) {\\n            ll pos = pow[i] - 1, neg = pow[n-1-i] - 1;\\n            ans = (ans + (pos - neg) * nums[i]) % big; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373322,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int MOD = (int)1e9 + 7;\\n        Arrays.sort(nums);\\n        \\n        long ans = 0;\\n        long p = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            ans = (ans + p * nums[i] - p * nums[nums.length - 1 - i]) % MOD;\\n            p = (p * 2) % MOD;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        int MOD = (int)1e9 + 7;\\n        Arrays.sort(nums);\\n        \\n        long ans = 0;\\n        long p = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            ans = (ans + p * nums[i] - p * nums[nums.length - 1 - i]) % MOD;\\n            p = (p * 2) % MOD;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370250,
                "title": "short-trick-to-remove-integer-overflow-c",
                "content": "```\\n int mod=1000000007;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        //Step 1--> Sort krke ans nikalna is same as normally ans nikalna as at the end hmse max-min pucha hai 4 8 3 ka b (max-min) same hoga aur 3 4 8 ka bhi..\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        long long power2[n];\\n        power2[0]=1;\\n        \\n        //Step 2--> Power 2 bohat bdi bn skti hai as n=10^5 so mod krte chalo and bar bar krna na pde to 2^i ko store krte chalo array me \\n        for(int i=1;i<n;i++)\\n        power2[i]=(power2[i-1]*2)%mod;\\n            \\n        long long sum=0;\\n        \\n         //Step 3 --> VERY VERY IMPORTANT TO REMOVE OVERFLOW --> sum=sum+(xyz) means long long variable pehle likhdiya to overflow nahi hoga long long dominate kr jayega int ko \\n        for(int i=0;i<n;i++)\\n            sum=(sum+nums[i]*(power2[i]-power2[n-i-1]))%mod;  //sum+= nahi chlega yaha pe \\n\\n        return sum%mod;       \\n    }",
                "solutionTags": [],
                "code": "```\\n int mod=1000000007;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        \\n        //Step 1--> Sort krke ans nikalna is same as normally ans nikalna as at the end hmse max-min pucha hai 4 8 3 ka b (max-min) same hoga aur 3 4 8 ka bhi..\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        long long power2[n];\\n        power2[0]=1;\\n        \\n        //Step 2--> Power 2 bohat bdi bn skti hai as n=10^5 so mod krte chalo and bar bar krna na pde to 2^i ko store krte chalo array me \\n        for(int i=1;i<n;i++)\\n        power2[i]=(power2[i-1]*2)%mod;\\n            \\n        long long sum=0;\\n        \\n         //Step 3 --> VERY VERY IMPORTANT TO REMOVE OVERFLOW --> sum=sum+(xyz) means long long variable pehle likhdiya to overflow nahi hoga long long dominate kr jayega int ko \\n        for(int i=0;i<n;i++)\\n            sum=(sum+nums[i]*(power2[i]-power2[n-i-1]))%mod;  //sum+= nahi chlega yaha pe \\n\\n        return sum%mod;       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2359247,
                "title": "java-sorting",
                "content": "```\\nclass Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }\\n        return (int)width;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    long MOD=1000000007;\\n    public int sumSubseqWidths(int[] nums) {\\n        int i=0;\\n        int j=nums.length-1;\\n        long multi=1;\\n        long width=0;\\n        Arrays.sort(nums);\\n        while(i<nums.length&&j>=0){\\n            width=(width+nums[i]*multi-nums[j]*multi)%MOD;\\n            multi=(multi*2)%MOD;\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2357334,
                "title": "java-prefix-sum-o-nlogn",
                "content": "I now understand this is not the optimal solution but I am sharing it regardless. \\n- Sort the array first because the order doesn\\'t matter.\\n\\n- Consider each index ending in `i` being the max element, there are `[0, i-1]` min element choice, with each choice giving some `2^j` where `j` is the gap between the min and the max element.\\n\\n- Now Consider the whole array. If we fixed \"gap\", we will realize that for each specific gap `j`, the contribution of it is the suffix sum - prefix sum of the same size.\\n\\n#### Java \\n```Java\\n// Time O(nlogn)\\n// Space O(n)\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, two = 1, ans = 0, M = (int)1e9+7;\\n        long[] pre = new long[n];\\n        for (int i = 0; i < n; i++){\\n            pre[i] = i == 0? nums[i] : nums[i] + pre[i-1];\\n        }\\n        for (int i = 1; i < n; i++){\\n            long g = pre[n-1] - pre[i-1]; // suffix sum\\n            long l = pre[n-1-i]; // prefix sum\\n            ans += two * (g-l) % M; // contribution of the current gap.\\n            ans %= M;\\n            two = 2*two%M;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\n// Time O(nlogn)\\n// Space O(n)\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, two = 1, ans = 0, M = (int)1e9+7;\\n        long[] pre = new long[n];\\n        for (int i = 0; i < n; i++){\\n            pre[i] = i == 0? nums[i] : nums[i] + pre[i-1];\\n        }\\n        for (int i = 1; i < n; i++){\\n            long g = pre[n-1] - pre[i-1]; // suffix sum\\n            long l = pre[n-1-i]; // prefix sum\\n            ans += two * (g-l) % M; // contribution of the current gap.\\n            ans %= M;\\n            two = 2*two%M;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355112,
                "title": "easy-c-solution-with-explanation",
                "content": "Observations-\\n1- Since we need to find sum of width (difference between largest and smallest element) so the sequence of elements doesn\\'t matter.\\n2- sorting array to make things easier\\n\\nExample - [1,2,3,4]\\n\\nNow problem is boil down to find number of subsequence ends with an element (that element will be greater in that subsequences ) and number of subsequence starts with an element (that element will be smaller in that subsequences )\\n\\nlet say element 2\\nsubsequences ends with 2 => [1,2] [2]  (2 subsquences )\\nsubsequences starts with 2 => [2] [2,3] [2,4] [2,3,4] (4 subsquences)\\n\\ncontribution of these subsqences width in answer  can be calculated by ( 2* 4 - 2 * 2 )\\n\\n\\n\\n`````\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int mod=1e9+7;\\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<int>pow(n,1);\\n        pow[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }\\n        \\n        long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=(ans+1ll*nums[i]*(pow[i]-pow[n-i-1]))%mod;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int mod=1e9+7;\\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<int>pow(n,1);\\n        pow[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            pow[i]=(pow[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2355044,
                "title": "sum-of-subsequence-widths",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        //sorting the array so we can easily get max and min as width=max-min\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;    //answer can go beyond int range so mod it to come it in range\\n        \\n        long[] pow=new long[n];     //array to store power of 2\\n        \\n        pow[0]=1;   //power of 2^0==1 \\n\\n        \\n        //use to store power of 2\\n        //2^0,2^1,2^2....\\n        //we store power of two as we need total no of subsequence and to find no. of subsequence of n digit is 2^n\\n        for(int i=1;i<n;i++){\\n           pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        \\n        //width==max-min\\n        //n-i-1 for count of left element and then take the power of 2 from pow array which store power of 2\\n        for(int i=0;i<n;i++){\\n            //for ith element we have to find no of subsequence till me and no of subsequence after ith element \\n            //ith element can be in maximum element in previous subsequence and min in next subsequence as array is sorted\\n            //so as we already store power of 2 in pow array we just need count of element till prevoius and after i to               //last element , so we can take no of subsequence from pow\\n            //width=max*subsequence-min*subsequence\\n            ans=(ans+nums[i]*pow[i]-nums[i]*pow[n-i-1])%mod;\\n            System.out.println(ans);\\n            \\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n}\\n//1 2 3\\n//1 2 4\\n//0+1-1*4==-3\\n//-3+2*2-2*2==-3\\n//-3+3*4-3*1==-3+12-3=6\\n```\\nif have any query i will suggest you to go through this video \\nhttps://www.youtube.com/watch?v=kSo8W6ZGYqw",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        //sorting the array so we can easily get max and min as width=max-min\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;    //answer can go beyond int range so mod it to come it in range\\n        \\n        long[] pow=new long[n];     //array to store power of 2\\n        \\n        pow[0]=1;   //power of 2^0==1 \\n\\n        \\n        //use to store power of 2\\n        //2^0,2^1,2^2....\\n        //we store power of two as we need total no of subsequence and to find no. of subsequence of n digit is 2^n\\n        for(int i=1;i<n;i++){\\n           pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        \\n        //width==max-min\\n        //n-i-1 for count of left element and then take the power of 2 from pow array which store power of 2\\n        for(int i=0;i<n;i++){\\n            //for ith element we have to find no of subsequence till me and no of subsequence after ith element \\n            //ith element can be in maximum element in previous subsequence and min in next subsequence as array is sorted\\n            //so as we already store power of 2 in pow array we just need count of element till prevoius and after i to               //last element , so we can take no of subsequence from pow\\n            //width=max*subsequence-min*subsequence\\n            ans=(ans+nums[i]*pow[i]-nums[i]*pow[n-i-1])%mod;\\n            System.out.println(ans);\\n            \\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n}\\n//1 2 3\\n//1 2 4\\n//0+1-1*4==-3\\n//-3+2*2-2*2==-3\\n//-3+3*4-3*1==-3+12-3=6\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311848,
                "title": "python-users-pow-2-i-function-is-slow",
                "content": "Either use ```<<``` or construct the power array manually. I found that constructing the pow2 array as in the solution is the fastest",
                "solutionTags": [],
                "code": "```<<```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229984,
                "title": "o-nlog-n-time-complexity",
                "content": "```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222412,
                "title": "sum-of-subsequence-widths-easy-to-understand-solution-java",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;\\n        \\n        long []pow=new long[n];\\n        \\n        pow[0]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(pow[i]-pow[n-i-1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n\\n//for p numbers there are 2^p subsequences possible\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans=0;\\n        int n=nums.length;\\n        long mod=1000000007;\\n        \\n        long []pow=new long[n];\\n        \\n        pow[0]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            pow[i]=(2*pow[i-1])%mod;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans=(ans+nums[i]*(pow[i]-pow[n-i-1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n\\n//for p numbers there are 2^p subsequences possible\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181862,
                "title": "java-easy-understanding-solution",
                "content": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n      \\n       Arrays.sort(nums);\\n        int n = nums.length;\\n        \\n        long[] power = new long[n];\\n        long mod = 1000000007L;\\n        power[0] = 1;\\n        \\n        for(int i =1; i<n; i++){\\n            power[i] = (power[i-1]*2)%mod;\\n        }\\n        \\n        long ans = 0;\\n        \\n        for(int i = 0; i<n; i++){\\n            ans = (ans + nums[i]*power[i] - nums[i]*power[n-i-1])%mod;\\n        }\\n        return (int) ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] nums) {\\n      \\n       Arrays.sort(nums);\\n        int n = nums.length;\\n        \\n        long[] power = new long[n];\\n        long mod = 1000000007L;\\n        power[0] = 1;\\n        \\n        for(int i =1; i<n; i++){\\n            power[i] = (power[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2179790,
                "title": "c-simple-solution-no-power",
                "content": "```\\nint sumSubseqWidths(vector<int>& A) {\\n        int N = A.size();\\n        long mn = 0, mx = 0, mod = 1000000007;\\n\\n        sort(A.begin(), A.end());\\n        for(int i=0; i<N; i++) {\\n            mn = (mn*2)%mod;\\n            mn = (mn + A[i])%mod;\\n        }\\n\\n        for(int i=N-1; i>=0; i--) {\\n            mx = (mx*2)%mod;\\n            mx = (mx + A[i])%mod;\\n        }\\n        return (mx-mn + mod)%mod;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint sumSubseqWidths(vector<int>& A) {\\n        int N = A.size();\\n        long mn = 0, mx = 0, mod = 1000000007;\\n\\n        sort(A.begin(), A.end());\\n        for(int i=0; i<N; i++) {\\n            mn = (mn*2)%mod;\\n            mn = (mn + A[i])%mod;\\n        }\\n\\n        for(int i=N-1; i>=0; i--) {\\n            mx = (mx*2)%mod;\\n            mx = (mx + A[i])%mod;\\n        }\\n        return (mx-mn + mod)%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176301,
                "title": "java-easy-commented-solution",
                "content": "class Solution {\\n\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] pow = new long[n]; //this array keeps count of number of subsequences till a particular index\\n        pow[0] = 1;\\n        long mod = 1000000007;\\n        \\n        for(int i = 1; i<n; i++){\\n            pow[i] =( pow[i-1]*2)%mod;\\n        }\\n        \\n        long ans = 0;\\n        for(int i = 0; i<n; i++){\\n            //an element occurs adds in the answer only when it appears as mas of a subsequence and subtracts only when it occurs as min of a subarray so we calculated this and then kept on appending it in the answer\\n            ans = (ans + nums[i]*pow[i] - nums[i]*pow[n-i-1])%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int sumSubseqWidths(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] pow = new long[n]; //this array keeps count of number of subsequences till a particular index\\n        pow[0] = 1;\\n        long mod = 1000000007;\\n        \\n        for(int i = 1; i<n; i++){\\n            pow[i] =( pow[i-1]*2)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2162427,
                "title": "python-easy-sort-count",
                "content": "(1) first sort the array;\\n(2) ith item, + times=2**i-1, -times=2**(n-1-i)-1 times;\\n(3) sum up\\n\\n```\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        nums.sort()\\n        n=len(nums)\\n        ct=[1]*n\\n        a=1/2\\n        for i in range(n):\\n            a=int(a*2)%mod\\n            ct[i]=a\\n        res=0\\n        for i in range(n):\\n            count=ct[i]-1\\n            count-=ct[-i-1]-1\\n            res+=(mod+nums[i]*count)%mod\\n            res=res%mod\\n        return res",
                "solutionTags": [],
                "code": "(1) first sort the array;\\n(2) ith item, + times=2**i-1, -times=2**(n-1-i)-1 times;\\n(3) sum up\\n\\n```\\ndef sumSubseqWidths(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        nums.sort()\\n        n=len(nums)\\n        ct=[1]*n\\n        a=1/2\\n        for i in range(n):\\n            a=int(a*2)%mod\\n            ct[i]=a\\n        res=0\\n        for i in range(n):\\n            count=ct[i]-1\\n            count-=ct[-i-1]-1\\n            res+=(mod+nums[i]*count)%mod\\n            res=res%mod\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2069229,
                "title": "detailed-explanation-brute-force-optimised-algorithm-java-solution-89-faster",
                "content": "https://www.youtube.com/watch?v=LuiCMG_hBWc&t=223s",
                "solutionTags": [
                    "Math"
                ],
                "code": "https://www.youtube.com/watch?v=LuiCMG_hBWc&t=223s",
                "codeTag": "Unknown"
            },
            {
                "id": 2014439,
                "title": "simple-straight-forward-solution-no-tricks",
                "content": "This one is inspired by https://leetcode.com/problems/sum-of-subsequence-widths/discuss/881805/C%2B%2B-simple-sol-with-comments-beats-88\\n\\nWhere we find out the number of subsets a number would be a part of ending on that number and we sum those counts. Similarly, we subtract all the counts where the number would be a part of a subset starting from that index.\\n\\n```\\nvar sumSubseqWidths = function(nums) {\\n    const mod = 1000000007;\\n    nums.sort((a, b) => a - b), total = 0, power = 1;\\n    for(let i = 0; i < nums.length; i++) {\\n        total = (total + nums[i] * power) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    power = 1;\\n    for(let i = nums.length - 1; i >= 0; i--) {\\n        total = (total - nums[i] * power + mod) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    return (total + mod) % mod\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sumSubseqWidths = function(nums) {\\n    const mod = 1000000007;\\n    nums.sort((a, b) => a - b), total = 0, power = 1;\\n    for(let i = 0; i < nums.length; i++) {\\n        total = (total + nums[i] * power) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    power = 1;\\n    for(let i = nums.length - 1; i >= 0; i--) {\\n        total = (total - nums[i] * power + mod) % mod;\\n        power = (power * 2) % mod;\\n    }\\n    \\n    return (total + mod) % mod\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969433,
                "title": "python-sort-and-linear-scan-o-nlogn-explained",
                "content": "Let A be the array nums.\\nLet n be len(A).\\nFirst sort A.\\nFor each A[i] there are 2^i cases when A[i] becomes the minimum in a subsequence, and 2^(n-1-i) cases when A[i] becomes the maximum.\\nWith a linear scan, process at each position.\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        M = 10**9+7\\n        res = 0\\n        le = 1\\n        re = pow(2, n-1, M)\\n        #by Fermat\\'s Little Thm\\n        #inverse of 2 modulo M\\n        inv = pow(2, M-2, M)\\n        for num in nums:\\n            res = (res + num * (le - re))%M\\n            le = (le * 2) % M\\n            re = (re * inv) % M\\n        return res",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "Let A be the array nums.\\nLet n be len(A).\\nFirst sort A.\\nFor each A[i] there are 2^i cases when A[i] becomes the minimum in a subsequence, and 2^(n-1-i) cases when A[i] becomes the maximum.\\nWith a linear scan, process at each position.\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        M = 10**9+7\\n        res = 0\\n        le = 1\\n        re = pow(2, n-1, M)\\n        #by Fermat\\'s Little Thm\\n        #inverse of 2 modulo M\\n        inv = pow(2, M-2, M)\\n        for num in nums:\\n            res = (res + num * (le - re))%M\\n            le = (le * 2) % M\\n            re = (re * inv) % M\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1949106,
                "title": "sum-of-subsequence-widths-solution-java",
                "content": "class Solution {\\n  public int sumSubseqWidths(int[] nums) {\\n    final int kMod = (int) 1e9 + 7;\\n    final int n = nums.length;\\n    long ans = 0;\\n    long exp = 1;\\n\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i < n; ++i, exp = exp * 2 % kMod) {\\n      ans += (nums[i] - nums[n - i - 1]) * exp;\\n      ans %= kMod;\\n    }\\n\\n    return (int) ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "class Solution {\\n  public int sumSubseqWidths(int[] nums) {\\n    final int kMod = (int) 1e9 + 7;\\n    final int n = nums.length;\\n    long ans = 0;\\n    long exp = 1;\\n\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i < n; ++i, exp = exp * 2 % kMod) {\\n      ans += (nums[i] - nums[n - i - 1]) * exp;\\n      ans %= kMod;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1944862,
                "title": "python-sorting-solution",
                "content": "Sort the list since order won\\'t matter for subsequences.\\nThen just need to observer greatest item will be used 2^(len(nums) - 1) times next largest will used 2^(len(nums) - 2) times ...\\n\\nWe can just calculate this directly since Python ints are unbounded. \\n\\nSame for the mins.\\n\\nThen can just subtract the two.\\n\\n\\n\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        maxes, mins = 0, 0\\n        for i in range(len(nums) - 1, -1, -1):\\n            maxes += nums[i] * (1 << i)\\n        for i in range(len(nums)):\\n            mins += nums[i] * (1 << (len(nums) - i - 1))\\n        return (maxes - mins) % int(1e9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        maxes, mins = 0, 0\\n        for i in range(len(nums) - 1, -1, -1):\\n            maxes += nums[i] * (1 << i)\\n        for i in range(len(nums)):\\n            mins += nums[i] * (1 << (len(nums) - i - 1))\\n        return (maxes - mins) % int(1e9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934391,
                "title": "c-o-n-solution-in-one-linear-scan",
                "content": "```\\nconstexpr long p = 1000000007;\\nclass Solution \\n{\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        long totalWidth = 0;\\n        long numSubSets = 1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            totalWidth = (totalWidth + numSubSets * (nums[i] - nums[n - 1 - i])) % p;\\n            numSubSets = (numSubSets * 2) % p;\\n        }\\n        return totalWidth % p;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconstexpr long p = 1000000007;\\nclass Solution \\n{\\npublic:\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        long totalWidth = 0;\\n        long numSubSets = 1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            totalWidth = (totalWidth + numSubSets * (nums[i] - nums[n - 1 - i])) % p;\\n            numSubSets = (numSubSets * 2) % p;\\n        }\\n        return totalWidth % p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881830,
                "title": "python-easy-to-read-and-understand-sorting",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            mx = (2**i)*nums[i]\\n            mn = (2**(n-1-i))*nums[i]\\n            ans += (mx-mn)\\n        \\n        return ans%(10**9+7)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            mx = (2**i)*nums[i]\\n            mn = (2**(n-1-i))*nums[i]\\n            ans += (mx-mn)\\n        \\n        return ans%(10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 1855046,
                "title": "java-mathematics-logic-easy-to-understand",
                "content": "# public int sumSubseqWidths(int[] nums) {\\n        long res = 0;\\n        long mod = 1000000007;\\n        Arrays.sort(nums);\\n        long[] powers = new long[nums.length];\\n        powers[0] = 1;\\n        for (int i = 1; i < powers.length; i++) {\\n            powers[i] = (powers[i - 1] * 2) % mod;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            res = (res + nums[i] * (powers[i] - powers[nums.length - i - 1])) % mod;\\n        }\\n        return (int) res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "# public int sumSubseqWidths(int[] nums) {\\n        long res = 0;\\n        long mod = 1000000007;\\n        Arrays.sort(nums);\\n        long[] powers = new long[nums.length];\\n        powers[0] = 1;\\n        for (int i = 1; i < powers.length; i++) {\\n            powers[i] = (powers[i - 1] * 2) % mod;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            res = (res + nums[i] * (powers[i] - powers[nums.length - i - 1])) % mod;\\n        }\\n        return (int) res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1833525,
                "title": "c-o-nlogn-explained-completely-new-approach",
                "content": "**Intuition and Approach:** \\n\\nClearly, generating all subsequences is not possible because of huge constraints. So, try thinking about what each element can contribute to the answer. For each subsequence, we have to find the maximum and minimum element. \\n\\nThinking on a broader expectation, it can be said that pick two elements, consider one as max and one as min, and just multiply their absolute difference with the number of times they will be maximum and minimum in the subsequences generated.\\n\\nSort the array, such that no extra time could be taken to find max and min elements. \\n\\nlet sorted array be [1,2,3,4,5,6,7,8] \\n\\nLets consider 1 as min and 4 as max for a subsequence \\n\\n1 and 4 can have 3 elements in between as per the given array\\n\\n1 _   _   _  4\\n1 2 2 2 1\\n\\n**By permutations, we can say that the number of such possible subsequences are 1x2x2x2x1=8. Thus (4-1) will come 8 times in the total subsequences and will contribute (4-1)x8 to the answer.**\\n\\nThus, anwer is:\\n `for(i = 0 to n - 2) for(j = i + 1 to n - 1) ans+=(Aj - Ai) X (2^(j - i + 1))          ------------------> Eqn 1`\\n\\nWhere Aj and Ai are the max and min elements. \\n\\n**But if you simply run the above snippet, you will again get TLE because it is again O(N^2).**\\n\\nKeeping the same idea intact, try reducing `Eqn 1 `to its reduced version. \\n\\n**Consider elements [a,b,c,d] such that a <= b <= c <= d. Here n=4, place all values of i and j**\\n\\n```\\n= { A1 (2^0) + A2 (2^1) + A3 (2^2) + A2 (2^0) + A3 (2^1) + A3 (2^0) }  - { A0 (2^0) + A0 (2^1) + A0 (2^2) + A1 (2^0) + A1 (2^1) + A2 (2^0) }    \\n\\n= { (2^0)(A1+A2+A3) + (2^1)(A2+A3) + (2^2)(A3) }  - { (2^0)(A0+A1+A2) + (2^1)(A0+A1) + (2^2)(A0) }\\n```\\n\\nTo generalize this,  we can say that\\n\\n```\\nFor (i = 0 to n-1) ans = ans + 2^i * (prefix[n-1] - prefix[i]) - 2^i * prefix[n-2-i];\\n```\\nWe have to handle this under modulo.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int md=1e9+7;\\n    using ll=long long;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n\\n        vector<ll> pow(n), pref(n);\\n        pow[0]=1;\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++) {\\n            pow[i]=(2*pow[i-1]) % md;\\n            pref[i]=(pref[i-1]%md+nums[i]%md)%md;\\n        }\\n        \\n        ll ans=0;\\n         for(int i=0;i<n-1;i++) {\\n            ans+=(pow[i] * (pref[n-1]-pref[i])) % md  -  (pow[i] * pref[n-2-i] + md) % md;\\n            ans=(ans+md)%md;\\n         }\\n        return ans%md;\\n    }\\n};\\n```\\n\\n**Time: O(NlogN)\\nSpace: O(N)**\\n\\nUpvote if you liked!!\\nLet me know your doubts in the comment section!!",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n= { A1 (2^0) + A2 (2^1) + A3 (2^2) + A2 (2^0) + A3 (2^1) + A3 (2^0) }  - { A0 (2^0) + A0 (2^1) + A0 (2^2) + A1 (2^0) + A1 (2^1) + A2 (2^0) }    \\n\\n= { (2^0)(A1+A2+A3) + (2^1)(A2+A3) + (2^2)(A3) }  - { (2^0)(A0+A1+A2) + (2^1)(A0+A1) + (2^2)(A0) }\\n```\n```\\nFor (i = 0 to n-1) ans = ans + 2^i * (prefix[n-1] - prefix[i]) - 2^i * prefix[n-2-i];\\n```\n```\\nclass Solution {\\npublic:\\n    int md=1e9+7;\\n    using ll=long long;\\n    int sumSubseqWidths(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        \\n        sort(nums.begin(), nums.end());\\n\\n        vector<ll> pow(n), pref(n);\\n        pow[0]=1;\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++) {\\n            pow[i]=(2*pow[i-1]) % md;\\n            pref[i]=(pref[i-1]%md+nums[i]%md)%md;\\n        }\\n        \\n        ll ans=0;\\n         for(int i=0;i<n-1;i++) {\\n            ans+=(pow[i] * (pref[n-1]-pref[i])) % md  -  (pow[i] * pref[n-2-i] + md) % md;\\n            ans=(ans+md)%md;\\n         }\\n        return ans%md;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789008,
                "title": "java-easy-solution-o-nlogn-time-complexity",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] arr1) {\\n        Arrays.sort(arr1);\\n        int n=arr1.length;\\n        int mod=(int)1e9+7;\\n        long ans=0l;\\n        long power=1l;\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            ans=((ans%mod)+power*(arr1[i]-arr1[n-i-1])+mod)%mod;\\n            power=(power<<1)%mod;\\n        }\\n        \\n        return (int)(ans%mod);\\n    }   \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] arr1) {\\n        Arrays.sort(arr1);\\n        int n=arr1.length;\\n        int mod=(int)1e9+7;\\n        long ans=0l;\\n        long power=1l;\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            ans=((ans%mod)+power*(arr1[i]-arr1[n-i-1])+mod)%mod;\\n            power=(power<<1)%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1788362,
                "title": "nlog-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        long ans = 0;\\n        long mod = 1000000007;\\n        long[] pow = new long[arr.length];\\n        pow[0] = 1;\\n        for(int i = 1 ; i < pow.length ; i++){\\n            pow[i] = (pow[i-1]*2)%mod; \\n        }\\n        \\n        for(int i = 0 ; i < arr.length ; i++){\\n            ans = (ans + arr[i]*(pow[i] - pow[arr.length - i - 1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumSubseqWidths(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        long ans = 0;\\n        long mod = 1000000007;\\n        long[] pow = new long[arr.length];\\n        pow[0] = 1;\\n        for(int i = 1 ; i < pow.length ; i++){\\n            pow[i] = (pow[i-1]*2)%mod; \\n        }\\n        \\n        for(int i = 0 ; i < arr.length ; i++){\\n            ans = (ans + arr[i]*(pow[i] - pow[arr.length - i - 1]))%mod;\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755006,
                "title": "query-regarding-java-code",
                "content": "The mathematical base of this approach is correct for smaller lengths but for larger arrays I am getting a negative answer. Can someone help me to figure this out!\\n```\\n   Arrays.sort(a);\\n        long curr = 0;\\n        int n = a.length;\\n        int max=-1;\\n        long ans=0;\\n      \\n        long[] pow = new long[n+1];\\n        long cp =1;\\n        pow[0]=1;\\n        for(int i=1;i<=n;i++){\\n            cp = (cp*2)%mod;\\n            if(cp<0){\\n                cp+=mod;\\n            }\\n            pow[i] = cp;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            curr = (curr+(pow[max+1]*((long)(a[n-1])-(long)(a[i])))%mod)%mod;\\n            max++;\\n           \\n        }\\n        ans+=curr;\\n        \\n        for(int j= n-2;j>=0;j--){\\n          \\n            curr= (curr- (long)(a[j+1])+(long)(a[j]))%mod;\\n          \\n            curr/=2;\\n            max--;\\n            int nc= 0;\\n            if(max>=0){\\n                long k = ((pow[max+1]-1)%mod*((long)(a[j+1])-(long)(a[j]))%mod)%mod;\\n\\n                curr= (curr - k)%mod;\\n           \\n\\n            }\\n          \\n            \\n            ans = (ans+curr)%mod;\\n        }\\n        \\n        return (int)(ans%mod);\\n```",
                "solutionTags": [],
                "code": "```\\n   Arrays.sort(a);\\n        long curr = 0;\\n        int n = a.length;\\n        int max=-1;\\n        long ans=0;\\n      \\n        long[] pow = new long[n+1];\\n        long cp =1;\\n        pow[0]=1;\\n        for(int i=1;i<=n;i++){\\n            cp = (cp*2)%mod;\\n            if(cp<0){\\n                cp+=mod;\\n            }\\n            pow[i] = cp;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            curr = (curr+(pow[max+1]*((long)(a[n-1])-(long)(a[i])))%mod)%mod;\\n            max++;\\n           \\n        }\\n        ans+=curr;\\n        \\n        for(int j= n-2;j>=0;j--){\\n          \\n            curr= (curr- (long)(a[j+1])+(long)(a[j]))%mod;\\n          \\n            curr/=2;\\n            max--;\\n            int nc= 0;\\n            if(max>=0){\\n                long k = ((pow[max+1]-1)%mod*((long)(a[j+1])-(long)(a[j]))%mod)%mod;\\n\\n                curr= (curr - k)%mod;\\n           \\n\\n            }\\n          \\n            \\n            ans = (ans+curr)%mod;\\n        }\\n        \\n        return (int)(ans%mod);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730973,
                "title": "n-logn-time-complexity",
                "content": "In Swift, we don\\'t have anyway to store a number more than 2^63 - 1. So, for larger numbers we will get runtime error.\\n\\n```\\nfunc sumSubseqWidths(_ nums: [Int]) -> Int {\\n    let sortedNums = nums.sorted()\\n    var output: Int64 = 0\\n    let n = sortedNums.count\\n    \\n    for i in 0..<n {\\n        let num = Int64(sortedNums[i])\\n        let leftElements = i\\n        let rightElements = n-1-i\\n        let leftSubSeq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, leftElements))))%10000000007\\n        let rightSubseq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, rightElements))))%10000000007\\n        let diff: Int64 = (leftSubSeq-rightSubseq)%10000000007\\n        output += num*diff\\n    }\\n    \\n    return Int(output%10000000007)\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nfunc sumSubseqWidths(_ nums: [Int]) -> Int {\\n    let sortedNums = nums.sorted()\\n    var output: Int64 = 0\\n    let n = sortedNums.count\\n    \\n    for i in 0..<n {\\n        let num = Int64(sortedNums[i])\\n        let leftElements = i\\n        let rightElements = n-1-i\\n        let leftSubSeq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, leftElements))))%10000000007\\n        let rightSubseq: Int64 = Int64(truncating: NSDecimalNumber(decimal: (pow(2, rightElements))))%10000000007\\n        let diff: Int64 = (leftSubSeq-rightSubseq)%10000000007\\n        output += num*diff\\n    }\\n    \\n    return Int(output%10000000007)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677485,
                "title": "sum-of-subsequence-widths",
                "content": "Why does the solution (in java) do a mod of 1000000007 when calculating 2 power array. As per the question, the mod of 1000000007 should only be performed on the result. isnt it?",
                "solutionTags": [],
                "code": "Why does the solution (in java) do a mod of 1000000007 when calculating 2 power array. As per the question, the mod of 1000000007 should only be performed on the result. isnt it?",
                "codeTag": "Unknown"
            },
            {
                "id": 1627929,
                "title": "python-with-explanation",
                "content": "First, sort the nums as the order doesn\\'t matter in this case\\nSecond, let\\'s take a look which subarrays will be used and how many times they will be counted.\\n\\nAssume the length is *l*, and the subarrays are:\\n[0,1] once, [0,2] twice, [0,3] three times, .. [0,l-1] l times\\n\\t\\t\\t\\t\\t   [1,2] once, [1,3] twice, ..        [1,l-1] l-1 times\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[2,3] once, ..            [2,l-1] l-2 times\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[l-2,l-1] once\\nif we use an array res to represent the sum with different length *l* \\n        ****when l=2:****\\n        res[l=2] = (nums[1]-nums[0])*1 = nums[1]*2^0 - nums[0]*2^0\\n        ****when l=3:****\\n        res[l=3] = (nums[2]-nums[1])*1 + (nums[2]-nums[0])*2 + (nums[1]-nums[0])*1\\n\\t\\t\\t\\t\\t= res[l=2] + nums[2]*(2^0+2^1) - nums[1]*2^0 + nums[0]*2^1\\n        ****when l=4:****            \\n        res[l=4] = (nums[1]-nums[0])*1 + (nums[2]-nums[1])*1 + (nums[3]-nums[2])*1 + \\n                (nums[2]-nums[0])*2 + (nums[3]-nums[1])*2 +\\n                (nums[3]-nums[0])*2^2\\n            = nums[3]*(4+2+1)-nums[0]*(2^0+2^1+2^2) + nums[2]*(2) - nums[1]*(2)\\n            = res[3] + (nums[3]-nums[2])*1 + (nums[3]-nums[1])*2 + (nums[3]-nums[0])*2^2\\n            = res[l=3] + nums[3]*(1+2+4) - nums[2]*1 - nums[1]*2 - nums[0]*2^2\\n       ****when l=5:****\\n        res[l=5] = (nums[1]-nums[0])*1 + (nums[2]-nums[1])*1 + (nums[3]-nums[2])*1 + (nums[4]-nums[3])*1 +\\n                (nums[2]-nums[0])*2 + (nums[3]-nums[1])*2 + (nums[4]-nums[2])*2 +\\n                (nums[3]-nums[0])*2^2 + (nums[4]-nums[1])*2^2 +\\n                (nums[4]-nums[0])*2^3\\n            = res[l=4] + (nums[4]-nums[3])*1 + (nums[4]-nums[2])*2 + (nums[4]-nums[1])*2^2 + (nums[4]-nums[0])*2^3\\n            = res[l=4] + nums[4]*(2^0+2^1+2^2+2^3) - nums[3] - nums[2]*2 - nums[1]*2^2 - nums[0]*2^3\\n        ****when l=6:****\\n        res[l=6] = res[l=5] + nums[5]*(1+...+2^4) - nums[4] - nums[3]*2 - nums[2]*2^2 - nums[1]*2^3 - nums[0]*2^4\\n\\nIt\\'s easy to write code like this:\\n```\\nnums = sorted(nums)\\n        l = len(nums)\\n        res = 0\\n        n = 0\\n        s = 0\\n        m = 10**9+7\\n        for i in range(1,l):\\n            n = (n*2+nums[i-1])%m\\n            s = (s*2+1)%m\\n            res = (res + s*nums[i] - n)%m\\n        return res%m\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nnums = sorted(nums)\\n        l = len(nums)\\n        res = 0\\n        n = 0\\n        s = 0\\n        m = 10**9+7\\n        for i in range(1,l):\\n            n = (n*2+nums[i-1])%m\\n            s = (s*2+1)%m\\n            res = (res + s*nums[i] - n)%m\\n        return res%m\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590029,
                "title": "c-maths-sorting-greedy",
                "content": "class Solution {\\npublic:\\n    \\n    long long M=1e9+7;\\n    \\n    long long mod(long long a){\\n        \\n        return ((a%M)+M)%M;\\n        \\n    }\\n    \\n    long long mul(long long a,long long b){\\n        \\n        return mod(mod(a)*mod(b));\\n        \\n    }\\n    \\n    int sumSubseqWidths(vector<int>& nums) {\\n      \\n        long long n=nums.size();\\n        \\n        vector<long long>pow(n);\\n        \\n        pow[0]=1LL;\\n        \\n        for(long i=1;i<n;i++){\\n            \\n            pow[i]=mul(2,pow[i-1]);\\n            \\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        long long ans=0;\\n        \\n        for(long i=0;i<n;i++){\\n            \\n            long long val=(pow[i]-pow[n-i-1])*nums[i];\\n            \\n            ans=(ans+val)%M;\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    long long M=1e9+7;\\n    \\n    long long mod(long long a){\\n        \\n        return ((a%M)+M)%M;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1545974,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = val = 0 \\n        p = 1\\n        for i in range(1, len(nums)): \\n            p = p * 2 % MOD\\n            val = (2*val + (nums[i]-nums[i-1])*(p-1)) % MOD \\n            ans = (ans + val) % MOD \\n        return ans \\n```\n```\\nclass Solution:\\n    def sumSubseqWidths(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        ans = 0 \\n        for i, x in enumerate(sorted(nums)): \\n            ans += x * (pow(2, i, MOD) - pow(2, len(nums)-i-1, MOD))\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461971,
                "title": "somthing-wrong-with-this-test-case",
                "content": "[2,1] returns 1 as a test case and in my local dev env with python 3, but when I submit, I got a 0 as output. What am I missing here?\\n\\n![image](https://assets.leetcode.com/users/images/bde95861-01ba-4ad4-9dd2-fc8e8b21b7fe_1631562000.1102972.png)\\n",
                "solutionTags": [],
                "code": "[2,1] returns 1 as a test case and in my local dev env with python 3, but when I submit, I got a 0 as output. What am I missing here?\\n\\n![image](https://assets.leetcode.com/users/images/bde95861-01ba-4ad4-9dd2-fc8e8b21b7fe_1631562000.1102972.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1455321,
                "title": "python-time-complexity-nlogn",
                "content": "\\n```\\nclass Solution:\\n    def sumSubseqWidths(self, a: List[int]) -> int:\\n        mod=int(1e9)+7\\n        p=1\\n        ans=0\\n        n=len(a)\\n        a.sort()\\n        for i in range(0,n):\\n            ans=(ans+((a[i]-a[n-i-1])*p))%mod\\n            p=(p<<1)%mod\\n        return ans%mod\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, a: List[int]) -> int:\\n        mod=int(1e9)+7\\n        p=1\\n        ans=0\\n        n=len(a)\\n        a.sort()\\n        for i in range(0,n):\\n            ans=(ans+((a[i]-a[n-i-1])*p))%mod\\n            p=(p<<1)%mod\\n        return ans%mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419500,
                "title": "can-anyone-help-in-telling-me-the-issue-with-my-approach",
                "content": "My appaoach is that from result we substract and add in such a way that\\n1. Substract No. of subsequences in which nums[i] is minimum * nums[i]\\n2. Add no. of subsequences in which nums[i] is maximum * nums[i]\\n3. No of subsequences = 2^ (elements to left OR right of nums[i])\\n\\n\\n```\\npublic int sumSubseqWidths(int[] nums) {\\n        int MOD = 1000000007;\\n        long res =0, n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i=0;i<n;i++) {\\n            res = (res - ((long)Math.pow(2, n-1-i)*(long)nums[i]))%MOD;\\n            res = (res + ((long)Math.pow(2, i)*(long)nums[i]))%MOD;\\n        }\\n        return (int)(res % MOD);\\n    }\\n```\\n\\nIt is failing for following test case\\n[96,87,191,197,40,101,108,35,169,50,168,182,95,80,144,43,18,60,174,13,77,173,38,46,80,117,13,19,11,6,13,118,39,80,171,36,86,156,165,190,53,49,160,192,57,42,97,35,124,200,84,70,145,180,54,141,159,42,66,66,25,95,24,136,140,159,71,131,5,140,115,76,151,137,63,47,69,164,60,172,153,183,6,70,40,168,133,45,116,188,20,52,70,156,44,27,124,59,42,172]",
                "solutionTags": [],
                "code": "```\\npublic int sumSubseqWidths(int[] nums) {\\n        int MOD = 1000000007;\\n        long res =0, n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i=0;i<n;i++) {\\n            res = (res - ((long)Math.pow(2, n-1-i)*(long)nums[i]))%MOD;\\n            res = (res + ((long)Math.pow(2, i)*(long)nums[i]))%MOD;\\n        }\\n        return (int)(res % MOD);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1289099,
                "title": "c-nlogn-99-faster",
                "content": "logic:\\n1.Here we are considering every subsequence hence ordering don\\'t matter.Hence sort it ..work will become easy.\\n2.We know n elements can form 2^n subsequences\\n3.In sorted array A[i] will be maximum in 2^(i-1)subsequences and smallest in 2^(n-i-1) subsequences .\\n```\\n    int sumSubseqWidths(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        long long n=a.size(),i,ans=0,x=1,m=1e9+7;\\n        for(i=0;i<n;i++)\\n        {\\n            x%=m;\\n            ans=(ans+(x*a[i])%m-(x*(a[n-i-1]))%m)%m;\\n            x*=2;\\n        }\\n        \\n        return (ans+m)%m;\\n    }",
                "solutionTags": [],
                "code": "logic:\\n1.Here we are considering every subsequence hence ordering don\\'t matter.Hence sort it ..work will become easy.\\n2.We know n elements can form 2^n subsequences\\n3.In sorted array A[i] will be maximum in 2^(i-1)subsequences and smallest in 2^(n-i-1) subsequences .\\n```\\n    int sumSubseqWidths(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        long long n=a.size(),i,ans=0,x=1,m=1e9+7;\\n        for(i=0;i<n;i++)\\n        {\\n            x%=m;\\n            ans=(ans+(x*a[i])%m-(x*(a[n-i-1]))%m)%m;\\n            x*=2;\\n        }\\n        \\n        return (ans+m)%m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1274191,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    private  int mod = 1000000007;\\n\\n        public  int SumSubseqWidths(int[] nums)\\n        {\\n\\n            long ans = 0;\\n            Array.Sort(nums);\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                ans = (ans + (cChe(2L, i) - 1) * nums[i] % mod) % mod;\\n                ans = (ans - (cChe(2L, nums.Length - 1 - i) - 1) * nums[i] % mod) % mod;\\n            }\\n\\n            return (int)ans;\\n        }\\n\\n        private  long cChe(long x, long y)\\n        {\\n            long res = 1;\\n            while (y > 0)\\n            {\\n                if (y % 2 != 0)\\n                    res = res * x % mod;\\n                x = x * x % mod;\\n                y /= 2;\\n            }\\n            return res % mod;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private  int mod = 1000000007;\\n\\n        public  int SumSubseqWidths(int[] nums)\\n        {\\n\\n            long ans = 0;\\n            Array.Sort(nums);\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                ans = (ans + (cChe(2L, i) - 1) * nums[i] % mod) % mod;\\n                ans = (ans - (cChe(2L, nums.Length - 1 - i) - 1) * nums[i] % mod) % mod;\\n            }\\n\\n            return (int)ans;\\n        }\\n\\n        private  long cChe(long x, long y)\\n        {\\n            long res = 1;\\n            while (y > 0)\\n            {\\n                if (y % 2 != 0)\\n                    res = res * x % mod;\\n                x = x * x % mod;\\n                y /= 2;\\n            }\\n            return res % mod;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213909,
                "title": "c-o-nlgn",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    #define ll long long int\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        ll pow2[n];\\n        pow2[0]=1;\\n        for(int i=1;i<n;i++)\\n            pow2[i]=(2*pow2[i-1])%mod;\\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            res=(res+(pow2[i]-pow2[n-i-1])*nums[i])%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    #define ll long long int\\n    int sumSubseqWidths(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        ll pow2[n];\\n        pow2[0]=1;\\n        for(int i=1;i<n;i++)\\n            pow2[i]=(2*pow2[i-1])%mod;\\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            res=(res+(pow2[i]-pow2[n-i-1])*nums[i])%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203276,
                "title": "c-concise-code",
                "content": "```\\n#define mod 1000000007\\nint sumSubseqWidths(vector<int>& arr) \\n{\\n\\tsort(arr.begin(),arr.end());\\n\\tlong val=0,ret=0,_2=1;\\n\\tfor(int i=arr.size()-2;i>=0;--i)\\n\\t{\\n\\t\\tval=val*2+arr[i+1];\\n\\t\\t_2<<=1;\\n\\t\\t_2%=mod;\\n\\t\\tret+=(val-(_2-1)*arr[i]);\\n\\t\\tval%=mod;\\n\\t\\tret%=mod;\\n\\t}\\n\\treturn (ret+mod)%mod;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define mod 1000000007\\nint sumSubseqWidths(vector<int>& arr) \\n{\\n\\tsort(arr.begin(),arr.end());\\n\\tlong val=0,ret=0,_2=1;\\n\\tfor(int i=arr.size()-2;i>=0;--i)\\n\\t{\\n\\t\\tval=val*2+arr[i+1];\\n\\t\\t_2<<=1;\\n\\t\\t_2%=mod;\\n\\t\\tret+=(val-(_2-1)*arr[i]);\\n\\t\\tval%=mod;\\n\\t\\tret%=mod;\\n\\t}\\n\\treturn (ret+mod)%mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1160960,
                "title": "ruby",
                "content": "```\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef sum_subseq_widths(a)\\n  mod = 10 ** 9 + 7\\n  n = a.size\\n  a.sort!\\n  \\n  pow2 = Array.new(n)\\n  pow2[0] = 1\\n  \\n  (1..n).each do |i|\\n    pow2[i] = pow2[i - 1] * 2 % mod\\n  end\\n  \\n  ans = 0\\n  (0..n - 1).each do |i|\\n    ans = (ans + (pow2[i] - pow2[n-1-i]) * a[i]) % mod\\n  end\\n  \\n  ans\\n\\nend\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef sum_subseq_widths(a)\\n  mod = 10 ** 9 + 7\\n  n = a.size\\n  a.sort!\\n  \\n  pow2 = Array.new(n)\\n  pow2[0] = 1\\n  \\n  (1..n).each do |i|\\n    pow2[i] = pow2[i - 1] * 2 % mod\\n  end\\n  \\n  ans = 0\\n  (0..n - 1).each do |i|\\n    ans = (ans + (pow2[i] - pow2[n-1-i]) * a[i]) % mod\\n  end\\n  \\n  ans\\n\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1112290,
                "title": "how-this-can-be-optimized",
                "content": "Intution: I have use recurssive top to down approch for the given problem. My solution is divided into 3 parts. \\nPart 1: storing each subset into a temporary vector.\\nPart 2: I use a width vector to store width of each subset.\\nPart 3: Finally, adding all the values of width vector\\n\\nI am getting TLE. can anyone there to help me out where I can do optimization. Here is the code\\n```\\n\\tclass Solution {\\npublic:\\n    vector<long long int>width;\\nvoid subsequence(vector<int> &arr, int index, vector<int> &temp) \\n{\\n\\n\\tif (index == arr.size()) {\\n\\t\\tlong long int MAX = *max_element(temp.begin(),temp.end());\\n\\t\\tlong long int MIN = *min_element(temp.begin(),temp.end());\\n\\t\\twidth.push_back(MAX-MIN);\\n\\t\\treturn;\\n\\t}\\n\\telse {\\n\\n\\t\\ttemp.push_back(arr[index]);\\n\\t\\tsubsequence(arr, index + 1, temp); //  including\\n\\t\\ttemp.pop_back();\\n\\t\\tsubsequence(arr, index + 1, temp); // Not Including\\n\\n\\t\\treturn;\\n\\t}\\n}\\nint sumSubseqWidths(vector<int>& A) {\\n        vector<int> temp;\\n        subsequence(A, 0, temp);\\n        long long int ans = 0;\\n        for(auto i:width){\\n            ans+= i;\\n            ans = ans%1000000007;\\n        }\\n\\t    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    vector<long long int>width;\\nvoid subsequence(vector<int> &arr, int index, vector<int> &temp) \\n{\\n\\n\\tif (index == arr.size()) {\\n\\t\\tlong long int MAX = *max_element(temp.begin(),temp.end());\\n\\t\\tlong long int MIN = *min_element(temp.begin(),temp.end());\\n\\t\\twidth.push_back(MAX-MIN);\\n\\t\\treturn;\\n\\t}\\n\\telse {\\n\\n\\t\\ttemp.push_back(arr[index]);\\n\\t\\tsubsequence(arr, index + 1, temp); //  including\\n\\t\\ttemp.pop_back();\\n\\t\\tsubsequence(arr, index + 1, temp); // Not Including\\n\\n\\t\\treturn;\\n\\t}\\n}\\nint sumSubseqWidths(vector<int>& A) {\\n        vector<int> temp;\\n        subsequence(A, 0, temp);\\n        long long int ans = 0;\\n        for(auto i:width){\\n            ans+= i;\\n            ans = ans%1000000007;\\n        }\\n\\t    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077876,
                "title": "c-faster-than-97-braindead-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& v) {\\n        int n = v.size();\\n        const long long mod = 1000000007;\\n        sort(v.begin(), v.end());\\n        vector<long long> power_2(n, 1);\\n        for(int i = 1;i < n;i++)\\n            power_2[i] = (power_2[i - 1] << 1) % mod;\\n        long long res = 0;\\n        for(int i = 0;i < n;i++)\\n            res = (res + v[i] * (power_2[i] - power_2[n - i - 1])) % mod;\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& v) {\\n        int n = v.size();\\n        const long long mod = 1000000007;\\n        sort(v.begin(), v.end());\\n        vector<long long> power_2(n, 1);\\n        for(int i = 1;i < n;i++)\\n            power_2[i] = (power_2[i - 1] << 1) % mod;\\n        long long res = 0;\\n        for(int i = 0;i < n;i++)\\n            res = (res + v[i] * (power_2[i] - power_2[n - i - 1])) % mod;\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1042236,
                "title": "doubt",
                "content": "I see that the collection of  subsequences resemble the power set except null.Is there any relevant approach in that direction?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1035119,
                "title": "p23-5",
                "content": "Hint -> Sort the array, subseq when olny checking fo rmin and max does not effect after sorting\\nHint -> Complexity will be nlog(n)\\nHint -> For every element, find for how many it will be max, and for how many it will be min",
                "solutionTags": [],
                "code": "Hint -> Sort the array, subseq when olny checking fo rmin and max does not effect after sorting\\nHint -> Complexity will be nlog(n)\\nHint -> For every element, find for how many it will be max, and for how many it will be min",
                "codeTag": "Unknown"
            },
            {
                "id": 800350,
                "title": "can-someone-help-me-find-the-issue-in-this-code",
                "content": "The below mentioned solution passes 20/61 test cases. The ones in which it fails are very close to the answer. For example, actual answer = 8724365, my answer = 8724364\\n\\n\\n    int sumSubseqWidths(vector<int>& A) {\\n        int m = *max_element(A.begin(), A.end());\\n        long long int arr[m+1];\\n        for(int i = 0; i <= m; i++) {\\n            arr[i] = 0;\\n        }\\n\\t\\t\\n        for(int i = 0; i < A.size(); i++) {\\n            arr[A[i]]++;\\n        }\\n        \\n        //prefix sum\\n        for(int i = 1; i <= m; i++) {\\n            arr[i] += arr[i-1];\\n        }\\n        \\n        long long int ans = 0;\\n        for(int i = 1; i <= m-1; i++) {\\n            if(arr[i] == arr[i-1]) {\\n                continue;\\n            }\\n            for(int j = i+1; j <= m; j++) {\\n                if(arr[j] == arr[j-1]) {\\n                    continue;\\n                }\\n                long long int start = arr[i]-arr[i-1];\\n                long long int end = arr[j]-arr[j-1];\\n                long long int mid = arr[j-1]-arr[i];\\n                ans += (j-i)*pow(2, mid)*(pow(2, start)-1)*(pow(2, end)-1);\\n                ans = ans%1000000007;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "The below mentioned solution passes 20/61 test cases. The ones in which it fails are very close to the answer. For example, actual answer = 8724365, my answer = 8724364\\n\\n\\n    int sumSubseqWidths(vector<int>& A) {\\n        int m = *max_element(A.begin(), A.end());\\n        long long int arr[m+1];\\n        for(int i = 0; i <= m; i++) {\\n            arr[i] = 0;\\n        }\\n\\t\\t\\n        for(int i = 0; i < A.size(); i++) {\\n            arr[A[i]]++;\\n        }\\n        \\n        //prefix sum\\n        for(int i = 1; i <= m; i++) {\\n            arr[i] += arr[i-1];\\n        }\\n        \\n        long long int ans = 0;\\n        for(int i = 1; i <= m-1; i++) {\\n            if(arr[i] == arr[i-1]) {\\n                continue;\\n            }\\n            for(int j = i+1; j <= m; j++) {\\n                if(arr[j] == arr[j-1]) {\\n                    continue;\\n                }\\n                long long int start = arr[i]-arr[i-1];\\n                long long int end = arr[j]-arr[j-1];\\n                long long int mid = arr[j-1]-arr[i];\\n                ans += (j-i)*pow(2, mid)*(pow(2, start)-1)*(pow(2, end)-1);\\n                ans = ans%1000000007;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 788784,
                "title": "o-n-log-n-sort-compact-14-lines",
                "content": "```\\n#define MOD__ ((int)(1e9 + 7))\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1;\\n        int res = 0;\\n        \\n        for (int i = 0; i < A.size(); i++, c = c * 2 % MOD__)\\n            res = (res + A[i] * c - A[A.size() - i - 1] * c) % MOD__;\\n        \\n        return (res + MOD__) % MOD__;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD__ ((int)(1e9 + 7))\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1;\\n        int res = 0;\\n        \\n        for (int i = 0; i < A.size(); i++, c = c * 2 % MOD__)\\n            res = (res + A[i] * c - A[A.size() - i - 1] * c) % MOD__;\\n        \\n        return (res + MOD__) % MOD__;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738182,
                "title": "o-n-logn-sort-o-n-loop",
                "content": "```\\n#define M 1000000007\\n    int modularExponentiation(long long int x,long long int n)\\n    {\\n        long long int result=1;\\n        while(n>0)\\n        {\\n            if(n % 2 ==1)\\n                result=(result * x)%M;\\n            x=(x*x)%M;\\n            n=n/2;\\n        }\\n        return result;\\n    }\\n    \\n\\n    int sumSubseqWidths(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        long long int sumf=0,sumb=0;\\n        long long int ans=0;\\n        for(int i=0;i<n/2;++i){\\n            sumf+=v[i];\\n            sumb+=v[n-1-i];\\n            if(2*(i+1)==n){\\n                ans=(ans+(sumb-sumf)*(modularExponentiation(2,i))%M)%M;\\n            }\\n            else{\\n                 ans=(ans+(sumb-sumf)*(modularExponentiation(2,i)+modularExponentiation(2,n-2-i))%M)%M;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n#define M 1000000007\\n    int modularExponentiation(long long int x,long long int n)\\n    {\\n        long long int result=1;\\n        while(n>0)\\n        {\\n            if(n % 2 ==1)\\n                result=(result * x)%M;\\n            x=(x*x)%M;\\n            n=n/2;\\n        }\\n        return result;\\n    }\\n    \\n\\n    int sumSubseqWidths(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        long long int sumf=0,sumb=0;\\n        long long int ans=0;\\n        for(int i=0;i<n/2;++i){\\n            sumf+=v[i];\\n            sumb+=v[n-1-i];\\n            if(2*(i+1)==n){\\n                ans=(ans+(sumb-sumf)*(modularExponentiation(2,i))%M)%M;\\n            }\\n            else{\\n                 ans=(ans+(sumb-sumf)*(modularExponentiation(2,i)+modularExponentiation(2,n-2-i))%M)%M;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 725360,
                "title": "dp-c",
                "content": "```\\nclass Solution {\\n    int M=1e9+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        int N=A.size();\\n        sort(A.begin(),A.end());\\n        vector<long> dp(N),s(N);\\n        s[0]=A[0];\\n        long power=1;\\n        for(int i=1;i<N;++i)\\n        {\\n            power=power*2%M;\\n            dp[i]=(dp[i-1]+((power-1)*A[i])-s[i-1])%M;\\n            s[i]=(2*s[i-1]%M+A[i])%M;\\n        }\\n        return dp[N-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int M=1e9+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        int N=A.size();\\n        sort(A.begin(),A.end());\\n        vector<long> dp(N),s(N);\\n        s[0]=A[0];\\n        long power=1;\\n        for(int i=1;i<N;++i)\\n        {\\n            power=power*2%M;\\n            dp[i]=(dp[i-1]+((power-1)*A[i])-s[i-1])%M;\\n            s[i]=(2*s[i-1]%M+A[i])%M;\\n        }\\n        return dp[N-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721887,
                "title": "python-easy-and-concise-o-nlogn-sort-o-n-scan",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort(reverse=True)\\n         \\n        # a b c d\\n        # [a], scan b -> (b - a) * 1\\n        # [a, b], scan c -> (c - a) * 2 + (c - b) * 1\\n        # [a, b, c], scan d -> (d - a) * 4 + (d - b) * 2 + (d - c) * 1\\n        \\n        # b - a                  -> b   - (a)\\n        # 3c - 2a - b            -> 3c  - (2a + b)\\n        # 7d - 4a - 2b - c       -> 7d  - (4a + 2b + c)\\n        # 15e - 8a - 4b - 2c - d -> 15e - (8a + 4b + 2c + d)\\n        \\n        MOD = 10 ** 9 + 7\\n        total, incre, prev = 0, 2, A.pop()\\n        while A:\\n            number = A.pop()\\n            total = (total + (incre - 1) * number - prev) % MOD\\n            prev = (prev * 2 + number) % MOD\\n            incre = (incre * 2) % MOD\\n            \\n        return total\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort(reverse=True)\\n         \\n        # a b c d\\n        # [a], scan b -> (b - a) * 1\\n        # [a, b], scan c -> (c - a) * 2 + (c - b) * 1\\n        # [a, b, c], scan d -> (d - a) * 4 + (d - b) * 2 + (d - c) * 1\\n        \\n        # b - a                  -> b   - (a)\\n        # 3c - 2a - b            -> 3c  - (2a + b)\\n        # 7d - 4a - 2b - c       -> 7d  - (4a + 2b + c)\\n        # 15e - 8a - 4b - 2c - d -> 15e - (8a + 4b + 2c + d)\\n        \\n        MOD = 10 ** 9 + 7\\n        total, incre, prev = 0, 2, A.pop()\\n        while A:\\n            number = A.pop()\\n            total = (total + (incre - 1) * number - prev) % MOD\\n            prev = (prev * 2 + number) % MOD\\n            incre = (incre * 2) % MOD\\n            \\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701032,
                "title": "c-o-n-log-n-solution",
                "content": "```\\n        public class Solution\\n        {\\n            public int SumSubseqWidths(int[] A)\\n            {\\n                BigInteger modolo = BigInteger.Pow(10, 9) + 7;\\n                if (A.Length <= 1)\\n                {\\n                    return 0;\\n                }\\n                if (A.Length == 2)\\n                {\\n                    return (int)Math.Abs(A[1] - A[0]);\\n                }\\n                Array.Sort(A);\\n                BigInteger subSize = 1;\\n                BigInteger valueA = new BigInteger(A[1] - A[0]);\\n                int sum = (int)valueA;\\n                for (int i = 2; i < A.Length; i++)\\n                {\\n                    valueA = 2 * (valueA + subSize * (A[i] - A[i - 1])) +(A[i] - A[i - 1]);\\n                    sum += (int)(valueA % modolo);\\n                    sum = sum % (int)modolo;\\n                    subSize = (2 * subSize + 1);\\n            }\\n\\n                return  (sum %(int) modolo);\\n            }\\n        }\\n",
                "solutionTags": [],
                "code": "class Solution\\n        {\\n            public int SumSubseqWidths(int[] A)\\n            {\\n                BigInteger modolo = BigInteger.Pow(10, 9) + 7;\\n                if (A.Length <= 1)\\n                {\\n                    return 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 647841,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\tint kMod=1e9+7;\\n\\t\\t\\tvector<long> powOf2(20001);\\n\\t\\t\\tpowOf2[0]=1;\\n\\t\\t\\tfor(int i=1;i<=20000;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpowOf2[i]=(powOf2[i-1]*2)%kMod;\\n\\t\\t\\t}\\n\\t\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint n=A.size();\\n\\t\\t\\tfor(int i=0;i<A.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans-=A[i]*(powOf2[n-1-i+1-1]-1)%kMod;\\n\\t\\t\\t\\tans+=A[i]*(powOf2[i]-1)%kMod;\\n\\t\\t\\t\\tans%=kMod;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint sumSubseqWidths(vector<int>& A) {\\n\\t\\t\\tint kMod=1e9+7;\\n\\t\\t\\tvector<long> powOf2(20001);\\n\\t\\t\\tpowOf2[0]=1;\\n\\t\\t\\tfor(int i=1;i<=20000;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpowOf2[i]=(powOf2[i-1]*2)%kMod;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 643916,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int> A) {\\n        sort(A.begin(), A.end());\\n        long c = 1, res = 0, mod = 1e9 + 7, n = A.size();\\n        for (int i = 0; i < n; ++i, c = c * 2 % mod)\\n            res = (res + A[i] * c - A[n - i - 1] * c) % mod;\\n        return (res + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475268,
                "title": "simple-java-solution-cost-19ms",
                "content": "```java\\nclass Solution {\\n    public int sumSubseqWidths(int[] A) {\\n        if (A == null || A.length <= 1) {\\n            return 0;\\n        }\\n        Arrays.sort(A);\\n        int[] sum = new int[A.length];\\n        sum[0] = A[0];\\n        for(int i = 1; i < A.length; ++i) {\\n            sum[i] = sum[i - 1] + A[i];\\n        }\\n        long[] twoPow = new long[A.length];\\n        twoPow[0] = 1;\\n        for(int i = 1; i < A.length; ++i) {\\n            twoPow[i] = (twoPow[i - 1] << 1) % 1000000007l;\\n        }\\n        long res = 0;\\n        for(int i = 0; i < A.length - 1; ++i) {\\n            long tail = sum[A.length - 1] - sum[A.length - i - 2];\\n            long head = sum[i];\\n            res += (tail - head) * twoPow[A.length - i - 2];\\n            res = res % 1000000007l;\\n        }\\n        return (int) res;\\n    }\\n    \\n    // public long pow(long num, long exp) {\\n    //     if (exp == 0) {\\n    //         return 1l;\\n    //     }\\n    //     if (exp == 1) {\\n    //         return num;\\n    //     }\\n    //     long tmp = (exp & 1) == 0 ? 1 : num;\\n    //     long value = pow(num, exp / 2) % 1000000007l;\\n    //     return (tmp * value * value) % 1000000007l;\\n    // }\\n}\\n\\n//[1, 2, 3]\\n//[1, 3] * 2 + [1, 2] * 1\\n//[2, 3] * 1\\n\\n//[1, 3, 3]\\n\\n//[1, 3]\\n//[1, 3, 3]\\n//(a[0] - a[10]) * 8 + (a[0] - a[9]) * 7 + (a[0] - a[8]) * 6 + .... (a[0] - a[1])\\n//(a[1] - a[10]) * 7 + (a[1] - a[9]) * 6\\n//(a[2] - a[10]) * 6 ....\\n//(a[i] - a[10]) * (n - i - 2)\\n//(a[9] - a[10])\\n\\n\\n// ((a[n] + a[n - 1] ... + a[n - i]) - (a[0] + a[1] + ... + a[i])) * (n - i - 2)",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumSubseqWidths(int[] A) {\\n        if (A == null || A.length <= 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 474540,
                "title": "a-ordinary-solution-for-ordinary-people-but-simple-and-easy-to-come-up-with",
                "content": "After sorting the array. We group the A[i], A[j] pairs by the length (j - i - 1). Then we notice that the contribution of pairs with the same length can be calculated with the help of presum in one time.  \\n```\\nclass Solution {\\n    private static final int mod = (int)1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        int n = A.length;\\n        int[] pow = new int[n + 1];\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * 2) % mod;\\n        \\n        Arrays.sort(A);\\n        int[] presum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) presum[i] = (presum[i - 1] + A[i - 1]) % mod;\\n        \\n        long res = 0;\\n        for (int j = 0; j <= n - 2; j++) {\\n            long cur = (presum[n] - presum[j + 1] - presum[n - j - 1] + mod) % mod;\\n            cur = (cur * pow[j]) % mod;\\n            res = (res + cur) % mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int mod = (int)1e9 + 7;\\n    \\n    public int sumSubseqWidths(int[] A) {\\n        int n = A.length;\\n        int[] pow = new int[n + 1];\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * 2) % mod;\\n        \\n        Arrays.sort(A);\\n        int[] presum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) presum[i] = (presum[i - 1] + A[i - 1]) % mod;\\n        \\n        long res = 0;\\n        for (int j = 0; j <= n - 2; j++) {\\n            long cur = (presum[n] - presum[j + 1] - presum[n - j - 1] + mod) % mod;\\n            cur = (cur * pow[j]) % mod;\\n            res = (res + cur) % mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415126,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int SumSubseqWidths(int[] arr) \\n    {\\n        Array.Sort(arr);\\n        long res = 0, mod = 1_000_000_007, pow = 1, n = arr.Length;\\n        for(int i = 0; i < arr.Length; i++, pow = (2 * pow) % mod)\\n            res =  (res + (long) arr[i] * pow - (long) arr[n - i - 1] * pow) % mod;\\n        return  (int) res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int SumSubseqWidths(int[] arr) \\n    {\\n        Array.Sort(arr);\\n        long res = 0, mod = 1_000_000_007, pow = 1, n = arr.Length;\\n        for(int i = 0; i < arr.Length; i++, pow = (2 * pow) % mod)\\n            res =  (res + (long) arr[i] * pow - (long) arr[n - i - 1] * pow) % mod;\\n        return  (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380768,
                "title": "python-solution-suggestions-for-improvement-are-welcome",
                "content": "For each element we count the number of subsequences it is the maximum element of, like wise for the minimum. Multiply the counts with the values and subtract the minSum from the maxSum. I wonder where I can improve my code\\'s speed ? Maybe the powers of 2 can be done faster using merging ?? \\n\\n```\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        S = 0\\n        B = [1]*len(A)\\n        for i in range(1,len(B)):\\n            B[i] = 2*B[i-1]\\n        for i in range(len(A)):\\n            S += (B[i]-B[-1-i])*A[i]\\n        return S%((10**9)+7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef sumSubseqWidths(self, A: List[int]) -> int:\\n        A.sort()\\n        S = 0\\n        B = [1]*len(A)\\n        for i in range(1,len(B)):\\n            B[i] = 2*B[i-1]\\n        for i in range(len(A)):\\n            S += (B[i]-B[-1-i])*A[i]\\n        return S%((10**9)+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 380613,
                "title": "javascript-why-its-failing-for",
                "content": "Failing for\\n\\n[5,69,89,92,31,16,25,45,63,40,16,56,24,40,75,82,40,12,50,62,92,44,67,38,92,22,91,24,26,21,100,42,23,56,64,43,95,76,84,79,89,4,16,94,16,77,92,9,30,13]\\nOutput:\\n102383039574557488\\nExpected:\\n857876214\\n\\n```var sumSubseqWidths = function(A) {\\n  let min = 0;\\n  let max = 0;\\n  let N = A.length;\\n  A = A.sort((a,b) => a-b);\\n  for(let i =0; i < N;i++){\\n      let minTemp = Math.floor(Math.pow(2, i ) - 1)\\n      max += A[i]*(minTemp)\\n      min += A[i]*( Math.pow(2, (N - i - 1)) - 1);\\n  }\\n  result = max - min;\\n  return result\\n};```",
                "solutionTags": [],
                "code": "```var sumSubseqWidths = function(A) {\\n  let min = 0;\\n  let max = 0;\\n  let N = A.length;\\n  A = A.sort((a,b) => a-b);\\n  for(let i =0; i < N;i++){\\n      let minTemp = Math.floor(Math.pow(2, i ) - 1)\\n      max += A[i]*(minTemp)\\n      min += A[i]*( Math.pow(2, (N - i - 1)) - 1);\\n  }\\n  result = max - min;\\n  return result\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 376893,
                "title": "simple-explanation-cpp",
                "content": "first sort the array \\nso we have (2^i-1)  (selecting certain element or not selecting 2^i-1 options ) options for making certain a[i] maximum in the sorted array and (2^(n-i-1)-1) options for making it minimum for i (  0 to  n-1) \\n\\nso adding (2^i-1)a[i] ans subtracting (2^(n-1-i) -1)a[i]  for every i \\n\\n\\n\\n\\n#define ll  long long\\nconst ll m= 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n\\n    int sumSubseqWidths(vector<int>& a) \\n\\t\\n    {\\n\\t\\n\\t\\t\\tll res = 0, n = a.size();\\n\\t\\t\\tsort(a.begin(), a.end());\\n\\t\\t\\tll dp[20001];\\n\\t\\t\\tmemset(dp,0,sizeof(dp));\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i = 1; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i] = (dp[i - 1] % m * 2) % m;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres += a[i] * (dp[i] - dp[n - i - 1]);\\n\\t\\t\\t\\tres %= m;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n};\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int sumSubseqWidths(vector<int>& a) \\n\\t\\n    {\\n\\t\\n\\t\\t\\tll res = 0, n = a.size();\\n\\t\\t\\tsort(a.begin(), a.end());\\n\\t\\t\\tll dp[20001];\\n\\t\\t\\tmemset(dp,0,sizeof(dp));\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i = 1; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i] = (dp[i - 1] % m * 2) % m;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 297594,
                "title": "java-solution-in-dp-but-always-time-limit-exceeded",
                "content": "```\\n    public int sumSubseqWidths(int[] A) {\\n        List<MinMaxPair> subseqList = new ArrayList<>();\\n        int result = 0;\\n        for (int num : A) {\\n            if (subseqList.isEmpty()) {\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            } else {\\n                int size = subseqList.size();\\n                for (int i = 0; i < size; i++) {\\n                    MinMaxPair oldPair = subseqList.get(i);\\n                    MinMaxPair newPair = new MinMaxPair(oldPair);\\n                    subseqList.add(newPair);\\n                    if (num < newPair.min) {\\n                        newPair.min = num;\\n                    }\\n                    if (num > newPair.max) {\\n                        newPair.max = num;\\n                    }\\n                    result += (newPair.max - newPair.min);\\n                }\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    class MinMaxPair {\\n        public int min;\\n        public int max;\\n\\n        MinMaxPair(int min, int max) {\\n            this.min = min;\\n            this.max = max;\\n        }\\n\\n        MinMaxPair(MinMaxPair pair) {\\n            this.min = pair.min;\\n            this.max = pair.max;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int sumSubseqWidths(int[] A) {\\n        List<MinMaxPair> subseqList = new ArrayList<>();\\n        int result = 0;\\n        for (int num : A) {\\n            if (subseqList.isEmpty()) {\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            } else {\\n                int size = subseqList.size();\\n                for (int i = 0; i < size; i++) {\\n                    MinMaxPair oldPair = subseqList.get(i);\\n                    MinMaxPair newPair = new MinMaxPair(oldPair);\\n                    subseqList.add(newPair);\\n                    if (num < newPair.min) {\\n                        newPair.min = num;\\n                    }\\n                    if (num > newPair.max) {\\n                        newPair.max = num;\\n                    }\\n                    result += (newPair.max - newPair.min);\\n                }\\n                MinMaxPair pair = new MinMaxPair(num, num);\\n                subseqList.add(pair);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    class MinMaxPair {\\n        public int min;\\n        public int max;\\n\\n        MinMaxPair(int min, int max) {\\n            this.min = min;\\n            this.max = max;\\n        }\\n\\n        MinMaxPair(MinMaxPair pair) {\\n            this.min = pair.min;\\n            this.max = pair.max;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291698,
                "title": "go-most-fast-solution-without-power-or-multiply",
                "content": "```go\\nfunc sumSubseqWidths(A []int) int {\\n\\tsort.Ints(A)\\n\\tvar ans int = 0\\n\\tfor i:=0; i<len(A); i++ {\\n\\t\\tans *= 2\\n\\t\\tans += A[len(A)-1-i] - A[i]\\n\\t\\tans %= 1E9+7\\n\\t}\\n\\tif ans < 0 { ans += 1E9+7 }\\n\\treturn ans\\n}\\n```\\n\\nWe can do it top-down so that we can avoid multiply or shift or power\\nThis could help if A is extremely long",
                "solutionTags": [],
                "code": "```go\\nfunc sumSubseqWidths(A []int) int {\\n\\tsort.Ints(A)\\n\\tvar ans int = 0\\n\\tfor i:=0; i<len(A); i++ {\\n\\t\\tans *= 2\\n\\t\\tans += A[len(A)-1-i] - A[i]\\n\\t\\tans %= 1E9+7\\n\\t}\\n\\tif ans < 0 { ans += 1E9+7 }\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 281708,
                "title": "super-nice-and-clean-java",
                "content": "\\n```\\nimport java.math.BigInteger;\\nimport java.util.Arrays;\\n\\nclass Solution {\\n\\n    public int sumSubseqWidths(final int[] arr) {\\n        if (arr.length == 1) {\\n            return 0;\\n        }\\n\\n        Arrays.sort(arr);\\n        BigInteger count = BigInteger.ZERO;\\n\\n        for (int gap = 0; gap < arr.length - 1; gap++) {\\n            long sumPerGap = 0L;\\n\\n            for (int i = 0; i + gap + 1 < arr.length; i++) {\\n                sumPerGap = sumPerGap + (arr[i + gap + 1] - arr[i]);\\n            }\\n\\n            count = count.add(BigInteger.valueOf(sumPerGap).multiply(BigInteger.valueOf(2).pow(gap)));\\n        }\\n\\n        return count.remainder(BigInteger.valueOf((long)Math.pow(10, 9) + 7)).intValue();\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\nimport java.util.Arrays;\\n\\nclass Solution {\\n\\n    public int sumSubseqWidths(final int[] arr) {\\n        if (arr.length == 1) {\\n            return 0;\\n        }\\n\\n        Arrays.sort(arr);\\n        BigInteger count = BigInteger.ZERO;\\n\\n        for (int gap = 0; gap < arr.length - 1; gap++) {\\n            long sumPerGap = 0L;\\n\\n            for (int i = 0; i + gap + 1 < arr.length; i++) {\\n                sumPerGap = sumPerGap + (arr[i + gap + 1] - arr[i]);\\n            }\\n\\n            count = count.add(BigInteger.valueOf(sumPerGap).multiply(BigInteger.valueOf(2).pow(gap)));\\n        }\\n\\n        return count.remainder(BigInteger.valueOf((long)Math.pow(10, 9) + 7)).intValue();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222325,
                "title": "o-n-nlog-n",
                "content": "1.sort the array\\n2.iterate from 1 to n\\n3.using the fact that # subsequence upto i is equal to sum(# subsequence from [0,n-1])+1\\n4.use long long int to handel higher test cases\\n\\n```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private : int mod=pow(10,9)+7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<long long >size(A.size(),0);\\n        vector<long long >sum(A.size(),0);\\n        long long  real=0;\\n        size[0]=1;\\n        sum[0]=A[0];\\n        vector<long long >temp(A.size(),0);\\n        \\n        for(int i=1;i<A.size();i++){\\n            real=((A[i]*size[i-1])%mod-sum[i-1]+mod)%mod;\\n            temp[i]=real;\\n            size[i]=(2*size[i-1]+1)%mod;\\n            sum[i]=( (sum[i-1]+sum[i-1])%mod+A[i]+mod)%mod;\\n            \\n        }\\n        real=0;\\n        for(int i=0;i<temp.size();i++){\\n            real=(real+temp[i]+mod)%mod;\\n        }\\n        \\n        return real;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213939,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        s = diff = 0 \\n        k = 1 << max(len(A)-2,0)\\n        A.sort() \\n        for i in range(len(A)):\\n            diff += A[~i] - A[i] \\n            s += k * diff \\n            k >>= 1 \\n        return s % (10 ** 9 + 7)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def sumSubseqWidths(self, A):\\n        s = diff = 0 \\n        k = 1 << max(len(A)-2,0)\\n        A.sort() \\n        for i in range(len(A)):\\n            diff += A[~i] - A[i] \\n            s += k * diff \\n            k >>= 1 \\n        return s % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 190386,
                "title": "could-someone-help-me-why-my-algorithm-is-not-correct",
                "content": "I think algorithm is straightforward.\\n1. We sort the array.\\n2. We loop from smallest to largest number.\\n3. For each number we calculate in how many subsequences we can have when we pick minimum and maximum, A[i] and A[j] in the code, the number will be pow(2, j - i - 1)\\n\\n failed at:\\n[96,87,191,197,40,101,108,35,169,50,168,182,95,80,144,43,18,60,174,13,77,173,38,46,80,117,13,19,11,6,13,118,39,80,171,36,86,156,165,190,53,49,160,192,57,42,97,35,124,200,84,70,145,180,54,141,159,42,66,66,25,95,24,136,140,159,71,131,5,140,115,76,151,137,63,47,69,164,60,172,153,183,6,70,40,168,133,45,116,188,20,52,70,156,44,27,124,59,42,172]\\nmy outcome is: 931507168\\nthe expected is: 136988321\\n\\nMuch appreciated.\\n```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long result = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int j = i + 1; j < A.size(); j++) {\\n                int gap = A[j] - A[i];\\n                long count = pow(2, j - i - 1);\\n                count %= mod;\\n                result += count * gap;\\n                result %= mod;\\n            }\\n        }\\n        return result % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long result = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            for (int j = i + 1; j < A.size(); j++) {\\n                int gap = A[j] - A[i];\\n                long count = pow(2, j - i - 1);\\n                count %= mod;\\n                result += count * gap;\\n                result %= mod;\\n            }\\n        }\\n        return result % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185577,
                "title": "explaining-the-nlogn-n-thought-process",
                "content": "```\\n# Note that 1 << k == 2**k\\ndef sum_subsequence_widths(nums):\\n    nums.sort()\\n    mod = 10**9 + 7\\n    result = 0\\n    for i, n in enumerate(nums):\\n        # I am min for all the subsequences that start at me and end to the right.\\n        # For each of the subsequences that end to my right, subtract me once as min.\\n        result = (result - n*(1 << len(nums)-i-1)) % mod\\n        # I am max for all the subsequences that end at me.\\n        # For each of the subsequences that begin to my left, add me once as max.\\n        result = (result + n*(1 << i)) % mod\\n    \\n    return result\\n```",
                "solutionTags": [],
                "code": "```\\n# Note that 1 << k == 2**k\\ndef sum_subsequence_widths(nums):\\n    nums.sort()\\n    mod = 10**9 + 7\\n    result = 0\\n    for i, n in enumerate(nums):\\n        # I am min for all the subsequences that start at me and end to the right.\\n        # For each of the subsequences that end to my right, subtract me once as min.\\n        result = (result - n*(1 << len(nums)-i-1)) % mod\\n        # I am max for all the subsequences that end at me.\\n        # For each of the subsequences that begin to my left, add me once as max.\\n        result = (result + n*(1 << i)) % mod\\n    \\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 169511,
                "title": "lookup-table-of-the-power-of-2-for-acceleration",
                "content": "Use the dp lookup table to save the computation time.\\n```cpp\\n#define ll  long long\\nconst ll MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) \\n    {\\n        ll res = 0, sz = A.size();\\n        sort(A.begin(), A.end());\\n        ll dp[20001] = {0};\\n        dp[0] = 1;\\n        for(int i = 1; i < sz; i++)\\n        {\\n            dp[i] = (dp[i - 1] % MOD * 2) % MOD;\\n        }\\n        for(int i = 0; i < sz; i++)\\n        {\\n            res += A[i] * (dp[i] - dp[sz - i - 1]);\\n            res %= MOD;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n#define ll  long long\\nconst ll MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) \\n    {\\n        ll res = 0, sz = A.size();\\n        sort(A.begin(), A.end());\\n        ll dp[20001] = {0};\\n        dp[0] = 1;\\n        for(int i = 1; i < sz; i++)\\n        {\\n            dp[i] = (dp[i - 1] % MOD * 2) % MOD;\\n        }\\n        for(int i = 0; i < sz; i++)\\n        {\\n            res += A[i] * (dp[i] - dp[sz - i - 1]);\\n            res %= MOD;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167688,
                "title": "better-choice-of-modulo",
                "content": "Problems like this should have a smaller modulo so that the calculations never run into long type. Wrong answer due to use of **int** when answer is expected in **int** is simply infuriating.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 163661,
                "title": "what-is-the-error-in-this",
                "content": "```\\nsubs,r={()},0\\n        for num in nums:\\n            subs |= {sub+(num,)\\n                    for sub in subs}\\n        \\n        for i in subs:\\n            if len(i)>1: r+=max(i)-min(i)\\n                \\n        return r%((pow(10,9)+7))\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nsubs,r={()},0\\n        for num in nums:\\n            subs |= {sub+(num,)\\n                    for sub in subs}\\n        \\n        for i in subs:\\n            if len(i)>1: r+=max(i)-min(i)\\n                \\n        return r%((pow(10,9)+7))\\n\\t\\t\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 161885,
                "title": "python-math-time-o-nlogn",
                "content": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        length=len(A)\\n        if(length==1):\\n            return 0\\n        p1=length-1\\n        p2=0\\n        P1=2**(length-1)\\n        P2=2**0\\n        index=0\\n        A.sort()\\n        mod=10**9+7\\n        while(p1>p2):\\n            index+=((P1-P2)*(A[p1]-A[p2]))\\n            index%=mod\\n            p1-=1\\n            p2+=1\\n            P1//=2\\n            P2*=2\\n        return index\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumSubseqWidths(self, A):\\n        length=len(A)\\n        if(length==1):\\n            return 0\\n        p1=length-1\\n        p2=0\\n        P1=2**(length-1)\\n        P2=2**0\\n        index=0\\n        A.sort()\\n        mod=10**9+7\\n        while(p1>p2):\\n            index+=((P1-P2)*(A[p1]-A[p2]))\\n            index%=mod\\n            p1-=1\\n            p2+=1\\n            P1//=2\\n            P2*=2\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161842,
                "title": "c-math-dp-solution-easy-to-explain-and-impl-in-20mins",
                "content": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n\\n        long long cur = 0;\\n        long long base = 1;\\n        long long res = 0;\\n\\n        int n = A.size();\\n        for (int i = 1; i < n; ++i) {\\n            long long delta = A[i] - A[i - 1];\\n            base = (base * 2) % MOD;\\n            cur = (cur * 2 + delta * (base - 1)) % MOD;\\n            res = (res + cur) % MOD;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n\\n        long long cur = 0;\\n        long long base = 1;\\n        long long res = 0;\\n\\n        int n = A.size();\\n        for (int i = 1; i < n; ++i) {\\n            long long delta = A[i] - A[i - 1];\\n            base = (base * 2) % MOD;\\n            cur = (cur * 2 + delta * (base - 1)) % MOD;\\n            res = (res + cur) % MOD;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 161742,
                "title": "my-c-o-nlgn-time-o-1-space-solution-with-detail-explanation",
                "content": "1. Sort the array first.\\n2.  For each pair `[j, i]`, if we choose elements between `j` ans `i`, then the maximum element is `A[i]`, and the minimum element is `A[j]`.\\n3.  We will choose at least two elements(which is `A[j]` and `A[i]`) and at most `i-j+1` elements.\\n4.  The total sum of pair `[j, i]` is \\n`(A[i] - A[j]) * (C(0, i-j-1) + C(1, i-j-1) + ... + C(i-j-1, i-j-1))`\\n`=(A[i] - A[j]) * (2^(i-j-1))`  \\n(`C(x, y)` means the total combinations of `y` numbers select `x` numbers)\\n5. Given an `i`, we can calculate all pairs `[j, i]`(`0 <= j < i`), use `S` to store\\n`S[i] = A[i] * (2^(i-1) + 2^(i-2) + ... + 2^(i-j-1) + ... + 2^1 + 2^0) `\\n`- (A[0] * 2^(i-1) + A[1] * 2^(i-2) + ... + A[j] * 2^(i-j-1) + ... + A[i-1] * 2^0)`\\n`= A[i] * (2^i - 1) -  (A[0] * 2^(i-1) + A[1] * 2^(i-2) + ... + A[j] * 2^(i-j-1) + ... + A[i-1] * 2^0)` \\n6. Use `sum` to store the right part of `-`, so we get this:\\n`S[i] = A[i] * (2^i - 1) -  sum[i]`\\n`sum[i] = 2 * sum[i-1] + A[i-1]`\\n7. The answer is sum of `S`, (by the way don\\'t forget mod `1000000007`)\\nthe c++ code below use two varible(`ans` and `sum`) to save the space.\\n```\\nclass Solution {\\npublic:\\n    #define M 1000000007\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long long ans=0, sum=A[0], p=2;\\n        for (int i=1;i<A.size();++i){\\n            ans=(ans+(p-1)*A[i]-sum)%M;\\n            sum=(2*sum+A[i])%M;\\n            p=(p<<1)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define M 1000000007\\n    int sumSubseqWidths(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        long long ans=0, sum=A[0], p=2;\\n        for (int i=1;i<A.size();++i){\\n            ans=(ans+(p-1)*A[i]-sum)%M;\\n            sum=(2*sum+A[i])%M;\\n            p=(p<<1)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161393,
                "title": "19-64-test-pass-i-don-t-know-why-i-was-wrong-i-think-i-am-right",
                "content": "```\\n public  int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        for(int i:A)System.out.println(i);\\n        int sum=0;\\n        for(int n=2;n<=A.length;n++)\\n        {\\n            for(int m=0;m<=n-2;m++)\\n            {\\n                sum+=(A[n-1]-A[m])*(Math.pow(2,n-2-m));\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public  int sumSubseqWidths(int[] A) {\\n        Arrays.sort(A);\\n        for(int i:A)System.out.println(i);\\n        int sum=0;\\n        for(int n=2;n<=A.length;n++)\\n        {\\n            for(int m=0;m<=n-2;m++)\\n            {\\n                sum+=(A[n-1]-A[m])*(Math.pow(2,n-2-m));\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1568049,
                "content": [
                    {
                        "username": "leetgugu",
                        "content": "Firstly I used  a simple way as the provided solution like this:\\n       //sort A first\\n       sum += (A[j] - A[i]) * pow(2, j-i-1);\\nThen I realized the duplicated number is different and should be treated in a different way.\\n\\nLook the testcase array: [2,3,3,7]. The sum should be calculated with such steps:\\n1) subarray [2,3,3]:    non-zero sequence [2,3]  and [2,3,3] then sum += 2*1\\n2) subarray [2,3,3,7]: non-zero sequence [2,7], [2,3,7], [2,3,3,7]. then sum += 3*5\\n3) subarray [3,3]: sum += 0\\n4) subarray [3,3,7]: non-zero sequence [3,7],[3,3,7],  then sum += 2*4\\n\\nSo the final result is 25, rather than 35.\\n\\n35 is calculated by this way:\\n[2,3]   ----> [2,3]                sum += 1 * 1\\n[2,3,3] ---->[2,3](the number  3 is the number at last pos),[2,3,3]      sum += 2 * 1\\n[2,3,3,7] --->[2,7],[2,3,7],[2,3,7],[2,3,3,7]       sum += 4 * 5\\n[3,3,7].  ----> [3,7],[3,3,7].                sum += 2 * 4\\n[3,7]. -------->[3,7]                   sum += 1 * 4\\nthen sum =35\\n\\nbut I think when the duplicated numbers in different postions are picked into a subsequence, the original postion does not make any sense, so some subsequences which are equal should be ignored. Then the final sum is 25 in this testcase.\\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* **Sort**: Since Q does\\'t involve subarray, and sorting doesn\\'t affect the min-max in a subsequence, SORT!\\n* **Element contribution**: Instead of condiering the naive 2^N backtracking approach, consider each element being min and max. For this pre-computation of sort BECAME HANDY.\\n* **Subsequence property**: No. of subsequences ending at index i = 2^i\\n\\n**Similar**: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/\\n\\n**Subsequences properties**:\\n![image](https://assets.leetcode.com/users/images/c6097e86-b794-4ae0-9612-9834a590ab75_1633799786.4522336.jpeg)\\n\\n"
                    },
                    {
                        "username": "huyalvchuan",
                        "content": "\\u5148\\u6392\\u5E8F\\u5F97\\u5230\\u6392\\u5E8F\\u540E\\u7684A\\n\\u7136\\u540E\\u6211\\u4EEC\\u901A\\u8FC7\\u89C2\\u5BDF\\u5F97\\u5230\\u4E0B\\u9762\\u7684\\u4E00\\u4E2A\\u516C\\u5F0F\\uFF1A\\nf(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u5BBD\\u3002\\nk(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u4E2A\\u6570\\n\\u90A3\\u4E48f(i) = 2 * (f(i - 1) + A[i] - A[i - 1]) + (A[i] - A[i - 1])"
                    }
                ]
            },
            {
                "id": 1567677,
                "content": [
                    {
                        "username": "leetgugu",
                        "content": "Firstly I used  a simple way as the provided solution like this:\\n       //sort A first\\n       sum += (A[j] - A[i]) * pow(2, j-i-1);\\nThen I realized the duplicated number is different and should be treated in a different way.\\n\\nLook the testcase array: [2,3,3,7]. The sum should be calculated with such steps:\\n1) subarray [2,3,3]:    non-zero sequence [2,3]  and [2,3,3] then sum += 2*1\\n2) subarray [2,3,3,7]: non-zero sequence [2,7], [2,3,7], [2,3,3,7]. then sum += 3*5\\n3) subarray [3,3]: sum += 0\\n4) subarray [3,3,7]: non-zero sequence [3,7],[3,3,7],  then sum += 2*4\\n\\nSo the final result is 25, rather than 35.\\n\\n35 is calculated by this way:\\n[2,3]   ----> [2,3]                sum += 1 * 1\\n[2,3,3] ---->[2,3](the number  3 is the number at last pos),[2,3,3]      sum += 2 * 1\\n[2,3,3,7] --->[2,7],[2,3,7],[2,3,7],[2,3,3,7]       sum += 4 * 5\\n[3,3,7].  ----> [3,7],[3,3,7].                sum += 2 * 4\\n[3,7]. -------->[3,7]                   sum += 1 * 4\\nthen sum =35\\n\\nbut I think when the duplicated numbers in different postions are picked into a subsequence, the original postion does not make any sense, so some subsequences which are equal should be ignored. Then the final sum is 25 in this testcase.\\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* **Sort**: Since Q does\\'t involve subarray, and sorting doesn\\'t affect the min-max in a subsequence, SORT!\\n* **Element contribution**: Instead of condiering the naive 2^N backtracking approach, consider each element being min and max. For this pre-computation of sort BECAME HANDY.\\n* **Subsequence property**: No. of subsequences ending at index i = 2^i\\n\\n**Similar**: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/\\n\\n**Subsequences properties**:\\n![image](https://assets.leetcode.com/users/images/c6097e86-b794-4ae0-9612-9834a590ab75_1633799786.4522336.jpeg)\\n\\n"
                    },
                    {
                        "username": "huyalvchuan",
                        "content": "\\u5148\\u6392\\u5E8F\\u5F97\\u5230\\u6392\\u5E8F\\u540E\\u7684A\\n\\u7136\\u540E\\u6211\\u4EEC\\u901A\\u8FC7\\u89C2\\u5BDF\\u5F97\\u5230\\u4E0B\\u9762\\u7684\\u4E00\\u4E2A\\u516C\\u5F0F\\uFF1A\\nf(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u5BBD\\u3002\\nk(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u4E2A\\u6570\\n\\u90A3\\u4E48f(i) = 2 * (f(i - 1) + A[i] - A[i - 1]) + (A[i] - A[i - 1])"
                    }
                ]
            },
            {
                "id": 1572356,
                "content": [
                    {
                        "username": "leetgugu",
                        "content": "Firstly I used  a simple way as the provided solution like this:\\n       //sort A first\\n       sum += (A[j] - A[i]) * pow(2, j-i-1);\\nThen I realized the duplicated number is different and should be treated in a different way.\\n\\nLook the testcase array: [2,3,3,7]. The sum should be calculated with such steps:\\n1) subarray [2,3,3]:    non-zero sequence [2,3]  and [2,3,3] then sum += 2*1\\n2) subarray [2,3,3,7]: non-zero sequence [2,7], [2,3,7], [2,3,3,7]. then sum += 3*5\\n3) subarray [3,3]: sum += 0\\n4) subarray [3,3,7]: non-zero sequence [3,7],[3,3,7],  then sum += 2*4\\n\\nSo the final result is 25, rather than 35.\\n\\n35 is calculated by this way:\\n[2,3]   ----> [2,3]                sum += 1 * 1\\n[2,3,3] ---->[2,3](the number  3 is the number at last pos),[2,3,3]      sum += 2 * 1\\n[2,3,3,7] --->[2,7],[2,3,7],[2,3,7],[2,3,3,7]       sum += 4 * 5\\n[3,3,7].  ----> [3,7],[3,3,7].                sum += 2 * 4\\n[3,7]. -------->[3,7]                   sum += 1 * 4\\nthen sum =35\\n\\nbut I think when the duplicated numbers in different postions are picked into a subsequence, the original postion does not make any sense, so some subsequences which are equal should be ignored. Then the final sum is 25 in this testcase.\\n"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* **Sort**: Since Q does\\'t involve subarray, and sorting doesn\\'t affect the min-max in a subsequence, SORT!\\n* **Element contribution**: Instead of condiering the naive 2^N backtracking approach, consider each element being min and max. For this pre-computation of sort BECAME HANDY.\\n* **Subsequence property**: No. of subsequences ending at index i = 2^i\\n\\n**Similar**: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/\\n\\n**Subsequences properties**:\\n![image](https://assets.leetcode.com/users/images/c6097e86-b794-4ae0-9612-9834a590ab75_1633799786.4522336.jpeg)\\n\\n"
                    },
                    {
                        "username": "huyalvchuan",
                        "content": "\\u5148\\u6392\\u5E8F\\u5F97\\u5230\\u6392\\u5E8F\\u540E\\u7684A\\n\\u7136\\u540E\\u6211\\u4EEC\\u901A\\u8FC7\\u89C2\\u5BDF\\u5F97\\u5230\\u4E0B\\u9762\\u7684\\u4E00\\u4E2A\\u516C\\u5F0F\\uFF1A\\nf(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u5BBD\\u3002\\nk(i)\\u8868\\u793A\\u4EE5\\u7B2Ci\\u4E2A\\u4F4D\\u7F6E\\u4E3A\\u5B50\\u5E8F\\u5217\\u6700\\u5927\\u503C\\u7684\\u6240\\u6709\\u5B50\\u5E8F\\u5217\\u7684\\u4E2A\\u6570\\n\\u90A3\\u4E48f(i) = 2 * (f(i - 1) + A[i] - A[i - 1]) + (A[i] - A[i - 1])"
                    }
                ]
            }
        ]
    }
]