[
    {
        "title": "Reverse Nodes in k-Group",
        "question_content": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n\nExample 2:\n\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is n.\n\t1 <= k <= n <= 5000\n\t0 <= Node.val <= 1000\n\n&nbsp;\nFollow-up: Can you solve the problem in O(1) extra memory space?",
        "solutions": [
            {
                "id": 11423,
                "title": "short-but-recursive-java-code-with-comments",
                "content": "Hi, guys!\\nDespite the fact that the approach is recursive, the code is less than 20 lines. :)\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode curr = head;\\n        int count = 0;\\n        while (curr != null && count != k) { // find the k+1 node\\n            curr = curr.next;\\n            count++;\\n        }\\n        if (count == k) { // if k+1 node is found\\n            curr = reverseKGroup(curr, k); // reverse list with k+1 node as head\\n            // head - head-pointer to direct part, \\n            // curr - head-pointer to reversed part;\\n            while (count-- > 0) { // reverse current k-group: \\n                ListNode tmp = head.next; // tmp - next head in direct part\\n                head.next = curr; // preappending \"direct\" head to the reversed list \\n                curr = head; // move head of reversed part to a new node\\n                head = tmp; // move \"direct\" head to the next node in direct part\\n            }\\n            head = curr;\\n        }\\n        return head;\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi, guys!\\nDespite the fact that the approach is recursive, the code is less than 20 lines. :)\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode curr = head;\\n        int count = 0;\\n        while (curr != null && count != k) { // find the k+1 node\\n            curr = curr.next;\\n            count++;\\n        }\\n        if (count == k) { // if k+1 node is found\\n            curr = reverseKGroup(curr, k); // reverse list with k+1 node as head\\n            // head - head-pointer to direct part, \\n            // curr - head-pointer to reversed part;\\n            while (count-- > 0) { // reverse current k-group: \\n                ListNode tmp = head.next; // tmp - next head in direct part\\n                head.next = curr; // preappending \"direct\" head to the reversed list \\n                curr = head; // move head of reversed part to a new node\\n                head = tmp; // move \"direct\" head to the next node in direct part\\n            }\\n            head = curr;\\n        }\\n        return head;\\n    }\\n\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 11440,
                "title": "non-recursive-java-solution-and-idea",
                "content": "Reference: \\nhttp://www.cnblogs.com/lichen782/p/leetcode_Reverse_Nodes_in_kGroup.html\\n\\nFirst, build a function reverse() to reverse the ListNode between begin and end. See the explanation below:\\n\\n       /**\\n         * Reverse a link list between begin and end exclusively\\n         * an example:\\n         * a linked list:\\n         * 0->1->2->3->4->5->6\\n         * |           |   \\n         * begin       end\\n         * after call begin = reverse(begin, end)\\n         * \\n         * 0->3->2->1->4->5->6\\n         *          |  |\\n         *      begin end\\n         * @return the reversed list's 'begin' node, which is the precedence of node end\\n         */\\n\\nThen walk thru the linked list and apply reverse() iteratively. See the code below.\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode begin;\\n        if (head==null || head.next ==null || k==1)\\n        \\treturn head;\\n        ListNode dummyhead = new ListNode(-1);\\n        dummyhead.next = head;\\n        begin = dummyhead;\\n        int i=0;\\n        while (head != null){\\n        \\ti++;\\n        \\tif (i%k == 0){\\n        \\t\\tbegin = reverse(begin, head.next);\\n        \\t\\thead = begin.next;\\n        \\t} else {\\n        \\t\\thead = head.next;\\n        \\t}\\n        }\\n        return dummyhead.next;\\n        \\n    }\\n    \\n    public ListNode reverse(ListNode begin, ListNode end){\\n    \\tListNode curr = begin.next;\\n    \\tListNode next, first;\\n    \\tListNode prev = begin;\\n    \\tfirst = curr;\\n    \\twhile (curr!=end){\\n    \\t\\tnext = curr.next;\\n    \\t\\tcurr.next = prev;\\n    \\t\\tprev = curr;\\n    \\t\\tcurr = next;\\n    \\t}\\n    \\tbegin.next = prev;\\n    \\tfirst.next = curr;\\n    \\treturn first;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Reference: \\nhttp://www.cnblogs.com/lichen782/p/leetcode_Reverse_Nodes_in_kGroup.html\\n\\nFirst, build a function reverse() to reverse the ListNode between begin and end. See the explanation below:\\n\\n       /**\\n         * Reverse a link list between begin and end exclusively\\n         * an example:\\n         * a linked list:\\n         * 0->1->2->3->4->5->6\\n         * |           |   \\n         * begin       end\\n         * after call begin = reverse(begin, end)\\n         * \\n         * 0->3->2->1->4->5->6\\n         *          |  |\\n         *      begin end\\n         * @return the reversed list's 'begin' node, which is the precedence of node end\\n         */\\n\\nThen walk thru the linked list and apply reverse() iteratively. See the code below.\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode begin;\\n        if (head==null || head.next ==null || k==1)\\n        \\treturn head;\\n        ListNode dummyhead = new ListNode(-1);\\n        dummyhead.next = head;\\n        begin = dummyhead;\\n        int i=0;\\n        while (head != null){\\n        \\ti++;\\n        \\tif (i%k == 0){\\n        \\t\\tbegin = reverse(begin, head.next);\\n        \\t\\thead = begin.next;\\n        \\t} else {\\n        \\t\\thead = head.next;\\n        \\t}\\n        }\\n        return dummyhead.next;\\n        \\n    }\\n    \\n    public ListNode reverse(ListNode begin, ListNode end){\\n    \\tListNode curr = begin.next;\\n    \\tListNode next, first;\\n    \\tListNode prev = begin;\\n    \\tfirst = curr;\\n    \\twhile (curr!=end){\\n    \\t\\tnext = curr.next;\\n    \\t\\tcurr.next = prev;\\n    \\t\\tprev = curr;\\n    \\t\\tcurr = next;\\n    \\t}\\n    \\tbegin.next = prev;\\n    \\tfirst.next = curr;\\n    \\treturn first;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11491,
                "title": "succinct-iterative-python-o-n-time-o-1-space",
                "content": "Use a dummy head, and\\n\\nl, r :          define reversing range\\n\\npre, cur :  used in reversing, standard reverse linked linked list method\\n\\njump :      used to connect last node in previous k-group to first node in following k-group\\n\\n    def reverseKGroup(self, head, k):\\n        dummy = jump = ListNode(0)\\n        dummy.next = l = r = head\\n        \\n        while True:\\n            count = 0\\n            while r and count < k:   # use r to locate the range\\n                r = r.next\\n                count += 1\\n            if count == k:  # if size k satisfied, reverse the inner linked list\\n                pre, cur = r, l\\n                for _ in range(k):\\n                    cur.next, cur, pre = pre, cur.next, cur  # standard reversing\\n                jump.next, jump, l = pre, l, r  # connect two k-groups\\n            else:\\n                return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "Use a dummy head, and\\n\\nl, r :          define reversing range\\n\\npre, cur :  used in reversing, standard reverse linked linked list method\\n\\njump :      used to connect last node in previous k-group to first node in following k-group\\n\\n    def reverseKGroup(self, head, k):\\n        dummy = jump = ListNode(0)\\n        dummy.next = l = r = head\\n        \\n        while True:\\n            count = 0\\n            while r and count < k:   # use r to locate the range\\n                r = r.next\\n                count += 1\\n            if count == k:  # if size k satisfied, reverse the inner linked list\\n                pre, cur = r, l\\n                for _ in range(k):\\n                    cur.next, cur, pre = pre, cur.next, cur  # standard reversing\\n                jump.next, jump, l = pre, l, r  # connect two k-groups\\n            else:\\n                return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 183356,
                "title": "java-o-n-solution-with-super-detailed-explanation-illustration",
                "content": "This problem can be split into several steps:\\n1. Since we need to reverse the linked-list every k nodes, we need to check whether the number of list nodes are enough to reverse. Otherwise, there is no need to reverse.\\n\\n2. If we need to reverse the k nodes, how to do that? Following is my idea:\\n\\n\\t  If the structure of the linkedlist is like this:   \\n\\t\\t\\n\\t\\t1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n\\t\\t\\nThen there will always be a pointer, which points to the node **AHEAD** of the first node to reverse. The pointer will help to link the linkedlist after.\\n\\nAt first, we will add a dummy node in front of the linked list to act as the first pointer. After we add the pointer, the linked list will look like this:\\n```\\n    0 (pointer) -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n```\\n\\t\\nSuppose that there are enough nodes to be reversed, we just use the \"reverse linked list\" trick to reverse the k nodes. Please refer to \"https://leetcode.com/problems/reverse-linked-list/\" if you don\\'t know how to reverse a linked list.\\n\\nif k = 3, we can reverse 1 to 3 first using the following code:\\n```\\n  ListNode prev = null, curr = pointer.next, next = null;\\n  for (int i = 0; i < k; i++) {\\n\\t\\tnext = curr.next;\\n\\t\\tcurr.next = prev;\\n\\t\\tprev = curr;\\n\\t\\tcurr = next;\\n  }\\n```\\nThis is the illustartion of the first 3 steps:\\n```\\n    step1: 0 (pointer) -> 1      2 -> 3 -> 4 -> 5 -> 6 -> 7\\n\\tstep2: 0 (pointer) -> 1 <- 2      3 -> 4 -> 5 -> 6 -> 7\\n\\tstep3: 0 (pointer) -> 1 <- 2 <- 3      4 -> 5 -> 6 -> 7\\n```\\n\\nThis is an easy and general algorithm to reverse a linked list. However, if you are careful enough, you will find that after the for-loop, the link from 3 to 4 will be cut (as shown in step3).\\n\\t\\nNow we need to reconstruct the linked list and fix the issue. You will figure out that at step3, the 3 is the **prev** node, 4 is the **curr** node. \\n```\\n\\tstep3: 0 (pointer) -> 1 <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n```\\nWe can fix the sequence based on the following codes. The basic idea is to link the pointer to 3 and link 1 to 4:\\n```\\n\\tListNode tail = pointer.next;\\n\\ttail.next = curr; \\n\\tpointer.next = prev;\\n\\tpointer = tail;\\n```\\n\\nThen the result is:\\n```\\n\\tafter first line:   0 (pointer) -> 1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\tafter second line:  0 (pointer) -> 1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t       |____________________________\\u2191\\n\\tafter third line:   \\n\\t\\t\\t\\t\\t\\t\\t\\t|-----------------------\\u2193\\n\\t\\t\\t\\t\\t\\t0 (pointer)    1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   |____________________________\\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\tafter forth line:\\t0 -> 3 -> 2 -> 1 (pointer) -> 4 -> 5 -> 6 -> 7\\n```\\n\\t\\t\\t\\nNow we get the new pointer, and we can repeat the process. Note that to retrieve the head, we need to record the first dummy node (0).\\n\\nHere is the code:\\n```\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode pointer = dummy;\\n        while (pointer != null) {\\n            ListNode node = pointer;\\n            // first check whether there are k nodes to reverse\\n            for (int i = 0; i < k && node != null; i++) {\\n                node = node.next;\\n            }\\n            if (node == null) break;\\n            \\n            // now we know that we have k nodes, we will start from the first node\\n            ListNode prev = null, curr = pointer.next, next = null;\\n            for (int i = 0; i < k; i++) {\\n                next = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = next;\\n            }\\n            ListNode tail = pointer.next;\\n            tail.next = curr;\\n            pointer.next = prev;\\n            pointer = tail;\\n        }\\n        return dummy.next;\\n    }\\n```\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n    0 (pointer) -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n```\n```\\n  ListNode prev = null, curr = pointer.next, next = null;\\n  for (int i = 0; i < k; i++) {\\n\\t\\tnext = curr.next;\\n\\t\\tcurr.next = prev;\\n\\t\\tprev = curr;\\n\\t\\tcurr = next;\\n  }\\n```\n```\\n    step1: 0 (pointer) -> 1      2 -> 3 -> 4 -> 5 -> 6 -> 7\\n\\tstep2: 0 (pointer) -> 1 <- 2      3 -> 4 -> 5 -> 6 -> 7\\n\\tstep3: 0 (pointer) -> 1 <- 2 <- 3      4 -> 5 -> 6 -> 7\\n```\n```\\n\\tstep3: 0 (pointer) -> 1 <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n```\n```\\n\\tListNode tail = pointer.next;\\n\\ttail.next = curr; \\n\\tpointer.next = prev;\\n\\tpointer = tail;\\n```\n```\\n\\tafter first line:   0 (pointer) -> 1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\tafter second line:  0 (pointer) -> 1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t       |____________________________\\u2191\\n\\tafter third line:   \\n\\t\\t\\t\\t\\t\\t\\t\\t|-----------------------\\u2193\\n\\t\\t\\t\\t\\t\\t0 (pointer)    1 (tail) <- 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   |____________________________\\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\tafter forth line:\\t0 -> 3 -> 2 -> 1 (pointer) -> 4 -> 5 -> 6 -> 7\\n```\n```\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode pointer = dummy;\\n        while (pointer != null) {\\n            ListNode node = pointer;\\n            // first check whether there are k nodes to reverse\\n            for (int i = 0; i < k && node != null; i++) {\\n                node = node.next;\\n            }\\n            if (node == null) break;\\n            \\n            // now we know that we have k nodes, we will start from the first node\\n            ListNode prev = null, curr = pointer.next, next = null;\\n            for (int i = 0; i < k; i++) {\\n                next = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = next;\\n            }\\n            ListNode tail = pointer.next;\\n            tail.next = curr;\\n            pointer.next = prev;\\n            pointer = tail;\\n        }\\n        return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 523641,
                "title": "c-iterative-solution-recursive-solution",
                "content": "# Recursive solution\\n\\nRecursive solution has `O(n)` space complexity because of call stacks.\\n\\n```c++\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n            if(cursor == nullptr) return head;\\n            cursor = cursor->next;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* nxt = nullptr;\\n        for(int i = 0; i < k; i++){\\n            nxt = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        head->next = reverseKGroup(curr, k);\\n        return prev;\\n    }\\n```\\n\\n\\n******************************************************************************************\\n\\n\\n# Iterative solution\\n\\nIterative solution has `O(1)` space complexity.\\n\\n```c++\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* before = dummy;\\n        ListNode* after = head;\\n        ListNode* curr = nullptr;\\n        ListNode* prev = nullptr;\\n        ListNode* nxt = nullptr;\\n        while(true){\\n            ListNode* cursor = after;\\n            for(int i = 0; i < k; i++){\\n                if(cursor == nullptr) return dummy->next;\\n                cursor = cursor->next;\\n            }\\n            curr = after;\\n            prev = before;\\n            for(int i = 0; i < k; i++){\\n                nxt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nxt;\\n            }\\n            after->next = curr;\\n            before->next = prev;\\n            before = after;\\n            after = curr;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```c++\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n            if(cursor == nullptr) return head;\\n            cursor = cursor->next;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* nxt = nullptr;\\n        for(int i = 0; i < k; i++){\\n            nxt = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        head->next = reverseKGroup(curr, k);\\n        return prev;\\n    }\\n```\n```c++\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* before = dummy;\\n        ListNode* after = head;\\n        ListNode* curr = nullptr;\\n        ListNode* prev = nullptr;\\n        ListNode* nxt = nullptr;\\n        while(true){\\n            ListNode* cursor = after;\\n            for(int i = 0; i < k; i++){\\n                if(cursor == nullptr) return dummy->next;\\n                cursor = cursor->next;\\n            }\\n            curr = after;\\n            prev = before;\\n            for(int i = 0; i < k; i++){\\n                nxt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nxt;\\n            }\\n            after->next = curr;\\n            before->next = prev;\\n            before = after;\\n            after = curr;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11435,
                "title": "c-elegant-and-small",
                "content": "    class Solution \\n    {\\n    public:\\n        \\n        ListNode* reverse(ListNode* first, ListNode* last)\\n        {\\n            ListNode* prev = last;\\n            \\n            while ( first != last )\\n            {\\n                auto tmp = first->next;\\n                first->next = prev;\\n                prev = first;\\n                first = tmp;\\n            }\\n            \\n            return prev;\\n        }\\n        \\n        ListNode* reverseKGroup(ListNode* head, int k) \\n        {\\n            auto node=head;\\n            for (int i=0; i < k; ++i)\\n            {\\n                if ( ! node  )\\n                    return head; // nothing to do list too sort\\n                node = node->next;\\n            }\\n    \\n            auto new_head = reverse( head, node);\\n            head->next = reverseKGroup( node, k);\\n            return new_head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution \\n    {\\n    public:\\n        \\n        ListNode* reverse(ListNode* first, ListNode* last)\\n        {\\n            ListNode* prev = last;\\n            \\n            while ( first != last )\\n            {\\n                auto tmp = first->next;\\n                first->next = prev;\\n                prev = first;\\n                first = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 11457,
                "title": "20-line-iterative-c-solution",
                "content": "    -1 -> 1 -> 2 -> 3 -> 4 -> 5\\n     |    |    |    | \\n    pre  cur  nex  tmp\\n\\n    -1 -> 2 -> 1 -> 3 -> 4 -> 5\\n     |         |    |    | \\n    pre       cur  nex  tmp\\n\\n    -1 -> 3 -> 2 -> 1 -> 4 -> 5\\n     |              |    |    | \\n    pre            cur  nex  tmp\\n\\n\\nAbove is how it works inside one group iteration(for example, k=3)\\n\\n    class Solution {\\n    public:\\n        ListNode *reverseKGroup(ListNode *head, int k) {\\n            if(head==NULL||k==1) return head;\\n            int num=0;\\n            ListNode *preheader = new ListNode(-1);\\n            preheader->next = head;\\n            ListNode *cur = preheader, *nex, *tmp, *pre = preheader;\\n            while(cur = cur->next) \\n                num++;\\n            while(num>=k) {\\n                cur = pre->next;\\n                nex = cur->next;\\n                for(int i=1;i<k;i++) {\\n                    tmp= nex->next;\\n                    nex->next = pre->next;\\n                    pre->next = nex;\\n                    cur->next = tmp;\\n                    nex = tmp;\\n                }\\n                pre = cur;\\n                num-=k;\\n            }\\n            return preheader->next;\\n        }\\n    };\\n\\nThanks to ciaoliang1992, the tmp pointer is no necessary, so the more concise solution is \\n\\n    class Solution {\\n    public:\\n        ListNode *reverseKGroup(ListNode *head, int k) {\\n            if(head==NULL||k==1) return head;\\n            int num=0;\\n            ListNode *preheader = new ListNode(-1);\\n            preheader->next = head;\\n            ListNode *cur = preheader, *nex, *pre = preheader;\\n            while(cur = cur->next) \\n                num++;\\n            while(num>=k) {\\n                cur = pre->next;\\n                nex = cur->next;\\n                for(int i=1;i<k;++i) {\\n                    cur->next=nex->next;\\n                    nex->next=pre->next;\\n                    pre->next=nex;\\n                    nex=cur->next;\\n                }\\n                pre = cur;\\n                num-=k;\\n            }\\n            return preheader->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *reverseKGroup(ListNode *head, int k) {\\n            if(head==NULL||k==1) return head;\\n            int num=0;\\n            ListNode *preheader = new ListNode(-1);\\n            preheader->next = head;\\n            ListNode *cur = preheader, *nex, *tmp, *pre = preheader;\\n            while(cur = cur->next) \\n                num++;\\n            while(num>=k) {\\n                cur = pre->next;\\n                nex = cur->next;\\n                for(int i=1;i<k;i++) {\\n                    tmp= nex->next;\\n                    nex->next = pre->next;\\n                    pre->next = nex;\\n                    cur->next = tmp;\\n                    nex = tmp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 172576,
                "title": "python-follow-up-of-lc206",
                "content": "This problem is a standard follow up to\n`LC 206 Reverse Linked List`\n\nA lot of the solutions implemented the reversing logic from scratch\nI am going to pretend that I just finish writing the standard reverse method, and reuse the method on the follow up.\n\n### LC 206 Reverse Linked List\n```python\nclass Solution:\n    def reverseList(self, head):\n        if not head or not head.next:\n            return head\n        \n        prev, cur, nxt = None, head, head\n        while cur:\n            nxt = cur.next\n            cur.next = prev\n            prev = cur\n            cur = nxt\n        return prev    \n```\n\n\n\n### Follow up: Please reverse the list into K Group\n```python\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        count, node = 0, head\n        while node and count < k:\n            node = node.next\n            count += 1\n        if count < k: return head\n        new_head, prev = self.reverse(head, count)\n        head.next = self.reverseKGroup(new_head, k)\n        return prev\n    \n    def reverse(self, head, count):\n        prev, cur, nxt = None, head, head\n        while count > 0:\n            nxt = cur.next\n            cur.next = prev\n            prev = cur\n            cur = nxt\n            count -= 1\n        return (cur, prev)\n```",
                "solutionTags": [],
                "code": "```python\nclass Solution:\n    def reverseList(self, head):\n        if not head or not head.next:\n            return head\n        \n        prev, cur, nxt = None, head, head\n        while cur:\n            nxt = cur.next\n            cur.next = prev\n            prev = cur\n            cur = nxt\n        return prev    \n```\n```python\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        count, node = 0, head\n        while node and count < k:\n            node = node.next\n            count += 1\n        if count < k: return head\n        new_head, prev = self.reverse(head, count)\n        head.next = self.reverseKGroup(new_head, k)\n        return prev\n    \n    def reverse(self, head, count):\n        prev, cur, nxt = None, head, head\n        while count > 0:\n            nxt = cur.next\n            cur.next = prev\n            prev = cur\n            cur = nxt\n            count -= 1\n        return (cur, prev)\n```",
                "codeTag": "Java"
            },
            {
                "id": 11413,
                "title": "share-my-java-solution-with-comments-in-line",
                "content": "      \\n      public class Solution {\\n            public ListNode reverseKGroup(ListNode head, int k) {\\n                if (head==null||head.next==null||k<2) return head;\\n        \\n                ListNode dummy = new ListNode(0);\\n                dummy.next = head;\\n                \\n                ListNode tail = dummy, prev = dummy,temp;\\n                int count;\\n                while(true){\\n                    count =k;\\n                    while(count>0&&tail!=null){\\n                        count--;\\n                        tail=tail.next;\\n                    } \\n                    if (tail==null) break;//Has reached the end\\n                    \\n        \\n                    head=prev.next;//for next cycle\\n                // prev-->temp-->...--->....--->tail-->....\\n                // Delete @temp and insert to the next position of @tail\\n                // prev-->...-->...-->tail-->head-->...\\n                // Assign @temp to the next node of @prev\\n                // prev-->temp-->...-->tail-->...-->...\\n                // Keep doing until @tail is the next node of @prev\\n                    while(prev.next!=tail){\\n                        temp=prev.next;//Assign\\n                        prev.next=temp.next;//Delete\\n                        \\n                        temp.next=tail.next;\\n                        tail.next=temp;//Insert\\n                        \\n                    }\\n                    \\n                    tail=head;\\n                    prev=head;\\n                    \\n                }\\n                return dummy.next;\\n                \\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public ListNode reverseKGroup(ListNode head, int k) {\\n                if (head==null||head.next==null||k<2) return head;\\n        \\n                ListNode dummy = new ListNode(0);\\n                dummy.next = head;\\n                \\n                ListNode tail = dummy, prev = dummy,temp;\\n                int count;\\n                while(true){\\n                    count =k;\\n                    while(count>0&&tail!=null){\\n                        count--;\\n                        tail=tail.next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 718457,
                "title": "python3-easy-recursion-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:        \\n        # Check if we need to reverse the group\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n\\t\\t        \\n\\t\\t\\t\\t\\n        # Reverse the group (basic way to reverse linked list)\\n        prev = None\\n        curr = head\\n        for _ in range(k):\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        \\n\\t\\t\\n        # After reverse, we know that `head` is the tail of the group.\\n\\t\\t# And `curr` is the next pointer in original linked list order\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n    ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:        \\n        # Check if we need to reverse the group\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n\\t\\t        \\n\\t\\t\\t\\t\\n        # Reverse the group (basic way to reverse linked list)\\n        prev = None\\n        curr = head\\n        for _ in range(k):\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        \\n\\t\\t\\n        # After reverse, we know that `head` is the tail of the group.\\n\\t\\t# And `curr` is the next pointer in original linked list order\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 11653,
                "title": "python-recursive-and-iterative-solutions-with-comments",
                "content": "       \\n    # Recursively\\n    def reverseKGroup(self, head, k):\\n        l, node = 0, head\\n        while node:\\n            l += 1\\n            node = node.next\\n        if k <= 1 or l < k:\\n            return head\\n        node, cur = None, head\\n        for _ in xrange(k):\\n            nxt = cur.next\\n            cur.next = node\\n            node = cur\\n            cur = nxt\\n        head.next = self.reverseKGroup(cur, k)\\n        return node\\n    \\n    # Iteratively    \\n    def reverseKGroup(self, head, k):\\n        if not head or not head.next or k <= 1:\\n            return head\\n        cur, l = head, 0\\n        while cur:\\n            l += 1\\n            cur = cur.next\\n        if k > l:\\n            return head\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        # totally l//k groups\\n        for i in xrange(l//k):\\n            # reverse each group\\n            node = None\\n            for j in xrange(k-1):\\n                nxt = head.next\\n                head.next = node\\n                node = head\\n                head = nxt\\n            # update nodes and connect nodes\\n            tmp = head.next\\n            head.next = node\\n            pre.next.next = tmp\\n            tmp1 = pre.next\\n            pre.next = head\\n            head = tmp\\n            pre = tmp1\\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "       \\n    # Recursively\\n    def reverseKGroup(self, head, k):\\n        l, node = 0, head\\n        while node:\\n            l += 1\\n            node = node.next\\n        if k <= 1 or l < k:\\n            return head\\n        node, cur = None, head\\n        for _ in xrange(k):\\n            nxt = cur.next\\n            cur.next = node\\n            node = cur\\n            cur = nxt\\n        head.next = self.reverseKGroup(cur, k)\\n        return node\\n    \\n    # Iteratively    \\n    def reverseKGroup(self, head, k):\\n        if not head or not head.next or k <= 1:\\n            return head\\n        cur, l = head, 0\\n        while cur:\\n            l += 1\\n            cur = cur.next\\n        if k > l:\\n            return head\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        # totally l//k groups\\n        for i in xrange(l//k):\\n            # reverse each group\\n            node = None\\n            for j in xrange(k-1):\\n                nxt = head.next\\n                head.next = node\\n                node = head\\n                head = nxt\\n            # update nodes and connect nodes\\n            tmp = head.next\\n            head.next = node\\n            pre.next.next = tmp\\n            tmp1 = pre.next\\n            pre.next = head\\n            head = tmp\\n            pre = tmp1\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 11543,
                "title": "c-iterative",
                "content": "We first get the length `len` of the list. Then we know we need to perform `len / k` groups of reverse operations. In each group, the reverse is performed for `k - 1` times.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        dummy -> next = head;\\n        int len = length(head);\\n        for (int i = 0; i < len / k; i++) {\\n            for (int j = 1; j < k; j++) {\\n                ListNode* temp = pre -> next;\\n                pre -> next = head -> next;\\n                head -> next = head -> next -> next;\\n                pre -> next -> next = temp;\\n            }\\n            pre = head;\\n            head = head -> next;\\n        }\\n        return dummy -> next;\\n    }\\nprivate:\\n    ListNode *dummy = new ListNode(0), *pre = dummy;\\n    int length(ListNode* head) {\\n        int len = 0;\\n        while (head) {\\n            len++;\\n            head = head -> next;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        dummy -> next = head;\\n        int len = length(head);\\n        for (int i = 0; i < len / k; i++) {\\n            for (int j = 1; j < k; j++) {\\n                ListNode* temp = pre -> next;\\n                pre -> next = head -> next;\\n                head -> next = head -> next -> next;\\n                pre -> next -> next = temp;\\n            }\\n            pre = head;\\n            head = head -> next;\\n        }\\n        return dummy -> next;\\n    }\\nprivate:\\n    ListNode *dummy = new ListNode(0), *pre = dummy;\\n    int length(ListNode* head) {\\n        int len = 0;\\n        while (head) {\\n            len++;\\n            head = head -> next;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345510,
                "title": "reverse-nodes-in-k-group-iterative-recursion-w-explanation",
                "content": "***Solution 1:(Recursion)***\\n***\\n**Approach:**\\n```\\n1) The first step is to check whether the Head is NULL or Not, if its NULL then we can directly return NULL,\\n2) If the Head is not NULL, then we need to check the length of Linked List starting from current Head.\\n3) If it is not a multiple of K(Less than K) , then there is no need to reverse it and hence we can directly return head,\\n4) Else if its a multiple of K, then we have to reverse the K elements starting from current Head,\\n5) We will follow the same steps for the rest of the elements Recursively.\\n```\\n***\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(!head)\\n            return NULL;\\n        ListNode *KSizeChecker = head;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(KSizeChecker==NULL)\\n                return head;\\n            KSizeChecker = KSizeChecker->next;\\n        }\\n        int cnt=0;\\n        ListNode *cur=head,*prev=NULL,*next=NULL;\\n        while(cur and cnt<k)\\n        {\\n            next=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=next;\\n            cnt++;\\n        }\\n        if(next)\\n            head->next=reverseKGroup(next,k);\\n        return prev;\\n    }\\n};\\n```\\n\\n***\\n***Solution 2:(Iterative):***\\n**Approach:**\\n```\\n1) We first try to find out the length of linked list,\\nLet it be \"Len\"\\n2) Now we try to find out , how many groups of size \"K\" are there to reverse,\\nthis can be easily done using the formula --- \"Len/K\"\\n3) Hence we have Len/K groups to reverse,\\n4) To easily find out the new Linked List\\'s Head(After reversal), we will make a dummyNode just before the head,\\nand at last for new Head we can directly return dummyNode->next,\\n5) The reversal of linked list is very easy ,\\nwe just need to keep track of remaining Nodes and the new head for reversed linked list.\\n```\\n\\n**C++:**\\n```\\nclass Solution {\\n    int getLengthOfLinkedList(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        int cnt=0;\\n        while(ptr)\\n        {\\n            cnt++;\\n            ptr=ptr->next;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(!head)\\n            return NULL;\\n    \\n        int len = getLengthOfLinkedList(head);\\n        if(len<k)\\n            return head;\\n        \\n        int numberOfGroupsToReverse = len/k;\\n        \\n        ListNode *dummyNode = new ListNode(-1);\\n        dummyNode->next = head;\\n        ListNode *start = dummyNode;\\n\\n        ListNode *pre,*remaining,*next;\\n        for(int i=0;i<numberOfGroupsToReverse;i++)\\n        {\\n            pre = NULL;\\n            remaining = head;\\n            for(int j=0;j<k;j++)\\n            {\\n                next = head->next;\\n                head->next = pre;\\n                pre=head;\\n                head=next;\\n            }\\n            start->next = pre;\\n            remaining->next = head;\\n            start = remaining;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1) The first step is to check whether the Head is NULL or Not, if its NULL then we can directly return NULL,\\n2) If the Head is not NULL, then we need to check the length of Linked List starting from current Head.\\n3) If it is not a multiple of K(Less than K) , then there is no need to reverse it and hence we can directly return head,\\n4) Else if its a multiple of K, then we have to reverse the K elements starting from current Head,\\n5) We will follow the same steps for the rest of the elements Recursively.\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(!head)\\n            return NULL;\\n        ListNode *KSizeChecker = head;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(KSizeChecker==NULL)\\n                return head;\\n            KSizeChecker = KSizeChecker->next;\\n        }\\n        int cnt=0;\\n        ListNode *cur=head,*prev=NULL,*next=NULL;\\n        while(cur and cnt<k)\\n        {\\n            next=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=next;\\n            cnt++;\\n        }\\n        if(next)\\n            head->next=reverseKGroup(next,k);\\n        return prev;\\n    }\\n};\\n```\n```\\n1) We first try to find out the length of linked list,\\nLet it be \"Len\"\\n2) Now we try to find out , how many groups of size \"K\" are there to reverse,\\nthis can be easily done using the formula --- \"Len/K\"\\n3) Hence we have Len/K groups to reverse,\\n4) To easily find out the new Linked List\\'s Head(After reversal), we will make a dummyNode just before the head,\\nand at last for new Head we can directly return dummyNode->next,\\n5) The reversal of linked list is very easy ,\\nwe just need to keep track of remaining Nodes and the new head for reversed linked list.\\n```\n```\\nclass Solution {\\n    int getLengthOfLinkedList(ListNode *head)\\n    {\\n        ListNode *ptr = head;\\n        int cnt=0;\\n        while(ptr)\\n        {\\n            cnt++;\\n            ptr=ptr->next;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(!head)\\n            return NULL;\\n    \\n        int len = getLengthOfLinkedList(head);\\n        if(len<k)\\n            return head;\\n        \\n        int numberOfGroupsToReverse = len/k;\\n        \\n        ListNode *dummyNode = new ListNode(-1);\\n        dummyNode->next = head;\\n        ListNode *start = dummyNode;\\n\\n        ListNode *pre,*remaining,*next;\\n        for(int i=0;i<numberOfGroupsToReverse;i++)\\n        {\\n            pre = NULL;\\n            remaining = head;\\n            for(int j=0;j<k;j++)\\n            {\\n                next = head->next;\\n                head->next = pre;\\n                pre=head;\\n                head=next;\\n            }\\n            start->next = pre;\\n            remaining->next = head;\\n            start = remaining;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11475,
                "title": "my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n    int length(ListNode * node){\\n        int count=0;\\n        while(node){\\n            count++;\\n            node=node->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       if(length(head) < k)return head;\\n       ListNode * cur=head;\\n       ListNode * prev=NULL, *next=NULL;\\n       while(int i=0; i < k; i++){\\n           next=cur->next;\\n           cur->next=prev;\\n           prev=cur;\\n           cur=next;\\n       }\\n       head->next=reverseKGroup(cur, k);\\n       return prev;\\n     }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int length(ListNode * node){\\n        int count=0;\\n        while(node){\\n            count++;\\n            node=node->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1345590,
                "title": "python-o-n-o-1-time-memory-a-bit-explained",
                "content": "This is quite classical linked list problem and it is quite nasty in my opinion. It can be a bit problematic to imagine all this in your head, do it on paper. The idea is to add dummy variable, then calculate number of nodes. We need this, because we do not need to reverse last group. Then we use idea similar to problem **0206** Reverse Linked List: but here we need to reverse `k` elements, and then reconnect first and last nodes in each group and update `cnt`.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def reverseKGroup(self, head, k):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur, nxt, pre = dummy, dummy, dummy\\n        cnt = 0\\n        while cur.next:\\n            cnt += 1\\n            cur = cur.next\\n            \\n        while cnt >= k:\\n            cur = new = pre.next\\n            nxt = cur.next\\n            for _ in range(k-1):\\n                tmp = nxt.next\\n                nxt.next = cur\\n                cur = nxt\\n                nxt = tmp\\n            \\n            pre.next = cur\\n            new.next = nxt\\n            pre = new\\n            cnt -= k\\n            \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseKGroup(self, head, k):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur, nxt, pre = dummy, dummy, dummy\\n        cnt = 0\\n        while cur.next:\\n            cnt += 1\\n            cur = cur.next\\n            \\n        while cnt >= k:\\n            cur = new = pre.next\\n            nxt = cur.next\\n            for _ in range(k-1):\\n                tmp = nxt.next\\n                nxt.next = cur\\n                cur = nxt\\n                nxt = tmp\\n            \\n            pre.next = cur\\n            new.next = nxt\\n            pre = new\\n            cnt -= k\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367041,
                "title": "c-simple-and-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head, ListNode* tail) {\\n        ListNode* current = head;\\n        ListNode *prev = NULL, *next = NULL;\\n \\n        while (current != tail) {\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* ptr = head;\\n        \\n        for (int i = 0; i < k; i++) {\\n            if (!ptr) return head;\\n            ptr = ptr->next;\\n            \\n        }\\n        ListNode* tmp = reverse(head, ptr);\\n        head->next = reverseKGroup(ptr, k);\\n        return tmp;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head, ListNode* tail) {\\n        ListNode* current = head;\\n        ListNode *prev = NULL, *next = NULL;\\n \\n        while (current != tail) {\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* ptr = head;\\n        \\n        for (int i = 0; i < k; i++) {\\n            if (!ptr) return head;\\n            ptr = ptr->next;\\n            \\n        }\\n        ListNode* tmp = reverse(head, ptr);\\n        head->next = reverseKGroup(ptr, k);\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11638,
                "title": "java-o-n-elegant-code-solution",
                "content": "  why use while(true) loop? We don't know if there is k nodes left out in advance. So we advance tail for k steps to check for that. If there is no k nodes, the program exits from there.\\n\\n \\n\\n     public class Solution {\\n            public ListNode reverseKGroup(ListNode head, int k) {\\n                if (k <= 1 || head == null || head.next == null)\\n                    return head;\\n                ListNode newHead = new ListNode(0);\\n                newHead.next = head;\\n                ListNode prev, start, then, tail;\\n                tail = prev = newHead;\\n                start = prev.next;\\n                while (true) {\\n                    // check if there's k nodes left-out\\n                    for (int i = 0; i < k; i++) {\\n                        tail = tail.next;\\n                        if (tail == null)\\n                            return newHead.next;\\n                    }\\n                    // reverse k nodes\\n                    for (int i = 0; i < k - 1; i++) {\\n                        then = start.next;\\n                        start.next = then.next;\\n                        then.next = prev.next;\\n                        prev.next = then;\\n                    }\\n                    tail = prev = start;\\n                    start = prev.next;\\n                }\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public ListNode reverseKGroup(ListNode head, int k) {\\n                if (k <= 1 || head == null || head.next == null)\\n                    return head;\\n                ListNode newHead = new ListNode(0);\\n                newHead.next = head;\\n                ListNode prev, start, then, tail;\\n                tail = prev = newHead;\\n                start = prev.next;\\n                while (true) {\\n                    // check if there's k nodes left-out\\n                    for (int i = 0; i < k; i++) {\\n                        tail = tail.next;\\n                        if (tail == null)\\n                            return newHead.next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1656819,
                "title": "solution-swift-reverse-nodes-in-k-group-test-cases",
                "content": "```swift\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        let node = ListNode(0)\\n        node.next = head\\n        \\n        var prev = node\\n        \\n        while prev.next != nil {\\n            var tail: ListNode? = prev\\n            for _ in 1...k { tail = tail?.next }\\n            guard var node = tail else { break }\\n            \\n            let next = node.next\\n            var last = next\\n            var curr = prev.next\\n            \\n            while curr !== next {\\n                let cnext = curr!.next\\n                curr!.next = last\\n                last = curr\\n                curr = cnext\\n            }\\n            if let pnext = prev.next { node = pnext }\\n            prev.next = last\\n            prev = node\\n        }\\n        return node.next\\n    }\\n}\\n```\\n\\n---\\n\\n<p><details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.040 (0.042) seconds\\n</pre></p>\\n\\n```swift\\n// Result: Executed 2 tests, with 0 failures (0 unexpected) in 0.020 (0.022) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.reverseKGroup(ListNode([1,2,3,4,5]), 2)\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3,5])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.reverseKGroup(ListNode([1,2,3,4,5]), 3)\\n        XCTAssertEqual(value?.val, ListNode([3,2,1,4,5])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>\\n\\n<p><details>\\n<summary>\\n<b>ListNode</b>\\n</summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        let node = ListNode(0)\\n        node.next = head\\n        \\n        var prev = node\\n        \\n        while prev.next != nil {\\n            var tail: ListNode? = prev\\n            for _ in 1...k { tail = tail?.next }\\n            guard var node = tail else { break }\\n            \\n            let next = node.next\\n            var last = next\\n            var curr = prev.next\\n            \\n            while curr !== next {\\n                let cnext = curr!.next\\n                curr!.next = last\\n                last = curr\\n                curr = cnext\\n            }\\n            if let pnext = prev.next { node = pnext }\\n            prev.next = last\\n            prev = node\\n        }\\n        return node.next\\n    }\\n}\\n```\n```swift\\n// Result: Executed 2 tests, with 0 failures (0 unexpected) in 0.020 (0.022) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.reverseKGroup(ListNode([1,2,3,4,5]), 2)\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3,5])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.reverseKGroup(ListNode([1,2,3,4,5]), 3)\\n        XCTAssertEqual(value?.val, ListNode([3,2,1,4,5])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799333,
                "title": "c-simple-recursive-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++){\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        ListNode *prev=NULL;\\n        ListNode *nex1=NULL;\\n        temp=head;\\n        for(int i=0;i<k;i++){\\n            nex1=temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nex1;\\n        }\\n        if(nex1!=NULL)\\n            head->next=reverseKGroup(nex1,k);\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++){\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        ListNode *prev=NULL;\\n        ListNode *nex1=NULL;\\n        temp=head;\\n        for(int i=0;i<k;i++){\\n            nex1=temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nex1;\\n        }\\n        if(nex1!=NULL)\\n            head->next=reverseKGroup(nex1,k);\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441014,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* counter = head;\\n        ListNode* temp = head;\\n        ListNode* ans = head;\\n        while(counter!=NULL){\\n            cnt++;\\n            counter = counter->next;\\n        }\\n        cnt /= k;\\n        stack<int> st;\\n        int k1 = k;\\n\\n        while(temp!=NULL){\\n            st.push(temp->val);\\n            k1--;\\n            temp = temp->next;\\n            if(k1==0){\\n                while(!st.empty()){\\n                    ans->val = st.top();\\n                    st.pop();\\n                    ans = ans->next;\\n                }\\n                cnt--;\\n                k1 = k;\\n            }\\n            if(cnt==0){\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* counter = head;\\n        ListNode* temp = head;\\n        ListNode* ans = head;\\n        while(counter!=NULL){\\n            cnt++;\\n            counter = counter->next;\\n        }\\n        cnt /= k;\\n        stack<int> st;\\n        int k1 = k;\\n\\n        while(temp!=NULL){\\n            st.push(temp->val);\\n            k1--;\\n            temp = temp->next;\\n            if(k1==0){\\n                while(!st.empty()){\\n                    ans->val = st.top();\\n                    st.pop();\\n                    ans = ans->next;\\n                }\\n                cnt--;\\n                k1 = k;\\n            }\\n            if(cnt==0){\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517593,
                "title": "c-java-python-javascript-tc-o-n-optimized-solution",
                "content": "# Intuition:\\nWe can use a two-pointer approach to reverse the linked list in groups of k nodes. We will maintain a `prevGroupTail` pointer that will point to the tail of the previous reversed group, and we will connect it to the head of the current group after reversing it. We will also use a `dummy` node as the head of the resulting list to avoid edge cases.\\n\\n# Approach:\\n1. Create a dummy node and set its next to the head of the input list.\\n2. Initialize a `prevGroupTail` pointer to the dummy node.\\n3. Loop through the list until we reach the end.\\n4. In each iteration, set `groupStart` to the current `head`, and find `groupEnd` using the `getGroupEnd` function, which returns the end node of the current group (which is `k` nodes away from the `groupStart`). If `groupEnd` is null, then we don\\'t need to reverse the remaining nodes because there are less than `k` nodes left in the list.\\n5. Set `nextGroupStart` to `groupEnd->next`, and then set `groupEnd->next` to null to separate the group to be reversed from the rest of the list.\\n6. Reverse the current group using the `reverseList` function and set `prevGroupTail->next` to the new head of the reversed group. Then set `groupStart->next` to `nextGroupStart`.\\n7. Update `prevGroupTail` to the `groupStart`.\\n8. Set `head` to `nextGroupStart`.\\n9. Return the head of the resulting list (which is the `dummy->next` node).\\n\\n# Complexity\\n- Time Complexity:\\nThe time complexity of the algorithm is O(n), where n is the number of nodes in the list, since we visit each node once.\\n\\n- Space Complexity:\\nThe space complexity of the algorithm is O(1), since we only use a constant amount of extra space for the `dummy` and `prevGroupTail` nodes, and we reverse the list in-place without using any additional data structures.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prevGroupTail = dummy;\\n        \\n        while (head) {\\n            ListNode* groupStart = head;\\n            ListNode* groupEnd = getGroupEnd(head, k);\\n            \\n            if (!groupEnd) {\\n                break; // Remaining nodes are less than k, so no need to reverse\\n            }\\n            \\n            ListNode* nextGroupStart = groupEnd->next;\\n            groupEnd->next = nullptr; // Separate the group to be reversed\\n            \\n            // Reverse the group\\n            prevGroupTail->next = reverseList(groupStart);\\n            groupStart->next = nextGroupStart;\\n            \\n            prevGroupTail = groupStart;\\n            head = nextGroupStart;\\n        }\\n        \\n        ListNode* newHead = dummy->next;\\n        delete dummy;\\n        return newHead;\\n    }\\n    \\nprivate:\\n    ListNode* getGroupEnd(ListNode* head, int k) {\\n        while (head && k > 1) {\\n            head = head->next;\\n            k--;\\n        }\\n        return head;\\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr) {\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prevGroupTail = dummy;\\n\\n        while (head != null) {\\n            ListNode groupStart = head;\\n            ListNode groupEnd = getGroupEnd(head, k);\\n\\n            if (groupEnd == null)\\n                break;\\n\\n            prevGroupTail.next = reverseList(groupStart, groupEnd.next);\\n            prevGroupTail = groupStart;\\n            head = prevGroupTail.next;\\n        }\\n\\n        ListNode newHead = dummy.next;\\n        return newHead;\\n    }\\n\\n    private ListNode getGroupEnd(ListNode head, int k) {\\n        while (head != null && --k > 0)\\n            head = head.next;\\n        return head;\\n    }\\n\\n    private ListNode reverseList(ListNode head, ListNode stop) {\\n        ListNode prev = stop;\\n        while (head != stop) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def reverseKGroup(self, head, k):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prevGroupTail = dummy\\n\\n        while head:\\n            groupStart = head\\n            groupEnd = self.getGroupEnd(head, k)\\n\\n            if not groupEnd:\\n                break\\n\\n            prevGroupTail.next = self.reverseList(groupStart, groupEnd.next)\\n            prevGroupTail = groupStart\\n            head = prevGroupTail.next\\n\\n        newHead = dummy.next\\n        return newHead\\n\\n    def getGroupEnd(self, head, k):\\n        while head and k > 1:\\n            head = head.next\\n            k -= 1\\n        return head\\n\\n    def reverseList(self, head, stop):\\n        prev = stop\\n        while head != stop:\\n            next = head.next\\n            head.next = prev\\n            prev = head\\n            head = next\\n        return prev\\n```\\n---\\n# JavaScript\\n```\\nvar reverseKGroup = function(head, k) {\\n    var dummy = new ListNode(0);\\n        dummy.next = head;\\n        var prevGroupTail = dummy;\\n\\n        while (head) {\\n            var groupStart = head;\\n            var groupEnd = getGroupEnd(head, k);\\n\\n            if (!groupEnd)\\n                break;\\n\\n            prevGroupTail.next = reverseList(groupStart, groupEnd.next);\\n            prevGroupTail = groupStart;\\n            head = prevGroupTail.next;\\n        }\\n    var newHead = dummy.next;\\n    return newHead;\\n}\\n\\nvar getGroupEnd = function(head, k) {\\n    while (head && k > 1) {\\n        head = head.next;\\n        k--;\\n    }\\n    return head;\\n}\\n\\nvar reverseList = function(head, stop) {\\n    var prev = stop;\\n    while (head !== stop) {\\n        var next = head.next;\\n        head.next = prev;\\n        prev = head;\\n        head = next;\\n    }\\n    return prev;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prevGroupTail = dummy;\\n        \\n        while (head) {\\n            ListNode* groupStart = head;\\n            ListNode* groupEnd = getGroupEnd(head, k);\\n            \\n            if (!groupEnd) {\\n                break; // Remaining nodes are less than k, so no need to reverse\\n            }\\n            \\n            ListNode* nextGroupStart = groupEnd->next;\\n            groupEnd->next = nullptr; // Separate the group to be reversed\\n            \\n            // Reverse the group\\n            prevGroupTail->next = reverseList(groupStart);\\n            groupStart->next = nextGroupStart;\\n            \\n            prevGroupTail = groupStart;\\n            head = nextGroupStart;\\n        }\\n        \\n        ListNode* newHead = dummy->next;\\n        delete dummy;\\n        return newHead;\\n    }\\n    \\nprivate:\\n    ListNode* getGroupEnd(ListNode* head, int k) {\\n        while (head && k > 1) {\\n            head = head->next;\\n            k--;\\n        }\\n        return head;\\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr) {\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prevGroupTail = dummy;\\n\\n        while (head != null) {\\n            ListNode groupStart = head;\\n            ListNode groupEnd = getGroupEnd(head, k);\\n\\n            if (groupEnd == null)\\n                break;\\n\\n            prevGroupTail.next = reverseList(groupStart, groupEnd.next);\\n            prevGroupTail = groupStart;\\n            head = prevGroupTail.next;\\n        }\\n\\n        ListNode newHead = dummy.next;\\n        return newHead;\\n    }\\n\\n    private ListNode getGroupEnd(ListNode head, int k) {\\n        while (head != null && --k > 0)\\n            head = head.next;\\n        return head;\\n    }\\n\\n    private ListNode reverseList(ListNode head, ListNode stop) {\\n        ListNode prev = stop;\\n        while (head != stop) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def reverseKGroup(self, head, k):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prevGroupTail = dummy\\n\\n        while head:\\n            groupStart = head\\n            groupEnd = self.getGroupEnd(head, k)\\n\\n            if not groupEnd:\\n                break\\n\\n            prevGroupTail.next = self.reverseList(groupStart, groupEnd.next)\\n            prevGroupTail = groupStart\\n            head = prevGroupTail.next\\n\\n        newHead = dummy.next\\n        return newHead\\n\\n    def getGroupEnd(self, head, k):\\n        while head and k > 1:\\n            head = head.next\\n            k -= 1\\n        return head\\n\\n    def reverseList(self, head, stop):\\n        prev = stop\\n        while head != stop:\\n            next = head.next\\n            head.next = prev\\n            prev = head\\n            head = next\\n        return prev\\n```\n```\\nvar reverseKGroup = function(head, k) {\\n    var dummy = new ListNode(0);\\n        dummy.next = head;\\n        var prevGroupTail = dummy;\\n\\n        while (head) {\\n            var groupStart = head;\\n            var groupEnd = getGroupEnd(head, k);\\n\\n            if (!groupEnd)\\n                break;\\n\\n            prevGroupTail.next = reverseList(groupStart, groupEnd.next);\\n            prevGroupTail = groupStart;\\n            head = prevGroupTail.next;\\n        }\\n    var newHead = dummy.next;\\n    return newHead;\\n}\\n\\nvar getGroupEnd = function(head, k) {\\n    while (head && k > 1) {\\n        head = head.next;\\n        k--;\\n    }\\n    return head;\\n}\\n\\nvar reverseList = function(head, stop) {\\n    var prev = stop;\\n    while (head !== stop) {\\n        var next = head.next;\\n        head.next = prev;\\n        prev = head;\\n        head = next;\\n    }\\n    return prev;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11649,
                "title": "javascript-solution",
                "content": "    function reverseKGroup(head, k) {\\n      if (!head) return null;\\n      var tail = head;\\n      for (var i = 1; i < k; i++) {\\n        tail = tail.next;\\n        if (!tail) return head;\\n      }\\n      var next = tail.next;\\n      tail.next = null;\\n      reverse(head);\\n      head.next = reverseKGroup(next, k);\\n      return tail;\\n    }\\n    \\n    function reverse(curr) {\\n      var prev = null;\\n      while (curr) {\\n        var next = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = next;\\n      }\\n      return prev;\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function reverseKGroup(head, k) {\\n      if (!head) return null;\\n      var tail = head;\\n      for (var i = 1; i < k; i++) {\\n        tail = tail.next;\\n        if (!tail) return head;\\n      }\\n      var next = tail.next;\\n      tail.next = null;\\n      reverse(head);\\n      head.next = reverseKGroup(next, k);\\n      return tail;\\n    }\\n    \\n    function reverse(curr) {\\n      var prev = null;\\n      while (curr) {\\n        var next = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = next;\\n      }\\n      return prev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11425,
                "title": "simple-python-solution-one-pass-no-additional-space-109ms",
                "content": "The key idea is to keep track of the `next_head` while reversing the group, `tail` of the current group is always the start node of the group, once the group reversing is done, `next_head` is available, simply connect it to `tail`. \\n\\n     \\n    def reverseKGroup(self, head, k):\\n        if head is None or k < 2:\\n            return head\\n        \\n        next_head = head\\n        for i in range(k - 1):\\n            next_head = next_head.next\\n            if next_head is None:\\n                return head\\n        ret = next_head\\n        \\n        current = head\\n        while next_head:\\n            tail = current\\n            prev = None\\n            for i in range(k):\\n                if next_head:\\n                    next_head = next_head.next\\n                _next = current.next\\n                current.next = prev\\n                prev = current\\n                current = _next\\n            tail.next = next_head or current\\n                \\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "The key idea is to keep track of the `next_head` while reversing the group, `tail` of the current group is always the start node of the group, once the group reversing is done, `next_head` is available, simply connect it to `tail`. \\n\\n     \\n    def reverseKGroup(self, head, k):\\n        if head is None or k < 2:\\n            return head\\n        \\n        next_head = head\\n        for i in range(k - 1):\\n            next_head = next_head.next\\n            if next_head is None:\\n                return head\\n        ret = next_head\\n        \\n        current = head\\n        while next_head:\\n            tail = current\\n            prev = None\\n            for i in range(k):\\n                if next_head:\\n                    next_head = next_head.next\\n                _next = current.next\\n                current.next = prev\\n                prev = current\\n                current = _next\\n            tail.next = next_head or current\\n                \\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 3521559,
                "title": "python3-iterative-recursive-solutions-beats-98",
                "content": "# Iterative solution:\\n```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        def getGroupEnd(cur, k):\\n            while k > 1 and cur.next:\\n                cur = cur.next \\n                k-=1\\n            return cur if k == 1 else None\\n\\n        def reverseGroup(start, end):\\n            prev, cur, new_group_start = None, start, end.next\\n            while cur != new_group_start:\\n                cur.next, cur, prev = prev, cur.next, cur  \\n\\n        dummy = ListNode()\\n        prev_group = dummy\\n        while head:\\n            group_start = head\\n            group_end = getGroupEnd(head, k)\\n            if not group_end: break # not enough todes to make a new group\\n            next_group_start = group_end.next # save link to the next group start\\n            reverseGroup(group_start, group_end) # reverse the current group\\n            prev_group.next = group_end # group_end is the start of the reversed group\\n            prev_group = group_start # group_start is the end of the reversed group\\n            group_start.next = next_group_start # link current reversed group with the next group\\n            head = next_group_start # move current point to the start of the next group\\n\\n        return dummy.next        \\n```\\n```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        prev_group = dummy\\n        while head:\\n            j, group_end = 1, head #start of group = end after reverse\\n            while j < k and head.next:\\n                head = head.next \\n                j+=1\\n            group_start = head #end of group = start after reverse\\n            next_group = head = head.next #start of next group\\n\\n            if j != k:  #don\\'t need reverse (not enough nodes)\\n                break\\n            #reverse current group without links to prev and next groups\\n            prev, cur = None, group_end\\n            while cur != next_group:\\n                cur.next, cur, prev = prev, cur.next, cur  \\n\\n            prev_group.next = group_start\\n            prev_group = group_end\\n            group_end.next = next_group\\n\\n        return dummy.next    \\n```\\n![Screenshot 2023-08-03 at 03.09.07.png](https://assets.leetcode.com/users/images/b4a03976-433e-4ee0-b939-8d792674dcea_1691021437.7787385.png)\\n# Recursive solution:\\n```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head: return\\n        start, end = head, head\\n        for _ in range(k):\\n            if not end: return head\\n            end = end.next\\n        \\n        # reverse diapason [start:end)\\n        def reverse(start, end):\\n            prev = None\\n            while start != end:\\n                start.next, start, prev = prev, start.next, start\\n            return prev # return head node of the reversed group\\n        \\n        newHead = reverse(start, end)\\n        start.next = self.reverseKGroup(end, k)\\n\\n        return newHead\\n```\\n![Screenshot 2023-08-03 at 04.06.16.png](https://assets.leetcode.com/users/images/23207cea-9dec-4462-acd9-b5e9732060c4_1691024788.7471995.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        def getGroupEnd(cur, k):\\n            while k > 1 and cur.next:\\n                cur = cur.next \\n                k-=1\\n            return cur if k == 1 else None\\n\\n        def reverseGroup(start, end):\\n            prev, cur, new_group_start = None, start, end.next\\n            while cur != new_group_start:\\n                cur.next, cur, prev = prev, cur.next, cur  \\n\\n        dummy = ListNode()\\n        prev_group = dummy\\n        while head:\\n            group_start = head\\n            group_end = getGroupEnd(head, k)\\n            if not group_end: break # not enough todes to make a new group\\n            next_group_start = group_end.next # save link to the next group start\\n            reverseGroup(group_start, group_end) # reverse the current group\\n            prev_group.next = group_end # group_end is the start of the reversed group\\n            prev_group = group_start # group_start is the end of the reversed group\\n            group_start.next = next_group_start # link current reversed group with the next group\\n            head = next_group_start # move current point to the start of the next group\\n\\n        return dummy.next        \\n```\n```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        prev_group = dummy\\n        while head:\\n            j, group_end = 1, head #start of group = end after reverse\\n            while j < k and head.next:\\n                head = head.next \\n                j+=1\\n            group_start = head #end of group = start after reverse\\n            next_group = head = head.next #start of next group\\n\\n            if j != k:  #don\\'t need reverse (not enough nodes)\\n                break\\n            #reverse current group without links to prev and next groups\\n            prev, cur = None, group_end\\n            while cur != next_group:\\n                cur.next, cur, prev = prev, cur.next, cur  \\n\\n            prev_group.next = group_start\\n            prev_group = group_end\\n            group_end.next = next_group\\n\\n        return dummy.next    \\n```\n```python3 []\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head: return\\n        start, end = head, head\\n        for _ in range(k):\\n            if not end: return head\\n            end = end.next\\n        \\n        # reverse diapason [start:end)\\n        def reverse(start, end):\\n            prev = None\\n            while start != end:\\n                start.next, start, prev = prev, start.next, start\\n            return prev # return head node of the reversed group\\n        \\n        newHead = reverse(start, end)\\n        start.next = self.reverseKGroup(end, k)\\n\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391334,
                "title": "0ms-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic ListNode reverseKGroup(ListNode head, int k) {\\n        int count = 0;\\n        ListNode temp = head;\\n        while(temp!=null && count<k) {\\n            temp = temp.next;\\n            count++;\\n        }\\n        if(count<k) return head; \\n        \\n        int n = k;\\n        ListNode tail = head;                \\n        ListNode front = reverse(head,n);\\n        tail.next = reverseKGroup(temp,n);        \\n        return front;\\n    }\\n    \\n    private ListNode reverse(ListNode head,int k){\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next = head;  \\n        while(k--!=0){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic ListNode reverseKGroup(ListNode head, int k) {\\n        int count = 0;\\n        ListNode temp = head;\\n        while(temp!=null && count<k) {\\n            temp = temp.next;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 816529,
                "title": "c-easy-code-with-explanation",
                "content": "Code taken from @luming.zhang.75\\n\\n**Code Explanation:**\\n![image](https://assets.leetcode.com/users/images/5032b423-d4e6-4c75-92d4-4d4a2f289f31_1598617516.880798.png)\\n![image](https://assets.leetcode.com/users/images/f4ef38d4-073c-4dd9-a89f-4c92cb2d0678_1598617518.1261814.png)\\n\\n**Code**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        \\n        ListNode *preheader=new ListNode(-1);\\n        preheader->next=head;\\n        ListNode *pre=preheader,*curr=preheader,*nex;\\n        \\n        //Counting total elements\\n        int nums=0;\\n        while(curr->next!=NULL)\\n            nums++,curr=curr->next;\\n        \\n        while(nums>=k)\\n        {\\n            curr=pre->next;\\n            nex=curr->next;\\n            \\n            //k-1 swaps\\n            for(int i=1;i<k;i++)\\n            {\\n                curr->next=nex->next;\\n                nex->next=pre->next;\\n                pre->next=nex;\\n                nex=curr->next;\\n            }\\n            pre=curr;\\n            nums=nums-k;\\n        }\\n        return preheader->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) \\n    {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        \\n        ListNode *preheader=new ListNode(-1);\\n        preheader->next=head;\\n        ListNode *pre=preheader,*curr=preheader,*nex;\\n        \\n        //Counting total elements\\n        int nums=0;\\n        while(curr->next!=NULL)\\n            nums++,curr=curr->next;\\n        \\n        while(nums>=k)\\n        {\\n            curr=pre->next;\\n            nex=curr->next;\\n            \\n            //k-1 swaps\\n            for(int i=1;i<k;i++)\\n            {\\n                curr->next=nex->next;\\n                nex->next=pre->next;\\n                pre->next=nex;\\n                nex=curr->next;\\n            }\\n            pre=curr;\\n            nums=nums-k;\\n        }\\n        return preheader->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902455,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        var tmp1: ListNode? = head\\n        \\n        for _ in 0..<k - 1 { tmp1 = tmp1?.next }\\n        if tmp1 == nil {\\n            return head\\n        } else {\\n            var current: ListNode?\\n            var tmp2: ListNode?\\n            \\n            for _ in 0..<k {\\n                if current == nil {\\n                    current = head?.next\\n                    head?.next = reverseKGroup(tmp1?.next, k)\\n                    tmp1 = head\\n                } else {\\n                    tmp2 = current?.next\\n                    current?.next = tmp1\\n                    tmp1 = current\\n                    current = tmp2\\n                }\\n            }\\n            return tmp1\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        var tmp1: ListNode? = head\\n        \\n        for _ in 0..<k - 1 { tmp1 = tmp1?.next }\\n        if tmp1 == nil {\\n            return head\\n        } else {\\n            var current: ListNode?\\n            var tmp2: ListNode?\\n            \\n            for _ in 0..<k {\\n                if current == nil {\\n                    current = head?.next\\n                    head?.next = reverseKGroup(tmp1?.next, k)\\n                    tmp1 = head\\n                } else {\\n                    tmp2 = current?.next\\n                    current?.next = tmp1\\n                    tmp1 = current\\n                    current = tmp2\\n                }\\n            }\\n            return tmp1\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909747,
                "title": "solution-using-known-methods-to-solve-for-reverse-linked-list",
                "content": "* Code to solve [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head || !head -> next)\\n            return head;\\n        \\n        ListNode *curr = head, *pre = NULL, *next = NULL;\\n        while(curr){\\n            next = curr -> next;\\n            curr -> next = pre;\\n            pre = curr;\\n            curr = next;\\n        }\\n        \\n        return pre;\\n    }\\n};\\n```\\n* Code to solve [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(m != 1){\\n            head -> next = reverseBetween(head -> next, m - 1, n -1);\\n            return head;\\n        }\\n        else{\\n            ListNode *prev = nullptr, *next = nullptr, *temp = head;\\n            int count = 0;\\n            // Following code is same as Reverse Linked List\\n            while(count++ < n){\\n                next = head -> next;\\n                head -> next = prev;\\n                prev = head;\\n                head = next;\\n            }\\n            temp -> next = head;\\n            return prev;\\n        }\\n    }\\n};\\n```\\n* Code to solve [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(k == 1)\\n            return head;\\n        int n = 0;\\n        ListNode* temp = head;\\n        while(temp){\\n            temp = temp -> next;\\n            ++n;\\n        }\\n\\n        int i = 1;\\n        while(i + k <= n + 1){\\n            head = reverseBetween(head, i , i + k - 1);\\n            i += k;\\n        }\\n        return head;\\n    }\\n    \\n    // Following code is same as Reverse Linked List II\\n    ListNode* reverseBetween(ListNode* head, int m, int n){\\n        if(m != 1){\\n            head -> next = reverseBetween(head -> next, m - 1, n -1);\\n            return head;\\n        }\\n        else{\\n            ListNode *prev = nullptr, *next = nullptr, *temp = head;\\n            int count = 0;\\n            // Following code is same as Reverse Linked List\\n            while(count++ < n){\\n                next = head -> next;\\n                head -> next = prev;\\n                prev = head;\\n                head = next;\\n            }\\n            temp -> next = head;\\n            return prev;\\n        }\\n    }\\n};\\n```\\n\\nAs we can see one method can be used within another method to solve the problem.\\n\\n* Same problem can also be solved using calling the same reverse function till it reaches end or where k is more than end.\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(k == 1)\\n            return head;\\n        ListNode *curr = head, *prev = nullptr, *next = nullptr;\\n        int count = 0;\\n        while(count++ < k && curr){\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        if(next){\\n            int i = 0;\\n            ListNode* temp = next;\\n            while(temp && i < k){\\n                temp = temp -> next;\\n                i++;\\n            }\\n            if(i == k)\\n                head -> next = reverseKGroup(next, k);\\n            else\\n                head -> next = next;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head || !head -> next)\\n            return head;\\n        \\n        ListNode *curr = head, *pre = NULL, *next = NULL;\\n        while(curr){\\n            next = curr -> next;\\n            curr -> next = pre;\\n            pre = curr;\\n            curr = next;\\n        }\\n        \\n        return pre;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(m != 1){\\n            head -> next = reverseBetween(head -> next, m - 1, n -1);\\n            return head;\\n        }\\n        else{\\n            ListNode *prev = nullptr, *next = nullptr, *temp = head;\\n            int count = 0;\\n            // Following code is same as Reverse Linked List\\n            while(count++ < n){\\n                next = head -> next;\\n                head -> next = prev;\\n                prev = head;\\n                head = next;\\n            }\\n            temp -> next = head;\\n            return prev;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(k == 1)\\n            return head;\\n        int n = 0;\\n        ListNode* temp = head;\\n        while(temp){\\n            temp = temp -> next;\\n            ++n;\\n        }\\n\\n        int i = 1;\\n        while(i + k <= n + 1){\\n            head = reverseBetween(head, i , i + k - 1);\\n            i += k;\\n        }\\n        return head;\\n    }\\n    \\n    // Following code is same as Reverse Linked List II\\n    ListNode* reverseBetween(ListNode* head, int m, int n){\\n        if(m != 1){\\n            head -> next = reverseBetween(head -> next, m - 1, n -1);\\n            return head;\\n        }\\n        else{\\n            ListNode *prev = nullptr, *next = nullptr, *temp = head;\\n            int count = 0;\\n            // Following code is same as Reverse Linked List\\n            while(count++ < n){\\n                next = head -> next;\\n                head -> next = prev;\\n                prev = head;\\n                head = next;\\n            }\\n            temp -> next = head;\\n            return prev;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(k == 1)\\n            return head;\\n        ListNode *curr = head, *prev = nullptr, *next = nullptr;\\n        int count = 0;\\n        while(count++ < k && curr){\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        if(next){\\n            int i = 0;\\n            ListNode* temp = next;\\n            while(temp && i < k){\\n                temp = temp -> next;\\n                i++;\\n            }\\n            if(i == k)\\n                head -> next = reverseKGroup(next, k);\\n            else\\n                head -> next = next;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346053,
                "title": "java-solution-0ms-100-with-detailed-comments",
                "content": "**Time Complexity for this solution is O(n) \\nSpace Complexity is O(1)**\\n\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n\\t\\t/**\\n\\t\\t* The first rule is if k = 1 we don\\'t need to swap anything. \\n\\t\\t* That is because the only way is to swap with itself that doesn\\'t make any sense\\n\\t\\t*/\\n        if (k == 1) return head;\\n\\t\\t\\n\\t\\t/**\\n\\t\\t* That is my favourite technique to have the top handler of LinkedList. \\n\\t\\t* It prevents from accidentally losing or damaging the head node somewhere in our code\\n\\t\\t*/\\n        ListNode root = new ListNode(-1);\\n        root.next = head;\\n\\n\\t\\t/**\\n\\t\\t* That approach helps us to know beforehand how many groups are available for reversing. \\n\\t\\t* e.g if head = 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 and k = 3 we will know that only 1 -> 2 -> 3 \\n\\t\\t* and 4 -> 5 -> 6 are groups that need to be swapped and not to touch 7 -> 8\\n\\t\\t*/\\n        int count = countNodes(head);\\n        int reverseCount = count / k;\\n        ListNode node = root;\\n        while (reverseCount > 0) {\\n            node = reverse(node, k);\\n            reverseCount--;\\n        }\\n\\n        return root.next;\\n    }\\n\\n\\t/*\\n\\t* The main job is in that method. Basically what we are doing here is to reverse the LinkedList in a particular range.  \\n\\t* That method takes the handler of the current potential group and returns the new handler for the next group for a further iteration.\\n\\t* e.g if we are given head = 1 -> 2 -> 3 -> 4 -> 5 and k = 2 as I mentioned earlier I add root handler(value = -1) to the head like this: \\n\\t* root => -1 ->  | 1 -> 2 | -> 3 -> 4 -> 5. \\n\\t* So the method will take reference of -1 at first, then reverses 1 and 2 like this \\n\\t* root = -1 -> | 2 -> 1 | -> 3 -> 4 -> 5 and returns the reference of next potential group node = 1 -> | 3 -> 4 | -> 5. \\n\\t* On the second iteration the method does the same. it reverses 3 and 4 like this 1 -> | 4 -> 3 | -> 5 and \\n\\t* returns the reference of next potential group node = 3 -> | 5 . . . |\\n\\t* And this process goes again and again\\n\\t*/\\n    public ListNode reverse(ListNode node, int k) {\\n        ListNode curr = node.next;\\n        ListNode tail = null;\\n        ListNode reversed = null;\\n\\n        while (k > 0 && curr != null) {\\n            ListNode newNode = curr.next;\\n            curr.next = reversed;\\n            reversed = curr;\\n            curr = newNode;\\n            if (reversed.next == null) tail = reversed;\\n\\n            k--;\\n        }\\n\\n        tail.next = curr;\\n        node.next = reversed;\\n\\n        return tail;\\n    }\\n\\n    public int countNodes(ListNode node) {\\n        int count = 0;\\n        while (node != null) {\\n            count++;\\n            node = node.next;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n\\t\\t/**\\n\\t\\t* The first rule is if k = 1 we don\\'t need to swap anything. \\n\\t\\t* That is because the only way is to swap with itself that doesn\\'t make any sense\\n\\t\\t*/\\n        if (k == 1) return head;\\n\\t\\t\\n\\t\\t/**\\n\\t\\t* That is my favourite technique to have the top handler of LinkedList. \\n\\t\\t* It prevents from accidentally losing or damaging the head node somewhere in our code\\n\\t\\t*/\\n        ListNode root = new ListNode(-1);\\n        root.next = head;\\n\\n\\t\\t/**\\n\\t\\t* That approach helps us to know beforehand how many groups are available for reversing. \\n\\t\\t* e.g if head = 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 and k = 3 we will know that only 1 -> 2 -> 3 \\n\\t\\t* and 4 -> 5 -> 6 are groups that need to be swapped and not to touch 7 -> 8\\n\\t\\t*/\\n        int count = countNodes(head);\\n        int reverseCount = count / k;\\n        ListNode node = root;\\n        while (reverseCount > 0) {\\n            node = reverse(node, k);\\n            reverseCount--;\\n        }\\n\\n        return root.next;\\n    }\\n\\n\\t/*\\n\\t* The main job is in that method. Basically what we are doing here is to reverse the LinkedList in a particular range.  \\n\\t* That method takes the handler of the current potential group and returns the new handler for the next group for a further iteration.\\n\\t* e.g if we are given head = 1 -> 2 -> 3 -> 4 -> 5 and k = 2 as I mentioned earlier I add root handler(value = -1) to the head like this: \\n\\t* root => -1 ->  | 1 -> 2 | -> 3 -> 4 -> 5. \\n\\t* So the method will take reference of -1 at first, then reverses 1 and 2 like this \\n\\t* root = -1 -> | 2 -> 1 | -> 3 -> 4 -> 5 and returns the reference of next potential group node = 1 -> | 3 -> 4 | -> 5. \\n\\t* On the second iteration the method does the same. it reverses 3 and 4 like this 1 -> | 4 -> 3 | -> 5 and \\n\\t* returns the reference of next potential group node = 3 -> | 5 . . . |\\n\\t* And this process goes again and again\\n\\t*/\\n    public ListNode reverse(ListNode node, int k) {\\n        ListNode curr = node.next;\\n        ListNode tail = null;\\n        ListNode reversed = null;\\n\\n        while (k > 0 && curr != null) {\\n            ListNode newNode = curr.next;\\n            curr.next = reversed;\\n            reversed = curr;\\n            curr = newNode;\\n            if (reversed.next == null) tail = reversed;\\n\\n            k--;\\n        }\\n\\n        tail.next = curr;\\n        node.next = reversed;\\n\\n        return tail;\\n    }\\n\\n    public int countNodes(ListNode node) {\\n        int count = 0;\\n        while (node != null) {\\n            count++;\\n            node = node.next;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11602,
                "title": "4ms-c-solution-o-n-time-and-o-1-space",
                "content": "Use a scout pointer to scan ahead. Once scout has passed k nodes, reverse this chain of k nodes just passed by scout. Initially, both first and current point to the beginning node of this chain. As each node in the chain following current is placed to the beginning of the chain, first is adjusted to always point to the beginning of the chain, while current moves down the chain (since nodes are placed before it). (k-1) nodes need to be moved during each chain reversing. The reversed chain is connected to the previous node (which always points to the one node before the just reversed chain). current (which points to the end of the chain now) is moved forward to the place of scout, count is reset to 0, and scout can now resume scanning forward. : )\\n\\n    struct ListNode* reverseKGroup(struct ListNode* head, int k) {\\n        \\n        struct ListNode *current, *previous, *scout;\\n        int count;\\n        \\n        scout = current = head;\\n        previous = NULL;\\n        count = 0;\\n    \\n        while (scout) {\\n            \\n            ++count;\\n    \\n            if (k > 1 && count == k) {\\n                \\n                scout = scout->next;\\n                struct ListNode *first, *following;\\n                first = current;\\n                \\n                while (count-- > 1) {\\n                    \\n                    following = current->next;\\n                    current->next = following->next;\\n                    following->next = first;\\n                    first = following;\\n                }\\n                \\n                if (previous)\\n                    previous->next = first;\\n                else\\n                    head = first;\\n                    \\n                previous = current;\\n                current = scout;\\n                count = 0;\\n            }\\n            else\\n                scout = scout->next;\\n        }\\n        \\n        return head;\\n    }",
                "solutionTags": [],
                "code": "Use a scout pointer to scan ahead. Once scout has passed k nodes, reverse this chain of k nodes just passed by scout. Initially, both first and current point to the beginning node of this chain. As each node in the chain following current is placed to the beginning of the chain, first is adjusted to always point to the beginning of the chain, while current moves down the chain (since nodes are placed before it). (k-1) nodes need to be moved during each chain reversing. The reversed chain is connected to the previous node (which always points to the one node before the just reversed chain). current (which points to the end of the chain now) is moved forward to the place of scout, count is reset to 0, and scout can now resume scanning forward. : )\\n\\n    struct ListNode* reverseKGroup(struct ListNode* head, int k) {\\n        \\n        struct ListNode *current, *previous, *scout;\\n        int count;\\n        \\n        scout = current = head;\\n        previous = NULL;\\n        count = 0;\\n    \\n        while (scout) {\\n            \\n            ++count;\\n    \\n            if (k > 1 && count == k) {\\n                \\n                scout = scout->next;\\n                struct ListNode *first, *following;\\n                first = current;\\n                \\n                while (count-- > 1) {\\n                    \\n                    following = current->next;\\n                    current->next = following->next;\\n                    following->next = first;\\n                    first = following;\\n                }\\n                \\n                if (previous)\\n                    previous->next = first;\\n                else\\n                    head = first;\\n                    \\n                previous = current;\\n                current = scout;\\n                count = 0;\\n            }\\n            else\\n                scout = scout->next;\\n        }\\n        \\n        return head;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2026441,
                "title": "python-simple-o-n-time-o-1-space-iterative-solution",
                "content": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        cur = head\\n        count = 0\\n        while cur:\\n            count += 1\\n            cur = cur.next\\n        \\n        pre = dummy\\n        while count >= k:\\n            cur = pre.next\\n            nex = cur.next\\n            for i in range(k-1):\\n                cur.next = nex.next\\n                nex.next = pre.next\\n                pre.next = nex\\n                nex = cur.next\\n            pre = cur\\n            count -= k\\n            \\n        return dummy.next\\n\\n# Time: O(N)\\n# Space: O(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        cur = head\\n        count = 0\\n        while cur:\\n            count += 1\\n            cur = cur.next\\n        \\n        pre = dummy\\n        while count >= k:\\n            cur = pre.next\\n            nex = cur.next\\n            for i in range(k-1):\\n                cur.next = nex.next\\n                nex.next = pre.next\\n                pre.next = nex\\n                nex = cur.next\\n            pre = cur\\n            count -= k\\n            \\n        return dummy.next\\n\\n# Time: O(N)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187652,
                "title": "javascript-2-steps-reverse-linked-list-attach",
                "content": "The first part of this problem `reverse()` can be done using pretty much the [[Easy] Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/) algorithm. But instead of reversing it all, this time we\\'re just interested in K length, so `reverse(head, length)`.\\n\\nThe second part of this problem consists in iterating (making sure K group can be done) and attaching the reversed parts.\\n\\n`[reversedPart] + [reversedPart] + ...`\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nvar reverseKGroup = function(head, k) {\\n    const root = new ListNode();\\n    root.next = head;\\n    \\n    let prev = root; // prev.next --> start of group\\n    let i = 0;\\n    while (i < k && head) { // head --> start of next group\\n        head = head.next;\\n        i += 1;\\n        if (i === k) {\\n            const [reversedHead, reversedTail] = reverse(prev.next, k);\\n            prev.next = reversedHead;\\n            reversedTail.next = head;\\n            prev = reversedTail;\\n            i = 0;\\n        }\\n    }\\n    \\n    return root.next;\\n};\\n\\nfunction reverse(head, length) {\\n    const tail = head;\\n    let prev = null;\\n    while (length > 0) {\\n        const next = head.next;\\n        head.next = prev;\\n        prev = head;\\n        head = next;\\n        length -= 1;\\n    }\\n    return [prev, tail];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nvar reverseKGroup = function(head, k) {\\n    const root = new ListNode();\\n    root.next = head;\\n    \\n    let prev = root; // prev.next --> start of group\\n    let i = 0;\\n    while (i < k && head) { // head --> start of next group\\n        head = head.next;\\n        i += 1;\\n        if (i === k) {\\n            const [reversedHead, reversedTail] = reverse(prev.next, k);\\n            prev.next = reversedHead;\\n            reversedTail.next = head;\\n            prev = reversedTail;\\n            i = 0;\\n        }\\n    }\\n    \\n    return root.next;\\n};\\n\\nfunction reverse(head, length) {\\n    const tail = head;\\n    let prev = null;\\n    while (length > 0) {\\n        const next = head.next;\\n        head.next = prev;\\n        prev = head;\\n        head = next;\\n        length -= 1;\\n    }\\n    return [prev, tail];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3330501,
                "title": "c-recursive-easy-to-understand-short-sweet-code",
                "content": "````\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int x = k;\\n        ListNode* p = head;\\n        while(x>0&&p){\\n            p = p->next;\\n            x--;\\n        }\\n        if(x==0){\\n            ListNode* pre = NULL,*next = NULL,*curr = head;\\n            while(curr != p){\\n                next = curr->next;\\n                curr->next = pre;\\n                pre = curr;\\n                curr = next;\\n            }\\n            head->next = reverseKGroup(p,k);\\n            return head = pre;\\n        }else{\\n            return head;\\n        }\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int x = k;\\n        ListNode* p = head;\\n        while(x>0&&p){\\n            p = p->next;\\n            x--;\\n        }\\n        if(x==0){\\n            ListNode* pre = NULL,*next = NULL,*curr = head;\\n            while(curr != p){\\n                next = curr->next;\\n                curr->next = pre;\\n                pre = curr;\\n                curr = next;\\n            }\\n            head->next = reverseKGroup(p,k);\\n            return head = pre;\\n        }else{\\n            return head;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083185,
                "title": "c-iterative-with-comments-and-images-readable-code",
                "content": "\\n![image](https://assets.leetcode.com/users/images/419ed926-0459-4594-a19f-451d5b313576_1653739309.9063733.jpeg)\\n![image](https://assets.leetcode.com/users/images/7fab7e72-8191-4dc5-87f5-810742bf1b63_1653739324.674521.jpeg)\\n![image](https://assets.leetcode.com/users/images/4f618fa2-25f3-4257-a778-8781a8fea0ba_1653739334.9270487.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int lengthofll(ListNode* head){\\n        int cnt=0;\\n        while(head != nullptr){\\n            cnt++;\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || !head->next || k == 1) return head; \\n        int n = lengthofll(head);\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* pre = dummy;\\n        ListNode* curr;\\n        ListNode* nex;\\n        while(n >= k){\\n            curr = pre->next;\\n            nex = curr->next;\\n            for(int i=1;i < k;i++){\\n                curr->next = nex->next;\\n                nex->next = pre->next;\\n                pre->next = nex;\\n                nex = curr->next;\\n            }\\n            pre = curr;\\n            n = n-k;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lengthofll(ListNode* head){\\n        int cnt=0;\\n        while(head != nullptr){\\n            cnt++;\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || !head->next || k == 1) return head; \\n        int n = lengthofll(head);\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* pre = dummy;\\n        ListNode* curr;\\n        ListNode* nex;\\n        while(n >= k){\\n            curr = pre->next;\\n            nex = curr->next;\\n            for(int i=1;i < k;i++){\\n                curr->next = nex->next;\\n                nex->next = pre->next;\\n                pre->next = nex;\\n                nex = curr->next;\\n            }\\n            pre = curr;\\n            n = n-k;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745897,
                "title": "easy-12-line-solution",
                "content": "**Please upvote if you find it helpfull\\uD83D\\uDE4F**\\n```\\n public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode cur = head, temp = head, prev=null;\\n        for(int i=0;i<k;i++,  temp=temp.next){\\n            //temp=temp.next; \\n            if(temp==null)\\n                return head;   \\n        }\\n        for(int i=0;i<k;i++){\\n            temp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = temp;\\n        }\\n        head.next = reverseKGroup(cur, k);\\n        return prev;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode cur = head, temp = head, prev=null;\\n        for(int i=0;i<k;i++,  temp=temp.next){\\n            //temp=temp.next; \\n            if(temp==null)\\n                return head;   \\n        }\\n        for(int i=0;i<k;i++){\\n            temp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = temp;\\n        }\\n        head.next = reverseKGroup(cur, k);\\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1508396,
                "title": "javascript-o-n-easy-solution-with-stack",
                "content": "```\\nvar reverseKGroup = function(head, k) {\\n    let stack = [];\\n    let newNode = new ListNode(-1);\\n    let temp = newNode;\\n    \\n    while(head) {\\n        for(let i = 0; i < k && head; i++) {\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        \\n        if(stack.length === k) {\\n            while(stack.length > 0) {\\n                temp.next = stack.pop();\\n                temp = temp.next;\\n            }\\n            temp.next = head;\\n        }\\n    }\\n    return newNode.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar reverseKGroup = function(head, k) {\\n    let stack = [];\\n    let newNode = new ListNode(-1);\\n    let temp = newNode;\\n    \\n    while(head) {\\n        for(let i = 0; i < k && head; i++) {\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        \\n        if(stack.length === k) {\\n            while(stack.length > 0) {\\n                temp.next = stack.pop();\\n                temp = temp.next;\\n            }\\n            temp.next = head;\\n        }\\n    }\\n    return newNode.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113903,
                "title": "java-simple-and-easy-solution-0-ms-faster-than-100-00-space-o-1-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode mainCurr = head;\\n        \\n\\t\\t/*\\n            Intuition \\n            a. if K or more nodes available in given list\\n                 1. reverse first k node,\\n                 2. remove from the main list\\n                 3. append in the new list\\n                 4. move main pointer to next group first node\\n\\n            b. if NOT available \\n                 1. just append the Remaining nodes in new list\\n        \\n        */\\n            \\n        \\n        \\n        //dummy nodes, places holder of head \\n        //reverse linked list\\n        ListNode dummyNode = new ListNode();\\n        ListNode newCurr = dummyNode;\\n        \\n        while(mainCurr != null){\\n            ListNode curr = mainCurr;\\n            \\n            //get next group first node\\n            int i = k;\\n            int availableNode = 0;\\n            while(i --> 0 && curr != null){\\n                curr = curr.next;\\n                availableNode++;\\n            }\\n            ListNode nextGroupFirstNode = curr;\\n            \\n            //if Available node is K, then reverse and add in newNode list\\n            //otherwise just append remaining node\\n            if(availableNode == k){\\n                newCurr.next = getReverseFirstKNodes(mainCurr, k);\\n                newCurr = mainCurr;\\n            }else{\\n                newCurr.next = mainCurr;\\n            }\\n            \\n            //move to next group\\n            mainCurr = nextGroupFirstNode;\\n        }\\n        \\n        return dummyNode.next;\\n    }\\n    \\n\\n    //reverse K first node, and \\n    //return the head of K node list\\n    private ListNode getReverseFirstKNodes(ListNode node, int k){\\n        ListNode prev = null;\\n        ListNode curr = node;\\n        \\n        while(curr != null && k --> 0){\\n            ListNode next = curr.next;\\n            \\n            curr.next = prev;\\n            prev = curr;\\n            \\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode mainCurr = head;\\n        \\n\\t\\t/*\\n            Intuition \\n            a. if K or more nodes available in given list\\n                 1. reverse first k node,\\n                 2. remove from the main list\\n                 3. append in the new list\\n                 4. move main pointer to next group first node\\n\\n            b. if NOT available \\n                 1. just append the Remaining nodes in new list\\n        \\n        */\\n            \\n        \\n        \\n        //dummy nodes, places holder of head \\n        //reverse linked list\\n        ListNode dummyNode = new ListNode();\\n        ListNode newCurr = dummyNode;\\n        \\n        while(mainCurr != null){\\n            ListNode curr = mainCurr;\\n            \\n            //get next group first node\\n            int i = k;\\n            int availableNode = 0;\\n            while(i --> 0 && curr != null){\\n                curr = curr.next;\\n                availableNode++;\\n            }\\n            ListNode nextGroupFirstNode = curr;\\n            \\n            //if Available node is K, then reverse and add in newNode list\\n            //otherwise just append remaining node\\n            if(availableNode == k){\\n                newCurr.next = getReverseFirstKNodes(mainCurr, k);\\n                newCurr = mainCurr;\\n            }else{\\n                newCurr.next = mainCurr;\\n            }\\n            \\n            //move to next group\\n            mainCurr = nextGroupFirstNode;\\n        }\\n        \\n        return dummyNode.next;\\n    }\\n    \\n\\n    //reverse K first node, and \\n    //return the head of K node list\\n    private ListNode getReverseFirstKNodes(ListNode node, int k){\\n        ListNode prev = null;\\n        ListNode curr = node;\\n        \\n        while(curr != null && k --> 0){\\n            ListNode next = curr.next;\\n            \\n            curr.next = prev;\\n            prev = curr;\\n            \\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515740,
                "title": "easy-to-understand-python-solution-with-comments-52ms-o-1-space",
                "content": "The basic idea is rearranging the nodes in a new list. I use `p` to iterate through the original list, while putting all the nodes behind a new starting node `r`, and `e` is used to store the end of the previous group, where new nodes of the next group will be inserted.\\n```python\\ndef reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n    p = head\\n    e = r = ListNode(None)\\n\\n\\t# find out the length of the list\\n    n = 0\\n    while head:\\n        head = head.next\\n        n += 1\\n\\n\\t# rearrange the nodes\\n    for i in range(n // k):    # for every group\\n        s = p                  # record the first node of a group that will soon become the last node of the reversed group\\n        for _ in range(k):     # for every node in a group\\n            t = p.next\\n            p.next = e.next    # put the current node right before the head of the reversed group\\n            e.next = p         # register p as the head of the reversed group\\n            p = t              # visit the next node in the original list\\n        e = s                  # update the end of the reversed group\\n    e.next = p                 # append the tail to the end\\n    return r.next\\n```\\nVote up if find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\ndef reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n    p = head\\n    e = r = ListNode(None)\\n\\n\\t# find out the length of the list\\n    n = 0\\n    while head:\\n        head = head.next\\n        n += 1\\n\\n\\t# rearrange the nodes\\n    for i in range(n // k):    # for every group\\n        s = p                  # record the first node of a group that will soon become the last node of the reversed group\\n        for _ in range(k):     # for every node in a group\\n            t = p.next\\n            p.next = e.next    # put the current node right before the head of the reversed group\\n            e.next = p         # register p as the head of the reversed group\\n            p = t              # visit the next node in the original list\\n        e = s                  # update the end of the reversed group\\n    e.next = p                 # append the tail to the end\\n    return r.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 11486,
                "title": "beautiful-javascript-code",
                "content": "```\\nfunction reverseKGroup(head, k) {\\n    const stack = [], preHead = new ListNode();\\n    preHead.next = head;\\n    let lastTail = preHead;\\n    while (head) {\\n        for (let i = 0; i < k && head; i++) {\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        if (stack.length === k) {\\n            while (stack.length > 0) {\\n                lastTail.next = stack.pop();\\n                lastTail = lastTail.next;\\n            }\\n            lastTail.next = head;\\n        }\\n    }\\n\\n    return preHead.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction reverseKGroup(head, k) {\\n    const stack = [], preHead = new ListNode();\\n    preHead.next = head;\\n    let lastTail = preHead;\\n    while (head) {\\n        for (let i = 0; i < k && head; i++) {\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        if (stack.length === k) {\\n            while (stack.length > 0) {\\n                lastTail.next = stack.pop();\\n                lastTail = lastTail.next;\\n            }\\n            lastTail.next = head;\\n        }\\n    }\\n\\n    return preHead.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3236987,
                "title": "c-recursive-easy-10-liner-unique-and-diffrent-approach",
                "content": "# Intuition\\n**Simple** and **easy Brute force** intuition(read Approach you will get to know why it is **EASY** and **SIMPLE**).\\n\\n# Approach\\n- Take a var and count if there are k nodes left in list to be reversed.\\n-  If there were no k nodes left So  we will return the normal list without reversing according to the question.\\n- If at least K nodes Left it means k nodes should be reversed So the normal Recursive reversing process(rest of the code) will be executed.\\n- We will reverse the list till next k nodes.\\n- We will have to attach next upcoming list to our current reversed list so we will get to the tail of current reversed list and attach it to the recursively reversed rest of  the list(you will unterstand it properly when u see the code).\\n- \\n\\n\\n# Complexity\\n- Time complexity: **O(N)**\\n   - Traversing to N nodes that\\'s why N Time Complexity.\\n\\n- Space complexity: **Recursion Stack**\\n\\n\\n# Code\\n### swipe up a bit for clean code without comments\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* curr, int k) {\\n        int t=0;\\n        ListNode* prev=nullptr, *check=curr;\\n        while(t<k && check!=nullptr) check=check->next,t++;   //checking if there are k nodes left to be reversed (using loop)\\n        if(t<k) return curr;  // if there are less than k nodes we need not reverse so return the normal List\\n        while(t-- && curr!=nullptr){   // reversing loop\\n            ListNode* next= curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        ListNode* tail=prev;  //iterating till tail of the current reversed List\\n        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;  //  so that we can attach it to  recursively reversed upcomming List\\n        tail->next = curr ? reverseKGroup(curr,k) : nullptr;  //attacing the next upcomming reverse list the current reversed List\\n        return prev;\\n    }\\n};\\n```\\n# C++ Solution\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* curr, int k) {\\n        int t=0;\\n        ListNode* prev=nullptr, *check=curr;\\n        while(t<k && check!=nullptr) check=check->next,t++;\\n        if(t<k) return curr;\\n        while(t-- && curr!=nullptr){\\n            ListNode* next= curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        ListNode* tail=prev;\\n        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;\\n        tail->next = curr ? reverseKGroup(curr,k) : nullptr;\\n        return prev;\\n    }\\n};\\n```\\n## Thanks for the Upvote \\uD83D\\uDE07",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* curr, int k) {\\n        int t=0;\\n        ListNode* prev=nullptr, *check=curr;\\n        while(t<k && check!=nullptr) check=check->next,t++;   //checking if there are k nodes left to be reversed (using loop)\\n        if(t<k) return curr;  // if there are less than k nodes we need not reverse so return the normal List\\n        while(t-- && curr!=nullptr){   // reversing loop\\n            ListNode* next= curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        ListNode* tail=prev;  //iterating till tail of the current reversed List\\n        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;  //  so that we can attach it to  recursively reversed upcomming List\\n        tail->next = curr ? reverseKGroup(curr,k) : nullptr;  //attacing the next upcomming reverse list the current reversed List\\n        return prev;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* curr, int k) {\\n        int t=0;\\n        ListNode* prev=nullptr, *check=curr;\\n        while(t<k && check!=nullptr) check=check->next,t++;\\n        if(t<k) return curr;\\n        while(t-- && curr!=nullptr){\\n            ListNode* next= curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        ListNode* tail=prev;\\n        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;\\n        tail->next = curr ? reverseKGroup(curr,k) : nullptr;\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789332,
                "title": "easy-c-recursive-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* curr = head;\\n        ListNode* nodenext=NULL;\\n        ListNode* prevnode = NULL;\\n        int count=0;\\n        while(curr!=NULL && count<k){\\n            nodenext = curr->next;\\n            curr->next = prevnode;\\n            prevnode = curr;\\n            curr = nodenext;\\n            count++;\\n        }\\n        if(count!=k){\\n            ListNode* t = prevnode;\\n            prevnode = NULL;\\n            while(t!=NULL){\\n                nodenext = t->next;\\n                t->next = prevnode;\\n                prevnode = t;\\n                t = nodenext;\\n            }\\n            return prevnode;\\n        }\\n        if(nodenext!=NULL){\\n            ListNode* rest_head = reverseKGroup(nodenext , k);\\n            head->next = rest_head;\\n        }\\n        return prevnode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* curr = head;\\n        ListNode* nodenext=NULL;\\n        ListNode* prevnode = NULL;\\n        int count=0;\\n        while(curr!=NULL && count<k){\\n            nodenext = curr->next;\\n            curr->next = prevnode;\\n            prevnode = curr;\\n            curr = nodenext;\\n            count++;\\n        }\\n        if(count!=k){\\n            ListNode* t = prevnode;\\n            prevnode = NULL;\\n            while(t!=NULL){\\n                nodenext = t->next;\\n                t->next = prevnode;\\n                prevnode = t;\\n                t = nodenext;\\n            }\\n            return prevnode;\\n        }\\n        if(nodenext!=NULL){\\n            ListNode* rest_head = reverseKGroup(nodenext , k);\\n            head->next = rest_head;\\n        }\\n        return prevnode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188167,
                "title": "c-recursive-solution-12ms-only-13-line-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n  ListNode *reverseKGroup(ListNode *head, int k) {\\n    ListNode *post = head; // indicate the latest one to be connected\\n    for (int i = 0; i < k; i++) {\\n      if (!post) return head;\\n      post = post->next;\\n    }\\n    ListNode *last = head; // current the head, but the last of a group after reversion\\n    for (int i = 0; i < k; i++) {\\n      ListNode *temp = head->next;\\n      head->next = post;\\n      post = head;\\n      head = temp;\\n    }\\n    last->next = reverseKGroup(last->next, k);\\n    return post;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  ListNode *reverseKGroup(ListNode *head, int k) {\\n    ListNode *post = head; // indicate the latest one to be connected\\n    for (int i = 0; i < k; i++) {\\n      if (!post) return head;\\n      post = post->next;\\n    }\\n    ListNode *last = head; // current the head, but the last of a group after reversion\\n    for (int i = 0; i < k; i++) {\\n      ListNode *temp = head->next;\\n      head->next = post;\\n      post = head;\\n      head = temp;\\n    }\\n    last->next = reverseKGroup(last->next, k);\\n    return post;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11498,
                "title": "10-lines-short-easy-java-code-with-comments",
                "content": "    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode cur = head, tmp = head, prev = null;\\n        for(int i = 0 ; i < k; i++, tmp = tmp.next) if(tmp == null) return head;  // check if there is enough k elements for reverse in current group\\n        for(int i = 0; i < k; i++){ // reverse k elements in current group\\n            tmp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        head.next = reverseKGroup(cur, k); // connect the real tail of current reversed group with the real head of remaining reversed group\\n        return prev; // return the real tail of current reversed group\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode cur = head, tmp = head, prev = null;\\n        for(int i = 0 ; i < k; i++, tmp = tmp.next) if(tmp == null) return head;  // check if there is enough k elements for reverse in current group\\n        for(int i = 0; i < k; i++){ // reverse k elements in current group\\n            tmp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        head.next = reverseKGroup(cur, k); // connect the real tail of current reversed group with the real head of remaining reversed group\\n        return prev; // return the real tail of current reversed group\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3181828,
                "title": "tc-o-n-sc-o-n-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n    if(head==NULL)\\n        return NULL;\\n    \\n    //reverse 1st k nodes\\n    ListNode* forward=NULL;\\n    ListNode* prev=NULL;\\n    ListNode* curr=head;\\n    int cnt=0;\\n    \\n    ListNode* cursor = head;\\n    for(int i = 0; i < k; i++){\\n         if(cursor == nullptr) \\n             return head;\\n         cursor = cursor->next;\\n    }\\n    while(curr!=NULL && cnt<k ){\\n        forward=curr->next;\\n        curr->next=prev;\\n        prev=curr;\\n        curr=forward;\\n        cnt++;\\n    }\\n    \\n    head->next=reverseKGroup(forward,k);\\n    return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n    if(head==NULL)\\n        return NULL;\\n    \\n    //reverse 1st k nodes\\n    ListNode* forward=NULL;\\n    ListNode* prev=NULL;\\n    ListNode* curr=head;\\n    int cnt=0;\\n    \\n    ListNode* cursor = head;\\n    for(int i = 0; i < k; i++){\\n         if(cursor == nullptr) \\n             return head;\\n         cursor = cursor->next;\\n    }\\n    while(curr!=NULL && cnt<k ){\\n        forward=curr->next;\\n        curr->next=prev;\\n        prev=curr;\\n        curr=forward;\\n        cnt++;\\n    }\\n    \\n    head->next=reverseKGroup(forward,k);\\n    return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714698,
                "title": "c-solution-using-recursion-easy-0ms",
                "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n \\n //please UPVOTE\\nclass Solution {\\npublic:\\n    int getllsize(ListNode* head){\\n        ListNode* temp=head;\\n        int c=0;\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            c++;\\n        }\\n        return c;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int n =getllsize(head);\\n        if(head==NULL || n < k)return head;\\n     ListNode *prev=NULL;\\n      ListNode *curr=head;\\n      ListNode *forw=NULL;\\n    int c=0;\\n    while(curr!=NULL && c!=k ){\\n      forw = curr -> next;\\n            curr -> next=prev;\\n            prev=curr;\\n            curr=forw;\\n        c++;\\n    }\\n    head->next=reverseKGroup(curr,k);\\n    \\n    \\n    \\n    return prev;\\n    }\\n\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int getllsize(ListNode* head){\\n        ListNode* temp=head;\\n        int c=0;\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2245982,
                "title": "iterative-time-complexity-space-complexity-explanation",
                "content": "Time Complexity - Iterating over all the nodes once takes O(N) time.\\nSpace Complexity - Since we are not using any extra space, space complexity is O(1).\\nExplanation -\\nA dummy node is created which points to the initial head of the LL.\\nWe create currNode, nextNode and prevNode - all of which are point to the same address as dummy.\\nThen we calculate the length of the LL and store it in a variable called count.\\n\\nWe have a WHILE LOOP running while count >= k.\\nAt the start of every group of k size, we need to have currNode set as the 1st node and nextNode as the second node.\\nThen we run a FOR LOOP k times in order to reverse the links for the group of size k  (links of k - 1 nodes are reversed as the first node does not need reversal).\\nWhen the for loop ends - prevNode is a pointer to the last node in the group of size k, currNode->next stores the address which helps us travel to the next set of nodes.\\nWe now change prevNode to point to currNode - because it is necessary to store the address that will help us travel to next set of nodes.\\nThus, upon the next iteration of the while loop, we can use prevNode->next to set new values of currNode and nextNode.\\n\\nAt the end of the while loop, we return our new head node which is pointed to by dummy->next.\\nHOW? Initially prevNode and dummy are pointing to the same address, hence any change makes to prevNode reflects in dummy. \\nBut after reversing the first group of size k, prevNode points to a completely different address and hence dummy->next manages to save the address of the new head node.\\n\\n```\\n\\tclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || k == 1) return head;\\n        ListNode *dummy = new ListNode(0, head); // Dummy node with value 0 pointing to the initial head of the given LL\\n        ListNode *currNode = dummy, *nextNode = dummy, *prevNode = dummy;\\n        \\n        // Calculate length of LL\\n        int count = -1; // The initial value of count is taken as -1 because the dummy node shouldn\\'t be counted\\n        while(currNode){\\n            count++;\\n            currNode = currNode->next;\\n        }\\n        \\n        // Iterating till we have groups of size >= k\\n        while(count >= k){\\n            // For every group of size k, we need to make sure that currNode is 1st node and nextNode is 2nd node\\n            currNode = prevNode->next; // prevNode is the previous node of the previous group and points to the first node of the new group\\n            nextNode = currNode->next;\\n            \\n            // Reverse k - 1 nodes\\n            for(int i = 1; i < k; i++){\\n                currNode->next = nextNode->next; // currNode keeps track of where we can shift nextNode after a single reversal\\n                nextNode->next = prevNode->next; // Reversing the link\\n                prevNode->next = nextNode; // prevNode->next stores the address where we can shift currNode (current nextNode is going to be our next currNode)\\n                nextNode = currNode->next; // currNode->next indicates the new address of nextNode (nextNode->next cannot be used as it has been reversed)\\n            }\\n            prevNode = currNode; // prevNode should stand at the last node of the previous reversed group of size k\\n            count -= k; // Reversal has been successful for k nodes, so we reduce k from count\\n        }\\n        return dummy->next; // dummy->next points to the last node of the first reversed group of size k\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || k == 1) return head;\\n        ListNode *dummy = new ListNode(0, head); // Dummy node with value 0 pointing to the initial head of the given LL\\n        ListNode *currNode = dummy, *nextNode = dummy, *prevNode = dummy;\\n        \\n        // Calculate length of LL\\n        int count = -1; // The initial value of count is taken as -1 because the dummy node shouldn\\'t be counted\\n        while(currNode){\\n            count++;\\n            currNode = currNode->next;\\n        }\\n        \\n        // Iterating till we have groups of size >= k\\n        while(count >= k){\\n            // For every group of size k, we need to make sure that currNode is 1st node and nextNode is 2nd node\\n            currNode = prevNode->next; // prevNode is the previous node of the previous group and points to the first node of the new group\\n            nextNode = currNode->next;\\n            \\n            // Reverse k - 1 nodes\\n            for(int i = 1; i < k; i++){\\n                currNode->next = nextNode->next; // currNode keeps track of where we can shift nextNode after a single reversal\\n                nextNode->next = prevNode->next; // Reversing the link\\n                prevNode->next = nextNode; // prevNode->next stores the address where we can shift currNode (current nextNode is going to be our next currNode)\\n                nextNode = currNode->next; // currNode->next indicates the new address of nextNode (nextNode->next cannot be used as it has been reversed)\\n            }\\n            prevNode = currNode; // prevNode should stand at the last node of the previous reversed group of size k\\n            count -= k; // Reversal has been successful for k nodes, so we reduce k from count\\n        }\\n        return dummy->next; // dummy->next points to the last node of the first reversed group of size k\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054341,
                "title": "easy-recursion-understanding-ii-c",
                "content": "We will use the intuition behind Reverse Linked List.Only difference is we will reverse Nodes in K group. So we will seggregate the Linked List into size K and let recursion handle the rest.\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //base condition\\n        //to not reverse the last group which is less than k\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(temp==nullptr)\\n                return head;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        //reverse first k nodes\\n        ListNode* prev=nullptr;\\n        ListNode* curr=head;\\n        ListNode* next=nullptr;\\n        int count=0;\\n        \\n        while(curr && count<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            count++;\\n        }\\n        \\n        //recursion will take care the rest\\n        if(next){\\n            head->next = reverseKGroup(next,k);\\n        }\\n        \\n        //return head of reversed list i.e., prev\\n        return prev;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE** *if you liked the approach*",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //base condition\\n        //to not reverse the last group which is less than k\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(temp==nullptr)\\n                return head;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        //reverse first k nodes\\n        ListNode* prev=nullptr;\\n        ListNode* curr=head;\\n        ListNode* next=nullptr;\\n        int count=0;\\n        \\n        while(curr && count<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            count++;\\n        }\\n        \\n        //recursion will take care the rest\\n        if(next){\\n            head->next = reverseKGroup(next,k);\\n        }\\n        \\n        //return head of reversed list i.e., prev\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621752,
                "title": "13-line-easy-to-understand-code-using-vectors",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        vector<int> order;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            order.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        for(int index = 0 ; index+ k <= order.size() ; index += k)\\n            reverse(order.begin() + index , order.begin() + index + k);\\n        \\n        int index = 0;\\n        temp = head;\\n        \\n        while(temp != NULL){\\n            temp->val = order[index++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        vector<int> order;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            order.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        for(int index = 0 ; index+ k <= order.size() ; index += k)\\n            reverse(order.begin() + index , order.begin() + index + k);\\n        \\n        int index = 0;\\n        temp = head;\\n        \\n        while(temp != NULL){\\n            temp->val = order[index++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346680,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n```\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n\\tnode, cnt := head, 0\\n\\tfor cnt < k {\\n\\t\\tif node == nil {\\n\\t\\t\\treturn head\\n\\t\\t}\\n\\t\\tnode = node.Next\\n\\t\\tcnt++\\n\\t}\\n\\n\\tprev := reverseKGroup(node, k)\\n\\tfor cnt > 0 {\\n\\t\\tnext := head.Next\\n\\t\\thead.Next = prev\\n\\t\\tprev = head\\n\\t\\thead = next\\n\\t\\tcnt--\\n\\t}\\n\\n\\treturn prev\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n\\tnode, cnt := head, 0\\n\\tfor cnt < k {\\n\\t\\tif node == nil {\\n\\t\\t\\treturn head\\n\\t\\t}\\n\\t\\tnode = node.Next\\n\\t\\tcnt++\\n\\t}\\n\\n\\tprev := reverseKGroup(node, k)\\n\\tfor cnt > 0 {\\n\\t\\tnext := head.Next\\n\\t\\thead.Next = prev\\n\\t\\tprev = head\\n\\t\\thead = next\\n\\t\\tcnt--\\n\\t}\\n\\n\\treturn prev\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11606,
                "title": "java-recursive-and-iterative-solutions",
                "content": "       \\n     // recursively \\n    public ListNode reverseKGroup1(ListNode head, int k) {\\n        int l = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            l++;\\n            cur = cur.next;\\n        }\\n        if (k > l) {\\n            return head;\\n        }\\n        cur = head;\\n        ListNode node = null;\\n        for (int i = 0; i < k; i++) {\\n            ListNode nxt = cur.next;\\n            cur.next = node;\\n            node = cur;\\n            cur = nxt;\\n        }\\n        head.next = reverseKGroup(cur, k);\\n        return node;\\n    }\\n    \\n    // iteratively\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int l = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            l++;\\n            cur = cur.next;\\n        }\\n        if (l < k) {\\n            return head;\\n        }\\n        int n = l/k;\\n        ListNode pre = new ListNode(0), node, rem, ret = pre;\\n        for (int i = 0; i < n; i++) {\\n            node = null;\\n            rem = head;\\n            for (int j = 0; j < k; j++) {\\n                ListNode nxt = head.next;\\n                head.next = node;\\n                node = head;\\n                head = nxt;\\n            }\\n            pre.next = node;\\n            rem.next = head;\\n            pre = rem;\\n        }\\n        return ret.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "       \\n     // recursively \\n    public ListNode reverseKGroup1(ListNode head, int k) {\\n        int l = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            l++;\\n            cur = cur.next;\\n        }\\n        if (k > l) {\\n            return head;\\n        }\\n        cur = head;\\n        ListNode node = null;\\n        for (int i = 0; i < k; i++) {\\n            ListNode nxt = cur.next;\\n            cur.next = node;\\n            node = cur;\\n            cur = nxt;\\n        }\\n        head.next = reverseKGroup(cur, k);\\n        return node;\\n    }\\n    \\n    // iteratively\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int l = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            l++;\\n            cur = cur.next;\\n        }\\n        if (l < k) {\\n            return head;\\n        }\\n        int n = l/k;\\n        ListNode pre = new ListNode(0), node, rem, ret = pre;\\n        for (int i = 0; i < n; i++) {\\n            node = null;\\n            rem = head;\\n            for (int j = 0; j < k; j++) {\\n                ListNode nxt = head.next;\\n                head.next = node;\\n                node = head;\\n                head = nxt;\\n            }\\n            pre.next = node;\\n            rem.next = head;\\n            pre = rem;\\n        }\\n        return ret.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2204168,
                "title": "python-solution-space-o-1-time-o-n-faster-iterative-easy-solution-with-comments",
                "content": "**If You like the Solution , Please Upvote **\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        # Base case\\n        if k==1:\\n            return  head\\n        # find lenght of linked list\\n        lenght = 0\\n        curr = head\\n        while curr:\\n            curr = curr.next\\n            lenght+=1\\n            \\n        groups = lenght//k # no. of groups, we want to reverse\\n        ans = ListNode(-1) #dummy node : next of this node point head of requried linked list\\n        last = ans # pointer last : point the last node of each reversed group of  k\\n\\n        while groups:\\n            count = 1 #count the size of reversed group\\n            st = head # start node of group which will be last node after reverse the group \\n            pre , curr , nxt = None, head , head.next #reverse the group by taking three pointers\\n            while count<k:\\n                curr.next = pre\\n                pre , curr , nxt = curr , nxt  , nxt.next # move each pointer to next node\\n                count+=1\\n                \\n            curr.next = pre\\n            # curr point the start node of reversed group \\n            last.next = curr # asign last node->next of previous reversed group to start node of this reversed group \\n            last = st # asign last pointer to end node of currently reveresed group       \\n            head = nxt\\n            last.next = head # take care if last group have size less than k\\n            groups -=1 # reduce the count of unreversed groups\\n            \\n        return ans.next # return head of required linked list   \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "**If You like the Solution , Please Upvote **\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        # Base case\\n        if k==1:\\n            return  head\\n        # find lenght of linked list\\n        lenght = 0\\n        curr = head\\n        while curr:\\n            curr = curr.next\\n            lenght+=1\\n            \\n        groups = lenght//k # no. of groups, we want to reverse\\n        ans = ListNode(-1) #dummy node : next of this node point head of requried linked list\\n        last = ans # pointer last : point the last node of each reversed group of  k\\n\\n        while groups:\\n            count = 1 #count the size of reversed group\\n            st = head # start node of group which will be last node after reverse the group \\n            pre , curr , nxt = None, head , head.next #reverse the group by taking three pointers\\n            while count<k:\\n                curr.next = pre\\n                pre , curr , nxt = curr , nxt  , nxt.next # move each pointer to next node\\n                count+=1\\n                \\n            curr.next = pre\\n            # curr point the start node of reversed group \\n            last.next = curr # asign last node->next of previous reversed group to start node of this reversed group \\n            last = st # asign last pointer to end node of currently reveresed group       \\n            head = nxt\\n            last.next = head # take care if last group have size less than k\\n            groups -=1 # reduce the count of unreversed groups\\n            \\n        return ans.next # return head of required linked list   \\n",
                "codeTag": "Java"
            },
            {
                "id": 1598365,
                "title": "iterative-solution-100-faster-in-java",
                "content": "```\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n        if(head.next == null){\\n            return head;\\n        }\\n        int size = 0;\\n# \\t\\tCalculating size so that we have to only reverse size/k times. For example - 1->2->3->4>-5 and k = 2, we will reverse in groups. First 1->2 and then 3->4 and we do not have to reach till the end of the list.;\\n        ListNode temp = head;\\n        while(temp != null){\\n            size++;\\n            temp = temp.next;\\n        }\\n\\t\\n        temp = head;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode p = dummy;\\n        ListNode prev = dummy;\\n        for(int j = 0; j < size / k; j++){\\n            ListNode last = temp;\\n# \\t\\t\\tReverse k items in the list\\n            for(int i = 0; i < k; i++){\\n                ListNode node = temp.next;\\n                temp.next = prev;\\n                prev = temp;\\n                temp = node;\\n            }\\n# \\t\\t\\tConnect the list\\n            p.next = prev;\\n            last.next = temp;\\n            p = last;\\n            prev = last;\\n# \\t\\t\\tAfter 1 loop -  the list will look like this dummy->2->1->3->4->5->null\\n# \\t\\t\\tp = 1, prev = 2, temp = 3\\n\\t\\t\\t\\n# \\t\\t\\tAfter 2 loop - dummy->2->1->4->3->5->null\\n# \\t\\t\\tRepeat this process size/k times until the list looks like this \\n# \\t\\t\\tSince the outer loop will run size/k times this will be the required output\\n        }\\n        \\n        return dummy.next;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n        if(head.next == null){\\n            return head;\\n        }\\n        int size = 0;\\n# \\t\\tCalculating size so that we have to only reverse size/k times. For example - 1->2->3->4>-5 and k = 2, we will reverse in groups. First 1->2 and then 3->4 and we do not have to reach till the end of the list.;\\n        ListNode temp = head;\\n        while(temp != null){\\n            size++;\\n            temp = temp.next;\\n        }\\n\\t\\n        temp = head;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode p = dummy;\\n        ListNode prev = dummy;\\n        for(int j = 0; j < size / k; j++){\\n            ListNode last = temp;\\n# \\t\\t\\tReverse k items in the list\\n            for(int i = 0; i < k; i++){\\n                ListNode node = temp.next;\\n                temp.next = prev;\\n                prev = temp;\\n                temp = node;\\n            }\\n# \\t\\t\\tConnect the list\\n            p.next = prev;\\n            last.next = temp;\\n            p = last;\\n            prev = last;\\n# \\t\\t\\tAfter 1 loop -  the list will look like this dummy->2->1->3->4->5->null\\n# \\t\\t\\tp = 1, prev = 2, temp = 3\\n\\t\\t\\t\\n# \\t\\t\\tAfter 2 loop - dummy->2->1->4->3->5->null\\n# \\t\\t\\tRepeat this process size/k times until the list looks like this \\n# \\t\\t\\tSince the outer loop will run size/k times this will be the required output\\n        }\\n        \\n        return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1159137,
                "title": "c-recursively-get-reversed-linked-list",
                "content": "The difference between https://leetcode.com/problems/reverse-linked-list/ is we calculate each group recursively and set it as the  `start node` of the previous group\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\t// first, find the (k+1)-th node, that is the node for the next group\\n\\t\\t// if the nodes remained is smaller than k, just return\\n\\t\\n        ListNode* node = head;\\n        for(int i=0;i<k;i++) {\\n            if(!node) return head;\\n            node = node->next;\\n        }   \\n        \\n\\t\\t// Like problem in `reverse-linked-list` (https://leetcode.com/problems/reverse-linked-list/)\\n\\t\\t// Instead, compute next group first\\n        ListNode* cur = reverseKGroup(node, k);\\n        while(head != node) {\\n            ListNode* next = head->next;\\n            head->next = cur;\\n            cur = head;\\n            head = next;\\n        }\\n        return cur;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\t// first, find the (k+1)-th node, that is the node for the next group\\n\\t\\t// if the nodes remained is smaller than k, just return\\n\\t\\n        ListNode* node = head;\\n        for(int i=0;i<k;i++) {\\n            if(!node) return head;\\n            node = node->next;\\n        }   \\n        \\n\\t\\t// Like problem in `reverse-linked-list` (https://leetcode.com/problems/reverse-linked-list/)\\n\\t\\t// Instead, compute next group first\\n        ListNode* cur = reverseKGroup(node, k);\\n        while(head != node) {\\n            ListNode* next = head->next;\\n            head->next = cur;\\n            cur = head;\\n            head = next;\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096547,
                "title": "c-simple-solution",
                "content": "**Key points:**\\n* Peek k steps ahead to decide we have enough to do reverse. If not long enough, just return as is.\\n* Reverse k nodes.\\n* Do the same recursively for the remaining list.\\n```\\n  ListNode* reverseKGroup(ListNode* head, int k) {\\n    if (k <= 1)\\n      return head;\\n    \\n    ListNode * nextHead = head;\\n    for (int i=0; i<k; ++i) {\\n      if (!nextHead)\\n        return head;\\n      nextHead = nextHead->next;\\n    }\\n    \\n    ListNode * prev = head;\\n    ListNode * next = head->next;\\n    for (int i=0; i<k-1; ++i) {\\n      ListNode * tmp = next->next;\\n      next->next = prev;\\n      prev = next;\\n      next = tmp;\\n    }\\n    \\n    head->next = reverseKGroup(nextHead, k);\\n    return prev;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  ListNode* reverseKGroup(ListNode* head, int k) {\\n    if (k <= 1)\\n      return head;\\n    \\n    ListNode * nextHead = head;\\n    for (int i=0; i<k; ++i) {\\n      if (!nextHead)\\n        return head;\\n      nextHead = nextHead->next;\\n    }\\n    \\n    ListNode * prev = head;\\n    ListNode * next = head->next;\\n    for (int i=0; i<k-1; ++i) {\\n      ListNode * tmp = next->next;\\n      next->next = prev;\\n      prev = next;\\n      next = tmp;\\n    }\\n    \\n    head->next = reverseKGroup(nextHead, k);\\n    return prev;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817587,
                "title": "python-easy-solution-o-n-time-o-1-space",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseHelper(self, head, k, leftNodes):\\n        if leftNodes < k:\\n            return head\\n    \\n        count = 0\\n        prev = None\\n        current = head\\n        while current and count < k:\\n            count += 1\\n            leftNodes -= 1\\n            next = current.next\\n            current.next = prev\\n            prev = current\\n            current = next\\n\\n        if next:\\n            head.next = self.reverseHelper(next, k, leftNodes)\\n\\n        return prev\\n        \\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        leftNodes = 0\\n        node = head\\n        while node:\\n            leftNodes += 1\\n            node = node.next\\n\\n        return self.reverseHelper(head, k, leftNodes)\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseHelper(self, head, k, leftNodes):\\n        if leftNodes < k:\\n            return head\\n    \\n        count = 0\\n        prev = None\\n        current = head\\n        while current and count < k:\\n            count += 1\\n            leftNodes -= 1\\n            next = current.next\\n            current.next = prev\\n            prev = current\\n            current = next\\n\\n        if next:\\n            head.next = self.reverseHelper(next, k, leftNodes)\\n\\n        return prev\\n        \\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        leftNodes = 0\\n        node = head\\n        while node:\\n            leftNodes += 1\\n            node = node.next\\n\\n        return self.reverseHelper(head, k, leftNodes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987590,
                "title": "python-97-85-faster-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        count=0\\n        temp=head\\n        while temp:\\n            temp=temp.next\\n            count+=1\\n        n=count//k #No. of groups to be reversed\\n        prev=dummy=ListNode()\\n        dummy.next=head\\n        while n:\\n            curr=prev.next\\n            nex=curr.next\\n            for i in range(1,k): #If we have to reverse k nodes then k-1 links will be reversed\\n                curr.next=nex.next\\n                nex.next=prev.next\\n                prev.next=nex\\n                nex=curr.next\\n            prev=curr\\n            n-=1\\n        return dummy.next\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        count=0\\n        temp=head\\n        while temp:\\n            temp=temp.next\\n            count+=1\\n        n=count//k #No. of groups to be reversed\\n        prev=dummy=ListNode()\\n        dummy.next=head\\n        while n:\\n            curr=prev.next\\n            nex=curr.next\\n            for i in range(1,k): #If we have to reverse k nodes then k-1 links will be reversed\\n                curr.next=nex.next\\n                nex.next=prev.next\\n                prev.next=nex\\n                nex=curr.next\\n            prev=curr\\n            n-=1\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584694,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* head, int k) {\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        ListNode* nxt;\\n        while (k--) {\\n            nxt = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = nxt;\\n        }\\n        head->next = cur;\\n        return prev;\\n    }    \\n    int length(ListNode* head) {\\n        int len = 0;\\n        while(head != NULL) {\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        ListNode* cur = head;\\n        while (cur != NULL) {\\n            if (len >= k) {\\n                temp->next = reverse(cur, k);\\n                len -= k;\\n                temp = cur;\\n                cur = cur->next;\\n            } else {\\n                break;\\n            }\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* head, int k) {\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        ListNode* nxt;\\n        while (k--) {\\n            nxt = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = nxt;\\n        }\\n        head->next = cur;\\n        return prev;\\n    }    \\n    int length(ListNode* head) {\\n        int len = 0;\\n        while(head != NULL) {\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        ListNode* cur = head;\\n        while (cur != NULL) {\\n            if (len >= k) {\\n                temp->next = reverse(cur, k);\\n                len -= k;\\n                temp = cur;\\n                cur = cur->next;\\n            } else {\\n                break;\\n            }\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431696,
                "title": "easy-to-understand-recursive-approach-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken by this solution is as follows:\\n\\n1. Check if k group is available to reverse or not. If not, return head as it is.\\n2. If k group is available, then reverse the first k nodes.\\n3. Recursively apply the same operation on the remaining linked list starting from the k+1th node.\\n4. Return the new head, which is the last node of the first k nodes.\\n\\nThe function takes in a head node of the linked list and an integer k as arguments and returns the head of the modified linked list after reversing the nodes in k groups.\\n\\n![image.png](https://assets.leetcode.com/users/images/9deb0470-dff9-4582-96f2-0bb7ff79689a_1681834820.5916502.png)\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        if(head==NULL){\\n            return NULL;\\n        }\\n        //step1-we check that if k group is avaliable or not to reverse\\n        int avaliable= k, cnt = 0;\\n        ListNode* temp = head;\\n        while(avaliable > 0 && temp != NULL){\\n            temp = temp -> next;\\n           avaliable--;\\n        }\\n        if(avaliable==0){\\n        //step2- we reverse for first k group\\n        ListNode* next=NULL;\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        while(curr!=NULL && cnt<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev =curr;\\n            curr=next;\\n            cnt++;\\n        }\\n        //step3-we recursively take care of the remaining cases that are left out\\n        if(next!=NULL){\\n            head->next=reverseKGroup(next,k);\\n        }\\n        //step4 return prev as at last it will be the new head\\n        return prev;\\n        }\\n        //return head as the k group is not present to reverse\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        if(head==NULL){\\n            return NULL;\\n        }\\n        //step1-we check that if k group is avaliable or not to reverse\\n        int avaliable= k, cnt = 0;\\n        ListNode* temp = head;\\n        while(avaliable > 0 && temp != NULL){\\n            temp = temp -> next;\\n           avaliable--;\\n        }\\n        if(avaliable==0){\\n        //step2- we reverse for first k group\\n        ListNode* next=NULL;\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        while(curr!=NULL && cnt<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev =curr;\\n            curr=next;\\n            cnt++;\\n        }\\n        //step3-we recursively take care of the remaining cases that are left out\\n        if(next!=NULL){\\n            head->next=reverseKGroup(next,k);\\n        }\\n        //step4 return prev as at last it will be the new head\\n        return prev;\\n        }\\n        //return head as the k group is not present to reverse\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395110,
                "title": "extending-reverse-ll-approach-recursive-boom",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are asked to reverse nodes in groups. We will reverse first k nodes, then make a recursive call.\\n\\nif you dont know, how to reverse LL, go and check- https://leetcode.com/problems/reverse-linked-list/solutions/3389694/cpp-solution-iterative-recursion-o-n/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. check reverse LL, through link.\\n2. Here, we take x = k, to check if Further k nodes are present or not.\\n3. if present, then reverse the K nodes. \\n4. if not, return head bcz head is pointing to the next element , that is, forward node. EXAMPLE- 1,2,3,4,5    AND K = 3,  in this, head points to 4. and it gets attached to head->next pointer. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head == NULL)\\n        return head;\\n\\n        int x = k, count = 0;\\n        ListNode* temp = head;\\n        while(x > 0 && temp != NULL){\\n            temp = temp -> next;\\n            x--;\\n        }\\n        if(x == 0)\\n        {\\n            ListNode* forward = NULL;\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            while(count < k){\\n                forward = curr -> next;\\n                curr -> next = prev;\\n                prev = curr;\\n                curr = forward;\\n                count++:\\n            }\\n            head -> next = reverseKGroup(forward, k);\\n            return prev;\\n        }\\n        else\\n            return head; // gets attached to head->next as it points to null.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head == NULL)\\n        return head;\\n\\n        int x = k, count = 0;\\n        ListNode* temp = head;\\n        while(x > 0 && temp != NULL){\\n            temp = temp -> next;\\n            x--;\\n        }\\n        if(x == 0)\\n        {\\n            ListNode* forward = NULL;\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            while(count < k){\\n                forward = curr -> next;\\n                curr -> next = prev;\\n                prev = curr;\\n                curr = forward;\\n                count++:\\n            }\\n            head -> next = reverseKGroup(forward, k);\\n            return prev;\\n        }\\n        else\\n            return head; // gets attached to head->next as it points to null.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276880,
                "title": "easy-solution-in-c-recursive",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // Base case\\n        if (head == NULL || k == 1) {\\n            return head;\\n        }\\n\\n        //step 1: reverse first k Nodes\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int count = 0;\\n\\n        while (curr != NULL && count < k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Check if there are enough nodes to reverse\\n        if (count < k) {\\n            // Reverse back the first count nodes to maintain the original order\\n            ListNode* temp = NULL;\\n            while (count > 0) {\\n                temp = prev->next;\\n                prev->next = curr;\\n                curr = prev;\\n                prev = temp;\\n                count--;\\n            }\\n            return curr;\\n        }\\n\\n        // step 2: recursion for k groups\\n        if (next != NULL) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // step 3: return the head of reversed list\\n        return prev;\\n    }\\n};\\n\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // Base case\\n        if (head == NULL || k == 1) {\\n            return head;\\n        }\\n\\n        //step 1: reverse first k Nodes\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int count = 0;\\n\\n        while (curr != NULL && count < k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Check if there are enough nodes to reverse\\n        if (count < k) {\\n            // Reverse back the first count nodes to maintain the original order\\n            ListNode* temp = NULL;\\n            while (count > 0) {\\n                temp = prev->next;\\n                prev->next = curr;\\n                curr = prev;\\n                prev = temp;\\n                count--;\\n            }\\n            return curr;\\n        }\\n\\n        // step 2: recursion for k groups\\n        if (next != NULL) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // step 3: return the head of reversed list\\n        return prev;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138247,
                "title": "clean-understandable-java-sol-0ms-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1) return head;\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n\\n        ListNode curr = dummy,nex = dummy,pre = dummy;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr = curr.next;             // counting number of nodes.\\n            count++;\\n        }\\n\\n        while(count>=k){                 // iterate till groups of k.\\n            curr = pre.next;             // put curr at first and nex at second node of that group.\\n            nex = curr.next;           \\n            for(int i=1;i<k;i++){        //rum loop K-1 times and revrerse every link.\\n                curr.next = nex.next;\\n                nex.next = pre.next;\\n                pre.next = nex;\\n                nex = curr.next;\\n            }\\n            pre = curr;                   // to make pre stand at last node of previous reversed group of size k.\\n            count-=k;                     // decrementing count by k as the group is reversed and we move to next group of k if present.\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1) return head;\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n\\n        ListNode curr = dummy,nex = dummy,pre = dummy;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr = curr.next;             // counting number of nodes.\\n            count++;\\n        }\\n\\n        while(count>=k){                 // iterate till groups of k.\\n            curr = pre.next;             // put curr at first and nex at second node of that group.\\n            nex = curr.next;           \\n            for(int i=1;i<k;i++){        //rum loop K-1 times and revrerse every link.\\n                curr.next = nex.next;\\n                nex.next = pre.next;\\n                pre.next = nex;\\n                nex = curr.next;\\n            }\\n            pre = curr;                   // to make pre stand at last node of previous reversed group of size k.\\n            count-=k;                     // decrementing count by k as the group is reversed and we move to next group of k if present.\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694132,
                "title": "1ms-java-solution-beats-69",
                "content": "*Time Complexity - O(n)*\\nPlease upvote if it was helpful\\n\\n```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n \\n        ListNode dum = new ListNode(0);\\n        dum.next = head;\\n        ListNode pointer = dum;\\n        while (pointer != null) {\\n            ListNode node = pointer;\\n            //  check there are k nodes to reverse\\n            for (int i = 0; i < k && node != null; i++) {\\n                node = node.next;\\n            }\\n            if (node == null) break;\\n            \\n            //  we have k nodes, then start from the first node\\n            ListNode prev = null, curr = pointer.next, next = null;\\n            for (int i = 0; i < k; i++) {\\n                next = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = next;\\n            }\\n            ListNode tail = pointer.next;\\n            tail.next = curr;\\n            pointer.next = prev;\\n            pointer = tail;\\n        }\\n        return dum.next;\\n    }\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n \\n        ListNode dum = new ListNode(0);\\n        dum.next = head;\\n        ListNode pointer = dum;\\n        while (pointer != null) {\\n            ListNode node = pointer;\\n            //  check there are k nodes to reverse\\n            for (int i = 0; i < k && node != null; i++) {\\n                node = node.next;\\n            }\\n            if (node == null) break;\\n            \\n            //  we have k nodes, then start from the first node\\n            ListNode prev = null, curr = pointer.next, next = null;\\n            for (int i = 0; i < k; i++) {\\n                next = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = next;\\n            }\\n            ListNode tail = pointer.next;\\n            tail.next = curr;\\n            pointer.next = prev;\\n            pointer = tail;\\n        }\\n        return dum.next;\\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521178,
                "title": "two-pointers-make-this-problem-to-an-easy-one",
                "content": "``` class Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head\\n        temp = []\\n        \\n        while fast:\\n            temp.append(fast.val)\\n            \\n            if len(temp) == k:\\n                while temp:\\n                    slow.val = temp.pop()\\n                    slow = slow.next\\n                    \\n            fast = fast.next\\n            \\n        return head\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "``` class Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head\\n        temp = []\\n        \\n        while fast:\\n            temp.append(fast.val)\\n            \\n            if len(temp) == k:\\n                while temp:\\n                    slow.val = temp.pop()\\n                    slow = slow.next\\n                    \\n            fast = fast.next\\n            \\n        return head\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2041406,
                "title": "c-recursive-easy-to-understand",
                "content": "```\\n ListNode* reverseKGroup(ListNode* head, int k) \\n    {   \\n        //to not reverse the last group which is less than k\\n         ListNode* temp=head;\\n         for(int i=0;i<k;i++)\\n         {\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        //here we go again\\n        ListNode *prev = NULL;\\n        ListNode *curr = head;\\n        ListNode *next;\\n        int count=0;\\n        while(curr and count<k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        //aage ka recursion ke bharose\\n        if(next){\\n            head->next = reverseKGroup(next,k);    //head->next=prev\\n        }\\n        \\n        return prev;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n ListNode* reverseKGroup(ListNode* head, int k) \\n    {   \\n        //to not reverse the last group which is less than k\\n         ListNode* temp=head;\\n         for(int i=0;i<k;i++)\\n         {\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        //here we go again\\n        ListNode *prev = NULL;\\n        ListNode *curr = head;\\n        ListNode *next;\\n        int count=0;\\n        while(curr and count<k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        //aage ka recursion ke bharose\\n        if(next){\\n            head->next = reverseKGroup(next,k);    //head->next=prev\\n        }\\n        \\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943998,
                "title": "my-simple-100-faster-solution-using-recursion-with-explanation",
                "content": "class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n\\t\\n        ListNode prev = null;\\n        ListNode current = head;\\n        int count = 0;\\n        ListNode next = null;\\n\\t\\t\\n        //reverse blindly\\n        while (current != null && count < k) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }\\n\\n        //restoring if count lesser\\n        if (count < k) {\\n            current = prev;\\n            prev = null;\\n            next = null;\\n\\t\\t\\t\\n            while (count != 0) {\\n                count--;\\n                next = current.next;\\n                current.next = prev;\\n                prev = current;\\n                current = next;\\n            }\\n        }\\n        //head always contains first node (last node after reverse) current head will become current tail and next set should be attached to that\\n        if (next != null) {\\n            head.next = reverseKGroup(next, k);\\n        }\\n        //prev contains current head and it should be returned\\n        return prev;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n\\t\\n        ListNode prev = null;\\n        ListNode current = head;\\n        int count = 0;\\n        ListNode next = null;\\n\\t\\t\\n        //reverse blindly\\n        while (current != null && count < k) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 493558,
                "title": "c-simple-solution-with-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head)\\n            return NULL;\\n        ListNode *prev = NULL;\\n        auto cur = head;\\n        int n = 0;\\n        while(cur && n != k){\\n            auto tmp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = tmp;\\n            n++;\\n        }\\n        if(n != k){\\n            return reverseKGroup(prev, n);\\n        }\\n        head->next = reverseKGroup(cur, k);\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head)\\n            return NULL;\\n        ListNode *prev = NULL;\\n        auto cur = head;\\n        int n = 0;\\n        while(cur && n != k){\\n            auto tmp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = tmp;\\n            n++;\\n        }\\n        if(n != k){\\n            return reverseKGroup(prev, n);\\n        }\\n        head->next = reverseKGroup(cur, k);\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 215165,
                "title": "rust",
                "content": "```\\nfn add(head: Option<Box<ListNode>>, tail: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n    let mut head = head;\\n    let mut tail = tail;\\n\\n    while let Some(mut new_tail) = head.take() {\\n        head = new_tail.next.take();\\n        new_tail.next = tail.take();\\n        tail = Some(new_tail);\\n    }\\n    tail\\n}\\n\\nimpl Solution {\\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut tail = &mut head;\\n        for _ in 0..k {\\n            match tail.as_mut() {\\n                None => return head,\\n                Some(tail_ref) => tail = &mut tail_ref.next,\\n            }\\n        }\\n        let tail = tail.take();\\n        add(head, Solution::reverse_k_group(tail, k))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfn add(head: Option<Box<ListNode>>, tail: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n    let mut head = head;\\n    let mut tail = tail;\\n\\n    while let Some(mut new_tail) = head.take() {\\n        head = new_tail.next.take();\\n        new_tail.next = tail.take();\\n        tail = Some(new_tail);\\n    }\\n    tail\\n}\\n\\nimpl Solution {\\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut tail = &mut head;\\n        for _ in 0..k {\\n            match tail.as_mut() {\\n                None => return head,\\n                Some(tail_ref) => tail = &mut tail_ref.next,\\n            }\\n        }\\n        let tail = tail.take();\\n        add(head, Solution::reverse_k_group(tail, k))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11622,
                "title": "python-non-recursive-solution-easy-understand-68-ms",
                "content": "\\n    # pre alway point the last one in previous KGoup. \\n    # Constant insert cur kGroup's node after it.\\n    class Solution(object): \\n    def reverseKGroup(self, head, k):\\n        pre, pre.next = self, head\\n        while self.needReverse(head, k):\\n            tail = head  # 1st one in cur KGroup\\n            for _ in xrange(k):\\n                pre.next, head.next, head = head, pre.next, head.next\\n            pre = tail  # now, it become the last one in previous KGroup \\n        pre.next = head  #maybe there are some rest node.\\n        return self.next\\n        \\n    def needReverse(self, head, k):\\n        while head and k:\\n            k -= 1\\n            head = head.next\\n        return k == 0\\n\\n    # 68 ms, 81 / 81 test cases passed.\\n    # beats 84.43% of python submissions.",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    # pre alway point the last one in previous KGoup. \\n    # Constant insert cur kGroup's node after it.\\n    class Solution(object): \\n    def reverseKGroup(self, head, k):\\n        pre, pre.next = self, head\\n        while self.needReverse(head, k):\\n            tail = head  # 1st one in cur KGroup\\n            for _ in xrange(k):\\n                pre.next, head.next, head = head, pre.next, head.next\\n            pre = tail  # now, it become the last one in previous KGroup \\n        pre.next = head  #maybe there are some rest node.\\n        return self.next\\n        \\n    def needReverse(self, head, k):\\n        while head and k:\\n            k -= 1\\n            head = head.next\\n        return k == 0\\n\\n    # 68 ms, 81 / 81 test cases passed.\\n    # beats 84.43% of python submissions.",
                "codeTag": "Java"
            },
            {
                "id": 11645,
                "title": "short-recursive-java-solution",
                "content": "    public class Solution {\\n           \\n       public  ListNode reverse(ListNode head, ListNode end){\\n    \\t       if(head==null || head.next==null || head==end || head.next==end) return head;\\n    \\t       ListNode sec = head.next;\\n    \\t       ListNode rem = reverse(sec,end);\\n    \\t       sec.next =head; head.next=null;\\n    \\t       return rem;\\n    \\t   }\\n    \\t    public  ListNode reverseKGroup(ListNode head, int k) {\\n    \\t        ListNode curr = head; int count = 0;\\n    \\t        while (curr != null && count != k) {\\n    \\t            curr = curr.next;count++;\\n    \\t        }\\n    \\t        if (count == k) {\\n    \\t            ListNode temp = reverseKGroup(curr, k);\\n    \\t            ListNode t = reverse(head,curr);\\n    \\t            head.next = temp;\\n    \\t            return t;\\n    \\t        }\\n    \\t        return head;\\n    \\t    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n           \\n       public  ListNode reverse(ListNode head, ListNode end){\\n    \\t       if(head==null || head.next==null || head==end || head.next==end) return head;\\n    \\t       ListNode sec = head.next;\\n    \\t       ListNode rem = reverse(sec,end);\\n    \\t       sec.next =head; head.next=null;\\n    \\t       return rem;\\n    \\t   }",
                "codeTag": "Java"
            },
            {
                "id": 3865908,
                "title": "best-recursive-and-iterative-approach-with-video-explanation-beats-100",
                "content": "# [Video link](https://youtu.be/fi2vh0nQLi0) \\n\\n# Code\\n```\\n// Recursive approach Space O(N) (Stack)\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int size = 0;\\n        ListNode *temp = head;\\n        while(temp!=NULL){\\n            temp = temp -> next;\\n            size++;\\n        }\\n        if(size < k)    return head;   \\n\\n        // Base call\\n        if(head == NULL)\\n            return NULL;\\n\\n        // Step 1 - Reverse first k nodes\\n        ListNode *curr = head, *prev = NULL, *next = NULL;\\n        int count = 0;\\n        while(curr != NULL && count <k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Step 2 - Use recursion to reverse rest of the nodes\\n        if(next!=NULL){\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // Step 3 - Return head\\n        return prev;\\n    }\\n};\\n\\n// Iterative approach Space - O(1)\\nclass Solution {\\npublic:\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode *before = dummy, *after = head;\\n        ListNode *curr = NULL, *prev = NULL, *nxt = NULL;\\n        while(true){\\n            ListNode* cursor = after;\\n            for(int i = 0; i < k; i++){\\n                if(cursor == nullptr) \\n                    return dummy->next;\\n                cursor = cursor->next;\\n            }\\n            curr = after;\\n            prev = before;\\n            for(int i = 0; i < k; i++){\\n                nxt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nxt;\\n            }\\n            after->next = curr;\\n            before->next = prev;\\n            before = after;\\n            after = curr;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n// Recursive approach Space O(N) (Stack)\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int size = 0;\\n        ListNode *temp = head;\\n        while(temp!=NULL){\\n            temp = temp -> next;\\n            size++;\\n        }\\n        if(size < k)    return head;   \\n\\n        // Base call\\n        if(head == NULL)\\n            return NULL;\\n\\n        // Step 1 - Reverse first k nodes\\n        ListNode *curr = head, *prev = NULL, *next = NULL;\\n        int count = 0;\\n        while(curr != NULL && count <k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Step 2 - Use recursion to reverse rest of the nodes\\n        if(next!=NULL){\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // Step 3 - Return head\\n        return prev;\\n    }\\n};\\n\\n// Iterative approach Space - O(1)\\nclass Solution {\\npublic:\\n\\tListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode *before = dummy, *after = head;\\n        ListNode *curr = NULL, *prev = NULL, *nxt = NULL;\\n        while(true){\\n            ListNode* cursor = after;\\n            for(int i = 0; i < k; i++){\\n                if(cursor == nullptr) \\n                    return dummy->next;\\n                cursor = cursor->next;\\n            }\\n            curr = after;\\n            prev = before;\\n            for(int i = 0; i < k; i++){\\n                nxt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nxt;\\n            }\\n            after->next = curr;\\n            before->next = prev;\\n            before = after;\\n            after = curr;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796263,
                "title": "c-easy-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(K)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int LinkListLen(ListNode* head){\\n        int res = 0;\\n        while(head!=NULL){\\n            res++;head = head->next;\\n        }\\n\\n        return res;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* ans = new ListNode(-1);\\n        ListNode* dummy = ans;\\n        int len = LinkListLen(head);\\n        while(head!=NULL){\\n            if(len>=k){\\n                ListNode* tem = NULL;\\n                for(int i=0;i<k;i++){\\n                    ListNode* n = new ListNode(head->val);\\n                    head = head->next;\\n                    n->next = tem;\\n                    tem = n;len--;\\n                }\\n                dummy->next = tem;\\n                while(dummy->next!=NULL){\\n                    dummy = dummy->next;\\n                }\\n            } else {\\n                dummy->next=head;\\n                break;\\n            }\\n        }\\n        \\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int LinkListLen(ListNode* head){\\n        int res = 0;\\n        while(head!=NULL){\\n            res++;head = head->next;\\n        }\\n\\n        return res;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* ans = new ListNode(-1);\\n        ListNode* dummy = ans;\\n        int len = LinkListLen(head);\\n        while(head!=NULL){\\n            if(len>=k){\\n                ListNode* tem = NULL;\\n                for(int i=0;i<k;i++){\\n                    ListNode* n = new ListNode(head->val);\\n                    head = head->next;\\n                    n->next = tem;\\n                    tem = n;len--;\\n                }\\n                dummy->next = tem;\\n                while(dummy->next!=NULL){\\n                    dummy = dummy->next;\\n                }\\n            } else {\\n                dummy->next=head;\\n                break;\\n            }\\n        }\\n        \\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606051,
                "title": "better-than-92-easy-recursive-solution-with-comments-for-better-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReverse k nodes and then do recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**IMPORTANT: Read the comments in the code, they are self-explanatory.**\\n1. Reverse k nodes initially.\\n2. Call for the remaining \\'len - k\\' nodes, where len = length of the Linked List.\\n3. Connect the kth node of the k nodes reversed linked list to the head of the remaining linked list.\\n\\n# Complexity\\n- Time complexity: **O(len)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(len) for the length function\\nO(len/k) for the loop inside reverseKGroup\\nO(len) for the recursive calls inside reverseKGroup\\n\\nOverall ~ O(len)\\n\\n- Space complexity:**O(len)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nlen = length of the linked list, this is due to recursive call stack.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length (ListNode* head)\\n    {\\n        int len = 0;\\n        while(head != NULL)\\n        {\\n            len++;\\n            head = head -> next;\\n        }\\n        return len;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //head = 1\\n\\n        int len = length(head); //Calculate length of LL\\n        if(len < k) //As mentioned in aue, if len < k don\\'t reverse\\n        {\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* curr = head; //1 --- After 1st step, curr = 2\\n        ListNode* prev = NULL; //NULL\\n        ListNode* forward = NULL;\\n\\n        while(curr != NULL && cnt < k)  //Reverseing \\'k\\' nodes initially\\n        {\\n            forward = curr -> next; //2 --- 3\\n            curr -> next = prev; //1 -> 2 is broken and NULL <- 1 --- 2 -> 1\\n            prev = curr; //prev = 1 --- prev = 2\\n            curr = forward; // curr = 2 --- curr = 3\\n            cnt++;\\n        }\\n        if(forward != NULL)\\n        {\\n            head -> next = reverseKGroup(forward, k); //Recursively calling for remaining nodes\\n        }\\n        //I\\'ve stored it in head -> next bcz, head = 1 and I\\'ve coneected it with 4, head of the new LL\\n\\n        return prev; // return prev bcz, 2 is the head of our final LL and it is stored in prev\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length (ListNode* head)\\n    {\\n        int len = 0;\\n        while(head != NULL)\\n        {\\n            len++;\\n            head = head -> next;\\n        }\\n        return len;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //head = 1\\n\\n        int len = length(head); //Calculate length of LL\\n        if(len < k) //As mentioned in aue, if len < k don\\'t reverse\\n        {\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* curr = head; //1 --- After 1st step, curr = 2\\n        ListNode* prev = NULL; //NULL\\n        ListNode* forward = NULL;\\n\\n        while(curr != NULL && cnt < k)  //Reverseing \\'k\\' nodes initially\\n        {\\n            forward = curr -> next; //2 --- 3\\n            curr -> next = prev; //1 -> 2 is broken and NULL <- 1 --- 2 -> 1\\n            prev = curr; //prev = 1 --- prev = 2\\n            curr = forward; // curr = 2 --- curr = 3\\n            cnt++;\\n        }\\n        if(forward != NULL)\\n        {\\n            head -> next = reverseKGroup(forward, k); //Recursively calling for remaining nodes\\n        }\\n        //I\\'ve stored it in head -> next bcz, head = 1 and I\\'ve coneected it with 4, head of the new LL\\n\\n        return prev; // return prev bcz, 2 is the head of our final LL and it is stored in prev\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558230,
                "title": "easy-c-solution-beat-85",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        ListNode* temp=head;\\n        int i=0;\\n        while(temp!=NULL){\\n            i++;\\n            temp=temp->next;\\n        }\\n        return i;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n    if(head==NULL)\\n    return NULL;\\n    int len=length(head);\\n    if(k>len)\\n    return head;\\n\\n    int count=0;\\n    ListNode* prev=NULL;\\n    ListNode* curr=head;\\n    ListNode* next=head->next;\\n    //reverse\\n    while(count<k){\\n        next=curr->next;\\n        curr->next=prev;\\n        prev=curr;\\n        curr=next;\\n        count++;\\n    }\\n    //reverse ll\\n    if(next!=NULL)\\n        head->next=reverseKGroup(next,k);\\n    return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        ListNode* temp=head;\\n        int i=0;\\n        while(temp!=NULL){\\n            i++;\\n            temp=temp->next;\\n        }\\n        return i;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n    if(head==NULL)\\n    return NULL;\\n    int len=length(head);\\n    if(k>len)\\n    return head;\\n\\n    int count=0;\\n    ListNode* prev=NULL;\\n    ListNode* curr=head;\\n    ListNode* next=head->next;\\n    //reverse\\n    while(count<k){\\n        next=curr->next;\\n        curr->next=prev;\\n        prev=curr;\\n        curr=next;\\n        count++;\\n    }\\n    //reverse ll\\n    if(next!=NULL)\\n        head->next=reverseKGroup(next,k);\\n    return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778878,
                "title": "easiest-approach-only-3-steps-beginner-friendly-easiest-c-solution",
                "content": "# **ONLY 3 STEPS**\\n1. Store all node values in a vector.\\n2. Apply operations on the vector i.e, swap values in a loop. \\n3. Make a new LinkedList by the processed vector and return it.\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\t//edge cases\\n        if (head == NULL || k ==0 ||k==1)return head;\\n\\t\\t// Store all node values in a vector.\\n        vector<int> v;\\n        ListNode* p = head;\\n        while(p){\\n            v.push_back(p->val);\\n            p = p->next;\\n        }\\n        int n = v.size();\\n\\t\\t// r is how many sub groups are to be reversed; \\n        int r = n/k;\\n        int q = 0;\\n\\t\\t// Apply operations on the vector i.e, swap values in a loop. \\n        while(r--){\\n            int i = k*q;\\n            int j = (k)*(q+1) - 1;\\n            while(i<j){\\n                swap(v[i++], v[j--]);\\n            }\\n            q++;\\n        }\\n\\t\\t// Make a new LinkedList by the processed vector and return it.\\n        ListNode* a = new ListNode(v[0]);\\n        ListNode* b = a;\\n        for(int i =1; i<v.size(); i++){\\n            b->next = new ListNode(v[i]);\\n            b = b->next;\\n        }\\n        return a;\\n    }\\n};\\n```\\n**Liked it ?\\nPlease Upvote**",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\t//edge cases\\n        if (head == NULL || k ==0 ||k==1)return head;\\n\\t\\t// Store all node values in a vector.\\n        vector<int> v;\\n        ListNode* p = head;\\n        while(p){\\n            v.push_back(p->val);\\n            p = p->next;\\n        }\\n        int n = v.size();\\n\\t\\t// r is how many sub groups are to be reversed; \\n        int r = n/k;\\n        int q = 0;\\n\\t\\t// Apply operations on the vector i.e, swap values in a loop. \\n        while(r--){\\n            int i = k*q;\\n            int j = (k)*(q+1) - 1;\\n            while(i<j){\\n                swap(v[i++], v[j--]);\\n            }\\n            q++;\\n        }\\n\\t\\t// Make a new LinkedList by the processed vector and return it.\\n        ListNode* a = new ListNode(v[0]);\\n        ListNode* b = a;\\n        for(int i =1; i<v.size(); i++){\\n            b->next = new ListNode(v[i]);\\n            b = b->next;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776693,
                "title": "java-fast-clean-recursion-beat-100-and-well-explain",
                "content": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        // base case\\n        if(k == 1) return head;\\n\\t\\t// first keep finding each group until we found last group\\n\\t\\t// there is no need to reverse the last group when we found it, just return start point of it\\n\\t\\t// even if the last group is null, it is still fine, just return it\\n        ListNode curr = head;\\n        for(int i = 0 ; i < k ; i ++) {\\n           if(head != null) {\\n                head = head.next;\\n           }else {\\n               // last group found\\n               return curr;\\n           }\\n        }\\n        // recursion\\n        ListNode nextGroup = reverseKGroup(head,k);\\n        // back tracking reverse curr group\\n        ListNode finalTail = curr;\\n        ListNode prev = curr;\\n        ListNode tempNext = null;\\n        for(int i = 0 ; i < k ; i ++) {\\n            tempNext = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tempNext;\\n        }\\n        // connect reversed curr to next group\\n        finalTail.next = nextGroup;\\n\\t\\t// return new reversed first node of curr group(which the prev point to) and keep back tracking until stack is empty\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        // base case\\n        if(k == 1) return head;\\n\\t\\t// first keep finding each group until we found last group\\n\\t\\t// there is no need to reverse the last group when we found it, just return start point of it\\n\\t\\t// even if the last group is null, it is still fine, just return it\\n        ListNode curr = head;\\n        for(int i = 0 ; i < k ; i ++) {\\n           if(head != null) {\\n                head = head.next;\\n           }else {\\n               // last group found\\n               return curr;\\n           }\\n        }\\n        // recursion\\n        ListNode nextGroup = reverseKGroup(head,k);\\n        // back tracking reverse curr group\\n        ListNode finalTail = curr;\\n        ListNode prev = curr;\\n        ListNode tempNext = null;\\n        for(int i = 0 ; i < k ; i ++) {\\n            tempNext = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tempNext;\\n        }\\n        // connect reversed curr to next group\\n        finalTail.next = nextGroup;\\n\\t\\t// return new reversed first node of curr group(which the prev point to) and keep back tracking until stack is empty\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253458,
                "title": "c-simple-fast-solution-reverse-nodes-in-k-group",
                "content": "class Solution {\\npublic:\\n    int lengthOfLL(ListNode* head)\\n    {\\n        int length=0;\\n        while(head!=NULL)\\n        {\\n            head=head->next;\\n            length++;   \\n        }\\n        return length;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k,int length)\\n    {\\n        if(length<k) return head;\\n        int count=0;\\n        ListNode*prev=NULL;\\n        ListNode*c=head;\\n        ListNode*n=NULL;\\n        while(c!=NULL && count<k)\\n        {\\n            n=c->next;\\n            c->next=prev;\\n            prev=c;\\n            c=n;\\n            count++;\\n        }\\n        //call recursion for remaining node\\n        if(n!=NULL)\\n        {\\n            head->next=reverseKGroup(n,k,length-k);\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n   int length=lengthOfLL(head);\\n        return reverseKGroup(head,k,length);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int lengthOfLL(ListNode* head)\\n    {\\n        int length=0;\\n        while(head!=NULL)\\n        {\\n            head=head->next;\\n            length++;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1990895,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n\\n    ListNode prev = null;\\n    ListNode current = head;\\n    int count = 0;\\n    ListNode next = null;\\n\\t\\n    //reverse blindly\\n    while (current != null && count < k) {\\n        next = current.next;\\n        current.next = prev;\\n        prev = current;\\n        current = next;\\n        count++;\\n    }\\n\\n    //restoring if count lesser\\n    if (count < k) {\\n        current = prev;\\n        prev = null;\\n        next = null;\\n\\t\\t\\n        while (count != 0) {\\n            count--;\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n    }\\n    //head always contains first node (last node after reverse) current head will become current tail and next set should be attached to that\\n    if (next != null) {\\n        head.next = reverseKGroup(next, k);\\n    }\\n    //prev contains current head and it should be returned\\n    return prev;\\n}\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++){\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        ListNode *prev=NULL;\\n        ListNode *nex1=NULL;\\n        temp=head;\\n        for(int i=0;i<k;i++){\\n            nex1=temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nex1;\\n        }\\n        if(nex1!=NULL)\\n            head->next=reverseKGroup(nex1,k);\\n        return prev;\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n        prev = None\\n        curr = head\\n        for _ in range(k):\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar reverseKGroup = function(head, k) {\\n\\t// will return the new head of the resultant linked list\\n    return reverseAGroup(head);\\n    \\n    function reverseAGroup(start) {\\n\\t\\t// a temp varaible to move the curr start pointer k steps \\n        let temp_k = k;\\n        let curr = start;\\n        while(curr && temp_k-- > 0) {\\n            curr = curr.next;\\n        }\\n        if(temp_k > 0) {  // curr group size is less than k, so need not reverse\\n            return start;\\n        }\\n        const groupTail = start,                // the start pointer is pointing to the tail node of the current group (on reversal)\\n              groupHead = reverse(start, curr); // get the tail pointer of the current group by reversing the group of nodes\\n        \\n        if(curr) {  // if there is a node followed by the current group, update the next pointer of the current group\\'s tail next pointer\\n            groupTail.next = reverseAGroup(curr);    // we will get the next group head by recursively calling the function on the following node\\n        }\\n        return groupHead;    // finally return the current group head node\\n    }\\n    function reverse(root, nextGroup) {\\n        let curr = root,\\n            next = null,\\n            prev = null;\\n        \\n        while(curr && curr !== nextGroup) {    // the terminate condition will check if the current node reaches the next group\\'s head node\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;    // this will point to the new head node of the group after reversing \\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\\n        \\n        // check whether there is more than k nodes \\n        var temp = head\\n        for (i in 0 until k) {\\n            // if there are less than k nodes, return head (no need to reverse node)\\n            if (temp == null) return head else temp = temp.next\\n        }\\n\\n        // newNextStart is the starting node(after which reversion has taken place)\\n        val newNextStart = reverseKGroup(temp, k) \\n        \\n        // reverse k nodes one by one \\n        var prev: ListNode? = null \\n        var curr: ListNode? = head \\n        for (i in 0 until k) {\\n            var next = curr!!.next \\n            curr.next = prev\\n            \\n            prev = curr\\n            curr = next\\n        }\\n        \\n        // link starting node(head) with the new next starting node(newNextStart)\\n        head!!.next = newNextStart\\n        \\n        return prev\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if(head == nil) {return nil}\\n        if(k < 2) {\\n            return head\\n        }\\n        var dummy = ListNode(0)\\n        guard let head = head else {\\n            return nil\\n        }\\n        dummy.next = head\\n        \\n        var current = dummy\\n\\n        while(current.next != nil) {\\n            var start = current.next\\n            var end = current.next\\n            \\n            var count = 1\\n            while(count < k && end != nil) {\\n                end = end!.next\\n                count += 1\\n            }\\n            if(end == nil) {\\n                break\\n            }\\n            \\n            //next keep track for head of remaing list\\n            var next = end!.next\\n            \\n            //break the chain to reverse the k elements\\n            end!.next = nil\\n            \\n            var tCurr = start\\n            var prev:ListNode? = nil\\n            while(tCurr != nil) {\\n                let tNext = tCurr!.next\\n                tCurr!.next = prev\\n                prev = tCurr!\\n                tCurr = tNext\\n            }\\n            \\n            \\n            //after reversing. Put the conenction back\\n            \\n            current.next = end\\n            \\n            start!.next = next\\n            \\n            //start next iteration\\n            current = start!\\n            \\n        }\\n        return dummy.next\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic ListNode reverseKGroup(ListNode head, int k) {\\n\\n    ListNode prev = null;\\n    ListNode current = head;\\n    int count = 0;\\n    ListNode next = null;\\n\\t\\n    //reverse blindly\\n    while (current != null && count < k) {\\n        next = current.next;\\n        current.next = prev;\\n        prev = current;\\n        current = next;\\n        count++;\\n    }\\n\\n    //restoring if count lesser\\n    if (count < k) {\\n        current = prev;\\n        prev = null;\\n        next = null;\\n\\t\\t\\n        while (count != 0) {\\n            count--;\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n    }\\n    //head always contains first node (last node after reverse) current head will become current tail and next set should be attached to that\\n    if (next != null) {\\n        head.next = reverseKGroup(next, k);\\n    }\\n    //prev contains current head and it should be returned\\n    return prev;\\n}\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        for(int i=0;i<k;i++){\\n            if(!temp)return head;\\n            temp=temp->next;\\n        }\\n        \\n        ListNode *prev=NULL;\\n        ListNode *nex1=NULL;\\n        temp=head;\\n        for(int i=0;i<k;i++){\\n            nex1=temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nex1;\\n        }\\n        if(nex1!=NULL)\\n            head->next=reverseKGroup(nex1,k);\\n        return prev;\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n        prev = None\\n        curr = head\\n        for _ in range(k):\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\n```\\n```\n```\\n```\n```\\nvar reverseKGroup = function(head, k) {\\n\\t// will return the new head of the resultant linked list\\n    return reverseAGroup(head);\\n    \\n    function reverseAGroup(start) {\\n\\t\\t// a temp varaible to move the curr start pointer k steps \\n        let temp_k = k;\\n        let curr = start;\\n        while(curr && temp_k-- > 0) {\\n            curr = curr.next;\\n        }\\n        if(temp_k > 0) {  // curr group size is less than k, so need not reverse\\n            return start;\\n        }\\n        const groupTail = start,                // the start pointer is pointing to the tail node of the current group (on reversal)\\n              groupHead = reverse(start, curr); // get the tail pointer of the current group by reversing the group of nodes\\n        \\n        if(curr) {  // if there is a node followed by the current group, update the next pointer of the current group\\'s tail next pointer\\n            groupTail.next = reverseAGroup(curr);    // we will get the next group head by recursively calling the function on the following node\\n        }\\n        return groupHead;    // finally return the current group head node\\n    }\\n    function reverse(root, nextGroup) {\\n        let curr = root,\\n            next = null,\\n            prev = null;\\n        \\n        while(curr && curr !== nextGroup) {    // the terminate condition will check if the current node reaches the next group\\'s head node\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;    // this will point to the new head node of the group after reversing \\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\\n        \\n        // check whether there is more than k nodes \\n        var temp = head\\n        for (i in 0 until k) {\\n            // if there are less than k nodes, return head (no need to reverse node)\\n            if (temp == null) return head else temp = temp.next\\n        }\\n\\n        // newNextStart is the starting node(after which reversion has taken place)\\n        val newNextStart = reverseKGroup(temp, k) \\n        \\n        // reverse k nodes one by one \\n        var prev: ListNode? = null \\n        var curr: ListNode? = head \\n        for (i in 0 until k) {\\n            var next = curr!!.next \\n            curr.next = prev\\n            \\n            prev = curr\\n            curr = next\\n        }\\n        \\n        // link starting node(head) with the new next starting node(newNextStart)\\n        head!!.next = newNextStart\\n        \\n        return prev\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\\n        if(head == nil) {return nil}\\n        if(k < 2) {\\n            return head\\n        }\\n        var dummy = ListNode(0)\\n        guard let head = head else {\\n            return nil\\n        }\\n        dummy.next = head\\n        \\n        var current = dummy\\n\\n        while(current.next != nil) {\\n            var start = current.next\\n            var end = current.next\\n            \\n            var count = 1\\n            while(count < k && end != nil) {\\n                end = end!.next\\n                count += 1\\n            }\\n            if(end == nil) {\\n                break\\n            }\\n            \\n            //next keep track for head of remaing list\\n            var next = end!.next\\n            \\n            //break the chain to reverse the k elements\\n            end!.next = nil\\n            \\n            var tCurr = start\\n            var prev:ListNode? = nil\\n            while(tCurr != nil) {\\n                let tNext = tCurr!.next\\n                tCurr!.next = prev\\n                prev = tCurr!\\n                tCurr = tNext\\n            }\\n            \\n            \\n            //after reversing. Put the conenction back\\n            \\n            current.next = end\\n            \\n            start!.next = next\\n            \\n            //start next iteration\\n            current = start!\\n            \\n        }\\n        return dummy.next\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845558,
                "title": "without-extra-space-recursion-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int length(ListNode *head){\\n        if(head==NULL){\\n            return 0;\\n        }\\n        else{\\n            return 1+length(head->next);\\n        }\\n    }\\n    ListNode *reverse(ListNode *head){\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        else{\\n            ListNode *newHead=reverse(head->next);\\n            ListNode *temp=head->next;\\n            temp->next=head;\\n            head->next=NULL;\\n            return newHead;\\n        }\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        if(length(head)<k){\\n            return head;\\n        }\\n        int count=0;\\n        ListNode *temp=head;\\n        while(count< k-1 and temp!=NULL){\\n            temp=temp->next;\\n            count=count+1;\\n        }\\n        ListNode *newpart=reverseKGroup(temp->next,k);\\n        temp->next=NULL;\\n        ListNode *newHead=reverse(head);\\n        head->next=newpart;\\n        return newHead;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(ListNode *head){\\n        if(head==NULL){\\n            return 0;\\n        }\\n        else{\\n            return 1+length(head->next);\\n        }\\n    }\\n    ListNode *reverse(ListNode *head){\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        else{\\n            ListNode *newHead=reverse(head->next);\\n            ListNode *temp=head->next;\\n            temp->next=head;\\n            head->next=NULL;\\n            return newHead;\\n        }\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        if(length(head)<k){\\n            return head;\\n        }\\n        int count=0;\\n        ListNode *temp=head;\\n        while(count< k-1 and temp!=NULL){\\n            temp=temp->next;\\n            count=count+1;\\n        }\\n        ListNode *newpart=reverseKGroup(temp->next,k);\\n        temp->next=NULL;\\n        ListNode *newHead=reverse(head);\\n        head->next=newpart;\\n        return newHead;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775313,
                "title": "short-and-easy-to-understand-c-iterative-solution-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *reverse(ListNode *head,int k){\\n        ListNode *curr=head,*prev=NULL,*temp;\\n        \\n         while(curr && k--){\\n            temp=curr->next;            \\n            curr->next=prev;\\n            prev=curr;\\n            curr=temp;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        ListNode *dummy=new ListNode();\\n        ListNode *curr=head;\\n        ListNode *first_node=head,*temp,*prev=dummy;  // here first_node is the first node of the group before reversing\\n        \\n        int count=0;\\n        while(curr){            \\n            count++;\\n            temp=curr->next;\\n            if(count%k==0){\\n                prev->next=reverse(first_node,k);\\n                prev=first_node; // prev points to the last node of the most recently reversed group\\n                first_node->next=temp;\\n                first_node=temp;\\n                count=0;\\n            }\\n            curr=temp;\\n        }       \\n        return dummy->next;\\n    }\\n};\\n```\\n\\n\\t\\t\\t",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *reverse(ListNode *head,int k){\\n        ListNode *curr=head,*prev=NULL,*temp;\\n        \\n         while(curr && k--){\\n            temp=curr->next;            \\n            curr->next=prev;\\n            prev=curr;\\n            curr=temp;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        ListNode *dummy=new ListNode();\\n        ListNode *curr=head;\\n        ListNode *first_node=head,*temp,*prev=dummy;  // here first_node is the first node of the group before reversing\\n        \\n        int count=0;\\n        while(curr){            \\n            count++;\\n            temp=curr->next;\\n            if(count%k==0){\\n                prev->next=reverse(first_node,k);\\n                prev=first_node; // prev points to the last node of the most recently reversed group\\n                first_node->next=temp;\\n                first_node=temp;\\n                count=0;\\n            }\\n            curr=temp;\\n        }       \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512614,
                "title": "easy-to-understand-code-c-recursion",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* prevptr=NULL;\\n        ListNode* currptr=head;\\n        ListNode* nextptr;\\n        int cnt=0;\\n        while(currptr){\\n            cnt++;\\n            currptr=currptr->next;\\n        }\\n        if(cnt<k){\\n            return head;\\n        }\\n        cnt=0;\\n        currptr=head;\\n        int count=0;\\n        while(currptr!=NULL && count<k){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            \\n            prevptr=currptr;\\n            currptr=nextptr;\\n            count++;\\n        }\\n        if(nextptr!=NULL){\\n            head->next=reverseKGroup(nextptr,k);\\n        }\\n        return prevptr;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* prevptr=NULL;\\n        ListNode* currptr=head;\\n        ListNode* nextptr;\\n        int cnt=0;\\n        while(currptr){\\n            cnt++;\\n            currptr=currptr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1346312,
                "title": "rust-simple-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut node = &mut head;\\n        for _ in 0..k {\\n            if let Some(n) = node {\\n                node = &mut n.next;\\n            } else {\\n                return head;\\n            }\\n        }\\n        let mut ret = Self::reverse_k_group(node.take(), k);\\n        while let Some(h) = head.take() {\\n            ret = Some(Box::new(ListNode {\\n                val: h.val,\\n                next: ret,\\n            }));\\n            head = h.next;\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut node = &mut head;\\n        for _ in 0..k {\\n            if let Some(n) = node {\\n                node = &mut n.next;\\n            } else {\\n                return head;\\n            }\\n        }\\n        let mut ret = Self::reverse_k_group(node.take(), k);\\n        while let Some(h) = head.take() {\\n            ret = Some(Box::new(ListNode {\\n                val: h.val,\\n                next: ret,\\n            }));\\n            head = h.next;\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1321590,
                "title": "simple-solution-with-explanation",
                "content": "Reversing *K nodes* at a time in linked list is similar to *reversing a specified portion of a linked list.* So I created a function **reverse()** which reverse a specified portion of the linked list from m to n. I called this function in a loop with portion as **[i,i+k-1], [i+k,i+2k -1]**, and so on until we have a upper bound less than the number of nodes in the given linked list.\\n\\nThis was my approach, feel free to share your approach :).\\n\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        if k==1:\\n            return head\\n        def reverse(head, m, n):\\n \\n            prev = None\\n            curr = head\\n            i = 1\\n            while curr is not None and i < m:\\n                prev = curr\\n                curr = curr.next\\n                i = i + 1\\n\\n            start = curr\\n            end = None\\n            while curr is not None and i <= n:\\n                next = curr.next\\n                curr.next = end\\n                end = curr\\n                curr = next\\n                i = i + 1\\n\\n            start.next = curr\\n            if prev is None:\\n                head = end\\n            else:\\n                prev.next = end\\n\\n            return head\\n        n=0\\n        cur = head\\n        while cur:\\n            cur=cur.next\\n            n+=1\\n        for i in range(1,n+1,k): \\n            if i+k-1<=n:\\n                head = reverse(head, i, i+k-1)\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        if k==1:\\n            return head\\n        def reverse(head, m, n):\\n \\n            prev = None\\n            curr = head\\n            i = 1\\n            while curr is not None and i < m:\\n                prev = curr\\n                curr = curr.next\\n                i = i + 1\\n\\n            start = curr\\n            end = None\\n            while curr is not None and i <= n:\\n                next = curr.next\\n                curr.next = end\\n                end = curr\\n                curr = next\\n                i = i + 1\\n\\n            start.next = curr\\n            if prev is None:\\n                head = end\\n            else:\\n                prev.next = end\\n\\n            return head\\n        n=0\\n        cur = head\\n        while cur:\\n            cur=cur.next\\n            n+=1\\n        for i in range(1,n+1,k): \\n            if i+k-1<=n:\\n                head = reverse(head, i, i+k-1)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290581,
                "title": "simple-java-solution-with-explanation-0ms-faster-than-100",
                "content": "**class Solution** {\\n\\t\\n\\tpublic ListNode reverseKGroup(ListNode head, int k) {   \\n        if(checkLength(head,k))return head;\\n        int count = 0;\\n        ListNode current = head;\\n        ListNode next=null,prev=null;\\n\\t\\t//usual linked list reversal\\n\\t\\t\\n        while(current!=null && count<k){\\n            next = current.next;\\n            current.next=prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }\\n\\t\\t//the head of the original list will now be the tail of the reversed linked list of size k\\n\\t\\t// and the next of that head is recursively assigned to what the function returns (prev)\\n        if(next!=null){\\n            ListNode temp = reverseKGroup(next,k);\\n            head.next = temp;\\n        }\\n        return prev;\\n    }\\n\\t// a helper function to check if the size of the remaining list is less than k\\n\\t// we need this to check whether we need to reverse the list or not\\n    public boolean checkLength(ListNode head,int k){\\n        ListNode start = head;\\n        int size = 0;\\n        while(start!=null){\\n            start = start.next;\\n            size++;\\n        }\\n        return size<k;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "class Solution** {\\n\\t\\n\\tpublic ListNode reverseKGroup(ListNode head, int k) {   \\n        if(checkLength(head,k))return head;\\n        int count = 0;\\n        ListNode current = head;\\n        ListNode next=null,prev=null;\\n\\t\\t//usual linked list reversal\\n\\t\\t\\n        while(current!=null && count<k){\\n            next = current.next;\\n            current.next=prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1256548,
                "title": "c-short-approach-with-explanation",
                "content": "To do:\\nReverse the starting k nodes and let recursion handle the rest nodes.\\n If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\\n \\n Give it a try :)\\n  For recusive approach we consider three steps 1)Base Case  2)Small calculation  3)Recursive call\\n \\nSTEPS:\\nstep 1. Base Case \\n * If  head==NULL (or) head->next=NULL\\n* return head \\n\\nstep 2. Samll Calculation\\n* Check if K nodes are available, and if not return head without any change\\nas mentioned in qsn **If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.**\\n* or else  Reverse the first k nodes \\n* Now head of the k nodes becomes the tail after reversing the k nodes \\n* tail of k nodes becomes head after reversing which we will return later.\\n\\nstep 3.Recursive Call\\n* perfome same process on the rest nodes using a recursive call\\n* now point the next pointer of head of small calculation to recursive call \\n* return the new head obtained in step2 after reversing k nodes \\n\\nclass Solution {\\npublic:\\n \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL) return head;\\n        if(k==1) return head; //no modification required\\n        \\n        ListNode *nTail=head;\\n        for(int i=0;i<k;i++){\\n            if(nTail==NULL) return head; //If the no. of nodes is not a multiple of k \\n                                          //then left-out nodes, in the end, should remain as it is\\n            nTail=nTail->next;\\n        }\\n  \\n        //to reverse the starting k nodes\\n        ListNode *currentNode=head;\\n        ListNode *previousNode=head;\\n        ListNode *nextNode=head;\\n        for(int i=0;i<k;i++){\\n            nextNode=currentNode->next;\\n            currentNode->next=previousNode;\\n            previousNode=currentNode;\\n            currentNode=nextNode;\\n        }\\n        \\n        head->next=reverseKGroup(currentNode,k); //head->next because staring k nodes have been reversed \\n                                                 //so head is now tail of those reversed node\\n        return previousNode;\\n    }\\n    \\n    \\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL) return head;\\n        if(k==1) return head; //no modification required\\n        \\n        ListNode *nTail=head;\\n        for(int i=0;i<k;i++){\\n            if(nTail==NULL) return head; //If the no. of nodes is not a multiple of k \\n                                          //then left-out nodes, in the end, should remain as it is\\n            nTail=nTail->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 484612,
                "title": "java-recursive-10-line-code-with-comments-beats-100",
                "content": "The idea is to use simple recursion and form the new linked list. \\nWe will start reversing the linked list in the groups of k. After reversal head will be the last of the reversed list, so we will call `reverseKGroup` for the next set of nodes and store them in head.next.\\n\\nIf we have less than k nodes remaining in our list we can reset the reversal by calling `reverseKGroup(prev, i)` as we know there are only i nodes and we don\\'t need to reverse them.\\n\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null) return null;\\n        ListNode curr = head, prev = null;\\n        \\n        for (int i = 0; i < k; i++) {\\n            if (curr == null) return reverseKGroup(prev, i); // We need to reset the nodes that have been reversed\\n            ListNode tmp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }\\n        \\n        head.next = reverseKGroup(curr, k);\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null) return null;\\n        ListNode curr = head, prev = null;\\n        \\n        for (int i = 0; i < k; i++) {\\n            if (curr == null) return reverseKGroup(prev, i); // We need to reset the nodes that have been reversed\\n            ListNode tmp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }\\n        \\n        head.next = reverseKGroup(curr, k);\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312180,
                "title": "java-recursive-solution-easiest-to-understand",
                "content": "The solution is not O(1) space though.\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode node = head;\\n        if (node == null) return node;\\n        for (int i = 0; i < k - 1; i++) {\\n            node = node.next;\\n            if (node == null) return head;\\n        }\\n        node.next = reverseKGroup(node.next, k);\\n        return reverseLinkedList(head, node.next);\\n    }\\n    \\n    private ListNode reverseLinkedList(ListNode head, ListNode tail) {\\n        ListNode p = head;\\n        ListNode prev = null;\\n        while (p != tail){\\n            ListNode tmp = p.next;\\n            p.next = prev;\\n            prev = p;\\n            p = tmp;\\n        }\\n        head.next = tail;\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode node = head;\\n        if (node == null) return node;\\n        for (int i = 0; i < k - 1; i++) {\\n            node = node.next;\\n            if (node == null) return head;\\n        }\\n        node.next = reverseKGroup(node.next, k);\\n        return reverseLinkedList(head, node.next);\\n    }\\n    \\n    private ListNode reverseLinkedList(ListNode head, ListNode tail) {\\n        ListNode p = head;\\n        ListNode prev = null;\\n        while (p != tail){\\n            ListNode tmp = p.next;\\n            p.next = prev;\\n            prev = p;\\n            p = tmp;\\n        }\\n        head.next = tail;\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276405,
                "title": "easy-to-understand-c-solution-beats-100-in-time-and-memory",
                "content": "The idea behind this is deceptively easy - it just combines several topics to make it look more intimidating. \\n\\nAre summarized description of this algorithm is : \\n\\n##### Function reverseKGroup(ListNode \\\\*head, int K) \\n\\n1. Check remaining amount of nodes and retrieve the (K+1) _th_ element if it exists. This element shall be designated \"next\".\\n2. If there\\'s less than K elements, stop.  Return head.\\n3. Otherwise, reverse the next K elements. The old head is now at the end of the K elements.\\n4. Set the next element after the old head is  **reverseKGroup(next,K)**\\n5. Return the new head.\\n\\nA C++ implementation is as follows: \\n\\n    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        ListNode* reverseKGroup(ListNode* head, int k) {\\n            ListNode *endOfGroup;\\n            // If there\\'s less than K elements, simply return the head - no further modification.\\n            if (gatherKGroup(head, endOfGroup, k) < k) return head; \\n            // Reverse the next K nodes\\n            ListNode *newHead = reverseKNodes(head,k);\\n            // Recursively reverse the rest\\n            head->next = reverseKGroup(endOfGroup,k);\\n            return newHead;\\n        }\\n    \\n        // Reverses K nodes\\n        ListNode *reverseKNodes(ListNode* node, int k) {\\n            ListNode *nextNode;\\n            ListNode *currNode = node;\\n            ListNode *prevNode = NULL;\\n            while (k > 0) {\\n                nextNode = currNode->next;\\n                currNode->next = prevNode;\\n                prevNode = currNode;\\n                currNode = nextNode;\\n                k = k-1;\\n            }\\n            return prevNode;\\n        }\\n    \\n        // This function does a few things - it finds the first element of the end of the list\\n        // And returns the amount of members, up to k.\\n        int gatherKGroup(ListNode *node, ListNode *&it, const int k) {\\n            if (node == NULL) return 0;\\n            int count = 0;\\n            while (node && count < k) {\\n                count = count+1;\\n                node = node->next;\\n            }\\n            if (count == k) it = node;\\n            return count;\\n        }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* reverseKGroup(ListNode* head, int k) {\\n            ListNode *endOfGroup;\\n            // If there\\'s less than K elements, simply return the head - no further modification.\\n            if (gatherKGroup(head, endOfGroup, k) < k) return head; \\n            // Reverse the next K nodes\\n            ListNode *newHead = reverseKNodes(head,k);\\n            // Recursively reverse the rest\\n            head->next = reverseKGroup(endOfGroup,k);\\n            return newHead;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 174192,
                "title": "java-4ms-non-recursive-solution-beats-100-o-n-time-and-o-1-memory",
                "content": "The solution itself is pretty straight forward, only thing worth noticing is the handling of pointers within each iteration, the intimidating part is the double for-loop, but it is after all just a \"reverse linked list\" problem.\\n```\\n  public ListNode reverseKGroup(ListNode head, int k) {\\n    // Count the length of the list\\n    if (head == null || k < 2) {\\n      return head;\\n    }\\n    int len = 0;\\n    ListNode ptr0 = head;\\n    while (ptr0 != null) {\\n      ptr0 = ptr0.next;\\n      len++;\\n    }\\n    if (len < k) {\\n      return head;\\n    }\\n\\t\\t\\n    // Start reversing the list\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ptr0 = dummy;\\n    ListNode ptr1 = dummy.next;\\n    for (int i = 0; i < len / k; i++) {\\n      for (int j = 0; j < k - 1; j++) { // k nodes only have k-1 links to reverse\\n        ListNode tmp = ptr1.next;\\n        ptr1.next = tmp.next;\\n        tmp.next = ptr0.next;\\n        ptr0.next = tmp;\\n      }\\n      ptr0 = ptr1;\\n      ptr1 = ptr0.next;\\n    }\\n    return dummy.next;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public ListNode reverseKGroup(ListNode head, int k) {\\n    // Count the length of the list\\n    if (head == null || k < 2) {\\n      return head;\\n    }\\n    int len = 0;\\n    ListNode ptr0 = head;\\n    while (ptr0 != null) {\\n      ptr0 = ptr0.next;\\n      len++;\\n    }\\n    if (len < k) {\\n      return head;\\n    }\\n\\t\\t\\n    // Start reversing the list\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ptr0 = dummy;\\n    ListNode ptr1 = dummy.next;\\n    for (int i = 0; i < len / k; i++) {\\n      for (int j = 0; j < k - 1; j++) { // k nodes only have k-1 links to reverse\\n        ListNode tmp = ptr1.next;\\n        ptr1.next = tmp.next;\\n        tmp.next = ptr0.next;\\n        ptr0.next = tmp;\\n      }\\n      ptr0 = ptr1;\\n      ptr1 = ptr0.next;\\n    }\\n    return dummy.next;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11573,
                "title": "share-my-java-recursive-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode temp = head;\\n        for (int i = 1; i < k && temp != null; i++, temp = temp.next);\\n        if (temp == null) return head;\\n        \\n        ListNode prev = reverseKGroup(temp.next, k);\\n        temp = head;\\n        while (k-- > 0) {\\n            ListNode post = temp.next;\\n            temp.next = prev;\\n            prev = temp;\\n            temp = post;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode temp = head;\\n        for (int i = 1; i < k && temp != null; i++, temp = temp.next);\\n        if (temp == null) return head;\\n        \\n        ListNode prev = reverseKGroup(temp.next, k);\\n        temp = head;\\n        while (k-- > 0) {\\n            ListNode post = temp.next;\\n            temp.next = prev;\\n            prev = temp;\\n            temp = post;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042248,
                "title": "c-solution-easy-to-understand",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode * reverse(ListNode * ptr, int &k, int size)\\n    {\\n        if(size < k) {\\n            return ptr;\\n        }\\n        if(ptr == NULL){\\n            return ptr;\\n        }\\n\\n        ListNode * cur = ptr;\\n        ListNode * temp = NULL;\\n        ListNode * pre = NULL;\\n        int cnt = 0;\\n        while(cur!=NULL && cnt < k)\\n        {\\n            temp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = temp;\\n            cnt++;\\n        }\\n\\n        ptr->next = reverse(temp,k,size-k);\\n        return pre;\\n    }\\n\\n    int func(ListNode * ptr)\\n    {\\n        int len = 0;\\n        while(ptr)\\n        {\\n            len++;\\n            ptr = ptr->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int n = func(head);\\n        return reverse(head,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode * reverse(ListNode * ptr, int &k, int size)\\n    {\\n        if(size < k) {\\n            return ptr;\\n        }\\n        if(ptr == NULL){\\n            return ptr;\\n        }\\n\\n        ListNode * cur = ptr;\\n        ListNode * temp = NULL;\\n        ListNode * pre = NULL;\\n        int cnt = 0;\\n        while(cur!=NULL && cnt < k)\\n        {\\n            temp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = temp;\\n            cnt++;\\n        }\\n\\n        ptr->next = reverse(temp,k,size-k);\\n        return pre;\\n    }\\n\\n    int func(ListNode * ptr)\\n    {\\n        int len = 0;\\n        while(ptr)\\n        {\\n            len++;\\n            ptr = ptr->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int n = func(head);\\n        return reverse(head,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010353,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "\\n# Approach\\nReverse k node at a time. \\nThen reduce Linked List size as size-k.\\nMake a recursive call for further nodes.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n// Reverse the node.\\n    ListNode * reverse(ListNode * ptr, int &k, int size)\\n    {\\n        if(size < k) return ptr;\\n        if(ptr == NULL) return ptr;\\n\\n        ListNode * cur = ptr, *temp = NULL, *pre = NULL;\\n        int cnt = 0;\\n        while(cur!=NULL && cnt < k)\\n        {\\n            temp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = temp;\\n            cnt++;\\n        }\\n\\n        ptr->next = reverse(temp,k,size-k);\\n        return pre;\\n    }\\n\\n// Find the length of the Linked List.\\n    int func(ListNode * ptr)\\n    {\\n        int len = 0;\\n        while(ptr)\\n        {\\n            len++;\\n            ptr = ptr->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int n = func(head);\\n        return reverse(head,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n// Reverse the node.\\n    ListNode * reverse(ListNode * ptr, int &k, int size)\\n    {\\n        if(size < k) return ptr;\\n        if(ptr == NULL) return ptr;\\n\\n        ListNode * cur = ptr, *temp = NULL, *pre = NULL;\\n        int cnt = 0;\\n        while(cur!=NULL && cnt < k)\\n        {\\n            temp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = temp;\\n            cnt++;\\n        }\\n\\n        ptr->next = reverse(temp,k,size-k);\\n        return pre;\\n    }\\n\\n// Find the length of the Linked List.\\n    int func(ListNode * ptr)\\n    {\\n        int len = 0;\\n        while(ptr)\\n        {\\n            len++;\\n            ptr = ptr->next;\\n        }\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int n = func(head);\\n        return reverse(head,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847909,
                "title": "step-by-step-recursive-c-code-with-elaborate-comments-for-better-understanding",
                "content": "# Intuition\\nThe problem requires reversing the nodes of a linked list in groups of size k. To do this, we can use a recursive approach where we reverse the first k nodes, then recursively call the function on the remaining linked list. We keep track of the previous and next nodes while reversing the current group, and the head of the reversed list is returned at each recursion level.\\n\\n# Approach\\n# \\n\\n1. Function definition: **`reverseKGroup(head, k)`**\\n2. Base case:\\n    - If the **`head`** is NULL (empty list), return NULL to indicate an empty list.\\n3. Check if the current group has enough nodes to reverse:\\n    - Traverse **`k`** nodes from the **`head`** and count the number of nodes in the current group.\\n    - If the count is less than **`k`**, it means the current group does not have enough nodes to reverse, so return the **`head`** of the group as it is.\\n4. Initialize three pointers:\\n    - **`prev`**: Points to the previous node (initially set to NULL).\\n    - **`next`**: Points to the next node (initially set to NULL).\\n    - **`curr`**: Points to the current node (initially set to **`head`**).\\n5. Reverse the current group of **`k`** nodes using a while loop:\\n    - Inside the loop, do the following k times:\\n        - Update **`next`** to **`curr->next`**.\\n        - Set **`curr->next`** to **`prev`**.\\n        - Move **`prev`** and **`curr`** to their respective next nodes.\\n    - After the loop, the current group of **`k`** nodes is reversed.\\n6. Check if there are more nodes left in the list (**`next != NULL`**):\\n    - If there are more nodes, make a recursive call to **`reverseKGroup`** with **`next`** as the new **`head`** and **`k`** as the group size.\\n    - This handles the remaining linked list and continues reversing groups until the end.\\n7. Return the **`prev`** pointer:\\n    - The **`prev`** pointer now points to the new head of the reversed list.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // base case\\n        if (head == NULL) return NULL;\\n\\n        // step 1: reverse first k nodes\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n\\n        // count the number of nodes in the current group\\n        while (curr != NULL && count < k) {\\n            curr = curr->next;\\n            count++;\\n        }\\n\\n        // if the current group has less than k nodes, no need to reverse, return the head as it is\\n        if (count < k) {\\n            return head;\\n        }\\n\\n        curr = head;\\n        count = 0;\\n\\n        while (curr != NULL && count < k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // step 2: recursive call for the remaining linked list\\n        if (next != NULL) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // step 3: return head of the reversed list\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // base case\\n        if (head == NULL) return NULL;\\n\\n        // step 1: reverse first k nodes\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n\\n        // count the number of nodes in the current group\\n        while (curr != NULL && count < k) {\\n            curr = curr->next;\\n            count++;\\n        }\\n\\n        // if the current group has less than k nodes, no need to reverse, return the head as it is\\n        if (count < k) {\\n            return head;\\n        }\\n\\n        curr = head;\\n        count = 0;\\n\\n        while (curr != NULL && count < k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // step 2: recursive call for the remaining linked list\\n        if (next != NULL) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n\\n        // step 3: return head of the reversed list\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649799,
                "title": "best-solution-using-stack-20ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->store the values of nodes till k in a stack and add them back again into the list by popping them using two temp ptrs.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        stack<int> st;\\n        ListNode* temp1=head;\\n        ListNode* temp2=head;\\n        int n = 0;\\n        while(temp1!=NULL){\\n            n++;\\n            temp1=temp1->next;\\n        }\\n        temp1=head;\\n\\n        int i =0;\\n        while(i<n){\\n            if(n-i>=k){\\n                for(int r=0;r<k;r++){\\n                    st.push(temp1->val);\\n                    temp1=temp1->next;\\n                }\\n                for(int l=0;l<k;l++){\\n                    temp2->val=st.top();\\n                    st.pop();\\n                    temp2=temp2->next;\\n                }\\n                i+=k;\\n            }\\n            else{\\n                return head;\\n            }\\n          \\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        stack<int> st;\\n        ListNode* temp1=head;\\n        ListNode* temp2=head;\\n        int n = 0;\\n        while(temp1!=NULL){\\n            n++;\\n            temp1=temp1->next;\\n        }\\n        temp1=head;\\n\\n        int i =0;\\n        while(i<n){\\n            if(n-i>=k){\\n                for(int r=0;r<k;r++){\\n                    st.push(temp1->val);\\n                    temp1=temp1->next;\\n                }\\n                for(int l=0;l<k;l++){\\n                    temp2->val=st.top();\\n                    st.pop();\\n                    temp2=temp2->next;\\n                }\\n                i+=k;\\n            }\\n            else{\\n                return head;\\n            }\\n          \\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572472,
                "title": "easy-solution-using-recursion-in-java",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode temp=head;\\n        for(int i=0;i<k;i++){\\n            if(temp==null){\\n                return head;\\n            }\\n            temp=temp.next;\\n        }\\n        ListNode sp=reverseKGroup(temp,k);\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        for(int i=0;i<k;i++){\\n            ListNode after =curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=after;\\n        }\\n        head.next=sp;\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode temp=head;\\n        for(int i=0;i<k;i++){\\n            if(temp==null){\\n                return head;\\n            }\\n            temp=temp.next;\\n        }\\n        ListNode sp=reverseKGroup(temp,k);\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        for(int i=0;i<k;i++){\\n            ListNode after =curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=after;\\n        }\\n        head.next=sp;\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369195,
                "title": "my-solution-using-reverse-and-link",
                "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def link(self,a,b):\\n        r=a\\n        while a.next:\\n            a=a.next\\n        a.next=b\\n\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        h=head\\n        nh=head\\n        if head == None:\\n            return None\\n        while h.next!=None:\\n            second=nh\\n            nh=h.next \\n            h.next=nh.next\\n            nh.next=second            \\n        return nh\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        heads=[]\\n        count=0\\n        x=head\\n        while x:\\n            if count%k==0:\\n                heads.append(x)\\n            x=x.next\\n            count+=1\\n        last=None\\n        if count%k!=0:\\n            last=heads.pop()\\n        newheads=[]\\n        for i in heads:\\n            c=0\\n            t=i\\n            while c<k-1:\\n                i=i.next\\n                c+=1\\n            i.next=None\\n            newheads.append(t)\\n        reverse=[]\\n        for i in newheads:\\n            reverse.append(self.reverseList(i))\\n        print(reverse)\\n        self.link(reverse[-1],last)\\n        for i in range(len(reverse)-2,-1,-1):\\n            self.link(reverse[i],reverse[i+1])\\n        return reverse[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def link(self,a,b):\\n        r=a\\n        while a.next:\\n            a=a.next\\n        a.next=b\\n\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        h=head\\n        nh=head\\n        if head == None:\\n            return None\\n        while h.next!=None:\\n            second=nh\\n            nh=h.next \\n            h.next=nh.next\\n            nh.next=second            \\n        return nh\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        heads=[]\\n        count=0\\n        x=head\\n        while x:\\n            if count%k==0:\\n                heads.append(x)\\n            x=x.next\\n            count+=1\\n        last=None\\n        if count%k!=0:\\n            last=heads.pop()\\n        newheads=[]\\n        for i in heads:\\n            c=0\\n            t=i\\n            while c<k-1:\\n                i=i.next\\n                c+=1\\n            i.next=None\\n            newheads.append(t)\\n        reverse=[]\\n        for i in newheads:\\n            reverse.append(self.reverseList(i))\\n        print(reverse)\\n        self.link(reverse[-1],last)\\n        for i in range(len(reverse)-2,-1,-1):\\n            self.link(reverse[i],reverse[i+1])\\n        return reverse[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284555,
                "title": "java-o-n-time-and-o-1-space",
                "content": "```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int n = 0;\\n        ListNode temp = head;\\n        while(temp != null){\\n            temp  = temp.next;\\n            n++;\\n        }\\n        ListNode ddfd = new ListNode(3423);\\n        ddfd.next = head;\\n        ListNode firstNode = ddfd;\\n        ListNode tempNode = head;\\n        int ptr = 1;\\n        int kptr = 1;\\n        ListNode cur = head;\\n        ListNode prev = null;\\n        if(k == 1) return ddfd.next;\\n        while(cur != null){\\n            ListNode next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n           // tempNode.next = null;\\n            if(kptr == k){\\n                firstNode.next = prev;\\n                firstNode = tempNode;\\n                firstNode.next = null;\\n                tempNode = cur;\\n                kptr = 0;\\n                if(ptr + k > n ){\\n                    firstNode.next = cur;\\n                    //System.out.println(\"breaked \" + ptr + \" \" + firstNode.val);\\n                    return ddfd.next;\\n                }\\n            }\\n            \\n            ptr++;\\n            kptr++;\\n        }\\n        return ddfd.next;\\n    }\\n    \\n}\\n```\\n# Please UpVote, If Found Useful :)",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int n = 0;\\n        ListNode temp = head;\\n        while(temp != null){\\n            temp  = temp.next;\\n            n++;\\n        }\\n        ListNode ddfd = new ListNode(3423);\\n        ddfd.next = head;\\n        ListNode firstNode = ddfd;\\n        ListNode tempNode = head;\\n        int ptr = 1;\\n        int kptr = 1;\\n        ListNode cur = head;\\n        ListNode prev = null;\\n        if(k == 1) return ddfd.next;\\n        while(cur != null){\\n            ListNode next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n           // tempNode.next = null;\\n            if(kptr == k){\\n                firstNode.next = prev;\\n                firstNode = tempNode;\\n                firstNode.next = null;\\n                tempNode = cur;\\n                kptr = 0;\\n                if(ptr + k > n ){\\n                    firstNode.next = cur;\\n                    //System.out.println(\"breaked \" + ptr + \" \" + firstNode.val);\\n                    return ddfd.next;\\n                }\\n            }\\n            \\n            ptr++;\\n            kptr++;\\n        }\\n        return ddfd.next;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284421,
                "title": "c-solution-with-iterative-approach",
                "content": "# Intuition\\nWe can traverse the Linked List in the group of `k` by traversing the List if `k` nodes are present in the further groups. In the end we can return the new head by putting it at the last node of first group.\\n\\n\\n\\n# Approach\\n1. We count the `length` of the whole list by iterating once over the list.\\n2. Then traverse the list `length/k` times to reverse the groups in `k` and by not reversing the nodes in the group remaining with less number of nodes than `k`.\\n3. Now after the reversal of first group of with `k` nodes we will have new head which is `prev` in this code. Here, we maintain one `bool isFirstGrp` to check if it is the first group or not, if it is than we assign `head` with the `prev`.\\n4. With another while loop which runs for `k` times for each group we perform the actual reverse operation.\\n5. After reversing the `k` nodes we attach the reversed node to the next remaning list by `firstOfPrev->next=prev`.\\n6. After traversing `length/k` times if there is one group of nodes with number of nodes less than `k` we will attach that list to the last reversed list with `firstOfPrev->next=curr` and will return `head`.\\n\\n# Complexity\\n- Time complexity:\\nIf there are \\'n\\' the given list then the for loop runs for $$O(n/k)$$ times and inner while loop runs for $$O(k)$$ times. n/k * k = n. Therefore, time complexity will be $$O(n)$$.\\n- Space complexity:\\nOnly constant space is used, therefore, space complexity = $$O(1)$$.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        int length=0;\\n\\n        //find length of the list\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            length++;\\n        }\\n\\n        bool isFirstGrp=1;                    \\n        ListNode* curr=head;\\n        ListNode* firstOfPrev=NULL;\\n        for(int i=0;i<length/k;i++){\\n            ListNode* prev=NULL;\\n            ListNode* first=curr;\\n            int cnt=0;\\n            //reversing the list with \\'k\\' nodes\\n            while(curr!=NULL && cnt<k){\\n                ListNode* next=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=next;\\n                cnt++;\\n            }\\n            //If its first group \\'head\\' will be \\'prev\\'\\n            if(isFirstGrp){\\n                head=prev;\\n                isFirstGrp=0;\\n            }\\n            else{\\n                //attaching the reversed list with the remaining list\\n                firstOfPrev->next=prev;\\n            }\\n            firstOfPrev=first;\\n            //if its the last group with \\'k\\' nodes connecting\\n            //it with the remaining nodes less than \\'k\\'\\n            firstOfPrev->next=curr;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\nUPVOTE :)",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        int length=0;\\n\\n        //find length of the list\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            length++;\\n        }\\n\\n        bool isFirstGrp=1;                    \\n        ListNode* curr=head;\\n        ListNode* firstOfPrev=NULL;\\n        for(int i=0;i<length/k;i++){\\n            ListNode* prev=NULL;\\n            ListNode* first=curr;\\n            int cnt=0;\\n            //reversing the list with \\'k\\' nodes\\n            while(curr!=NULL && cnt<k){\\n                ListNode* next=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=next;\\n                cnt++;\\n            }\\n            //If its first group \\'head\\' will be \\'prev\\'\\n            if(isFirstGrp){\\n                head=prev;\\n                isFirstGrp=0;\\n            }\\n            else{\\n                //attaching the reversed list with the remaining list\\n                firstOfPrev->next=prev;\\n            }\\n            firstOfPrev=first;\\n            //if its the last group with \\'k\\' nodes connecting\\n            //it with the remaining nodes less than \\'k\\'\\n            firstOfPrev->next=curr;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068608,
                "title": "c-easy-and-fast-recursive-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool length(ListNode* head, int k)\\n    {\\n        while(k and head)\\n        {\\n            head = head->next;\\n            k--;\\n        }\\n        return k==0;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *curr = head, *prev=NULL, *forward, *first = head;\\n        if(k==1) return head;\\n        if(!length(head, k)) return head;\\n\\n        for(int i=0;i<k;i++)\\n        {\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        // curr->next = NULL;\\n        head = prev;\\n        first->next = reverseKGroup(forward, k);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool length(ListNode* head, int k)\\n    {\\n        while(k and head)\\n        {\\n            head = head->next;\\n            k--;\\n        }\\n        return k==0;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *curr = head, *prev=NULL, *forward, *first = head;\\n        if(k==1) return head;\\n        if(!length(head, k)) return head;\\n\\n        for(int i=0;i<k;i++)\\n        {\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        // curr->next = NULL;\\n        head = prev;\\n        first->next = reverseKGroup(forward, k);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056035,
                "title": "c-easy-and-clean-solution-with-comments-recursive-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // Base condition\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n\\n        // Three pointer approach\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward;\\n\\n        // Check whether \\'k\\' no. of nodes present in list or not\\n        if(!possible(head, k)){\\n            return head;\\n        }\\n\\n        // Reverse first \\'K\\' Nodes\\n        for(int i=0; i<k; i++){\\n            forward = curr->next;\\n\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n\\n            if(curr == NULL){\\n                return prev;\\n            }\\n        }\\n\\n        // Connect first \\'K\\' nodes with rest of the list\\n        head -> next = reverseKGroup(curr, k);\\n\\n        return prev;\\n    }\\n\\n    bool possible(ListNode* head, int k){\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n        while(temp != NULL){\\n            temp=temp->next;\\n            length++;\\n\\n            // If at any point, length become greater than K, then return true\\n            if(length >= k){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        // Base condition\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n\\n        // Three pointer approach\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward;\\n\\n        // Check whether \\'k\\' no. of nodes present in list or not\\n        if(!possible(head, k)){\\n            return head;\\n        }\\n\\n        // Reverse first \\'K\\' Nodes\\n        for(int i=0; i<k; i++){\\n            forward = curr->next;\\n\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n\\n            if(curr == NULL){\\n                return prev;\\n            }\\n        }\\n\\n        // Connect first \\'K\\' nodes with rest of the list\\n        head -> next = reverseKGroup(curr, k);\\n\\n        return prev;\\n    }\\n\\n    bool possible(ListNode* head, int k){\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n        while(temp != NULL){\\n            temp=temp->next;\\n            length++;\\n\\n            // If at any point, length become greater than K, then return true\\n            if(length >= k){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676238,
                "title": "c-recursive-solution",
                "content": "```\\n//Recursive Solution\\n\\n//Function for finding length of a node\\nint getLength(ListNode *head)\\n{\\n    int count = 0;\\n    while (head)\\n    {\\n        count++;\\n        head = head->next;\\n    }\\n    return count;\\n}\\n\\n\\nListNode* ReverseList(ListNode *head, int k, int length)\\n{\\n\\n   \\t//Base case \\n    if (length < k) return head;\\n\\n   \\t//step 1 -> reverse first k element\\n    ListNode *previous = NULL;\\n    ListNode *current = head;\\n    ListNode *forward = NULL;\\n    int count = 0;\\n\\n    while ((current != NULL) && (count < k))\\n    {\\n        forward = current->next;\\n        current->next = previous;\\n\\n       \\t// 1 step sabhi ko aage badhaoo\\n        previous = current;\\n        current = forward;\\n        count++;\\n    }\\n\\n   \\t//Step 2 -> Make a recursive call if node is avilable after k\\n\\n    if (forward != NULL)\\n    {\\n        head->next = ReverseList(forward, k, length - k);\\n    }\\n\\n   \\t//step 3 -> return previous beacuse eventually our previous become head of given Node\\n    return previous;\\n}\\n\\n\\nclass Solution\\n{\\n    public:\\n        ListNode* reverseKGroup(ListNode *head, int k)\\n        {\\n            int length = getLength(head);\\n            return ReverseList(head, k, length);\\n        }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//Recursive Solution\\n\\n//Function for finding length of a node\\nint getLength(ListNode *head)\\n{\\n    int count = 0;\\n    while (head)\\n    {\\n        count++;\\n        head = head->next;\\n    }\\n    return count;\\n}\\n\\n\\nListNode* ReverseList(ListNode *head, int k, int length)\\n{\\n\\n   \\t//Base case \\n    if (length < k) return head;\\n\\n   \\t//step 1 -> reverse first k element\\n    ListNode *previous = NULL;\\n    ListNode *current = head;\\n    ListNode *forward = NULL;\\n    int count = 0;\\n\\n    while ((current != NULL) && (count < k))\\n    {\\n        forward = current->next;\\n        current->next = previous;\\n\\n       \\t// 1 step sabhi ko aage badhaoo\\n        previous = current;\\n        current = forward;\\n        count++;\\n    }\\n\\n   \\t//Step 2 -> Make a recursive call if node is avilable after k\\n\\n    if (forward != NULL)\\n    {\\n        head->next = ReverseList(forward, k, length - k);\\n    }\\n\\n   \\t//step 3 -> return previous beacuse eventually our previous become head of given Node\\n    return previous;\\n}\\n\\n\\nclass Solution\\n{\\n    public:\\n        ListNode* reverseKGroup(ListNode *head, int k)\\n        {\\n            int length = getLength(head);\\n            return ReverseList(head, k, length);\\n        }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616355,
                "title": "c-solution-easily-understandable-well-commented",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseList(struct ListNode* head)\\n{\\n    struct ListNode *prev = NULL, *curr = head, *nxt = NULL;\\n    \\n    while (curr != NULL) {\\n        nxt = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = nxt;\\n    }\\n    \\n    return prev;\\n}\\n\\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    // return head if there is 0/1 element in the list \\n    if (head == NULL || head->next == NULL)\\n        return head;\\n    \\n    struct ListNode *curr = head, *prev = head, *nxt = NULL;\\n    struct ListNode *lastTail = NULL, *retHead = NULL;\\n    struct ListNode *reverse = NULL;\\n    \\n    while (curr != NULL) {\\n        /*\\n\\t\\t * create a k-distance between the prev and curr node\\n\\t\\t * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL\\n\\t\\t * further we reverse the sub-list 1->2->3\\n\\t\\t */\\n        for (int i = 0; i < k - 1 && curr != NULL; i++)\\n            curr = curr->next;\\n        /*\\n         * if the curr has reached the end-point, \\n         * then there aren\\'t enough k-elements to\\n         * to reverse k-groups => Leaving the rest of\\n         * the list as it is\\n         */\\n        if (curr == NULL)\\n            return retHead;\\n        \\n        nxt = curr->next;\\n        curr->next = NULL;\\n        \\n        // reverse the elemnts in the k-group\\n        reverse = reverseList(prev);\\n        \\n        // keep track of the head node to be returned.\\n        if (retHead == NULL)\\n            retHead = reverse;\\n        \\n        // keep a track of the tail of the previously reversed k-group set\\n        if (lastTail != NULL)\\n            lastTail->next = reverse;\\n        lastTail = prev;\\n        \\n        // updating all pointers for the next set of k-group\\n        prev->next = nxt;\\n        curr = nxt;\\n        prev = curr;\\n    }\\n    \\n    return retHead;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseList(struct ListNode* head)\\n{\\n    struct ListNode *prev = NULL, *curr = head, *nxt = NULL;\\n    \\n    while (curr != NULL) {\\n        nxt = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = nxt;\\n    }\\n    \\n    return prev;\\n}\\n\\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    // return head if there is 0/1 element in the list \\n    if (head == NULL || head->next == NULL)\\n        return head;\\n    \\n    struct ListNode *curr = head, *prev = head, *nxt = NULL;\\n    struct ListNode *lastTail = NULL, *retHead = NULL;\\n    struct ListNode *reverse = NULL;\\n    \\n    while (curr != NULL) {\\n        /*\\n\\t\\t * create a k-distance between the prev and curr node\\n\\t\\t * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL\\n\\t\\t * further we reverse the sub-list 1->2->3\\n\\t\\t */\\n        for (int i = 0; i < k - 1 && curr != NULL; i++)\\n            curr = curr->next;\\n        /*\\n         * if the curr has reached the end-point, \\n         * then there aren\\'t enough k-elements to\\n         * to reverse k-groups => Leaving the rest of\\n         * the list as it is\\n         */\\n        if (curr == NULL)\\n            return retHead;\\n        \\n        nxt = curr->next;\\n        curr->next = NULL;\\n        \\n        // reverse the elemnts in the k-group\\n        reverse = reverseList(prev);\\n        \\n        // keep track of the head node to be returned.\\n        if (retHead == NULL)\\n            retHead = reverse;\\n        \\n        // keep a track of the tail of the previously reversed k-group set\\n        if (lastTail != NULL)\\n            lastTail->next = reverse;\\n        lastTail = prev;\\n        \\n        // updating all pointers for the next set of k-group\\n        prev->next = nxt;\\n        curr = nxt;\\n        prev = curr;\\n    }\\n    \\n    return retHead;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2166263,
                "title": "simple-java-solution-iterative-easy-to-understand-100-accepted",
                "content": "```\\n// Appraoch: Traverse the list and cut the list of k size and reverse it an so on.\\n\\npublic ListNode reverse(ListNode head){\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(curr != null){\\n            ListNode forw = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forw;\\n        }\\n        return prev;\\n    }\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head == null || head.next == null || k < 0)\\n            return head;\\n        ListNode curr = head;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode dp = dummy;\\n        \\n        while(curr != null){\\n            ListNode forw = curr;\\n            int temp = k;\\n            ListNode nhead;\\n            while(temp-- > 1 && forw != null){\\n                forw = forw.next;\\n            }\\n            if(forw != null){\\n                nhead = forw.next;\\n                forw.next = null;\\n            }else{\\n                break;\\n            }\\n            dp.next = reverse(curr);\\n            while(dp.next != null)\\n                dp = dp.next;\\n            curr = nhead;\\n        }\\n        dp.next = curr;\\n        return dummy.next;\\n    }\\n\\n**All suggestions are honoured**\\n\\n**UPVOTE IF YOU LIKE IT **",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n// Appraoch: Traverse the list and cut the list of k size and reverse it an so on.\\n\\npublic ListNode reverse(ListNode head){\\n        if(head == null || head.next == null)\\n            return head;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(curr != null){\\n            ListNode forw = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forw;\\n        }\\n        return prev;\\n    }\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head == null || head.next == null || k < 0)\\n            return head;\\n        ListNode curr = head;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode dp = dummy;\\n        \\n        while(curr != null){\\n            ListNode forw = curr;\\n            int temp = k;\\n            ListNode nhead;\\n            while(temp-- > 1 && forw != null){\\n                forw = forw.next;\\n            }\\n            if(forw != null){\\n                nhead = forw.next;\\n                forw.next = null;\\n            }else{\\n                break;\\n            }\\n            dp.next = reverse(curr);\\n            while(dp.next != null)\\n                dp = dp.next;\\n            curr = nhead;\\n        }\\n        dp.next = curr;\\n        return dummy.next;\\n    }\\n\\n**All suggestions are honoured**\\n\\n**UPVOTE IF YOU LIKE IT **",
                "codeTag": "Unknown"
            },
            {
                "id": 2154889,
                "title": "java-0ms-100-faster-easy-solution",
                "content": "# Please Upvote IF You Find This Helpful\\n![image](https://assets.leetcode.com/users/images/eaeceec3-5d52-4977-9f28-02b1662e5ead_1655296087.9395077.png)\\n```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k == 1) return head;\\n        int count = 1;\\n        ListNode node = head, tempHead = head, tempPrev = null;\\n        while (node != null) {\\n            if (count == k) {\\n                ListNode tempLast = node.next;\\n                node.next = null;\\n                if (tempHead == head) head = reverseList(tempHead);\\n                else tempPrev.next = reverseList(tempHead);\\n                tempHead.next = tempLast;\\n                tempPrev = node = tempHead;\\n                tempHead = tempHead.next;\\n                count = 0;\\n            }\\n            count++;\\n            node = node.next;\\n        }\\n        return head;\\n    }\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next = curr == null ? null : head.next;\\n        while (curr != null) {\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            next = next == null ? next  : next.next;\\n        }\\n        return prev;\\n    }\\n}\\n```\\n# Please Upvote IF You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (head == null || head.next == null || k == 1) return head;\\n        int count = 1;\\n        ListNode node = head, tempHead = head, tempPrev = null;\\n        while (node != null) {\\n            if (count == k) {\\n                ListNode tempLast = node.next;\\n                node.next = null;\\n                if (tempHead == head) head = reverseList(tempHead);\\n                else tempPrev.next = reverseList(tempHead);\\n                tempHead.next = tempLast;\\n                tempPrev = node = tempHead;\\n                tempHead = tempHead.next;\\n                count = 0;\\n            }\\n            count++;\\n            node = node.next;\\n        }\\n        return head;\\n    }\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next = curr == null ? null : head.next;\\n        while (curr != null) {\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            next = next == null ? next  : next.next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051653,
                "title": "java-super-easy-code-100-fast",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        \\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode temp = head;\\n        \\n        int count = 0;  // to only execute the reverse function for k times\\n        \\n        // check if there are enough elements ahead for k to run\\n        \\n        int check = k;\\n        \\n        while(check != 0)\\n        {\\n            if(temp == null)\\n            {\\n                return head;\\n            }\\n            temp = temp.next;\\n            check--;\\n        }\\n        \\n        while(curr != null && count < k)\\n        {\\n            temp = curr.next;\\n            \\n            curr.next = prev;\\n            \\n            prev = curr;\\n            curr = temp;\\n            \\n            count++;\\n        }\\n        \\n        if(temp != null)\\n        {\\n            head.next = reverseKGroup(temp, k);    // it will attach the head to the head of the newly transformed (reversed) linked list\\n        }\\n        \\n        return prev;    // the reason of returning this prev is - how internally the recursion function call works\\n        \\n        // Consider an example of 1->2->3->4 with k = 2\\n        // after the reverse in first iteration we will get \\n        // null<-1-<2    3->4->null\\n        // here prev = 2, and head = 1\\n        // now after second iteration - with the head.next part\\n        // 2->1->4->3\\n        // in second iteration prev = 4, and head = 3\\n        // but, in the case of recursion - when we return them it takes its parent value which was originally 2\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        \\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode temp = head;\\n        \\n        int count = 0;  // to only execute the reverse function for k times\\n        \\n        // check if there are enough elements ahead for k to run\\n        \\n        int check = k;\\n        \\n        while(check != 0)\\n        {\\n            if(temp == null)\\n            {\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1776121,
                "title": "best-solution-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\n\\t    // base case\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\t\\t\\n        //checking for reversing or not \\n        ListNode* temp=head;\\n        int cnt=0;\\n        while(temp!=NULL && cnt<k){\\n            temp = temp->next;\\n            cnt++;\\n        }\\n        \\n        if(cnt!=k)\\n            return head;\\n        \\n        //reversing in the window of size k\\n        ListNode* curr=head;\\n        ListNode* next = NULL;\\n        ListNode* prev=NULL;\\n        int count =0;\\n        \\n        while(curr!=NULL && count<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            count++;\\n        }\\n        \\n\\t\\t//recursion call\\n        if(next!=NULL){\\n              head->next = reverseKGroup(next,k);\\n        }\\n\\n        return prev;\\n    }\\n};\\n```\\n\\n# ****PLEASE UPVOTE",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\t\\n\\t    // base case\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\t\\t\\n        //checking for reversing or not \\n        ListNode* temp=head;\\n        int cnt=0;\\n        while(temp!=NULL && cnt<k){\\n            temp = temp->next;\\n            cnt++;\\n        }\\n        \\n        if(cnt!=k)\\n            return head;\\n        \\n        //reversing in the window of size k\\n        ListNode* curr=head;\\n        ListNode* next = NULL;\\n        ListNode* prev=NULL;\\n        int count =0;\\n        \\n        while(curr!=NULL && count<k){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            count++;\\n        }\\n        \\n\\t\\t//recursion call\\n        if(next!=NULL){\\n              head->next = reverseKGroup(next,k);\\n        }\\n\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248374,
                "title": "javascript-iterative",
                "content": "```\\nvar reverseKGroup = function (head, k) {\\n    const reverseNextKNodes = (head, k) => {\\n        let tempHead = head;\\n        for (let i = 0; i < k; i++) {\\n            if (tempHead.next === null) {\\n                return tempHead;\\n            }\\n            tempHead = tempHead.next;\\n        }\\n\\n        let nodeFirst = head.next;\\n        let prevNode = head;\\n        let currentNode = nodeFirst;\\n        for (let i = 0; i < k; i++) {\\n            let temp = currentNode.next;\\n            currentNode.next = prevNode;\\n            prevNode = currentNode;\\n            currentNode = temp;\\n        }\\n\\n        nodeFirst.next = currentNode;\\n        head.next = prevNode;\\n\\n        return nodeFirst;\\n    }\\n\\n    if (head === null || k <= 1) {\\n        return head;\\n    }\\n\\n    const tempNode = new ListNode(0);\\n    tempNode.next = head;\\n\\n    head = tempNode;\\n    while (head.next !== null) {\\n        head = reverseNextKNodes(head, k);\\n    }\\n\\n    return tempNode.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar reverseKGroup = function (head, k) {\\n    const reverseNextKNodes = (head, k) => {\\n        let tempHead = head;\\n        for (let i = 0; i < k; i++) {\\n            if (tempHead.next === null) {\\n                return tempHead;\\n            }\\n            tempHead = tempHead.next;\\n        }\\n\\n        let nodeFirst = head.next;\\n        let prevNode = head;\\n        let currentNode = nodeFirst;\\n        for (let i = 0; i < k; i++) {\\n            let temp = currentNode.next;\\n            currentNode.next = prevNode;\\n            prevNode = currentNode;\\n            currentNode = temp;\\n        }\\n\\n        nodeFirst.next = currentNode;\\n        head.next = prevNode;\\n\\n        return nodeFirst;\\n    }\\n\\n    if (head === null || k <= 1) {\\n        return head;\\n    }\\n\\n    const tempNode = new ListNode(0);\\n    tempNode.next = head;\\n\\n    head = tempNode;\\n    while (head.next !== null) {\\n        head = reverseNextKNodes(head, k);\\n    }\\n\\n    return tempNode.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128578,
                "title": "best-self-explanatory-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int count = 0;\\n        ListNode *curr = head;\\n        ListNode *prev = nullptr;\\n        ListNode *next = nullptr;\\n        \\n        ListNode *pCrawl = head;\\n        \\n        while(pCrawl) {\\n            count++;\\n            pCrawl = pCrawl->next;\\n        }\\n        \\n        if(count < k) return curr;\\n        else count = 0;\\n        \\n        while(count < k && curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        if(next) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int count = 0;\\n        ListNode *curr = head;\\n        ListNode *prev = nullptr;\\n        ListNode *next = nullptr;\\n        \\n        ListNode *pCrawl = head;\\n        \\n        while(pCrawl) {\\n            count++;\\n            pCrawl = pCrawl->next;\\n        }\\n        \\n        if(count < k) return curr;\\n        else count = 0;\\n        \\n        while(count < k && curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        if(next) {\\n            head->next = reverseKGroup(next, k);\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529672,
                "title": "javascript-with-comments-easy-understand-by-iteration-and-recursion",
                "content": "```javascript\\n/**\\n * 25. Reverse Nodes in k-Group\\n * https://leetcode.com/problems/reverse-nodes-in-k-group/\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nconst reverseKGroup = (head, k) => {\\n  if (head === null) return head\\n  // define startNode and endNode\\n  let start = head, end = head\\n  \\n  // return self if linked list\\'s length is smaller than k\\n  for (let i = 0; i < k; i++) {\\n    if (end === null) return head\\n    end = end.next\\n  }\\n  // reverse from startNode to endNode\\n  let newHead = reverse(start, end)\\n  // recursive the rest nodes and concat the result\\n  start.next = reverseKGroup(end, k)\\n  return newHead\\n};\\n\\n// reverse from startNode to endNode\\nconst reverse = (start, end) => {\\n  let [prev, curr] = [null, start]\\n  while (curr != end) [curr.next, prev, curr] = [prev, curr, curr.next]\\n  return prev\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```javascript\\n/**\\n * 25. Reverse Nodes in k-Group\\n * https://leetcode.com/problems/reverse-nodes-in-k-group/\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nconst reverseKGroup = (head, k) => {\\n  if (head === null) return head\\n  // define startNode and endNode\\n  let start = head, end = head\\n  \\n  // return self if linked list\\'s length is smaller than k\\n  for (let i = 0; i < k; i++) {\\n    if (end === null) return head\\n    end = end.next\\n  }\\n  // reverse from startNode to endNode\\n  let newHead = reverse(start, end)\\n  // recursive the rest nodes and concat the result\\n  start.next = reverseKGroup(end, k)\\n  return newHead\\n};\\n\\n// reverse from startNode to endNode\\nconst reverse = (start, end) => {\\n  let [prev, curr] = [null, start]\\n  while (curr != end) [curr.next, prev, curr] = [prev, curr, curr.next]\\n  return prev\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389483,
                "title": "easy-to-understand-iterative-way-in-java-with-detailed-comments",
                "content": "```\\n\\tpublic class ListNode {\\n\\t\\tint val;\\n\\t\\tListNode next;\\n\\n\\t\\tListNode(int x) {\\n\\t\\t\\tval = x;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"ListNode [val=\" + val + \", next=\" + next + \"]\";\\n\\t\\t}\\n\\n\\t}\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n                \\n        ListNode preOfGroupHead = dummy;\\n        ListNode groupHead = head; // the head node in this group\\n        ListNode groupNode = head; // the node that is used for traversal in this group\\n        ListNode groupTail = head; // the tail node in this group\\n\\n        while(true){\\n            int count = 1;\\n            while(count <= k && groupNode != null){ // if a group of K nodes have been traversed\\n                groupTail = groupNode;\\n                groupNode = groupNode.next;\\n                count ++;\\n            }\\n                        \\n            if(count <= k){ // a group has less then k nodes, aka the last group\\n                break;\\n            }\\n            \\n            // now, groupTail is the tail of current group\\n            // groupNode is the head of next group\\n            \\n            // preOfGroupHead -> (groupHead -> ... -> groupTail) -> groupNode\\n            reverseK(groupHead, k);\\n            \\n            // preOfGroupHead ? groupTail -> ... -> groupHead ? groupNode\\n            \\n            preOfGroupHead.next = groupTail;\\n            groupHead.next = groupNode;\\n            \\n            // preOfGroupHead -> groupTail -> ... -> groupHead -> groupNode\\n            preOfGroupHead = groupHead;\\n            groupHead = groupNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    /**\\n     * Reverse k linked nodes from head \\n     * this method returns nothing, because we\\'ve got left node and right node of the reversed part\\n     * @param head\\n     * @param k\\n     */\\n    private void reverseK(ListNode head, int k){\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(k > 0){\\n            ListNode tmpNext = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmpNext;\\n            k --;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n\\tpublic class ListNode {\\n\\t\\tint val;\\n\\t\\tListNode next;\\n\\n\\t\\tListNode(int x) {\\n\\t\\t\\tval = x;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"ListNode [val=\" + val + \", next=\" + next + \"]\";\\n\\t\\t}\\n\\n\\t}\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n                \\n        ListNode preOfGroupHead = dummy;\\n        ListNode groupHead = head; // the head node in this group\\n        ListNode groupNode = head; // the node that is used for traversal in this group\\n        ListNode groupTail = head; // the tail node in this group\\n\\n        while(true){\\n            int count = 1;\\n            while(count <= k && groupNode != null){ // if a group of K nodes have been traversed\\n                groupTail = groupNode;\\n                groupNode = groupNode.next;\\n                count ++;\\n            }\\n                        \\n            if(count <= k){ // a group has less then k nodes, aka the last group\\n                break;\\n            }\\n            \\n            // now, groupTail is the tail of current group\\n            // groupNode is the head of next group\\n            \\n            // preOfGroupHead -> (groupHead -> ... -> groupTail) -> groupNode\\n            reverseK(groupHead, k);\\n            \\n            // preOfGroupHead ? groupTail -> ... -> groupHead ? groupNode\\n            \\n            preOfGroupHead.next = groupTail;\\n            groupHead.next = groupNode;\\n            \\n            // preOfGroupHead -> groupTail -> ... -> groupHead -> groupNode\\n            preOfGroupHead = groupHead;\\n            groupHead = groupNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    /**\\n     * Reverse k linked nodes from head \\n     * this method returns nothing, because we\\'ve got left node and right node of the reversed part\\n     * @param head\\n     * @param k\\n     */\\n    private void reverseK(ListNode head, int k){\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(k > 0){\\n            ListNode tmpNext = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmpNext;\\n            k --;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313274,
                "title": "c-sol-beats-100-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* ptr = head, *nptr = NULL, *pptr = NULL;\\n        int count = 0;\\n        int size = 0;\\n        while(ptr){\\n            ptr = ptr->next;\\n            size++;\\n        }\\n        if(size < k){\\n            return head;\\n        }\\n        ptr = head;\\n        while(ptr && count < k){\\n            nptr = ptr->next;\\n            ptr->next = pptr;\\n            pptr = ptr;\\n            ptr = nptr;\\n            count++;\\n        }\\n        if(nptr != NULL)\\n            head->next = reverseKGroup(nptr, k);\\n        return pptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* ptr = head, *nptr = NULL, *pptr = NULL;\\n        int count = 0;\\n        int size = 0;\\n        while(ptr){\\n            ptr = ptr->next;\\n            size++;\\n        }\\n        if(size < k){\\n            return head;\\n        }\\n        ptr = head;\\n        while(ptr && count < k){\\n            nptr = ptr->next;\\n            ptr->next = pptr;\\n            pptr = ptr;\\n            ptr = nptr;\\n            count++;\\n        }\\n        if(nptr != NULL)\\n            head->next = reverseKGroup(nptr, k);\\n        return pptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11582,
                "title": "simple-java-iterative-solution-with-explanation",
                "content": "The basic idea is  for each step,we set the the node after `head` as the list's new head, so that `head` then is `tail`. After reversing k nodes, we update the references and iterate through the whole list. If the size of the list is a multiple of k, the list is safely returned. Otherwise, a recursive call is made on the left-out nodes to undo the reverse.  So the whole iteration times will be `(n + n%k)`\\n\\n Here is an example of how it works(case of K = 3):\\n\\nInitial:\\n\\n    sentinel -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 ->...\\n        |       |    |\\n      dummy    tail newHead   \\nSet the node after tail @newHead as the new head. And the list:\\n\\n    sentinel -> 2 -> 1 -> 3 -> 4 -> 5 -> 6 ->...\\n        |            |    |\\n      dummy        tail newHead\\nSet node after tail as new Head:\\n    \\n     sentinel -> 3 -> 2 -> 1 -> 4 -> 5 -> 6 ->...\\n        |                  |\\n      dummy               tail   \\n3 nodes are reversed. Update the references:\\n\\n    sentinel -> 3 -> 2 -> 1 -> 4 -> 5 -> 6 ->...\\n                          |    |    |\\n                        dummy tail newHead   \\n\\nHere is code:\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (k < 2 || head == null) return head;\\n        ListNode sentinel = new ListNode(0);\\n        sentinel.next = head;\\n        ListNode dummy = sentinel, tail = head, newHead;\\n        While (true) {\\n            int count = k - 1;\\n            while (count > 0) {\\n                if (tail.next != null) {\\n                    newHead = tail.next;\\n                    tail.next = newHead.next;\\n                    newHead.next = dummy.next;\\n                    dummy.next = newHead;\\n                    count--;\\n                } else { \\n                    /// list size is not multiple of k, a recursive call on the left-out nodes to undo the reverse\\n                    dummy.next = reverseKGroup(dummy.next, k - count);\\n                    return sentinel.next;\\n                }\\n            }\\n            if (tail.next == null) return sentinel.next; /// list size is multiple of k, safely return\\n            dummy = tail;\\n            tail = tail.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The basic idea is  for each step,we set the the node after `head` as the list's new head, so that `head` then is `tail`. After reversing k nodes, we update the references and iterate through the whole list. If the size of the list is a multiple of k, the list is safely returned. Otherwise, a recursive call is made on the left-out nodes to undo the reverse.  So the whole iteration times will be `(n + n%k)`\\n\\n Here is an example of how it works(case of K = 3):\\n\\nInitial:\\n\\n    sentinel -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 ->...\\n        |       |    |\\n      dummy    tail newHead   \\nSet the node after tail @newHead as the new head. And the list:\\n\\n    sentinel -> 2 -> 1 -> 3 -> 4 -> 5 -> 6 ->...\\n        |            |    |\\n      dummy        tail newHead\\nSet node after tail as new Head:\\n    \\n     sentinel -> 3 -> 2 -> 1 -> 4 -> 5 -> 6 ->...\\n        |                  |\\n      dummy               tail   \\n3 nodes are reversed. Update the references:\\n\\n    sentinel -> 3 -> 2 -> 1 -> 4 -> 5 -> 6 ->...\\n                          |    |    |\\n                        dummy tail newHead   \\n\\nHere is code:\\n\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if (k < 2 || head == null) return head;\\n        ListNode sentinel = new ListNode(0);\\n        sentinel.next = head;\\n        ListNode dummy = sentinel, tail = head, newHead;\\n        While (true) {\\n            int count = k - 1;\\n            while (count > 0) {\\n                if (tail.next != null) {\\n                    newHead = tail.next;\\n                    tail.next = newHead.next;\\n                    newHead.next = dummy.next;\\n                    dummy.next = newHead;\\n                    count--;\\n                } else { \\n                    /// list size is not multiple of k, a recursive call on the left-out nodes to undo the reverse\\n                    dummy.next = reverseKGroup(dummy.next, k - count);\\n                    return sentinel.next;\\n                }\\n            }\\n            if (tail.next == null) return sentinel.next; /// list size is multiple of k, safely return\\n            dummy = tail;\\n            tail = tail.next;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11596,
                "title": "my-recursive-c-solution-easy-to-understand",
                "content": "class Solution {\\n\\npublic:\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        for (int i=1; i<k; i++){\\n            if (!temp) return head;\\n            temp = temp->next;\\n        }\\n        ListNode* pre = NULL;\\n        if (!temp) return head;\\n        else pre = reverseKGroup(temp->next, k);\\n        ListNode* cur = head;\\n        ListNode* next;\\n        //reverse k nodes\\n        for (int i=1; i<k; i++){\\n            next = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = next;\\n        }\\n        cur->next = pre;\\n        return cur;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* temp = head;\\n        for (int i=1; i<k; i++){\\n            if (!temp) return head;\\n            temp = temp->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11676,
                "title": "64ms-python-solution-1",
                "content": "It says it runs only 64 ms, in Python?! I don't buy that. But whatever.\\n\\n    class Solution(object):\\n    def reverseKGroup(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return head\\n\\n        tail = head\\n        for i in range(k):\\n            if not tail:\\n                return head\\n\\n            tail = tail.next\\n\\n        tail = self.reverseKGroup(tail, k)\\n\\n        for i in range(k):\\n            next = head.next\\n            head.next = tail\\n            tail = head\\n            head = next\\n\\n        return tail",
                "solutionTags": [
                    "Python"
                ],
                "code": "It says it runs only 64 ms, in Python?! I don't buy that. But whatever.\\n\\n    class Solution(object):\\n    def reverseKGroup(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return head\\n\\n        tail = head\\n        for i in range(k):\\n            if not tail:\\n                return head\\n\\n            tail = tail.next\\n\\n        tail = self.reverseKGroup(tail, k)\\n\\n        for i in range(k):\\n            next = head.next\\n            head.next = tail\\n            tail = head\\n            head = next\\n\\n        return tail",
                "codeTag": "Java"
            },
            {
                "id": 11684,
                "title": "my-recursive-c-code-is-concise-and-easy",
                "content": "    void reverseGroup(ListNode *head, ListNode *tail) {\\n        ListNode *node = head, *tmp, *pre = node;\\n        if (!node) return;\\n        node = node->next;\\n        while (pre != tail) {\\n            tmp = node->next;\\n            node->next = pre;\\n            pre = node;\\n            node = tmp;\\n        }\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *runner = head, *tHead = head;\\n        for (int i = 1;i < k;++i)\\n            if (runner) runner = runner->next; else break;\\n        if (!runner) return head;\\n        tHead = runner->next;\\n        reverseGroup(head,runner);\\n        head->next = reverseKGroup(tHead,k);\\n        return runner;\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "    void reverseGroup(ListNode *head, ListNode *tail) {\\n        ListNode *node = head, *tmp, *pre = node;\\n        if (!node) return;\\n        node = node->next;\\n        while (pre != tail) {\\n            tmp = node->next;\\n            node->next = pre;\\n            pre = node;\\n            node = tmp;\\n        }\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *runner = head, *tHead = head;\\n        for (int i = 1;i < k;++i)\\n            if (runner) runner = runner->next; else break;\\n        if (!runner) return head;\\n        tHead = runner->next;\\n        reverseGroup(head,runner);\\n        head->next = reverseKGroup(tHead,k);\\n        return runner;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11693,
                "title": "easy-to-understand-c-solution",
                "content": "The idea is to take k items from main list, reverse them and join to the new list. thats all. And dont forget about leftovers.\\n\\n    class Solution {\\n    public:\\n        ListNode* reverseKGroup(ListNode* head, int k)\\n        {\\n            // Count size of the original list\\n            int size = 0;\\n            ListNode *tmp = head;\\n            while (tmp != NULL)\\n            {\\n                tmp = tmp->next;\\n                ++size;\\n            }\\n            \\n            // make sure we need to do anything :)\\n            if (k > size)\\n                return head;\\n            \\n            // these are the pointers to the final list that we a building\\n            ListNode *newHead = NULL;\\n            ListNode *newTail = NULL;\\n            \\n            // main cycle. While we need to reverse anything\\n            while (size >= k)\\n            {\\n                // build a short reversed list that will contain k items ready to be joined the final list.\\n                ListNode *grHead = NULL;\\n                for (int i=0; i<k; ++i)\\n                {\\n                    ListNode *item = head;\\n                    head = head->next;\\n                    --size;\\n                    item->next = grHead;\\n                    grHead = item;\\n                }\\n                // note after building reversed we move head as well and reduce size.\\n                \\n                // join group (reversed) list to the final list\\n                if (newHead == NULL)\\n                {\\n                    newHead = grHead;\\n                    newTail = grHead;\\n                }\\n                else\\n                {\\n                    newTail->next = grHead;\\n                }\\n                \\n                // newTail will point to the group of a k items. move it to the end\\n                while (newTail->next != NULL)\\n                    newTail = newTail->next;\\n            }\\n            \\n            // in case original list has leftovers. it may occur if we have list size 5 and k = 3. 2 last items needs to be joined too\\n            if (head != NULL)\\n                newTail->next = head;\\n            \\n            return newHead;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* reverseKGroup(ListNode* head, int k)\\n        {\\n            // Count size of the original list\\n            int size = 0;\\n            ListNode *tmp = head;\\n            while (tmp != NULL)\\n            {\\n                tmp = tmp->next;\\n                ++size;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3827662,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* Kreverse(ListNode* head,int k,int n){\\n\\n        if(n<k)return head;\\n        ListNode* next=NULL;\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        int cnt=0;\\n        while(cnt<k and curr!=NULL){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            cnt++;\\n        }\\n        if(next!=NULL)head->next=Kreverse(next,k,n-k);\\n\\n        return prev;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        if(head==NULL)return NULL;\\n        ListNode* temp=head;\\n        int n=0;\\n        while(temp){\\n            temp=temp->next;\\n            n++;\\n        }\\n        return Kreverse(head,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* Kreverse(ListNode* head,int k,int n){\\n\\n        if(n<k)return head;\\n        ListNode* next=NULL;\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        int cnt=0;\\n        while(cnt<k and curr!=NULL){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n            cnt++;\\n        }\\n        if(next!=NULL)head->next=Kreverse(next,k,n-k);\\n\\n        return prev;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        if(head==NULL)return NULL;\\n        ListNode* temp=head;\\n        int n=0;\\n        while(temp){\\n            temp=temp->next;\\n            n++;\\n        }\\n        return Kreverse(head,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799257,
                "title": "clean-and-readable-python-code",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(0, head)\\n        currGroup = dummy\\n\\n        while True:\\n            kth = self.getKth(currGroup, k)\\n            if not kth:\\n                break\\n            nextGroup =  kth.next\\n\\n            # reverse the currGroup\\n            prev, curr = kth.next, currGroup.next\\n            while curr != nextGroup:\\n                tmp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = tmp\\n\\n            currGroup.next, currGroup = kth, currGroup.next\\n\\n        return dummy.next\\n\\n\\n    def getKth(self, node, k):\\n        while node and k:\\n            node = node.next\\n            k -= 1\\n        return node\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(0, head)\\n        currGroup = dummy\\n\\n        while True:\\n            kth = self.getKth(currGroup, k)\\n            if not kth:\\n                break\\n            nextGroup =  kth.next\\n\\n            # reverse the currGroup\\n            prev, curr = kth.next, currGroup.next\\n            while curr != nextGroup:\\n                tmp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = tmp\\n\\n            currGroup.next, currGroup = kth, currGroup.next\\n\\n        return dummy.next\\n\\n\\n    def getKth(self, node, k):\\n        while node and k:\\n            node = node.next\\n            k -= 1\\n        return node\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723473,
                "title": "c-soro",
                "content": "## Intuition\\nGive it a ```dry run```, you well get it.\\n\\n....\\nhey you, yes you.. please do vote this up and let leetcode know you are enjoying what you are watching.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        if(head == NULL) return NULL;\\n\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int count = 0;\\n\\n        // edge case\\n        ListNode* ptr = head;\\n        for(int i = 0; i < k; i++) {\\n            if(ptr == NULL) return head;\\n            ptr = ptr->next;\\n        }\\n\\n\\n        while(curr != NULL && count < k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        if(next != NULL) head->next = reverseKGroup(next,k);\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```dry run```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        if(head == NULL) return NULL;\\n\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int count = 0;\\n\\n        // edge case\\n        ListNode* ptr = head;\\n        for(int i = 0; i < k; i++) {\\n            if(ptr == NULL) return head;\\n            ptr = ptr->next;\\n        }\\n\\n\\n        while(curr != NULL && count < k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        if(next != NULL) head->next = reverseKGroup(next,k);\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717931,
                "title": "easy-to-understand-recursion-c",
                "content": "\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n       //base case \\n       if(head == NULL)\\n       return NULL;\\n\\n       //reverse 1st k nodes \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n        int count = 0;\\n\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n         if(cursor == nullptr) \\n             return head;\\n         cursor = cursor->next;\\n    }\\n\\n        while(curr!=NULL && count<k){\\n           forward = curr->next; \\n           curr->next = prev;\\n           prev = curr;\\n           curr = forward;\\n           count++;\\n        }\\n\\n        // recursion dek lega\\n        if(forward != NULL){\\n            head->next = reverseKGroup(forward,k);\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n       //base case \\n       if(head == NULL)\\n       return NULL;\\n\\n       //reverse 1st k nodes \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n        int count = 0;\\n\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n         if(cursor == nullptr) \\n             return head;\\n         cursor = cursor->next;\\n    }\\n\\n        while(curr!=NULL && count<k){\\n           forward = curr->next; \\n           curr->next = prev;\\n           prev = curr;\\n           curr = forward;\\n           count++;\\n        }\\n\\n        // recursion dek lega\\n        if(forward != NULL){\\n            head->next = reverseKGroup(forward,k);\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628347,
                "title": "o-n-solution-intuitive-and-easy-to-understand-c-solution",
                "content": "# Approach : \\nDry run side by side to understand better.\\nCount the length of linked list to find how many groups needs to be reversed by dividing cnt /k. Run a loop until cnt\\u2265k to perform reverse and keep decrementing count by k once a group of k is reversed.\\n\\nFor reversing we take into account 3 pointers prev, nex, curr. We know that the first elem of the group to be reversed should always point to the next reversed group so always keep curr pointer at the first element. Create a dummy node for initial group and prev, curr and next all point to this dummy. now we know first elem of every group must be pointed by curr and curr will  point to the next element of the last element of the previous group meaning if k=3 in list 1\\u20142\\u20143\\u20144 then at the end of reversing curr\\u2192next will point to 4 because it is the next elem of the reversed group. so inside outer loop we write curr=prev\\u2192next. and next will point to current elem next which is next=curr\\u2192next\\n\\nNow in 1\\u20142\\u20143\\u20144 the link to be broken is 1\\u20142 we know 1 next must point to starting of another group. so now curr is pointing to 1 so we shift 1 by one the curr\\u2192next because curr\\u2192next is pointing to the next elem whose link needs to be changes so moving step by step curr\\u2192next will point to next\\u2192next because that is the only elem the farthest we can move using these pointers.\\n\\nnow once curr\\u2192next =nex\\u2192next now 2\\u20143 link needs to be broken so nex\\u2192next should now point to prev\\u2192next. now moving pointers prev\\u2192next=nex because we need to invert 3\\u20144 link for 3, the prev element must be 2 which is pointed by nex now moving nex which will be nex=curr\\u2192next mpving nex by 1 position. \\n\\nWe know prev\\u2192next and dummy\\u2192next points to same elem so when we are changing prev\\u2192 next dummy\\u2192next also changes. But after one iteration we change prev=curr\\u2192next so now dummy is no more affected by prev because now prev is pointed to other elem.\\n\\nNow for the next group we need to again set prev to curr\\u2192next because it was the last elem of previous group as we know that prev must point to the elem just before whose link needs to be altered.  We also reduce cnt-=k;\\n\\nAt last dummy stores the head so we return dummy\\u2192next\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int cnt=0;\\n        ListNode* temp=head;\\n        ListNode* dummy=new ListNode();\\n        dummy->next=head;\\n        ListNode *prev=dummy,*nex=dummy,*curr=dummy;\\n        while(temp!=NULL)\\n        {\\n            cnt++;\\n            temp=temp->next;\\n        }\\n        while(cnt>=k)\\n        {\\n            curr=prev->next;\\n            nex=curr->next;\\n            for(int i=1;i<k;i++)\\n            {\\n                curr->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=curr->next;\\n            }\\n            prev=curr;\\n            cnt-=k;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n\\n- Time Complexity : O(N/K)*K which is equal to O(N)\\n- Space Complexity : O(1)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int cnt=0;\\n        ListNode* temp=head;\\n        ListNode* dummy=new ListNode();\\n        dummy->next=head;\\n        ListNode *prev=dummy,*nex=dummy,*curr=dummy;\\n        while(temp!=NULL)\\n        {\\n            cnt++;\\n            temp=temp->next;\\n        }\\n        while(cnt>=k)\\n        {\\n            curr=prev->next;\\n            nex=curr->next;\\n            for(int i=1;i<k;i++)\\n            {\\n                curr->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=curr->next;\\n            }\\n            prev=curr;\\n            cnt-=k;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604279,
                "title": "c-iterative-o-n-time-o-1-space-detailed-explanation",
                "content": "# Explanation\\n- Use a dummy node to simplify the process. The dummy node is set as the previous node of the original head node.\\n- Maintain two pointers, beforeGroup and afterGroup, to keep track of the nodes before and after each group of k nodes.\\n- The current pointer is used to traverse the nodes within each group. The previous pointer is used to reverse the links between nodes. The nextNode pointer is used to store the next node before modifying the link.\\n- The main loop runs indefinitely until the entire list is processed.\\n- Inside the loop, first check if there are k nodes remaining. If not, return the modified list. Iterate k times to advance the cursor pointer, which helps determine if there are enough nodes remaining in the group. After confirming that there are k nodes, perform the actual reversal.\\n- Iterate k times and reverse the links between nodes by updating the next pointers.\\n- After reversing the group, update the links for the previous group (beforeGroup points to the last node of the reversed group) and the next group (afterGroup points to the first node of the next group).\\n- Finally, update the beforeGroup and afterGroup pointers to the appropriate positions for the next iteration of the loop.\\n- When the loop ends, the entire list is reversed in groups of k, return the modified list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* beforeGroup = dummy;\\n    ListNode* afterGroup = head;\\n    ListNode* current = nullptr;\\n    ListNode* previous = nullptr;\\n    ListNode* nextNode = nullptr;\\n\\n    while (true) {\\n        ListNode* cursor = afterGroup;\\n        for (int i = 0; i < k; i++) {\\n            if (cursor == nullptr) {\\n                return dummy->next;\\n            }\\n            cursor = cursor->next;\\n        }\\n\\n        current = afterGroup;\\n        previous = beforeGroup;\\n        for (int i = 0; i < k; i++) {\\n            nextNode = current->next;\\n            current->next = previous;\\n            previous = current;\\n            current = nextNode;\\n        }\\n\\n        afterGroup->next = current;\\n        beforeGroup->next = previous;\\n        beforeGroup = afterGroup;\\n        afterGroup = current;\\n    }\\n}\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* beforeGroup = dummy;\\n    ListNode* afterGroup = head;\\n    ListNode* current = nullptr;\\n    ListNode* previous = nullptr;\\n    ListNode* nextNode = nullptr;\\n\\n    while (true) {\\n        ListNode* cursor = afterGroup;\\n        for (int i = 0; i < k; i++) {\\n            if (cursor == nullptr) {\\n                return dummy->next;\\n            }\\n            cursor = cursor->next;\\n        }\\n\\n        current = afterGroup;\\n        previous = beforeGroup;\\n        for (int i = 0; i < k; i++) {\\n            nextNode = current->next;\\n            current->next = previous;\\n            previous = current;\\n            current = nextNode;\\n        }\\n\\n        afterGroup->next = current;\\n        beforeGroup->next = previous;\\n        beforeGroup = afterGroup;\\n        afterGroup = current;\\n    }\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446353,
                "title": "0ms-100-faster-solution-in-java-naive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nnaive approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n  if(head==null || k==1) return head;\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n\\n        ListNode curr = dummy,nex = dummy,pre = dummy;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr = curr.next;         \\n            count++;\\n        }\\n\\n        while(count>=k){                 \\n            curr = pre.next;            \\n            nex = curr.next;           \\n            for(int i=1;i<k;i++){        \\n                curr.next = nex.next;\\n                nex.next = pre.next;\\n                pre.next = nex;\\n                nex = curr.next;\\n            }\\n            pre = curr;   \\n            count-=k;                   \\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n  if(head==null || k==1) return head;\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n\\n        ListNode curr = dummy,nex = dummy,pre = dummy;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr = curr.next;         \\n            count++;\\n        }\\n\\n        while(count>=k){                 \\n            curr = pre.next;            \\n            nex = curr.next;           \\n            for(int i=1;i<k;i++){        \\n                curr.next = nex.next;\\n                nex.next = pre.next;\\n                pre.next = nex;\\n                nex = curr.next;\\n            }\\n            pre = curr;   \\n            count-=k;                   \\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400834,
                "title": "simple-c-solution-without-recursion-well-explained",
                "content": "# Intuition\\nCounting the total nodes to find how many `k` groups can be made. Using stack to reverse the order of the `k` nodes and then adding them to ListNode and returning that LinkedList.\\n\\n# Approach\\n1. Count the number of nodes.\\n2. devide number of nodes by `k` to find how many groups of `k` size can be made. save the result to `cnt` variable.\\n3. Declare a stack.\\n4. make a Listnode `ans` initially pointing to head node (`ListNode* ans = head`). We will make changes as said in question and return head to return the desired linkedlist.\\n5. Start interating in the LinkedList, use a variable `k1 = k`, so that we can renew the value of k1 after changing. push node values in stack and decrease value of `k1` till it reaches 0.\\n6. Once it reaches 0, start a loop till the stack gets empty and get the top value and assign it to the node of `ans` listNode and make `ans = ans->next`. pop the top value from stack.\\n7. once the stack gets empty decrease the `cnt` value by 1. make `k1 = k`.\\n8. let the iteration started in `5th` point continue till out `cnt` value gets 0, once it gets 0, we\\'ll break the loop and return the `head` of the linkedList.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* counter = head;\\n        ListNode* temp = head;\\n        ListNode* ans = head;\\n        while(counter!=NULL){\\n            cnt++;\\n            counter = counter->next;\\n        }\\n        cnt /= k;\\n        stack<int> st;\\n        int k1 = k;\\n\\n        while(temp!=NULL){\\n            st.push(temp->val);\\n            k1--;\\n            temp = temp->next;\\n            if(k1==0){\\n                while(!st.empty()){\\n                    ans->val = st.top();\\n                    st.pop();\\n                    ans = ans->next;\\n                }\\n                cnt--;\\n                k1 = k;\\n            }\\n            if(cnt==0){\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int cnt = 0;\\n        ListNode* counter = head;\\n        ListNode* temp = head;\\n        ListNode* ans = head;\\n        while(counter!=NULL){\\n            cnt++;\\n            counter = counter->next;\\n        }\\n        cnt /= k;\\n        stack<int> st;\\n        int k1 = k;\\n\\n        while(temp!=NULL){\\n            st.push(temp->val);\\n            k1--;\\n            temp = temp->next;\\n            if(k1==0){\\n                while(!st.empty()){\\n                    ans->val = st.top();\\n                    st.pop();\\n                    ans = ans->next;\\n                }\\n                cnt--;\\n                k1 = k;\\n            }\\n            if(cnt==0){\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387398,
                "title": "python-iterative-simple-and-clean-beats-98-09",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to reverse the nodes of the list k at a time. One way to approach this problem is to keep track of the length of the list and reverse the nodes of each group of k nodes. We will use a dummy node to keep track of the head of the list and use two pointers to reverse the nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the length of the list.\\n1. Create a dummy node and set its next to the head of the list.\\n1. Set the prev pointer to the dummy node and loop through the list in groups of k nodes.\\n1. For each group, set the curr pointer to prev.next and loop k-1 times.\\n1. In the loop, set the nxt pointer to curr.next, set curr.next to nxt.next, set nxt.next to prev.next, and set prev.next to nxt.\\n1. Set prev to curr.\\n1. Return the next node of the dummy node.\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the number of nodes in the list.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$, since we are only modifying the pointers of the existing list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or k==1:\\n            return head\\n\\n        length = 0\\n        curr = head\\n        while curr:\\n            length += 1\\n            curr = curr.next\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n        for i in range(length//k):\\n            curr = prev.next\\n            for j in range(k-1):\\n                nxt = curr.next\\n                curr.next = nxt.next\\n                nxt.next = prev.next\\n                prev.next = nxt\\n            prev = curr\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head or k==1:\\n            return head\\n\\n        length = 0\\n        curr = head\\n        while curr:\\n            length += 1\\n            curr = curr.next\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n        for i in range(length//k):\\n            curr = prev.next\\n            for j in range(k-1):\\n                nxt = curr.next\\n                curr.next = nxt.next\\n                nxt.next = prev.next\\n                prev.next = nxt\\n            prev = curr\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353014,
                "title": "easy-python-solution-99-80-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->If  you like the solution please upvote guys.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have to reverse the every k nodes and assign to the new linkedlist.finally dont reverse the nodes which nodes length is less than k.We have to link those nodes to our newlinked list and finally rerturn the linkedlist.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        a=b=ListNode()\\n        i=0\\n        z=None\\n        #Reverse the k nodes\\n        while head:\\n            i=i+1\\n            if i<=k:\\n                x=head.next\\n                head.next=z\\n                z=head\\n                head=x\\n            #Assign the reversed nodes to the new links\\n            if i==k:\\n                b.next=z\\n                #Take pointer until end of the reversed nodes\\n                while b and b.next:\\n                    b=b.next\\n                z=None\\n                i=0\\n        #And finally reverse the nodes and assign the nodes\\n        zz=None\\n        while z:\\n            #Reverse\\n            g=z.next\\n            z.next=zz\\n            zz=z\\n            z=g\\n        #Assign the final nodes which are length is the less than k\\n        b.next=zz\\n        #The total link connection is in a then return a.next\\n        return a.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        a=b=ListNode()\\n        i=0\\n        z=None\\n        #Reverse the k nodes\\n        while head:\\n            i=i+1\\n            if i<=k:\\n                x=head.next\\n                head.next=z\\n                z=head\\n                head=x\\n            #Assign the reversed nodes to the new links\\n            if i==k:\\n                b.next=z\\n                #Take pointer until end of the reversed nodes\\n                while b and b.next:\\n                    b=b.next\\n                z=None\\n                i=0\\n        #And finally reverse the nodes and assign the nodes\\n        zz=None\\n        while z:\\n            #Reverse\\n            g=z.next\\n            z.next=zz\\n            zz=z\\n            z=g\\n        #Assign the final nodes which are length is the less than k\\n        b.next=zz\\n        #The total link connection is in a then return a.next\\n        return a.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214814,
                "title": "using-recursion-easy-and-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n            if(cursor == nullptr) return head;\\n            cursor = cursor->next;\\n        }\\n\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* next = NULL;\\n\\n        int count=0;\\n\\n        while(curr != NULL && count < k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        if(next != NULL){\\n            head->next = reverseKGroup(next,k);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        ListNode* cursor = head;\\n        for(int i = 0; i < k; i++){\\n            if(cursor == nullptr) return head;\\n            cursor = cursor->next;\\n        }\\n\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* next = NULL;\\n\\n        int count=0;\\n\\n        while(curr != NULL && count < k){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n        \\n        if(next != NULL){\\n            head->next = reverseKGroup(next,k);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205239,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n           ListNode * dummy = new ListNode(0);\\n           dummy->next = head;\\n           ListNode* curr = dummy , *nex = dummy , *pre = dummy;\\n           int cnt = 0;\\n           while(curr->next) {\\n               curr = curr->next;\\n               cnt++;\\n           } \\n           while(cnt >= k) {\\n               curr = pre->next;\\n               nex = curr->next;\\n               for(int i=1;i<k;i++) {\\n                   curr->next = nex->next;\\n                   nex->next = pre->next;\\n                   pre->next = nex;\\n                   nex = curr->next;\\n               }\\n               pre = curr;\\n               cnt-=k;\\n           }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n           ListNode * dummy = new ListNode(0);\\n           dummy->next = head;\\n           ListNode* curr = dummy , *nex = dummy , *pre = dummy;\\n           int cnt = 0;\\n           while(curr->next) {\\n               curr = curr->next;\\n               cnt++;\\n           } \\n           while(cnt >= k) {\\n               curr = pre->next;\\n               nex = curr->next;\\n               for(int i=1;i<k;i++) {\\n                   curr->next = nex->next;\\n                   nex->next = pre->next;\\n                   pre->next = nex;\\n                   nex = curr->next;\\n               }\\n               pre = curr;\\n               cnt-=k;\\n           }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157702,
                "title": "golang-iterative-recursive",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\n/* Recursive Solution */\\n\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n    l := length(head)\\n    return reverse(head, l, k)\\n}\\n\\nfunc reverse(node *ListNode, l, k int) *ListNode {\\n    if l < k {\\n        return node\\n    }\\n\\n    var prev, next *ListNode\\n    curr := node\\n    for i := 0; i < k; i++ {\\n        next = curr.Next\\n        curr.Next = prev\\n        prev = curr\\n        curr = next\\n    }\\n\\n    node.Next = reverse(next, l-k, k)\\n    return prev\\n}\\n\\nfunc length(head *ListNode) int {\\n    count := 0\\n\\n    for head != nil {\\n        head = head.Next\\n        count++\\n    }\\n    return count\\n}\\n\\n/* Iterative Solution */\\n\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n    if head == nil || k == 1 {\\n        return head\\n    }\\n\\n    l := length(head)\\n    preHead := &ListNode{Next: head}\\n\\n    prev := preHead\\n    for l >= k {\\n        curr := prev.Next\\n        for i := 1; i < k; i++ {\\n            next := curr.Next\\n            curr.Next = next.Next\\n            next.Next = prev.Next\\n            prev.Next = next\\n        }\\n        prev = curr\\n        l -= k\\n    }\\n\\n    return preHead.Next\\n}\\n\\nfunc length(head *ListNode) int {\\n    count := 0\\n\\n    for head != nil {\\n        head = head.Next\\n        count++\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\n/* Recursive Solution */\\n\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n    l := length(head)\\n    return reverse(head, l, k)\\n}\\n\\nfunc reverse(node *ListNode, l, k int) *ListNode {\\n    if l < k {\\n        return node\\n    }\\n\\n    var prev, next *ListNode\\n    curr := node\\n    for i := 0; i < k; i++ {\\n        next = curr.Next\\n        curr.Next = prev\\n        prev = curr\\n        curr = next\\n    }\\n\\n    node.Next = reverse(next, l-k, k)\\n    return prev\\n}\\n\\nfunc length(head *ListNode) int {\\n    count := 0\\n\\n    for head != nil {\\n        head = head.Next\\n        count++\\n    }\\n    return count\\n}\\n\\n/* Iterative Solution */\\n\\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\\n    if head == nil || k == 1 {\\n        return head\\n    }\\n\\n    l := length(head)\\n    preHead := &ListNode{Next: head}\\n\\n    prev := preHead\\n    for l >= k {\\n        curr := prev.Next\\n        for i := 1; i < k; i++ {\\n            next := curr.Next\\n            curr.Next = next.Next\\n            next.Next = prev.Next\\n            prev.Next = next\\n        }\\n        prev = curr\\n        l -= k\\n    }\\n\\n    return preHead.Next\\n}\\n\\nfunc length(head *ListNode) int {\\n    count := 0\\n\\n    for head != nil {\\n        head = head.Next\\n        count++\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144386,
                "title": "simple-o-n-iterative-cpp",
                "content": "# Intuition\\nAs the question suggests, I have partitioned the whole length into groups of \\'k\\' nodes and then reversed the pointers within those k nodes along with changing the conventional head and tail of the list as a whole.\\n\\n# Approach\\nThe idea is to have a dummy head pointing to current head at first. Then I have sectioned the whol elength into groups of \\'k\\'. In those sections one can simply reverse the pointers with current and previous nodes. And hence the whole list will be reversed\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int findLen(ListNode *head){\\n        if (head==NULL){return 0;}\\n        if (head->next==NULL){return 1;}\\n        int len =1;\\n        while(head->next){\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n         if (head==NULL || head->next==NULL){\\n             return head;\\n         }\\n        int len = findLen(head); \\n        ListNode* dummyHead = new ListNode(0);\\n        dummyHead->next = head;\\n        ListNode* pre = dummyHead;\\n        ListNode* cur;\\n        ListNode* nex;\\n        while(len >= k) {\\n            cur = pre->next;\\n            nex = cur->next;\\n            for(int i=1;i<k;i++) {\\n                cur->next = nex->next;\\n                nex->next = pre->next;\\n                pre->next = nex;\\n                nex = cur->next;\\n            }\\n            pre = cur;\\n            len -= k;\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findLen(ListNode *head){\\n        if (head==NULL){return 0;}\\n        if (head->next==NULL){return 1;}\\n        int len =1;\\n        while(head->next){\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n         if (head==NULL || head->next==NULL){\\n             return head;\\n         }\\n        int len = findLen(head); \\n        ListNode* dummyHead = new ListNode(0);\\n        dummyHead->next = head;\\n        ListNode* pre = dummyHead;\\n        ListNode* cur;\\n        ListNode* nex;\\n        while(len >= k) {\\n            cur = pre->next;\\n            nex = cur->next;\\n            for(int i=1;i<k;i++) {\\n                cur->next = nex->next;\\n                nex->next = pre->next;\\n                pre->next = nex;\\n                nex = cur->next;\\n            }\\n            pre = cur;\\n            len -= k;\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113150,
                "title": "reverse-nodes-in-k-group",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     int length(ListNode* node)\\n     {\\n         int count=0;\\n         while(node)\\n         {\\n             count++;\\n             node = node->next;\\n         }\\n         return count;\\n     }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        if(length(head)<k)\\n        {\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* next = nullptr;\\n        ListNode* prev = nullptr;\\n        for(int i=0; i<k; i++)\\n        {\\n             next = curr->next;\\n             curr->next= prev;\\n             prev = curr;\\n             curr = next;\\n        }\\n        head -> next = reverseKGroup(curr,k);\\n        return prev;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     int length(ListNode* node)\\n     {\\n         int count=0;\\n         while(node)\\n         {\\n             count++;\\n             node = node->next;\\n         }\\n         return count;\\n     }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n\\n        if(length(head)<k)\\n        {\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* next = nullptr;\\n        ListNode* prev = nullptr;\\n        for(int i=0; i<k; i++)\\n        {\\n             next = curr->next;\\n             curr->next= prev;\\n             prev = curr;\\n             curr = next;\\n        }\\n        head -> next = reverseKGroup(curr,k);\\n        return prev;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043971,
                "title": "c-o-1-space-complexity",
                "content": "\\n### Complexity\\n- Time complexity: $$O(N * K)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* F(ListNode *curr) {\\n        ListNode *next = curr, *prev = nullptr;\\n        while(curr) {\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || !head-> next || k == 1) return head;\\n\\n        ListNode *curr = head;\\n        ListNode *answer = nullptr, *dummy = nullptr;\\n\\n        while(curr) {\\n            ListNode *left = curr, *right = nullptr;\\n            int cnt = 0;\\n            while(curr && cnt != k) {\\n                right = curr;\\n                curr = curr -> next;\\n                cnt++;\\n            }\\n\\n            if(cnt != k) {\\n                if(!answer) return head;\\n                dummy -> next = left;\\n                return answer;\\n            }\\n\\n            right -> next = nullptr;\\n            ListNode *r = F(left);\\n\\n            if(!answer) answer = r;\\n            else dummy -> next = r;\\n            dummy = left;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* F(ListNode *curr) {\\n        ListNode *next = curr, *prev = nullptr;\\n        while(curr) {\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(!head || !head-> next || k == 1) return head;\\n\\n        ListNode *curr = head;\\n        ListNode *answer = nullptr, *dummy = nullptr;\\n\\n        while(curr) {\\n            ListNode *left = curr, *right = nullptr;\\n            int cnt = 0;\\n            while(curr && cnt != k) {\\n                right = curr;\\n                curr = curr -> next;\\n                cnt++;\\n            }\\n\\n            if(cnt != k) {\\n                if(!answer) return head;\\n                dummy -> next = left;\\n                return answer;\\n            }\\n\\n            right -> next = nullptr;\\n            ListNode *r = F(left);\\n\\n            if(!answer) answer = r;\\n            else dummy -> next = r;\\n            dummy = left;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949622,
                "title": "python-solution-faster-than-90-o-n-time-and-space",
                "content": "# Intuition\\nWe are going to find the length of the list and knowing that reverse as many groups of k elements as we can. We will then append the remaining list.\\n\\n# Approach\\nTo find the length of the list we will just go through the entire list once.\\nThen we will reverse as many groups of k elements as we can. Those are going to be l//k. We will reverse them the same way we did in [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\\nFor every one of those groups we will put them in a dummy.\\nAt the end we will append the remaining list to the dummy.\\n# Complexity\\n- Time complexity: **O(n)** since we go through the linked list twice\\n\\n- Space complexity: **O(n)** since we store the dummy with length equal to the linked list.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if k == 1: return head\\n\\n        # find lenght of list by going through it\\n        l = 1\\n        tail = head\\n        while tail.next:\\n            tail = tail.next\\n            l += 1\\n        \\n        # reverse l//k times k elements\\n        curr,dummy = head,ListNode()\\n        tail = dummy\\n\\n        for i in range(l//k): # for every group of size k\\n            prev = None\\n\\n            # reverse it\\n            for x in range(k):\\n                temp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = temp\\n\\n\\n            tail.next = prev # append the group to the dummy\\n            # get the pointer to the end\\n            for x in range(k): tail = tail.next \\n\\n        # append the remaining list\\n        tail.next = curr\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if k == 1: return head\\n\\n        # find lenght of list by going through it\\n        l = 1\\n        tail = head\\n        while tail.next:\\n            tail = tail.next\\n            l += 1\\n        \\n        # reverse l//k times k elements\\n        curr,dummy = head,ListNode()\\n        tail = dummy\\n\\n        for i in range(l//k): # for every group of size k\\n            prev = None\\n\\n            # reverse it\\n            for x in range(k):\\n                temp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = temp\\n\\n\\n            tail.next = prev # append the group to the dummy\\n            # get the pointer to the end\\n            for x in range(k): tail = tail.next \\n\\n        # append the remaining list\\n        tail.next = curr\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927097,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length(ListNode * node)\\n    {\\n        int count=0;\\n        while(node){\\n            count++;\\n            node=node->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       if(length(head) < k)\\n           return head;\\n       ListNode * cur=head;\\n       ListNode * prev=NULL, *next=NULL;\\n       for(int i=0; i < k; i++)\\n       {\\n           next=cur->next;\\n           cur->next=prev;\\n           prev=cur;\\n           cur=next;\\n       }\\n       head->next=reverseKGroup(cur, k);\\n       return prev;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length(ListNode * node)\\n    {\\n        int count=0;\\n        while(node){\\n            count++;\\n            node=node->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       if(length(head) < k)\\n           return head;\\n       ListNode * cur=head;\\n       ListNode * prev=NULL, *next=NULL;\\n       for(int i=0; i < k; i++)\\n       {\\n           next=cur->next;\\n           cur->next=prev;\\n           prev=cur;\\n           cur=next;\\n       }\\n       head->next=reverseKGroup(cur, k);\\n       return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848333,
                "title": "easiest-solution-c-plus-plus-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint count1 = 0;\\nint length(ListNode* head){\\n    int ans = 0;\\n    ListNode* temp = head;\\n    while(temp!=NULL){\\n        ans++;\\n        temp=temp->next;\\n    }\\n    return ans;\\n}\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        count1=length(head);\\n        if(count1<k) return head;\\n        ListNode* temp = head;\\n        ListNode* nextt = NULL;\\n        ListNode* prev = NULL;\\n        int count =0;\\n        while(count<k && temp!=NULL){\\n            nextt = temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nextt;\\n            count++;\\n        }\\n        if(nextt!=NULL){\\n            head->next=reverseKGroup(nextt,k);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint count1 = 0;\\nint length(ListNode* head){\\n    int ans = 0;\\n    ListNode* temp = head;\\n    while(temp!=NULL){\\n        ans++;\\n        temp=temp->next;\\n    }\\n    return ans;\\n}\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        count1=length(head);\\n        if(count1<k) return head;\\n        ListNode* temp = head;\\n        ListNode* nextt = NULL;\\n        ListNode* prev = NULL;\\n        int count =0;\\n        while(count<k && temp!=NULL){\\n            nextt = temp->next;\\n            temp->next=prev;\\n            prev=temp;\\n            temp=nextt;\\n            count++;\\n        }\\n        if(nextt!=NULL){\\n            head->next=reverseKGroup(nextt,k);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803455,
                "title": "kotlin-easy-intuitive-reused-reverse-linked-list-function",
                "content": "# Intuition\\nFirst create a function to reverse linked list\\nthen call function (size of linked list)/k times\\n\\n# Approach\\nCreate Reverse function which accepts current node and end node\\nIn reverse function:\\n->Implement it using your approch just make prev = end and not null\\n\\nIn base function:\\n-> run while loop for linked list\\n-> run another nested while loop till i<k to find end(till when the nodes will be reversed)\\n-> then just call reverse(current, end)\\n\\n# Complexity\\n- Time complexity: O(n) \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\\n\\n        var cur = head\\n        var prev: ListNode? = null\\n        var newHead = head\\n        while(cur != null)\\n        {\\n            var i = 0\\n            var end = cur\\n            while( end != null && i < k)\\n            {\\n                end = end?.next\\n                i++\\n            }\\n            if(i == k)\\n            {\\n                if(cur == head)\\n                newHead = reverse(cur,end)\\n                else\\n                prev?.next = reverse(cur,end)\\n            }\\n            prev = cur\\n            cur = end\\n        }\\n\\n        return newHead\\n    }\\n\\n    fun reverse(cur1: ListNode?, end: ListNode?): ListNode?{\\n\\n        var prev = end\\n        var cur = cur1\\n        while(cur != end)\\n        {\\n            val temp = cur?.next\\n            cur?.next = prev\\n            prev = cur\\n            cur = temp\\n        }\\n\\n        return prev\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\\n\\n        var cur = head\\n        var prev: ListNode? = null\\n        var newHead = head\\n        while(cur != null)\\n        {\\n            var i = 0\\n            var end = cur\\n            while( end != null && i < k)\\n            {\\n                end = end?.next\\n                i++\\n            }\\n            if(i == k)\\n            {\\n                if(cur == head)\\n                newHead = reverse(cur,end)\\n                else\\n                prev?.next = reverse(cur,end)\\n            }\\n            prev = cur\\n            cur = end\\n        }\\n\\n        return newHead\\n    }\\n\\n    fun reverse(cur1: ListNode?, end: ListNode?): ListNode?{\\n\\n        var prev = end\\n        var cur = cur1\\n        while(cur != end)\\n        {\\n            val temp = cur?.next\\n            cur?.next = prev\\n            prev = cur\\n            cur = temp\\n        }\\n\\n        return prev\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795560,
                "title": "c-easiest-solution-faster-than-94-memory-and-90-speed",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode * res=new ListNode(-1);\\n        res->next=head;\\n        ListNode * prv=res;\\n        ListNode * A=head;\\n        while(A)\\n        {\\n            int c=0;\\n            ListNode * start=A;\\n            ListNode * x=A;\\n            ListNode * y=NULL;\\n            while(A && c<k)\\n            {\\n                A=A->next;\\n                c+=1;\\n            }\\n            if(c!=k)\\n            {\\n                prv->next=start;\\n                break;\\n            }\\n            while(x!=A)\\n            {\\n                ListNode * nxt=x->next;\\n                x->next=y;\\n                y=x;\\n                x=nxt;\\n            }\\n            prv->next=y;\\n            prv=start;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode * res=new ListNode(-1);\\n        res->next=head;\\n        ListNode * prv=res;\\n        ListNode * A=head;\\n        while(A)\\n        {\\n            int c=0;\\n            ListNode * start=A;\\n            ListNode * x=A;\\n            ListNode * y=NULL;\\n            while(A && c<k)\\n            {\\n                A=A->next;\\n                c+=1;\\n            }\\n            if(c!=k)\\n            {\\n                prv->next=start;\\n                break;\\n            }\\n            while(x!=A)\\n            {\\n                ListNode * nxt=x->next;\\n                x->next=y;\\n                y=x;\\n                x=nxt;\\n            }\\n            prv->next=y;\\n            prv=start;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787897,
                "title": "simple-approach-c-o-n-iterative-commented",
                "content": "ListNode *reverseLinkedListRec(ListNode *head) // For reversing a block of linked list in O(n)\\n{\\n\\n\\tif(head == NULL || head -> next == NULL)\\n        return head;\\n\\n    ListNode *newhead = reverseLinkedListRec(head -> next);\\n    head -> next -> next = head;\\n    head -> next = NULL;\\n\\treturn newhead;\\n}\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n\\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    if(k==1 || k==0)\\n        return head;\\n\\n    int c=1,d=0;\\n    ListNode *temp = head;\\n    ListNode *last = NULL; //for saving the last node of a k-group\\n    ListNode *fhead = NULL; //for saving the head of the linked list\\n    ListNode *newhead = NULL; // for saving the head of every new head\\n    while(temp != NULL){\\n        if(c==k){\\n            c=1;\\n            ListNode *a = temp -> next;\\n            temp -> next  = NULL;\\n            newhead = reverseLinkedListRec(head);\\n            if(last!=NULL)\\n                last -> next = newhead;\\n            if(d==0){\\n                fhead = newhead;\\n                d=1;\\n            }\\n            last = head;\\n            head = a;\\n            temp = a;\\n        } else {\\n            c++;\\n            temp = temp -> next;\\n        }\\n    }\\n\\t/* If the question has the alteration of reversing the remaining nodes if k is not a multiple of length of list\\n    if(head != NULL){\\n         newhead = reverseLinkedListRec(head);\\n\\t\\t last -> next = newhead;\\n     }\\n\\t */\\n    last -> next = head;\\n    return fhead;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "ListNode *reverseLinkedListRec(ListNode *head) // For reversing a block of linked list in O(n)\\n{\\n\\n\\tif(head == NULL || head -> next == NULL)\\n        return head;\\n\\n    ListNode *newhead = reverseLinkedListRec(head -> next);\\n    head -> next -> next = head;\\n    head -> next = NULL;\\n\\treturn newhead;\\n}\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n\\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    if(k==1 || k==0)\\n        return head;\\n\\n    int c=1,d=0;\\n    ListNode *temp = head;\\n    ListNode *last = NULL; //for saving the last node of a k-group\\n    ListNode *fhead = NULL; //for saving the head of the linked list\\n    ListNode *newhead = NULL; // for saving the head of every new head\\n    while(temp != NULL){\\n        if(c==k){\\n            c=1;\\n            ListNode *a = temp -> next;\\n            temp -> next  = NULL;\\n            newhead = reverseLinkedListRec(head);\\n            if(last!=NULL)\\n                last -> next = newhead;\\n            if(d==0){\\n                fhead = newhead;\\n                d=1;\\n            }\\n            last = head;\\n            head = a;\\n            temp = a;\\n        } else {\\n            c++;\\n            temp = temp -> next;\\n        }\\n    }\\n\\t/* If the question has the alteration of reversing the remaining nodes if k is not a multiple of length of list\\n    if(head != NULL){\\n         newhead = reverseLinkedListRec(head);\\n\\t\\t last -> next = newhead;\\n     }\\n\\t */\\n    last -> next = head;\\n    return fhead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2735575,
                "title": "java-runtime-1-ms-optimized-approach-wth-explanation",
                "content": "```\\nApproach\\n1.  we will make a variable total(length of linked list).\\n\\tAfter that will count the total length by using the while loop.\\n2.  Then we will reverse the given linked list according to size \\u2013 next \\u2013 \\n\\t(next of current element), prev \\u2013  (previous element of current),\\n\\tand current.\\n3.  Then we will decrease the total length by k after reversing the linked\\n\\t list and will check if the total length will be greater or equal to k \\n\\t then we will do the previous steps by using recursion.\\n4.  Else will link to the remaining node of the linked list.\\n    At last, we will return to the prev.\\n```\\n\\n```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int total = 0;\\n        ListNode current = head;\\n        while(current != null){\\n            total++;\\n            current = current.next;\\n        }\\n        int count = 0;\\n        ListNode prev = null;\\n        ListNode c = head;\\n        ListNode next = null;\\n        while(c != null && count < k){\\n            next = c.next;\\n            c.next = prev;\\n            prev = c;\\n            c = next;\\n            count++;\\n        }\\n        total -= k;\\n        if(total >= k){\\n            head.next = reverseKGroup(next,k);\\n        }\\n        else{\\n            head.next = next;\\n        }\\n        return prev; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nApproach\\n1.  we will make a variable total(length of linked list).\\n\\tAfter that will count the total length by using the while loop.\\n2.  Then we will reverse the given linked list according to size \\u2013 next \\u2013 \\n\\t(next of current element), prev \\u2013  (previous element of current),\\n\\tand current.\\n3.  Then we will decrease the total length by k after reversing the linked\\n\\t list and will check if the total length will be greater or equal to k \\n\\t then we will do the previous steps by using recursion.\\n4.  Else will link to the remaining node of the linked list.\\n    At last, we will return to the prev.\\n```\n```\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        int total = 0;\\n        ListNode current = head;\\n        while(current != null){\\n            total++;\\n            current = current.next;\\n        }\\n        int count = 0;\\n        ListNode prev = null;\\n        ListNode c = head;\\n        ListNode next = null;\\n        while(c != null && count < k){\\n            next = c.next;\\n            c.next = prev;\\n            prev = c;\\n            c = next;\\n            count++;\\n        }\\n        total -= k;\\n        if(total >= k){\\n            head.next = reverseKGroup(next,k);\\n        }\\n        else{\\n            head.next = next;\\n        }\\n        return prev; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711571,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverseKGroup(ListNode* head, int k) {\\n    \\n   ListNode* currCheck = head;\\n    \\n    for(int i = 0; i < k; i++)\\n    {\\n        if(currCheck == NULL)\\n            return head;\\n        \\n        currCheck = currCheck->next;\\n    }\\n\\n    ListNode* curr = head;\\n    ListNode* prev = NULL;\\n    ListNode* nxt = NULL;\\n    \\n    for(int i = 0; i < k; i++)\\n    {\\n        nxt = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = nxt;\\n        \\n    }\\n    head->next = reverseKGroup(curr, k);\\n    \\n    return prev;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverseKGroup(ListNode* head, int k) {\\n    \\n   ListNode* currCheck = head;\\n    \\n    for(int i = 0; i < k; i++)\\n    {\\n        if(currCheck == NULL)\\n            return head;\\n        \\n        currCheck = currCheck->next;\\n    }\\n\\n    ListNode* curr = head;\\n    ListNode* prev = NULL;\\n    ListNode* nxt = NULL;\\n    \\n    for(int i = 0; i < k; i++)\\n    {\\n        nxt = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = nxt;\\n        \\n    }\\n    head->next = reverseKGroup(curr, k);\\n    \\n    return prev;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667374,
                "title": "c-recursion-easy-to-understand-solution",
                "content": "class Solution {\\npublic:\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    ListNode* reverse_node(ListNode* head, int k, int len)\\n    {\\n\\t// check the condition if length is less than k return head. \\n        if(len < k)\\n        {\\n            return head;\\n        }\\n\\t\\t// take count variable to reverse the linked list till size k and break the loop when the count reaches size == k\\n        int count = 0;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n\\t\\t// simple code to reverse linked list.\\n        while(curr != NULL && count < k)\\n        {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\t\\t//  here we will call recursion with (length- k) size and assign value to head next (here head is   the last node of reverse list) and connect the linked list. \\n        head->next = reverse_node(next,k,len-k);\\n\\t\\t// return prev which is actual  head of the linked list.\\n        return prev;\\n    }\\n    \\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n       // first we will count the size of linked list. \\n        int len = 0;\\n        ListNode* temp = head;\\n        while(temp != NULL)\\n        {\\n            len++;\\n            temp = temp->next;\\n        }\\n\\t\\t// again assigning the value of head to temparory list.\\n        temp = head;\\n\\t\\t// call the function (reverse_node) with linked list, length of linked list and size k. \\n       return reverse_node(temp,k,len);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    ListNode* reverse_node(ListNode* head, int k, int len)\\n    {\\n\\t// check the condition if length is less than k return head. \\n        if(len < k)\\n        {\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2612686,
                "title": "unsafe-no-double-traverse-no-recursive-rust-code-with-o-1-of-space-and-o-n-of-time",
                "content": "Ok, first I think that leetcode should change the definition of ListNode and use RefCell. RefCell encapsulates unsafe code. You really need unsafe code here as you need to keep mutable pointers while changing the list at the same time. Otherwise, you need to traverse the list multiple times which is even worse. Recursion is not acceptable as it uses O(n/k) of memory. So here is my try on unsafe Rust. Happy to hear why it might go wrong.\\n\\n```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\n#[inline(always)]\\npub fn get_reversed_k_group(\\n    mut head: Option<Box<ListNode>>,\\n    k: i32,\\n) -> (Option<Box<ListNode>>, Option<Box<ListNode>>, bool) {\\n    // loop k times and reverse the list while looping\\n    // return the head of reversed list and the next node not yet reversed\\n    let mut prev = None;\\n    for _ in 0..k {\\n        if head.is_none() {\\n            // not enough nodes to reverse\\n            return (prev, head, false);\\n        }\\n        let next = head.as_mut().unwrap().next.take();\\n        head.as_mut().unwrap().next = prev;\\n        prev = head;\\n        head = next;\\n    }\\n    (prev, head, true)\\n}\\n\\n#[inline(always)]\\npub fn get_reversed_k_group_if_possible(\\n    mut head: Option<Box<ListNode>>,\\n    k: i32,\\n) -> (Option<Box<ListNode>>, Option<Box<ListNode>>) {\\n    // loop k times and reverse the list while looping\\n    // return the head of reversed list and the next node not yet reversed\\n    if k <= 1 {\\n        let next = head.as_mut().unwrap().next.take();\\n        return (head, next);\\n    }\\n    let (start_of_reversed, next, was_enough_items) = get_reversed_k_group(head, k);\\n    if was_enough_items {\\n        return (start_of_reversed, next);\\n    } else {\\n        let (start_of_reversed_back, _, _) = get_reversed_k_group(start_of_reversed, k);\\n        return (start_of_reversed_back, None);\\n    }\\n}\\n\\n\\n\\n\\n\\nimpl Solution {\\n\\tpub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n\\t\\t// this will have unsafe code as we need to keep a pointer to the last node of the reversed list\\n\\t\\tlet mut head = head;\\n\\t\\tif k <= 1 {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tif head.is_none() {\\n\\t\\t\\treturn None;\\n\\t\\t}\\n\\t\\tlet mut global_head = None;\\n\\t\\t// get raw pointer to head List Node\\n\\t\\tlet mut prev_last_node_in_reversed_list: *mut ListNode = &mut **head.as_mut().unwrap();\\n\\t\\tlet mut i = 0;\\n\\n\\t\\tloop {\\n\\t\\t\\tlet last_node_in_reversed_list: *mut ListNode = &mut **head.as_mut().unwrap();\\n\\n\\t\\t\\tlet (start_of_reversed, next) = get_reversed_k_group_if_possible(head, k);\\n\\t\\t\\tif global_head.is_none() {\\n\\t\\t\\t\\tglobal_head = start_of_reversed;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif i >= 1 {\\n\\t\\t\\t\\t\\tunsafe {\\n\\t\\t\\t\\t\\t\\t(*prev_last_node_in_reversed_list).next = start_of_reversed;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif next.is_none() {\\n\\t\\t\\t\\treturn global_head;\\n\\t\\t\\t}\\n\\t\\t\\thead = next;\\n\\t\\t\\tprev_last_node_in_reversed_list = last_node_in_reversed_list;\\n\\t\\t\\ti += 1\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\n#[inline(always)]\\npub fn get_reversed_k_group(\\n    mut head: Option<Box<ListNode>>,\\n    k: i32,\\n) -> (Option<Box<ListNode>>, Option<Box<ListNode>>, bool) {\\n    // loop k times and reverse the list while looping\\n    // return the head of reversed list and the next node not yet reversed\\n    let mut prev = None;\\n    for _ in 0..k {\\n        if head.is_none() {\\n            // not enough nodes to reverse\\n            return (prev, head, false);\\n        }\\n        let next = head.as_mut().unwrap().next.take();\\n        head.as_mut().unwrap().next = prev;\\n        prev = head;\\n        head = next;\\n    }\\n    (prev, head, true)\\n}\\n\\n#[inline(always)]\\npub fn get_reversed_k_group_if_possible(\\n    mut head: Option<Box<ListNode>>,\\n    k: i32,\\n) -> (Option<Box<ListNode>>, Option<Box<ListNode>>) {\\n    // loop k times and reverse the list while looping\\n    // return the head of reversed list and the next node not yet reversed\\n    if k <= 1 {\\n        let next = head.as_mut().unwrap().next.take();\\n        return (head, next);\\n    }\\n    let (start_of_reversed, next, was_enough_items) = get_reversed_k_group(head, k);\\n    if was_enough_items {\\n        return (start_of_reversed, next);\\n    } else {\\n        let (start_of_reversed_back, _, _) = get_reversed_k_group(start_of_reversed, k);\\n        return (start_of_reversed_back, None);\\n    }\\n}\\n\\n\\n\\n\\n\\nimpl Solution {\\n\\tpub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n\\t\\t// this will have unsafe code as we need to keep a pointer to the last node of the reversed list\\n\\t\\tlet mut head = head;\\n\\t\\tif k <= 1 {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tif head.is_none() {\\n\\t\\t\\treturn None;\\n\\t\\t}\\n\\t\\tlet mut global_head = None;\\n\\t\\t// get raw pointer to head List Node\\n\\t\\tlet mut prev_last_node_in_reversed_list: *mut ListNode = &mut **head.as_mut().unwrap();\\n\\t\\tlet mut i = 0;\\n\\n\\t\\tloop {\\n\\t\\t\\tlet last_node_in_reversed_list: *mut ListNode = &mut **head.as_mut().unwrap();\\n\\n\\t\\t\\tlet (start_of_reversed, next) = get_reversed_k_group_if_possible(head, k);\\n\\t\\t\\tif global_head.is_none() {\\n\\t\\t\\t\\tglobal_head = start_of_reversed;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif i >= 1 {\\n\\t\\t\\t\\t\\tunsafe {\\n\\t\\t\\t\\t\\t\\t(*prev_last_node_in_reversed_list).next = start_of_reversed;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif next.is_none() {\\n\\t\\t\\t\\treturn global_head;\\n\\t\\t\\t}\\n\\t\\t\\thead = next;\\n\\t\\t\\tprev_last_node_in_reversed_list = last_node_in_reversed_list;\\n\\t\\t\\ti += 1\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2598218,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k)\\n    {\\n        ListNode *h=head;\\n        int K=k;\\n        while(K--)\\n        {\\n            if(h==NULL) return head;\\n            h=h->next;\\n        }\\n        \\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        K=k;\\n        while(K--)\\n        {\\n            ListNode* nextNode = curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nextNode;\\n        }\\n        head->next=reverseKGroup(curr,k);\\n        return prev;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k)\\n    {\\n        ListNode *h=head;\\n        int K=k;\\n        while(K--)\\n        {\\n            if(h==NULL) return head;\\n            h=h->next;\\n        }\\n        \\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        K=k;\\n        while(K--)\\n        {\\n            ListNode* nextNode = curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nextNode;\\n        }\\n        head->next=reverseKGroup(curr,k);\\n        return prev;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593476,
                "title": "86-faster-simple-k-reverse-in-o-n-time",
                "content": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = temp = head\\n        nxt = None\\n        prev = None\\n        count = 0\\n\\n        # check if next count is equal to k\\n        while temp and count<k:\\n            temp = temp.next\\n            count += 1\\n        if count < k: \\n            return curr\\n\\n        # if k nodes then reverse\\n        count = 0\\n        while curr and count<k:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n            count += 1\\n\\n        # reverse next k\\n        if nxt :\\n            head.next = self.reverseKGroup(nxt, k)\\n\\n        return prev\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = temp = head\\n        nxt = None\\n        prev = None\\n        count = 0\\n\\n        # check if next count is equal to k\\n        while temp and count<k:\\n            temp = temp.next\\n            count += 1\\n        if count < k: \\n            return curr\\n\\n        # if k nodes then reverse\\n        count = 0\\n        while curr and count<k:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n            count += 1\\n\\n        # reverse next k\\n        if nxt :\\n            head.next = self.reverseKGroup(nxt, k)\\n\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566486,
                "title": "based-on-253-reverse-linked-list-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int length(ListNode * head)\\n{\\n    int len=0;\\n    while(head!=NULL){\\n        \\n        len++;\\n        head=head->next;\\n    }\\n    return len;\\n}\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *next=NULL;\\n         if(length(head) < k)\\n   {\\n       return head;\\n       //reverse ki maa ki aankh\\n   }\\n        for(int i=0;i<k;i++)\\n        {\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        head->next=reverseKGroup(curr,k);\\n        return prev;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2445505,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=2BCT3UEVkng",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=2BCT3UEVkng",
                "codeTag": "Unknown"
            },
            {
                "id": 2430932,
                "title": "c-accepted-best-approach-with-steps-explanation-easy-to-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Upvote if you like it!!!!***\\n\\n**Approach:**\\n\\nThe following steps are needed to arrive at the desired output. \\n\\n1. Create a dummy node. Point next to this node to head of the linked list provided.\\nIterate through the given linked list to get the length of the list.\\n2. Create three pointer pre,cur and nex to reverse each group. Why? If we observe output, we can see that we have to reverse each group, apart from modifying links of group.\\n3. Iterate through the linked list until the length of list to be processed is greater than and equal to given k.\\n4. For each iteration, point cur to pre->next and nex to nex->next.\\n5. Start nested iteration for length of k.\\n6. For each iteration, modify links as following steps:-\\n\\t\\t* cur->next = nex->next\\n\\t\\t* nex->next = pre->next\\n\\t\\t* pre->next = nex\\n\\t\\t* nex = cur->next\\n\\t\\t* Move pre to cur and reduce length by k.\\n7. At the end return dummy->next.\\n\\n**Dry run:**\\n\\n![image](https://assets.leetcode.com/users/images/555638ce-0be2-4a18-aaca-761ec92a0daa_1660591800.5138576.jpeg)\\n\\n**Code:-** \\n```\\nclass Solution {\\npublic:\\n    int listLength(ListNode* head){\\n        int len=0;\\n        while(head!=NULL){\\n            len++;\\n            head=head->next;\\n        }\\n        return len;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len=listLength(head);\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        ListNode* curr;\\n        ListNode* nex;\\n        \\n        while(len>=k){\\n            curr=prev->next;\\n            nex=curr->next;\\n            for(int i=1;i<k;i++){\\n                curr->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=curr->next;\\n            }\\n            prev=curr;\\n            len-=k;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int listLength(ListNode* head){\\n        int len=0;\\n        while(head!=NULL){\\n            len++;\\n            head=head->next;\\n        }\\n        return len;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len=listLength(head);\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        ListNode* curr;\\n        ListNode* nex;\\n        \\n        while(len>=k){\\n            curr=prev->next;\\n            nex=curr->next;\\n            for(int i=1;i<k;i++){\\n                curr->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=curr->next;\\n            }\\n            prev=curr;\\n            len-=k;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337808,
                "title": "simple-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public ListNode solve(ListNode head, int k, int n) {\\n        if(n<k) return head;      \\n        int i=0;\\n        ListNode temp=head, prev=null, next=null;\\n        while(i++<k) {\\n            next=temp.next;\\n            temp.next=prev;\\n            prev=temp;\\n            temp=next;\\n        }\\n        head.next= solve(temp,k, n-k);\\n        return prev;\\n    }\\n    \\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(k==1) return head;\\n        int n=0;\\n        ListNode temp=head;\\n        while(temp!=null) {\\n            temp=temp.next;\\n            n++;\\n        }\\n        return solve(head, k, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode solve(ListNode head, int k, int n) {\\n        if(n<k) return head;      \\n        int i=0;\\n        ListNode temp=head, prev=null, next=null;\\n        while(i++<k) {\\n            next=temp.next;\\n            temp.next=prev;\\n            prev=temp;\\n            temp=next;\\n        }\\n        head.next= solve(temp,k, n-k);\\n        return prev;\\n    }\\n    \\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(k==1) return head;\\n        int n=0;\\n        ListNode temp=head;\\n        while(temp!=null) {\\n            temp=temp.next;\\n            n++;\\n        }\\n        return solve(head, k, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177670,
                "title": "beginner-friendly-shortest-code-c-stack",
                "content": "Please **upvote** if it helped you to understand\\n\\n **Approach** :   \\n \\n**STEP 01**  :::     Traverse every k distance and keep inserting them in stack . \\n**STEP 02**  :::     Untill stack is empty pop & keep updating the values in linked list which is already in reversed form (  *Due to Stack* )\\n\\n**NOTE** :  *I have just shared my approach for the beginners ! You can definitely try with constant space*\\n\\nHere is the simple code : \\n\\n\\n```\\nListNode *reverseKGroup(ListNode *head, int k)\\n    {\\n        ListNode *fast = head, *slow = head;\\n        stack<int> st;\\n        while (fast){\\n            for (int i = 0; i < k; i++){\\n                if (fast) st.push(fast->val);\\n                else return head;\\n                fast = fast->next;\\n            }\\n            while (!st.empty()){\\n                slow->val = st.top();\\n                st.pop();\\n                slow = slow->next;\\n            }\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nListNode *reverseKGroup(ListNode *head, int k)\\n    {\\n        ListNode *fast = head, *slow = head;\\n        stack<int> st;\\n        while (fast){\\n            for (int i = 0; i < k; i++){\\n                if (fast) st.push(fast->val);\\n                else return head;\\n                fast = fast->next;\\n            }\\n            while (!st.empty()){\\n                slow->val = st.top();\\n                st.pop();\\n                slow = slow->next;\\n            }\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2066151,
                "title": "easy-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || k==1) return head;\\n        \\n        ListNode *dummy=new ListNode(0);\\n        dummy->next=head;\\n        \\n        ListNode *curr=dummy , *nex=dummy , *prev=dummy;\\n        int count=0;\\n        \\n        while(curr->next!=NULL){\\n            curr=curr->next;    //compute the length of LL\\n            count++;\\n        }\\n        \\n        while(count>=k){\\n            curr=prev->next;          //operations to reverse the LL in group of size k\\n            nex=curr->next;\\n            for(int i=1;i<k;i++){\\n                curr->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=curr->next;\\n            }\\n            prev=curr;        //move prev to curr and reduce length by k\\n            count-=k;\\n        }\\n        return dummy->next;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL || k==1) return head;\\n        \\n        ListNode *dummy=new ListNode(0);\\n        dummy->next=head;\\n        \\n        ListNode *curr=dummy , *nex=dummy , *prev=dummy;\\n        int count=0;\\n        \\n        while(curr->next!=NULL){\\n            curr=curr->next;    //compute the length of LL\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2033880,
                "title": "python-iteration-recursion-all-variants",
                "content": "**Approach 1: Iterative**\\nThis has a time complexity of `O(N)` and space complexity of `O(1)`\\n```\\nclass Solution:\\n\\tdef reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n\\t\\tif not head or not head.next or k == 1: return head\\n\\n\\t\\tdummy = ListNode(-1, head)\\n\\t\\tgroupPrev = dummy\\n\\t\\twhile True:\\n\\t\\t\\t# Get kth node of the group\\n\\t\\t\\tkth = self.getKth(groupPrev, k)\\n\\t\\t\\tif not kth: break\\n\\t\\t\\tgroupNext = kth.next\\n\\n\\t\\t\\t# Reverse Group\\n\\t\\t\\tprev, curr = groupNext, groupPrev.next\\n\\t\\t\\twhile curr != groupNext:\\n\\t\\t\\t\\tcurr.next, prev, curr = prev, curr, curr.next\\n\\n\\t\\t\\t# Move groupPrev pointer to the next group position(node before next group)\\n\\t\\t\\tgroupPrev.next, groupPrev = kth, groupPrev.next\\n\\n\\t\\treturn dummy.next\\n\\n    def getKth(self, curr: ListNode, k: int) -> ListNode:\\n\\t\\twhile curr and k > 0:\\n\\t\\t\\tcurr = curr.next\\n\\t\\t\\tk -= 1\\n\\t\\treturn curr\\n```\\n\\n\\n**Approach 2: Recursive**\\nThis has a time complexity of `O(N)` and space complexity of `O(N/k)`\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n\\n        # Check if k group size is valid\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n            \\n        # Reverse k nodes\\n        prev, curr = None, head\\n        for _ in range(k):\\n            curr.next, prev, curr = prev, curr, curr.next\\n        \\n        # Recursively solve for the remaining list\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\\n\\n\\n**Variant 1: Reverse the remaining nodes as well**\\nGiven: `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8` and `k=3`\\nResult: `3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 8 -> 7`\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n            \\n        # Reverse k nodes and if there is no current node left we simply return the previous node\\n        prev, curr = None, head\\n        for _ in range(k):\\n\\t\\t\\tif not curr: return prev\\n            curr.next, prev, curr = prev, curr, curr.next\\n        \\n        # Recursively solve for the remaining list\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\\n\\n\\n**Variant 2: Reverse nodes in alternate groups of k size**\\nGiven: `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9` and `k=3`\\nResult: `3 -> 2 -> 1 -> 4 -> 5 -> 6 -> 9 -> 8 -> 7`\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n\\t\\t\\n\\t\\t# Check if k group size is valid\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n            \\n        # Reverse k nodes\\n        prev, curr = None, head\\n        for _ in range(k):\\n            curr.next, prev, curr = prev, curr, curr.next\\n\\t\\t\\n\\t\\t# Point head.next to the remaining list\\n\\t\\thead.next = curr\\n\\t\\t\\n\\t\\t# Skip next k nodes\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tcurr = curr.next\\n        \\n        # Recursively solve for the remaining list\\n\\t\\tif curr: curr.next = self.reverseKGroup(curr.next, k)\\n        return prev\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n\\tdef reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n\\t\\tif not head or not head.next or k == 1: return head\\n\\n\\t\\tdummy = ListNode(-1, head)\\n\\t\\tgroupPrev = dummy\\n\\t\\twhile True:\\n\\t\\t\\t# Get kth node of the group\\n\\t\\t\\tkth = self.getKth(groupPrev, k)\\n\\t\\t\\tif not kth: break\\n\\t\\t\\tgroupNext = kth.next\\n\\n\\t\\t\\t# Reverse Group\\n\\t\\t\\tprev, curr = groupNext, groupPrev.next\\n\\t\\t\\twhile curr != groupNext:\\n\\t\\t\\t\\tcurr.next, prev, curr = prev, curr, curr.next\\n\\n\\t\\t\\t# Move groupPrev pointer to the next group position(node before next group)\\n\\t\\t\\tgroupPrev.next, groupPrev = kth, groupPrev.next\\n\\n\\t\\treturn dummy.next\\n\\n    def getKth(self, curr: ListNode, k: int) -> ListNode:\\n\\t\\twhile curr and k > 0:\\n\\t\\t\\tcurr = curr.next\\n\\t\\t\\tk -= 1\\n\\t\\treturn curr\\n```\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n\\n        # Check if k group size is valid\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n            \\n        # Reverse k nodes\\n        prev, curr = None, head\\n        for _ in range(k):\\n            curr.next, prev, curr = prev, curr, curr.next\\n        \\n        # Recursively solve for the remaining list\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n            \\n        # Reverse k nodes and if there is no current node left we simply return the previous node\\n        prev, curr = None, head\\n        for _ in range(k):\\n\\t\\t\\tif not curr: return prev\\n            curr.next, prev, curr = prev, curr, curr.next\\n        \\n        # Recursively solve for the remaining list\\n        head.next = self.reverseKGroup(curr, k)\\n        return prev\\n```\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n\\t\\t# Edge Cases\\n        if not head or not head.next or k == 1: return head\\n\\t\\t\\n\\t\\t# Check if k group size is valid\\n        curr = head\\n        for _ in range(k):\\n            if not curr: return head\\n            curr = curr.next\\n            \\n        # Reverse k nodes\\n        prev, curr = None, head\\n        for _ in range(k):\\n            curr.next, prev, curr = prev, curr, curr.next\\n\\t\\t\\n\\t\\t# Point head.next to the remaining list\\n\\t\\thead.next = curr\\n\\t\\t\\n\\t\\t# Skip next k nodes\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tcurr = curr.next\\n        \\n        # Recursively solve for the remaining list\\n\\t\\tif curr: curr.next = self.reverseKGroup(curr.next, k)\\n        return prev\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565061,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567351,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1741989,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567812,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1566356,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1568842,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1569766,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567342,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1576658,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1573202,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1565061,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567351,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1741989,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567812,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1566356,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1568842,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1569766,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1567342,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1576658,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1573202,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The description states that \"k is a positive integer and is less than or equal to the length of the linked list.\", yet one of test cases has list `[1]` and `k = 2`."
                    },
                    {
                        "username": "WarGames",
                        "content": "[@reassurance](/reassurance) Lol, so arange the single element in oposite order :) no, according to the rules you dont need to touch it"
                    },
                    {
                        "username": "reassurance",
                        "content": "LMAO ! How did you solve it then?\\n"
                    },
                    {
                        "username": "GS2306",
                        "content": "Test Case\\n[1,2], k = 3\\nis present in the test suite, which is wrong.\\n\\nIt is clearly mentioned in the question that k will be smaller than the length of the linked list"
                    },
                    {
                        "username": "calm27",
                        "content": "did in one pass, but with a small issue, i\\'ve spent ~4 hours to resolve it. \\ninterview -> failed\\nself-confidence -> up\\n"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "\"Your greatest teacher is you last mistake.\""
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "You gonna crack the next interview for sure"
                    },
                    {
                        "username": "2030019",
                        "content": "that is how you learn broski"
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Hi, This problem asks \"Only constant memory is allowed\". Even though my solution has passed the online judgement, I still want to know if a stack with maximum memory k is using constant memory. Thanks."
                    },
                    {
                        "username": "Husoski",
                        "content": "You can get the effect of that \"maximum memory k\" stack by making your own stack from nodes of the original list.  The only additional memory needed for that is a top-of-stack pointer, and probably an integer to count when the stack size reaches k.  "
                    },
                    {
                        "username": "Jupajupe",
                        "content": "No because k can be equal to n, which means you are potentially using O(n) memory"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "They are mentioning constant memory this means no stack space to be used at all. As in they are asking us to solve this question without recursion!"
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for follow-up question to reverse every alternate K nodes in C++/Java/Python:\\nhttps://www.techiedelight.com/reverse-alternate-group-k-nodes-linked-list/"
                    },
                    {
                        "username": "richarddia",
                        "content": "It is mentioned in the question stem that \"k is a positive integer and is **less than or equal to** the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\"\\n\\nI meet test cases like this\\n[1,2]\\nk = 3\\nThe expected answer is [2,1]???????"
                    },
                    {
                        "username": "keira_09",
                        "content": "in case if K passes the limit for the length of the list  , we simply need to put the condition for it and return the head as it is . "
                    },
                    {
                        "username": "parthbhide391",
                        "content": "description says \"k is a positive integer and is less than or equal to the length of the linked list.\" still have testcases where k > len."
                    },
                    {
                        "username": "xuchang75",
                        "content": "k is a positive integer and is less than or equal to the length of the linked list\n\nbut the test case actually contains:\n[1]\n2"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ Solution : https://www.nileshblog.tech/2022/04/22/leet-code-reverse-nodes-in-k-group-java-python-c-javascript-solution%ef%bf%bc/"
                    },
                    {
                        "username": "nmtdevelops",
                        "content": "How come  below mentioned test case is valiid when it is mentioned that \"k is a positive integer and is less than or equal to the length of the linked list. \"\\n[1]\\n2"
                    }
                ]
            },
            {
                "id": 1895029,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1568843,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1569762,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1572951,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1568844,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1568845,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1567294,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1939776,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1930640,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1739295,
                "content": [
                    {
                        "username": "proco",
                        "content": "I can\\'t Understand this Question someone please help me"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "[@Q1CHENL](/Q1CHENL) damn.. that\\'s  the best explanation I have seen in a while"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "you have to reverse *every* k nodes"
                    },
                    {
                        "username": "ooggnn123",
                        "content": "It is mentioned in the question that the value of k will be less than or equal to the length of the linked list. However there is a test case with input list: [1] and k: 2.\\n\\nForgive me if I am wrong. Thanks."
                    },
                    {
                        "username": "stevenc69",
                        "content": "I would have finished with just 1 submission, but there\\'s a test case where k = 2, but the length of the list is just 1. That\\'s invalid per the directions."
                    },
                    {
                        "username": "AnudeepReddyBondugula",
                        "content": "You can just return the list as it is"
                    },
                    {
                        "username": "lwchkg",
                        "content": "Unless the code is tail call optimized the extra memory of recursion is larger than O(1)."
                    },
                    {
                        "username": "ankurs",
                        "content": "There is a discrepancy in the problem statement and actual test cases. The problem statement says  - \"k is a positive integer and is less than or equal to the length of the linked list.\"\\n\\nHowever, for one of the test cases, input is an empty list and the value of \"k\" is 2. \\n\\nPlease look into it."
                    },
                    {
                        "username": "squirreljobhunting",
                        "content": "Does anyone know how to deal with k > length of the list?"
                    },
                    {
                        "username": "san003agarwal",
                        "content": "I think, in that case we need to print the as it is linked list..."
                    },
                    {
                        "username": "spc90",
                        "content": "**EDIT:** Well, it seems the testcases just simply ignore all the assumptions of the problems... good to know. \\n\\n**Issue:** The problem text states *\"k is a **positive integer** and is **less than or equal to the length** of the linked list\"*. This means that k is at least 1, and therefore so is the length of the list. So imagine my surprise when my code failed in the submission due to the testcase **\"[] 2\"** :-)\\n\\n**Fix:** either don\\'t specify anything about the value of k and then the list/k can also be empty/zero and, implicitly, also allow k > length cases (because the algorithms should already handle such cases when we are left with less than k nodes at the end), **or** just say k is a ***non-negative*** integer, keep the \"less than...\" part, and provide a correct(ed) testcase **\"[] 0\"** -- I propose the latter.\\n\\nUntil this is handled, I will add in my code the non-NULL check on the head pointer, but I\\'m not happy about it :-)"
                    },
                    {
                        "username": "urmichm",
                        "content": "This could have been a medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "this question is difficult i dont know when it will ever become easy for me "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "One of those problems where recursive solution is a breeze but the iterative one tests your ability. The iterative one is the only one with real O(1) space complexity. BUT in an interview setting it would make sense to do only recursive one because of time constraints.."
                    }
                ]
            },
            {
                "id": 1572629,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 1572515,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 1571063,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 1571064,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 1572103,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 1571930,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 2062924,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 2055841,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 2052967,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 2048698,
                "content": [
                    {
                        "username": "jiyoun",
                        "content": "The problem states : \\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\\n\\nOne of the test cases, when submitted, was as follows : \\n\\n[]\\n2\\n\\nThis, by definition of the k above does not suffice the required upper bound for k, which should be less than or equal to size of the list -- which in this case is 0.\\n\\nI don\\'t think this test case should be included in the problem. Any thoughts on this?"
                    },
                    {
                        "username": "JanzenLiu",
                        "content": "It said `k is a positive integer and is less than or equal to the length of the linked list` in the description, so I didn\\'t handle this case. But when I submitted I failed on testcases like `[],2`, `[1],2`. Honestly the description is really bad. If you have such testcases, you shouldn\\'t tell in the description in this way."
                    },
                    {
                        "username": "esrujan",
                        "content": "The problem statement clearly states that \"k is a positive integer and is less than or equal to the length of the linked list\" but the test cases do not satisfy this statement. This is very disappointing!!!!!!!"
                    },
                    {
                        "username": "zgkdzy",
                        "content": "I found a test case like this:\\n[1]\\n2\\nHowever, it is illegal, since k is a positive integer and is less than or equal to the length of the linked list. Please revise it if you think it's necessary."
                    },
                    {
                        "username": "87550444",
                        "content": "So easy. The problem shouldn\\'t be a hard one"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The recursive solution is medium but the iterative one is hard indeed."
                    },
                    {
                        "username": "GameMaker",
                        "content": "1) It says in the spec k will always be positive and less than or equal to the length, but it sends you [], 2 as an input. Which doesn\\'t satisfy its own requirements, so you fail for not checking the error condition. Ok, fine, whatever.\\n2) It says to reverse nodes, which I took to mean swap, ex:\\n1 - 2 - 3 - 4 - 5, k = 4 yields\\n4 - 2 - 3 - 1 - 5\\nBut that\\'s not right, it wants\\n4 - 3 - 2 - 1 - 5\\n\\nI get it, now, but it would be useful to include an example above k = 3, since for k < 4, the answers are identical."
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "It should be tagged easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "athulshibu",
                        "content": "What's stopping someone from making an array of node addresses, then creating a new linked list i the right order using those addresses?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "if you don\\'t have any idea about reversing linked list, try these simple first [206. Reverse Linked List\\n](https://leetcode.com/problems/reverse-linked-list/description/), [92. Reverse Linked List II\\n](https://leetcode.com/problems/reverse-linked-list-ii/description/)"
                    },
                    {
                        "username": "ravisuthaar",
                        "content": "k=4\\n"
                    }
                ]
            },
            {
                "id": 2047730,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 2030651,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 2018197,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1993036,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1984742,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1982930,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1949331,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1892920,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1867422,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1862969,
                "content": [
                    {
                        "username": "Aaryan_0001",
                        "content": "RECURSIVE APPROACH.\\n\\nBasic approach is that we will first reverse the list elements of k-group, once first group is reversed we will go to reverse the 2nd group and also check appropriate length is remaining or not. And call this recursively untill our length is traveresed.\\n\\n1. Declare a function which will return the lenghth of the linked list.\\n\\n2. Declare another function(we will use this as recursive function) and within this function reverse the k-group elements (use a pointer to keep track of \\'k\\' elements being reversed or not).\\n\\n3. Once our 1st group of elements are reversed we will call the function recursively to reverse the next set of elements (NOTE: each set of elements after reversing needs to be connected with each other i.e once you reverse a k-group the last element will be always pointing to NULL as its next node, so remember to update the end of each reversed node.\\n\\n4. Also in each recursive call rembember to check if appropriate length is left or not , i.e if list elements are 5 and k=3 then we can only reverse only 1 set of element bcoz once 3 elements are reversed we will be left with 5-3=2 elements and k=3 we will not be able to reverse 2 elements so keep track of length of list also.\\n\\n\\nlass Solution {\\npublic:\\n    ListNode* rev(ListNode* head, int k , int &length){\\n        if(head == nullptr || k>length)\\n            return head;\\n\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        ListNode* forward;\\n        int count = 0;      //this will keep track of k-groups in each iteration\\n\\n        while(curr!=nullptr && count<k && k<=length){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        length =length - k;\\n        if(forward!=nullptr)\\n            head->next = rev(forward,k,length);\\n        \\n        return prev;\\n    }\\n\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=nullptr){\\n            count++;\\n            temp = temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        int len = length(head);\\n        return rev(head,k,len);\\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is a really good exercise for linked list. And you may not worry about question regarding this topic once you can solve this with reasonable confidence."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Not the hardest Hard on leet, but problems that focus heavily on pointer manipulation can be tough to solve in an hour under the pressure of an interview. Plus, the time and space complexity requirements mean you must solve it iteratively, adding yet another layer of difficulty. \n\nWas able to solve it in two passes, but I would love to know how folks solved it in a single-pass. "
                    },
                    {
                        "username": "kve315",
                        "content": "Why is it showing error at return statement at last line. I think my answer is right but somehow it is showing this stupid error.\n\nPlz help!!!\n\n    ListNode* reverse(ListNode* head, int k){\n        ListNode* prev = NULL;\n        ListNode* nxt = NULL;\n        ListNode* curr = head;\n        int count = 0;\n        while(curr && count<k){\n            nxt = curr->next;\n            curr->next = prev;\n            prev= curr;\n            curr= nxt;\n            count++;\n        }\n        return prev;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n        if(!head || !head->next)\n        return head;\n\n        ListNode* curr = head;\n        int count=0;\n        while(curr && count<k-1){\n            curr=curr->next;\n            count++;\n        }\n\n        ListNode* tail = head;\n        ListNode* headnew = reverse(head);\n        ListNode* newTail= NULL;\n\n\n\n        while( curr )\n        {\n          curr= newTail;\n\n          count = 0;\n          while( curr && count<k)\n            { curr=curr->next;\n              count++;}\n            }\n          tail->next = reverse(newTail);\n           \n          tail = newTail;\n        }\n       return headnew;\n    }\n"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "first you should consider a k nodes list separately, then you have to apply reverse list function.\\n\\n\" ListNode* tail = head;\\n    ListNode* headnew = reverse(head);\\n    ListNode* newTail= NULL;\" in this code I think  you try to find reverse for first node itself so erase this step, and \\nnow \\n\"while( curr && count<k)\\n        { curr=curr->next;\\n          count++;}\\n        }\\n      tail->next = reverse(newTail);\" focus only on this step.\\n"
                    },
                    {
                        "username": "ategale",
                        "content": "Do we have to do it in-place?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "yeah you have to do it by swapping the nodes"
                    },
                    {
                        "username": "r_o_xx_",
                        "content": "Solved in 2 hours without any help. Confidence BOOSTED."
                    },
                    {
                        "username": "daydreamer15",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        \\n        //this much has been done to reverse up till first k nodes\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        ListNode*forward = NULL;\\n        ListNode*curr = head;\\n        ListNode*prev = NULL;\\n        int count = 0;\\n\\n        while(curr!=NULL && count<k){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        //Now we would let recursion do the upcoming next reversals\\n        if(forward!=NULL){\\n            head->next = reverseKGroup(forward, k);\\n        }\\n\\n        //Now we would return the head, which is the rpev node here in this case\\n        return prev;\\n    }\\n};\\n\\nHi guys, I\\'ve written this code, can anybody please tell me where am I wrong with this one? Please:)\\n"
                    },
                    {
                        "username": "Dominating_",
                        "content": "Prolly when the linked list length is not a multiple of K.\nfor example: -\n1 2 3 4 5\nyour output - 3 2 1 5 4\nactual output - 3 2 1 4 5\nTry using a valid function before \nhead->next = reverseKGroup(forward, k);\n\npublic Boolean checkvalid(ListNode head, int k) {\n        int count = 0;\n        ListNode temp = head;\n        while(count < k && temp != null) {\n            temp = temp.next;   \n            count += 1;\n        }\n        if (count < k) {\n            return false;\n        }\n        return true;\n    }"
                    },
                    {
                        "username": "vaishaliranjan",
                        "content": "like the cases where we would have elements less than the size of k"
                    },
                    {
                        "username": "alpacagm",
                        "content": "There can be different solutions optimized for execution time if we know a little bit more about test-data characteristics. At least there may be different approaches to handle \"dangling tails\" depending on expected n/k ratio"
                    },
                    {
                        "username": "Okpatu",
                        "content": "\\u201C If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is\\u201D \\nCan someone explain the above statement to me using example 1 as a reference? \\nI don\\u2019t understand it "
                    },
                    {
                        "username": "Dhabot",
                        "content": "Wow! First time I solved a Leetcode Hard problem. That too in 0 ms and O(1) extra space. "
                    }
                ]
            },
            {
                "id": 1857201,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1851233,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1834744,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1806565,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1803237,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1795466,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1791978,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1790635,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1783637,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1780679,
                "content": [
                    {
                        "username": "Masterdemon123",
                        "content": "to solve this problem , you guys can start with this problem first https://leetcode.com/problems/reverse-linked-list-ii/description/ \\nthen realize that this problem is just an upgrade  of that problem  "
                    },
                    {
                        "username": "XANTHERR",
                        "content": "i wrote the exact same code but with different variables, and when i run it, it shows error !\\nTHe code that i wrote is : \\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1){\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode curr = dummy, prev = dummy, nex = dummy;\\n        int count = 0;\\n        while(curr != null){\\n            curr = curr.next;\\n            count++;\\n        }\\n         \\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\nthe original code was :\\nclass Solution {\\n    public ListNode reverseKGroup(ListNode head, int k) {\\n        if(head==null || k==1)return head;\\n\\n        ListNode dum = new ListNode(0);\\n        dum.next=head;\\n\\n        ListNode curr=dum, nex=dum, prev=dum;\\n\\n        int count=0;\\n        while(curr.next!=null){\\n            curr=curr.next;\\n            count++;\\n        }\\n\\n        while(count>=k){\\n            curr=prev.next;\\n            nex=curr.next;\\n            for(int i=1; i<k; i++){\\n                curr.next=nex.next;\\n                nex.next=prev.next;\\n                prev.next=nex;\\n                nex=curr.next;\\n            }\\n            prev=curr;\\n            count-=k;\\n        }\\n        return dum.next;\\n    }\\n}\\n\\n\\nDo tell me what was the difference ?"
                    },
                    {
                        "username": "indranilghosh896",
                        "content": "the head.length method of js doesnt work in this problem and Array.isArray(head) returns false event though head is an array"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The head is not an array, is a linked list, It\\'s just the way that leetcode use to write it.\\nWe can use instead of that:\\n1 -> 2 -> 3 -> 4 -> null"
                    },
                    {
                        "username": "psionl0",
                        "content": "Interesting.\\n\\nMy solution ran in 3 ms. Then I cleaned the code by deleting all commented out lines and ran submit again. This time the running time is 11 ms."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Guys here through follow up they are asking us to use O(1) space, i.e. they are mentioning no stack space to be used at all. As in they are asking us to solve this question without recursion"
                    },
                    {
                        "username": "abhishah1304",
                        "content": "Can someone plzz explain what is wrong with this code ?\\n\\npair<ListNode*,ListNode*> reverse(ListNode *head)\\n{\\n         ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        while(curr)\\n        {\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        pair<ListNode*,ListNode*> p;\\n        p.first = prev;\\n        p.second = head;\\n        return p;\\n    }\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n        if((head==NULL)||(head->next==NULL))\\n        {\\n            return head;\\n        }\\n       \\n        ListNode *end = head;\\n        ListNode *temp = head;\\n        int count = 0;\\n        while(temp)\\n        {\\n            count++;\\n            temp = temp->next;\\n        }\\n        count++;\\n        k = (k%count);\\n        while(k-1)\\n        {\\n            end = end->next;\\n            k--;\\n        }\\n\\n        ListNode *res = reverseKGroup(end->next,k);\\n        pair<ListNode*,ListNode*> ans = reverse(head);\\n        ans.second->next = res;\\n        return ans.first;\\n  }"
                    },
                    {
                        "username": "rajkhandelwal3152001",
                        "content": "Can anyone tell what\\'s wrong in this code for this question.\\n\\nListNode* reverseKGroup(ListNode* head, int k) {\\n       \\n        ListNode* temp = head;\\n        ListNode* temp1 = head;\\n        temp1 = temp->next;\\n        while(temp1!=NULL){\\n            \\n            int value = temp->val;\\n            temp->val = temp1->val;\\n            temp1->val = value;\\n            int i=0;\\n            while(i<k){\\n                i++;\\n                temp = temp->next;\\n                temp1 = temp1->next;        \\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the approach:-\\nCount the number of nodes in the first k nodes of the linked list. If there are exactly k nodes, then we reverse the pointers of these k nodes. To do this, we recursively call reverseKGroup on the rest of the list (excluding the first k nodes) and then reverse the pointers of the first k nodes one by one. The function returns the new head of the reversed linked list. If there are less than k nodes in the first k nodes, then the list is unchanged and the original head is returned."
                    },
                    {
                        "username": "kennethone",
                        "content": "I solved the problem simply by creating a vector with indexes with pointers to each node, \\nI think this is an easy and elegant solution with no change O(n log n) time complexity and minimal additional space complexity to allocate a vector of pointers. I think going forward, I would solve all linked list problems this way. How would someone react to this solution as an interviewer?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "To train you can solve first:\n* [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) Easy\n* [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/) Medium\n\nIt would be a partial solution to this Hard problem"
                    },
                    {
                        "username": "akshat_20978",
                        "content": "Thanks man really helpful\\n"
                    }
                ]
            },
            {
                "id": 1773737,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1769419,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1760986,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1759434,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1758576,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1729687,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1717832,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1689427,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1682266,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            },
            {
                "id": 1678311,
                "content": [
                    {
                        "username": "Sahil_Dhariya_11",
                        "content": "Hello guys, need serious help in solving linked list questions, how to solve any given question in at least 30 min? I end up taking 2-3 hours or sometimes a half day. Even though logic is simple I make some linking mistake so I literally have to print the node values to understand what is going on.\\n\\nThanks in advance.\\n  "
                    },
                    {
                        "username": "shantanuborade007",
                        "content": "this is what progress is , this is how you learn dsa"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "O(N) Time Complexity Solution in c \\nstruct ListNode* reverseKGroup(struct ListNode* head, int k)\\n{\\n    if(head == NULL || k ==1 )\\n    {\\n        return head ;\\n    }\\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->next = head ;\\n    struct ListNode* curr = dummy ;\\n    struct ListNode* next = dummy ;\\n    struct ListNode* prev = dummy ;\\n    int count = 0 ;\\n    while(curr->next != NULL)\\n    {\\n        count++ ;\\n        curr = curr->next ;\\n    }\\n    while(count >= k)\\n    {\\n        curr = prev->next ;\\n        next = curr->next ;\\n        for(int i = 1 ; i < k ; i++)\\n        {\\n            curr->next = next->next ;\\n            next->next = prev->next ;\\n            prev->next = next ;\\n            next = curr->next ;\\n        }\\n        prev = curr ; \\n        count -= k ;\\n    }\\n    return dummy->next ;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "pamelah",
                        "content": "Hi why there always shows \"RecursionError: maximum recursion depth exceeded in comparison\"? Thanks a lot"
                    },
                    {
                        "username": "divyanshu_69",
                        "content": "in This problem there is mentioned clearly that  \"k\" integer will be be smaller or equal to the head  liknkedlist but in some test case list size is smaller and the k integer element is greater like -  L  = [1,  3 , 5]  and k =  4 .  `your inline code...your inline code...`"
                    },
                    {
                        "username": "hobrah_commander",
                        "content": "I\\'m understanding that perhaps these problems with poorly worded questions are the most applicable to real world. Client swears to you their assumptions about their problem are correct, only for you to find out they are wrong after banging your head against the wall wondering why 2+2=7."
                    },
                    {
                        "username": "belwalentin",
                        "content": "Can anyone explain why it is forbidden to change values?\\nDoes this create conditions close to solving a real production task?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "because if the nodes are bulky(big size), then writing values will take a lot of time. But changing links will not take much time. All the benefit of a linked list would be lost if we copy the values for whole of list. Changing links is the reason linked list is preferred in scenarios."
                    },
                    {
                        "username": "Jeevan-23",
                        "content": "hi malik please explain this code\\n"
                    },
                    {
                        "username": "user0213z",
                        "content": "I think in the rust ListNode definition to this problem there should be reference to next node, not the owning relationship.\n `pub struct ListNode {\n   pub val: i32,\n   pub next: &Option<Box<ListNode>>\n }`\nProbably like this. Because currently cloning the node causes cloning the whole list. \nNot an experienced rustacean so maybe I am wrong. "
                    },
                    {
                        "username": "whybro",
                        "content": "function ListNode(val, next) {\\n    this.val = (val===undefined ? 0 : val)\\n    this.next = (next===undefined ? null : next)\\n}\\n\\nvar reverseKGroup = function(head, k) {\\n    let newHead = new ListNode();\\n    newHead.next = head;\\n\\n    if (k > 1) {\\n        let prev = newHead;\\n        let cur = newHead.next;\\n\\n        let count = 1;\\n\\n        while (cur !== null) {\\n            if (count === k) {\\n                let next = cur.next;\\n\\n                cur.next = null;\\n\\n                const prevHead = prev.next;\\n                reverse(prevHead);\\n\\n                prev.next = cur;\\n                prevHead.next = next;\\n\\n                cur = next;\\n                prev = prevHead;\\n\\n                count = 1;\\n            } else {\\n                cur = cur.next;\\n                count++;\\n            }\\n        }\\n\\n    }\\n\\n    return newHead.next;\\n};\\n\\nfunction reverse(head) {\\n    let cur = head;\\n    let newHead = head;\\n\\n    if (cur !== null) {\\n        let next = cur.next;\\n\\n        while (next !== null) {\\n            const temp = next.next;\\n\\n            next.next = cur;\\n\\n            cur = next;\\n            next = temp;\\n        }\\n\\n        newHead = cur;\\n        head.next = null;\\n    }\\n\\n    return newHead;\\n}"
                    }
                ]
            }
        ]
    }
]