[
    {
        "title": "Binary Gap",
        "question_content": "Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0.\nTwo 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in \"1001\" have a distance of 3.\n&nbsp;\nExample 1:\n\nInput: n = 22\nOutput: 2\nExplanation: 22 in binary is \"10110\".\nThe first adjacent pair of 1's is \"10110\" with a distance of 2.\nThe second adjacent pair of 1's is \"10110\" with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that \"10110\" is not a valid pair since there is a 1 separating the two 1's underlined.\n\nExample 2:\n\nInput: n = 8\nOutput: 0\nExplanation: 8 in binary is \"1000\".\nThere are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n\nExample 3:\n\nInput: n = 5\nOutput: 2\nExplanation: 5 in binary is \"101\".\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 109",
        "solutions": [
            {
                "id": 149835,
                "title": "c-java-python-dividing-by-2",
                "content": "One pass on `N` in binary from right to left.\\n`d` means the distance from the last 1 position.\\n`d` is initial to a small enough value `-32`\\n\\n**C++:**\\n```\\n    int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N; N /= 2, d++)\\n            if (N % 2) res = max(res, d), d = 0;\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N > 0; N /= 2, d++)\\n            if (N % 2 == 1) {\\n                res = Math.max(res, d);\\n                d = 0;\\n            }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def binaryGap(self, N):\\n        index = [i for i, v in enumerate(bin(N)) if v == \\'1\\']\\n        return max([b - a for a, b in zip(index, index[1:])] or [0])\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N; N /= 2, d++)\\n            if (N % 2) res = max(res, d), d = 0;\\n        return res;\\n    }\\n```\n```\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        for (int d = -32; N > 0; N /= 2, d++)\\n            if (N % 2 == 1) {\\n                res = Math.max(res, d);\\n                d = 0;\\n            }\\n        return res;\\n    }\\n```\n```\\n    def binaryGap(self, N):\\n        index = [i for i, v in enumerate(bin(N)) if v == \\'1\\']\\n        return max([b - a for a, b in zip(index, index[1:])] or [0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149945,
                "title": "simple-java-10-ms",
                "content": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        int pos = 0;\\n        int lastPos = -1;\\n        while (N != 0) {\\n            pos++;\\n            if ((N & 1) == 1) {\\n                if (lastPos != -1) {\\n                    max = Math.max(max, pos-lastPos);\\n                }\\n                lastPos = pos;\\n            }\\n            N >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        int pos = 0;\\n        int lastPos = -1;\\n        while (N != 0) {\\n            pos++;\\n            if ((N & 1) == 1) {\\n                if (lastPos != -1) {\\n                    max = Math.max(max, pos-lastPos);\\n                }\\n                lastPos = pos;\\n            }\\n            N >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149834,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        pre = dist = 0\\n        for i, c in enumerate(bin(N)[2:]):\\n            if c == \"1\":\\n                dist = max(dist, i - pre)\\n                pre = i\\n        return dist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        pre = dist = 0\\n        for i, c in enumerate(bin(N)[2:]):\\n            if c == \"1\":\\n                dist = max(dist, i - pre)\\n                pre = i\\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358693,
                "title": "868-javascript-1-line-solution",
                "content": "> Runtime: **48 ms**, faster than *95.29%* of JavaScript online submissions\\n> Memory Usage: **33.9 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nconst binaryGap = N =>\\n  Math.max(\\n    0,\\n    ...N.toString(2)\\n      .split(\\'1\\')\\n      .slice(1, -1)\\n      .map(gap => gap.length + 1),\\n  );\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nconst binaryGap = N =>\\n  Math.max(\\n    0,\\n    ...N.toString(2)\\n      .split(\\'1\\')\\n      .slice(1, -1)\\n      .map(gap => gap.length + 1),\\n  );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151143,
                "title": "python-1-line-solution",
                "content": "If only one \\'1\\' exists in the binary, the number must be 2^N where N is a natural number and we return 0. Otherwise, given the binary, we strip \\'0\\' from both sides and split the string into sections by \\'1\\', and return the max length of consecutive \\'0\\'s plus 1.\\n```\\nclass Solution:\\n    def binaryGap(self, N):\\n        return max(len(c) for c in bin(N)[2:].strip(\\'0\\').split(\\'1\\')) + 1 if N & (N-1) else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        return max(len(c) for c in bin(N)[2:].strip(\\'0\\').split(\\'1\\')) + 1 if N & (N-1) else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382476,
                "title": "c-0-ms-simple-o-32",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint binaryGap(int n) {\\n\\t\\tint lastone = 32;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tif (n & (1 << i)) {\\n\\t\\t\\t\\tans = max(ans, i - lastone);\\n\\t\\t\\t\\tlastone = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint binaryGap(int n) {\\n\\t\\tint lastone = 32;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tif (n & (1 << i)) {\\n\\t\\t\\t\\tans = max(ans, i - lastone);\\n\\t\\t\\t\\tlastone = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613498,
                "title": "java-solution-100-with-explanation",
                "content": "The answer key to this problem uses bitwise from the start -- which is not where my mind immediately went; nor did my mind think to use linear space in the naive implementation (since we only care about space between consecutive 1\\'s). Hopefully this solution will help you think through the problem logically.\\n\\nThe first time I did the problem, I came up with a linear time solution that used linear space.\\n\\nRuntime: 1 ms, faster than 42.91% of Java online submissions for Binary Gap.\\nMemory Usage: 36 MB, less than 7.14% of Java online submissions for Binary Gap.\\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String binaryRepresentation = Integer.toBinaryString(N); // O(n) space\\n        int longestDistance = 0;\\n        int indexOne = binaryRepresentation.indexOf(\\'1\\');\\n        for (int i = 1; i < binaryRepresentation.length(); ++i) { // O(n) time\\n            if (binaryRepresentation.charAt(i) == \\'1\\') {\\n                longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n        \\n        return longestDistance;\\n    }\\n}\\n```\\n\\nI then realized this can be done faster since numbers are already stored as their binary representations. We can use bitwise operators, specifically, the bitwise right shift operator. All this means is take the rightmost bit off the binary representation during each iteration. This results in a solution with logarithmic time and constant space.\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Binary Gap.\\nMemory Usage: 36.1 MB, less than 7.14% of Java online submissions for Binary Gap.\\n\\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int indexOne = -1, longestDistance = 0;\\n        for (int i = 0; i < 32; ++i) { // 32 bit number so 32 iterations, could also use Integer.toBinaryString(N).length() but the time it takes to convert to binary string is longer than just doing extra iterations for numbers smaller than 32 bits in size\\n            if (((N >> i) & 1) == 1) { // take the right most bit, use the bitwise \\'AND\\' operator, if result is 1 then bit was a 1\\n                if (indexOne != -1) // only the first 1 will not trigger this conditional\\n                    longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n\\n        return longestDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String binaryRepresentation = Integer.toBinaryString(N); // O(n) space\\n        int longestDistance = 0;\\n        int indexOne = binaryRepresentation.indexOf(\\'1\\');\\n        for (int i = 1; i < binaryRepresentation.length(); ++i) { // O(n) time\\n            if (binaryRepresentation.charAt(i) == \\'1\\') {\\n                longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n        \\n        return longestDistance;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int indexOne = -1, longestDistance = 0;\\n        for (int i = 0; i < 32; ++i) { // 32 bit number so 32 iterations, could also use Integer.toBinaryString(N).length() but the time it takes to convert to binary string is longer than just doing extra iterations for numbers smaller than 32 bits in size\\n            if (((N >> i) & 1) == 1) { // take the right most bit, use the bitwise \\'AND\\' operator, if result is 1 then bit was a 1\\n                if (indexOne != -1) // only the first 1 will not trigger this conditional\\n                    longestDistance = Math.max(longestDistance, i - indexOne); // greedy\\n                indexOne = i; // update the index of the most recently seen \\'1\\'\\n            }\\n        }\\n\\n        return longestDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519571,
                "title": "simple-python-solution-o-log-n-t-o-log-n-s-explanation",
                "content": "We first convert the number to binary and then find the 1\\'s in the binary representation. We store the location of adjacent 1\\'s in the variables i and j. The maximum difference between these successive 1\\'s is the answer. \\nA number \\'n\\' has (log n) bits, hence the time complexity is log(n) and since we are storing these bits as a string, the space complexity is also log(n).\\n\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        bi = bin(n)[2:]\\n        maxi = 0\\n        i = 0\\n        j = 0\\n        \\n        for x in range(1, len(bi)):\\n            if bi[x] == \\'1\\':\\n                i = j\\n                j = x\\n                maxi = max(maxi, j - i)\\n                \\n        return maxi\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        bi = bin(n)[2:]\\n        maxi = 0\\n        i = 0\\n        j = 0\\n        \\n        for x in range(1, len(bi)):\\n            if bi[x] == \\'1\\':\\n                i = j\\n                j = x\\n                maxi = max(maxi, j - i)\\n                \\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380567,
                "title": "easy-c-solution-0ms-bit-manipulation",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Gap.\\nMemory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Binary Gap.\\n\\n```\\nint binaryGap(int N) {\\n        \\n        int maxGap = 0;\\n        int i = 1;\\n        int last = -1;\\n        \\n        while(N > 0)\\n        {\\n            int bit = N%2;\\n            if(bit == 1)\\n            {\\n                if(last >= 0)\\n                    maxGap = max(maxGap, i - last);\\n                last = i;\\n            }\\n            \\n            i++;\\n            N /= 2;\\n        }\\n        \\n        return maxGap;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint binaryGap(int N) {\\n        \\n        int maxGap = 0;\\n        int i = 1;\\n        int last = -1;\\n        \\n        while(N > 0)\\n        {\\n            int bit = N%2;\\n            if(bit == 1)\\n            {\\n                if(last >= 0)\\n                    maxGap = max(maxGap, i - last);\\n                last = i;\\n            }\\n            \\n            i++;\\n            N /= 2;\\n        }\\n        \\n        return maxGap;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1321031,
                "title": "intuitive-java-solution-with-explanation",
                "content": "We will first convert `n` into a character array which represents the binary string of `n`. We will then iterate over this array and store the indices of where a 1 occurs in this character array. If there was only one 1 in the binary string representation of `n` then we return 0 as the problem statement says. We then iterate over `indices` and calculate the distance of a 1 with its adjacent neighbor and update `ans` accordingly.\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        char[] bits = Integer.toBinaryString(n).toCharArray();\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < bits.length; i++) {\\n            if (bits[i] == \\'1\\') indices.add(i);\\n        }\\n        if (indices.size() == 1) return 0;\\n        int ans = 0;\\n        for (int i = 0; i < indices.size()-1; i++) {\\n            ans = Math.max(ans, indices.get(i+1)-indices.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        char[] bits = Integer.toBinaryString(n).toCharArray();\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < bits.length; i++) {\\n            if (bits[i] == \\'1\\') indices.add(i);\\n        }\\n        if (indices.size() == 1) return 0;\\n        int ans = 0;\\n        for (int i = 0; i < indices.size()-1; i++) {\\n            ans = Math.max(ans, indices.get(i+1)-indices.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481624,
                "title": "easy-solution-finding-the-total-number-of-set-bits",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint binaryGap(int n) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tvector<int> aux;\\n\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\tif((n & 1) == 1)\\n\\t\\t\\t\\t\\taux.push_back(i);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tn = n>>1;\\n\\t\\t\\t}\\n\\t\\t\\tif(aux.size()==1)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tint m = INT_MIN;\\n\\t\\t\\tfor(int x=1;x<aux.size();x++){\\n\\t\\t\\t\\tm = max(m,(aux[x]-aux[x-1]));\\n        }\\n\\t\\t\\treturn m;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint binaryGap(int n) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tvector<int> aux;\\n\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\tif((n & 1) == 1)\\n\\t\\t\\t\\t\\taux.push_back(i);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tn = n>>1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1129220,
                "title": "java-0ms",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr = -1;\\n        int max = 0;\\n        \\n        while(n%2==0)\\n            n /= 2;\\n        \\n        while(n > 0) {\\n            if(n%2 == 1) {\\n                curr++;\\n                max = Math.max(curr, max);\\n                curr = 0;\\n            } else {\\n                curr++;\\n            }\\n            n /= 2;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr = -1;\\n        int max = 0;\\n        \\n        while(n%2==0)\\n            n /= 2;\\n        \\n        while(n > 0) {\\n            if(n%2 == 1) {\\n                curr++;\\n                max = Math.max(curr, max);\\n                curr = 0;\\n            } else {\\n                curr++;\\n            }\\n            n /= 2;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508760,
                "title": "python3-beats-96-time-100-memory",
                "content": "\\'\\'\\'\\n\\n\\n    class Solution:\\n\\tdef binaryGap(self, N: int) -> int:\\n        \\n\\t\\tl = bin(N)\\n        p1, p2 = 0, 0\\n        dtc = 0\\n    \\n        for i in range(2, len(l)):\\n            if l[i] == \\'1\\':\\n                if p1 == 0:\\n                    p1 = i\\n                else:\\n                    p2 = i\\n                    dtc = max((p2-p1), dtc)\\n                    p1 = p2\\n                \\n        return dtc\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\n    class Solution:\\n\\tdef binaryGap(self, N: int) -> int:\\n        \\n\\t\\tl = bin(N)\\n        p1, p2 = 0, 0\\n        dtc = 0\\n    \\n        for i in range(2, len(l)):\\n            if l[i] == \\'1\\':\\n                if p1 == 0:\\n                    p1 = i\\n                else:\\n                    p2 = i\\n                    dtc = max((p2-p1), dtc)\\n                    p1 = p2\\n                \\n        return dtc\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2913701,
                "title": "java-1-ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        int idx = 0, max = -1;\\n        for (int i = 0; i < bin.length(); i++) {\\n            char c = bin.charAt(i);\\n            if (c == \\'1\\') {\\n                int cur = i - idx;\\n                if (max < cur) {\\n                    max = cur;\\n                }\\n                idx = i;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String bin = Integer.toBinaryString(n);\\n        int idx = 0, max = -1;\\n        for (int i = 0; i < bin.length(); i++) {\\n            char c = bin.charAt(i);\\n            if (c == \\'1\\') {\\n                int cur = i - idx;\\n                if (max < cur) {\\n                    max = cur;\\n                }\\n                idx = i;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308293,
                "title": "0ms-easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int Prev = -1, i = 0, Answer = 0;\\n\\t\\t/*\\n\\t\\t    Prev is the position of the previous 1\\n\\t\\t\\ti is the position\\n\\t\\t*/\\n        while(n)\\n        {\\n            if (n % 2) // if the bit is 1\\n            {\\n                if (Prev != -1 && i - Prev > Answer) \\n                    Answer = i - Prev;\\n\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t    if we have seen a one before and\\n\\t\\t\\t\\t\\t\\tthe current index minus previous \\n\\t\\t\\t\\t\\t\\tindex is more than the answer \\n\\t\\t\\t\\t\\t*/\\n                Prev = i;\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t    previous index equals the current index\\n\\t\\t\\t\\t\\tbecause the bit is equal to one\\n\\t\\t\\t\\t*/\\n            }\\n            ++i; // increment the position\\n            n /= 2;\\n        }\\n        return Answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int Prev = -1, i = 0, Answer = 0;\\n\\t\\t/*\\n\\t\\t    Prev is the position of the previous 1\\n\\t\\t\\ti is the position\\n\\t\\t*/\\n        while(n)\\n        {\\n            if (n % 2) // if the bit is 1\\n            {\\n                if (Prev != -1 && i - Prev > Answer) \\n                    Answer = i - Prev;\\n\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t    if we have seen a one before and\\n\\t\\t\\t\\t\\t\\tthe current index minus previous \\n\\t\\t\\t\\t\\t\\tindex is more than the answer \\n\\t\\t\\t\\t\\t*/\\n                Prev = i;\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t    previous index equals the current index\\n\\t\\t\\t\\t\\tbecause the bit is equal to one\\n\\t\\t\\t\\t*/\\n            }\\n            ++i; // increment the position\\n            n /= 2;\\n        }\\n        return Answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968113,
                "title": "c-faster-than-100-0ms-bit-manipulation-diagrammatic-representation",
                "content": "***Diagrammatic representation***\\n![image](https://assets.leetcode.com/users/images/64c84117-88d6-47e0-8f70-0a208378086d_1650504132.5012343.png)\\n![image](https://assets.leetcode.com/users/images/5759fe91-4034-47a8-8a60-c72533f6bd23_1650504170.695796.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=INT_MIN,res=0;\\n        while(n>0){\\n            if(n&1){\\n                res=max(count,res);\\n                count=0;\\n            }\\n            count++;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf you find this solution useful, kindly **upvote** it.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=INT_MIN,res=0;\\n        while(n>0){\\n            if(n&1){\\n                res=max(count,res);\\n                count=0;\\n            }\\n            count++;\\n            n=n>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697161,
                "title": "simple-javascript-solution",
                "content": "```\\nvar binaryGap = function(n) {\\n    const binary = n.toString(2);\\n    let max = 0, last = 0, i = 0;\\n    while(i < binary.length){\\n        if(binary[i] === \"1\"){\\n            let distance = i - last;\\n            last = i;\\n            max = Math.max(max, distance)\\n        }\\n        i++;\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    const binary = n.toString(2);\\n    let max = 0, last = 0, i = 0;\\n    while(i < binary.length){\\n        if(binary[i] === \"1\"){\\n            let distance = i - last;\\n            last = i;\\n            max = Math.max(max, distance)\\n        }\\n        i++;\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365234,
                "title": "c-std-bitset-0-ms-8-3-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) \\n    {\\n        constexpr const size_t Byte_Size = 8;\\n        std::bitset<sizeof(N) * Byte_Size> bits{ N };\\n        \\n        size_t i = 0;\\n        while(!bits.test(i)) // find first set bit\\n            ++i; \\n        \\n        auto max_dist = 0;\\n        auto current_dist = 0;\\n        for(++i; i < bits.size(); ++i)\\n        {\\n            ++current_dist;\\n            if(bits.test(i))\\n            {\\n                max_dist = std::max(max_dist, current_dist);\\n                current_dist = 0;\\n            }\\n        }\\n        \\n        return max_dist;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) \\n    {\\n        constexpr const size_t Byte_Size = 8;\\n        std::bitset<sizeof(N) * Byte_Size> bits{ N };\\n        \\n        size_t i = 0;\\n        while(!bits.test(i)) // find first set bit\\n            ++i; \\n        \\n        auto max_dist = 0;\\n        auto current_dist = 0;\\n        for(++i; i < bits.size(); ++i)\\n        {\\n            ++current_dist;\\n            if(bits.test(i))\\n            {\\n                max_dist = std::max(max_dist, current_dist);\\n                current_dist = 0;\\n            }\\n        }\\n        \\n        return max_dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316060,
                "title": "c-beats-100-time-and-92-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int ans = 0;\\n        if(N &&  !(N & (N-1))) return 0; //power of 2\\n        bool first_one = false;\\n        int k = 0;\\n        int one_idx;\\n        while(N) {\\n            k++;\\n            if(first_one) {\\n                if(N&1 == 1) {\\n                    ans = max(ans, k - one_idx);\\n                }\\n            }\\n            if(N&1 == 1) {\\n                first_one=true;\\n                one_idx = k;\\n            }\\n            N >>= 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int ans = 0;\\n        if(N &&  !(N & (N-1))) return 0; //power of 2\\n        bool first_one = false;\\n        int k = 0;\\n        int one_idx;\\n        while(N) {\\n            k++;\\n            if(first_one) {\\n                if(N&1 == 1) {\\n                    ans = max(ans, k - one_idx);\\n                }\\n            }\\n            if(N&1 == 1) {\\n                first_one=true;\\n                one_idx = k;\\n            }\\n            N >>= 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152701,
                "title": "easy-understand-java-solution",
                "content": "```\\n\\n```public int binaryGap(int N) {\\n        int max = 0;\\n        int d = -32;\\n        while(N > 0){\\n            if(N % 2 == 1){\\n                max = Math.max(max, d);\\n                d = 0;\\n            }\\n            N /= 2;\\n            d++;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2816558,
                "title": "simple-java-solution-in-linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate a binary string then loop over string to find distance between two 1\\'s and then store the max distance in a variable\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\nwhere N=length of Binary String\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677249,
                "title": "java-simple-solution",
                "content": "```\\n public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2485217,
                "title": "c-faster-than-100-setbits",
                "content": "class Solution {\\npublic:\\n\\n    int binaryGap(int n) {\\n        int maxi=0,one=0,count=0;\\n        while(n){\\n            if((n&1)==1 &&one==1){\\n                maxi=max(maxi,count);\\n                count=0;\\n            }\\n            else if((n&1)==1&&one==0){\\n                one=1;\\n            }\\n            if(one==1)\\n            count++;   \\n            n>>=1;\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int binaryGap(int n) {\\n        int maxi=0,one=0,count=0;\\n        while(n){\\n            if((n&1)==1 &&one==1){\\n                maxi=max(maxi,count);\\n                count=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1582979,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn binary_gap(mut n: i32) -> i32 {\\n        let (mut max_dist, mut cur_dist) = (0, 0);\\n        n >>= n.trailing_zeros(); // drop zeros 10100000 => 101\\n\\n        while n > 0 {\\n            if n & 1 == 1 && cur_dist > 0 {\\n                max_dist = max_dist.max(cur_dist);\\n                cur_dist = 0;\\n            }\\n            cur_dist += 1;\\n            n >>= 1;\\n        }\\n        max_dist\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(mut n: i32) -> i32 {\\n        let (mut max_dist, mut cur_dist) = (0, 0);\\n        n >>= n.trailing_zeros(); // drop zeros 10100000 => 101\\n\\n        while n > 0 {\\n            if n & 1 == 1 && cur_dist > 0 {\\n                max_dist = max_dist.max(cur_dist);\\n                cur_dist = 0;\\n            }\\n            cur_dist += 1;\\n            n >>= 1;\\n        }\\n        max_dist\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364757,
                "title": "golang-bitwise-shift",
                "content": "```\\nfunc binaryGap(n int) int {\\n\\tcurDistance, maxDistance := 0, 0\\n\\tseenOne := false\\n\\tfor ; n > 0; n >>= 1 {\\n\\t\\tif n & 1 == 1 {\\n\\t\\t\\tif curDistance > maxDistance {\\n\\t\\t\\t\\tmaxDistance = curDistance\\n\\t\\t\\t}\\n\\t\\t\\tcurDistance = 1\\n\\t\\t\\tseenOne = true\\n\\t\\t} else if seenOne {\\n\\t\\t\\tcurDistance++\\n\\t\\t}\\n\\t}\\n\\treturn maxDistance\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(n int) int {\\n\\tcurDistance, maxDistance := 0, 0\\n\\tseenOne := false\\n\\tfor ; n > 0; n >>= 1 {\\n\\t\\tif n & 1 == 1 {\\n\\t\\t\\tif curDistance > maxDistance {\\n\\t\\t\\t\\tmaxDistance = curDistance\\n\\t\\t\\t}\\n\\t\\t\\tcurDistance = 1\\n\\t\\t\\tseenOne = true\\n\\t\\t} else if seenOne {\\n\\t\\t\\tcurDistance++\\n\\t\\t}\\n\\t}\\n\\treturn maxDistance\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306246,
                "title": "easy-python-solution-100",
                "content": "Runtime: 16 ms, faster than 100.00% of Python3 online submissions for Binary Gap.\\nMemory Usage: 14.2 MB, less than 44.00% of Python3 online submissions for Binary Gap.\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        if(bin(n).count(\\'1\\'))==1:\\n            return 0\\n        c=0\\n        x=bin(n)[2:]\\n        for i in range(len(x)):\\n            if(x[i]==\\'1\\'):\\n                j=i+1\\n                while j<len(x):\\n                    if(x[j]==\\'1\\'):\\n                        c=max(j-i,c)\\n                        break\\n                    j+=1\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 16 ms, faster than 100.00% of Python3 online submissions for Binary Gap.\\nMemory Usage: 14.2 MB, less than 44.00% of Python3 online submissions for Binary Gap.\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        if(bin(n).count(\\'1\\'))==1:\\n            return 0\\n        c=0\\n        x=bin(n)[2:]\\n        for i in range(len(x)):\\n            if(x[i]==\\'1\\'):\\n                j=i+1\\n                while j<len(x):\\n                    if(x[j]==\\'1\\'):\\n                        c=max(j-i,c)\\n                        break\\n                    j+=1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 157931,
                "title": "0ms-commented-golang",
                "content": "```\\nfunc binaryGap(N int) int {\\n    maxGap := 0\\n    \\n    currentGap := 0\\n    for N > 0 {\\n        \\n        //Check if right most bit is a one\\n        if (N & 1 == 1) {\\n            if(currentGap > maxGap){\\n                maxGap = currentGap\\n            }\\n            currentGap = 1\\n        \\n            //need this to make sure we don\\'t increment currentGap until we have actualy hit our first one\\n        } else if (currentGap > 0){\\n            currentGap++\\n        }\\n        //right shift by 1\\n        N = N >> 1\\n    }\\n    \\n    return maxGap\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc binaryGap(N int) int {\\n    maxGap := 0\\n    \\n    currentGap := 0\\n    for N > 0 {\\n        \\n        //Check if right most bit is a one\\n        if (N & 1 == 1) {\\n            if(currentGap > maxGap){\\n                maxGap = currentGap\\n            }\\n            currentGap = 1\\n        \\n            //need this to make sure we don\\'t increment currentGap until we have actualy hit our first one\\n        } else if (currentGap > 0){\\n            currentGap++\\n        }\\n        //right shift by 1\\n        N = N >> 1\\n    }\\n    \\n    return maxGap\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992567,
                "title": "solution",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        b=bin(n)[2:]\\n        l=len(b)\\n        m=0\\n        for i in range(l):\\n            if b[i]==\\'1\\':\\n                for j in range(i+1,l):\\n                    if b[j]==\\'1\\':\\n                        d=j-i\\n                        if d>m:\\n                            m=d\\n                        break\\n        return m\\n\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        b=bin(n)[2:]\\n        l=len(b)\\n        m=0\\n        for i in range(l):\\n            if b[i]==\\'1\\':\\n                for j in range(i+1,l):\\n                    if b[j]==\\'1\\':\\n                        d=j-i\\n                        if d>m:\\n                            m=d\\n                        break\\n        return m\\n\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555976,
                "title": "868-binary-gap",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=0;\\n        int c=0;\\n        while(n>0){\\n            if(n%2==0){\\n                if(count>0){\\n                    count++;\\n                }\\n                c=max(c,count);\\n                n=n/2;\\n            }\\n            else{\\n                c=max(c,count);\\n                count=1;\\n                n=n/2;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count=0;\\n        int c=0;\\n        while(n>0){\\n            if(n%2==0){\\n                if(count>0){\\n                    count++;\\n                }\\n                c=max(c,count);\\n                n=n/2;\\n            }\\n            else{\\n                c=max(c,count);\\n                count=1;\\n                n=n/2;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499368,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int result = 0;\\n        int last = -1;\\n        for (int i = 0; i < 32; ++i) {\\n            if ((N >> i) & 1) {\\n                if (last != -1) {\\n                    result = max(result, i - last);\\n                }\\n                last = i;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        s = f\\'{n:b}\\'\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                continue\\n            for j in range(i + 1, len(s)):\\n                if s[j] == \\'0\\':\\n                    continue\\n                result = max(result, j - i)\\n                break\\n        return result\\n```\\n\\n```Java []\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int prev=-1;\\n        int tc=0;\\n        int mx=-1,ct=0;\\n        while(n>0){\\n            int r= n&1;\\n            if(r==1 ){\\n                ++tc;\\n                prev=0;\\n                    mx=Math.max(ct,mx);\\n                    ct=0;\\n                \\n            }else {\\n                if(prev!=-1){\\n                    ct++;\\n                }\\n            }\\n            n=n>>1;\\n        }\\n        if(tc<=1){\\n            return 0;\\n        }\\n        return mx+1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int result = 0;\\n        int last = -1;\\n        for (int i = 0; i < 32; ++i) {\\n            if ((N >> i) & 1) {\\n                if (last != -1) {\\n                    result = max(result, i - last);\\n                }\\n                last = i;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        s = f\\'{n:b}\\'\\n        result = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                continue\\n            for j in range(i + 1, len(s)):\\n                if s[j] == \\'0\\':\\n                    continue\\n                result = max(result, j - i)\\n                break\\n        return result\\n```\n```Java []\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int prev=-1;\\n        int tc=0;\\n        int mx=-1,ct=0;\\n        while(n>0){\\n            int r= n&1;\\n            if(r==1 ){\\n                ++tc;\\n                prev=0;\\n                    mx=Math.max(ct,mx);\\n                    ct=0;\\n                \\n            }else {\\n                if(prev!=-1){\\n                    ct++;\\n                }\\n            }\\n            n=n>>1;\\n        }\\n        if(tc<=1){\\n            return 0;\\n        }\\n        return mx+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464142,
                "title": "beats-100-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0, count = 1;\\n        \\n        while(n > 0 ){\\n            // first n\\n           if(n&1){\\n               cout << n << \" break\" << endl;\\n              n  =n >> 1;\\n               break;\\n\\n           }\\n           n = n >> 1;\\n        }\\n\\n        while(n > 0 ){\\n            if(n&1){\\n                // cout << n << \" 2 one \"<<  endl;\\n                ans = max(count , ans);\\n                count =1;\\n            }\\n            else\\n                count++;\\n            // n/=2;\\n           n =  n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0, count = 1;\\n        \\n        while(n > 0 ){\\n            // first n\\n           if(n&1){\\n               cout << n << \" break\" << endl;\\n              n  =n >> 1;\\n               break;\\n\\n           }\\n           n = n >> 1;\\n        }\\n\\n        while(n > 0 ){\\n            if(n&1){\\n                // cout << n << \" 2 one \"<<  endl;\\n                ans = max(count , ans);\\n                count =1;\\n            }\\n            else\\n                count++;\\n            // n/=2;\\n           n =  n >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3457342,
                "title": "easiest-solution-bit-manipulation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int last=-1;\\n        int ans=0;\\n   for(int i=0;i<32;i++){\\n       if(n&(1<<i)){\\n           if(last==-1) last=i;\\n           else{\\n               ans=max(ans,i-last);\\n               last=i;\\n           }\\n       }\\n   }\\n   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int last=-1;\\n        int ans=0;\\n   for(int i=0;i<32;i++){\\n       if(n&(1<<i)){\\n           if(last==-1) last=i;\\n           else{\\n               ans=max(ans,i-last);\\n               last=i;\\n           }\\n       }\\n   }\\n   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409133,
                "title": "very-understandable-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        b=bin(n)[2:]\\n        maxx=0\\n        x=0\\n        y=0\\n        for i in range(len(b)):\\n            if b[i]==\"1\":\\n                maxx=max(maxx,abs(x-y))\\n                x=y\\n            y=i+1\\n        return maxx\\n\\n\\n\\n        \"\"\"(or)\\n\\n        res=[i for i,j in enumerate(bin(n)[2:]) if j==\"1\"]\\n        return max([j-i for i,j in zip(res,res[1:])] or [0])\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        b=bin(n)[2:]\\n        maxx=0\\n        x=0\\n        y=0\\n        for i in range(len(b)):\\n            if b[i]==\"1\":\\n                maxx=max(maxx,abs(x-y))\\n                x=y\\n            y=i+1\\n        return maxx\\n\\n\\n\\n        \"\"\"(or)\\n\\n        res=[i for i,j in enumerate(bin(n)[2:]) if j==\"1\"]\\n        return max([j-i for i,j in zip(res,res[1:])] or [0])\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303808,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        while(n){\\n            bin+=to_string(n%2);\\n            n/=2;\\n        }\\n        reverse(bin.begin(), bin.end());\\n\\n        int maxi = INT_MIN;\\n        int count=1, t=0;\\n        \\n        for(int i = 0; i<bin.size(); i++){\\n            if(bin[i] == \\'1\\'){\\n                t++;\\n                maxi = max(maxi,count);\\n                count=1;\\n            }\\n            else count++;\\n        }\\n        return t > 1 ? maxi : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        while(n){\\n            bin+=to_string(n%2);\\n            n/=2;\\n        }\\n        reverse(bin.begin(), bin.end());\\n\\n        int maxi = INT_MIN;\\n        int count=1, t=0;\\n        \\n        for(int i = 0; i<bin.size(); i++){\\n            if(bin[i] == \\'1\\'){\\n                t++;\\n                maxi = max(maxi,count);\\n                count=1;\\n            }\\n            else count++;\\n        }\\n        return t > 1 ? maxi : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181929,
                "title": "beats-98-easy-solution-please-upvote",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int last = -1, ans = 0;\\n        for (int i = 0; i < 32; ++i)\\n            if (((n >> i) & 1) > 0) {\\n                if (last >= 0)\\n                    ans = Math.Max(ans, i - last);\\n                last = i;\\n            }\\n\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int last = -1, ans = 0;\\n        for (int i = 0; i < 32; ++i)\\n            if (((n >> i) & 1) > 0) {\\n                if (last >= 0)\\n                    ans = Math.Max(ans, i - last);\\n                last = i;\\n            }\\n\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176459,
                "title": "easy-solution-using-bin-function",
                "content": "\\n\\n# Approach\\nFirst of all ,We have to convert the given integer into its equivalent binary string. Then we will store all the indexes of \"1\" in an array.\\nThen we will calculate the difference between adjacent elements. After calculating the differences we will return the maximum difference ..\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=[]\\n        l=bin(n).replace(\"0b\",\"\")\\n        for i in range(len(l)):\\n            if l[i]==\"1\":\\n                a.append(i)\\n        if len(a)<=1:\\n            return 0\\n        maxi=0\\n        \\n        for i in range(len(a)-1):\\n            maxi=max(maxi,int(a[i+1])-int(a[i]))\\n        return maxi\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=[]\\n        l=bin(n).replace(\"0b\",\"\")\\n        for i in range(len(l)):\\n            if l[i]==\"1\":\\n                a.append(i)\\n        if len(a)<=1:\\n            return 0\\n        maxi=0\\n        \\n        for i in range(len(a)-1):\\n            maxi=max(maxi,int(a[i+1])-int(a[i]))\\n        return maxi\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113966,
                "title": "python3-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        m = -1\\n        while n:\\n            if 1&n:\\n                if m==-1:\\n                    m = 1\\n                else:\\n                    ans = max(ans,m)\\n                    m=1\\n            else:\\n                if m!=-1:\\n                    m+=1\\n                \\n            n = n>>1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        m = -1\\n        while n:\\n            if 1&n:\\n                if m==-1:\\n                    m = 1\\n                else:\\n                    ans = max(ans,m)\\n                    m=1\\n            else:\\n                if m!=-1:\\n                    m+=1\\n                \\n            n = n>>1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816573,
                "title": "simple-java-solution-in-linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerate a binary string then loop over string to find distance between two 1\\'s and then store the max distance in a variable\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\nwhere N=length of Binary String\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n       String s=\"\";\\n        int t=n;\\n        while(t>0)\\n        {\\n            int r=t%2;\\n            s=s+r+\"\";\\n            t=t/2;\\n        }\\n       \\n        int mx=0;\\n        int start=s.indexOf(\\'1\\');\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                 mx=Math.max(mx,i-start);\\n                 start=i;\\n            }\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790637,
                "title": "python-simple-solution-ii-o-n-one-pass",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        binary = bin(n)\\n        binary= binary[2:]\\n        found = False\\n        max_count =0\\n        for i in range(len(binary)):\\n             if(binary[i]==\\'1\\' and found ==False):\\n                 start= i\\n                 found = True\\n             elif(binary[i]==\\'1\\' and found==True):\\n                 count = i- start\\n                 start= i\\n                 if(count>max_count):\\n                     max_count= count\\n        return max_count\\n\\n             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        binary = bin(n)\\n        binary= binary[2:]\\n        found = False\\n        max_count =0\\n        for i in range(len(binary)):\\n             if(binary[i]==\\'1\\' and found ==False):\\n                 start= i\\n                 found = True\\n             elif(binary[i]==\\'1\\' and found==True):\\n                 count = i- start\\n                 start= i\\n                 if(count>max_count):\\n                     max_count= count\\n        return max_count\\n\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687088,
                "title": "c-0ms-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0,c=0,t=0;long x = 1;bool flag = false;\\n        while(n>=x){\\n            c++;\\n            if(x&n) {\\n                if(flag) ans = max(ans,c-t);\\n                t = c;\\n                flag = true;\\n            } x<<=1;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int ans = 0,c=0,t=0;long x = 1;bool flag = false;\\n        while(n>=x){\\n            c++;\\n            if(x&n) {\\n                if(flag) ans = max(ans,c-t);\\n                t = c;\\n                flag = true;\\n            } x<<=1;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565781,
                "title": "js-easy-solution-100-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/475ee9ed-ee46-4a6a-a0f9-f5783f5b13de_1662972381.4477122.png)\\n\\n```\\nvar binaryGap = function(n) {\\n    const binaryString = (n >>> 0).toString(2);\\n    let output = 0;\\n    let start;\\n\\n    for (let i = 0; i < binaryString.length; i++) {\\n        if (binaryString[i] === \"1\") {\\n            output = Math.max(output, start !== undefined ? (i - start) : 0);\\n            start = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    const binaryString = (n >>> 0).toString(2);\\n    let output = 0;\\n    let start;\\n\\n    for (let i = 0; i < binaryString.length; i++) {\\n        if (binaryString[i] === \"1\") {\\n            output = Math.max(output, start !== undefined ? (i - start) : 0);\\n            start = i;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437228,
                "title": "my-kotlin-solution-with-time-o-1-and-space-o-1",
                "content": "Below is my solution in kotlin, it preprocess the n with it right most bit and calculate the gap through shift right.\\n```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) & Space O(1);\\n     */\\n    fun binaryGap(n: Int): Int {\\n        tailrec fun process(num: Int, gap: Int = 0, maxGap: Int = 0): Int =\\n            when {\\n                num == 0 -> maxGap\\n                num and 1 == 0 -> process(num shr 1, gap + 1, maxGap)\\n                else -> process(num shr 1, 1, maxOf(gap, maxGap))\\n            }\\n\\n        val rightMostBit = n - (n and (n - 1))\\n        return if (rightMostBit == 0) 0 else process(num = n / rightMostBit)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) & Space O(1);\\n     */\\n    fun binaryGap(n: Int): Int {\\n        tailrec fun process(num: Int, gap: Int = 0, maxGap: Int = 0): Int =\\n            when {\\n                num == 0 -> maxGap\\n                num and 1 == 0 -> process(num shr 1, gap + 1, maxGap)\\n                else -> process(num shr 1, 1, maxOf(gap, maxGap))\\n            }\\n\\n        val rightMostBit = n - (n and (n - 1))\\n        return if (rightMostBit == 0) 0 else process(num = n / rightMostBit)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430116,
                "title": "binary-gap-c-5ms",
                "content": "class Solution {\\npublic:\\n    int binaryGap(int &n) {\\n        int ans = 0,x = 0;\\n        while(n){\\n            if(n%2==1){\\n                ans = max(ans,x-1);\\n                x = 1;\\n            }\\n            x > 0? x++: x = 0;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int &n) {\\n        int ans = 0,x = 0;\\n        while(n){\\n            if(n%2==1){\\n                ans = max(ans,x-1);\\n                x = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2145256,
                "title": "c-fast-easy-code-bit-manipulation",
                "content": "Check each bit from the back and if it\\'s \\'1\\', we calculate the distance using the difference between the current index and the previous index that points to the previous \\'1\\' found. Compare the value with the current max distance and store the larger value back. There\\'s no previous index for the first \\'1\\' so we simply set previous index to the current index.\\n\\n**Code:**\\n```\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091944,
                "title": "java-simple-solution",
                "content": "Here is a simple approach to solve this question.\\nWhat we are doing here is\\ni) if(n&1) is equal to 1 then find next 1\\n\\t\\t........**(subcondition)**.........if(n==0) then it means next 1 not found else 1 is found so set the value of max\\nii) else right shift.\\n\\n```class Solution {\\n    public int binaryGap(int n) {\\n        int max=0;\\n        while(n>0){\\n            int r=n&1;\\n\\t\\t\\t//if r==1 then search next occurence of 1\\n            if(r==1){\\n                n=n>>1;\\n                int var=1;\\n                while(n>0 && (n&1)!=1){\\n                    n=n>>1;\\n                    var++;\\n                }\\n                if(n!=0){\\n                    max=Math.max(max,var);\\n                }\\n                // else right shift\\n            }else{\\n                n=n>>1;\\n            }\\n        }\\n        return max;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int binaryGap(int n) {\\n        int max=0;\\n        while(n>0){\\n            int r=n&1;\\n\\t\\t\\t//if r==1 then search next occurence of 1\\n            if(r==1){\\n                n=n>>1;\\n                int var=1;\\n                while(n>0 && (n&1)!=1){\\n                    n=n>>1;\\n                    var++;\\n                }\\n                if(n!=0){\\n                    max=Math.max(max,var);\\n                }\\n                // else right shift\\n            }else{\\n                n=n>>1;\\n            }\\n        }\\n        return max;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1984287,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/4517167f-0053-4740-b183-710c7bd81536_1650990891.4216025.png)\\n\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, ans, prev = bin(n)[2:], 0, math.inf\\n\\n        for i, b in enumerate(num):\\n            if b == \\'1\\':\\n                ans, prev = max(ans, i - prev), i\\n\\n        return ans\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, size = map(int, bin(n)[2:]), math.floor(math.log2(n)) + 1  # size = bit cnt\\n        return max((b - a for a, b in itertools.pairwise(itertools.compress(range(size), num))), default=0)\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        idx = [i for i, v in enumerate(bin(n)) if v == \\'1\\']\\n        return max((b - a for a, b in itertools.pairwise(idx)), default=0)",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/4517167f-0053-4740-b183-710c7bd81536_1650990891.4216025.png)\\n\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, ans, prev = bin(n)[2:], 0, math.inf\\n\\n        for i, b in enumerate(num):\\n            if b == \\'1\\':\\n                ans, prev = max(ans, i - prev), i\\n\\n        return ans\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        num, size = map(int, bin(n)[2:]), math.floor(math.log2(n)) + 1  # size = bit cnt\\n        return max((b - a for a, b in itertools.pairwise(itertools.compress(range(size), num))), default=0)\\n\\n    def binaryGap(self, n: int) -> int:\\n        \"\"\" O(logN)T O(1)S \"\"\"\\n        idx = [i for i, v in enumerate(bin(n)) if v == \\'1\\']\\n        return max((b - a for a, b in itertools.pairwise(idx)), default=0)",
                "codeTag": "Python3"
            },
            {
                "id": 1919356,
                "title": "fast-solution-in-python3",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=list(bin(n)[2:])\\n        s=[]\\n        for i in range(len(a)):\\n            if a[i]!=\\'0\\':\\n                s.append(i)\\n        t=[]\\n        for i in range(len(s)):\\n            t.append(s[i]-s[i-1])\\n        return(max(t))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=list(bin(n)[2:])\\n        s=[]\\n        for i in range(len(a)):\\n            if a[i]!=\\'0\\':\\n                s.append(i)\\n        t=[]\\n        for i in range(len(s)):\\n            t.append(s[i]-s[i-1])\\n        return(max(t))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859275,
                "title": "100-time-o-logn-easy-to-understand",
                "content": "**here we are using  differnt function of bit to solve question**\\n***be noted why we initialize count to -32 i wrote it in comment in code***\\n\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count = -32, maxi = 0;//-32 is the smallest possible bit \\n\\t\\t//maxi is our answer\\n        //we have to start counting from -32 because we are moving reverse like if n=8 than we are travarsing 0->0->0->1 so be noted about it\\n        while (n != 0) {\\n            if ((n & 1) == 1) {// also write \\'n%2\\'\\n                maxi = max(maxi, count);\\n                count = 0;\\n            }\\n            count++;\\n            n >>= 1;//also write \\'n/=2\\'\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n***this is my solution if yu have any doubt than fill free to ask in comment if i can than absolutly solve it***\\n***if you find solution use ful than upwote else downvote***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int count = -32, maxi = 0;//-32 is the smallest possible bit \\n\\t\\t//maxi is our answer\\n        //we have to start counting from -32 because we are moving reverse like if n=8 than we are travarsing 0->0->0->1 so be noted about it\\n        while (n != 0) {\\n            if ((n & 1) == 1) {// also write \\'n%2\\'\\n                maxi = max(maxi, count);\\n                count = 0;\\n            }\\n            count++;\\n            n >>= 1;//also write \\'n/=2\\'\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794889,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\t\\t int max=0;\\n\\t\\t while(n!=1) {\\n             int c=0;\\n\\t\\t\\t if((n&1)==1) {\\n\\t\\t\\t\\t while(n!=0&&(n>>1&1)==0) {\\n\\t\\t\\t\\t\\t c++;\\n\\t\\t\\t\\t\\t n>>=1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t if(max<c+1) { \\n\\t\\t\\t\\t\\t max=(c+1);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\t\\t\\t\\n\\t\\t\\t n>>=1;\\n\\t\\t }\\n\\t\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\t\\t int max=0;\\n\\t\\t while(n!=1) {\\n             int c=0;\\n\\t\\t\\t if((n&1)==1) {\\n\\t\\t\\t\\t while(n!=0&&(n>>1&1)==0) {\\n\\t\\t\\t\\t\\t c++;\\n\\t\\t\\t\\t\\t n>>=1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t if(max<c+1) { \\n\\t\\t\\t\\t\\t max=(c+1);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\t\\t\\t\\n\\t\\t\\t n>>=1;\\n\\t\\t }\\n\\t\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736152,
                "title": "javascript-solution-using-bit-manipulation",
                "content": "```\\nvar max = (a,b) => {\\n    return a>b?a:b;\\n}\\nvar binaryGap = function(n) {\\n    var maxs = 0;\\n    var d=0;\\n    var i=0;\\n    var last=-1\\n    while(n!=0){\\n        if(last === -1 && n&1===1){\\n            last = i; \\n        }\\n        else if(n&1===1){\\n            maxs=max(maxs,i-last);\\n            last = i;\\n        }\\n        n=n>>1;\\n        i++;\\n    }\\n    return maxs\\n};",
                "solutionTags": [],
                "code": "```\\nvar max = (a,b) => {\\n    return a>b?a:b;\\n}\\nvar binaryGap = function(n) {\\n    var maxs = 0;\\n    var d=0;\\n    var i=0;\\n    var last=-1\\n    while(n!=0){\\n        if(last === -1 && n&1===1){\\n            last = i; \\n        }\\n        else if(n&1===1){\\n            maxs=max(maxs,i-last);\\n            last = i;\\n        }\\n        n=n>>1;\\n        i++;\\n    }\\n    return maxs\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1722203,
                "title": "using-format-for-binary-string",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        curr = \"{:b}\".format(n)\\n        n = len(curr)\\n        mdist = 0\\n        prev = -1\\n        for i in range(n):\\n            if curr[i] == \"1\":\\n                if prev >= 0:\\n                    mdist = max(mdist, i - prev)\\n                prev = i\\n        return mdist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        curr = \"{:b}\".format(n)\\n        n = len(curr)\\n        mdist = 0\\n        prev = -1\\n        for i in range(n):\\n            if curr[i] == \"1\":\\n                if prev >= 0:\\n                    mdist = max(mdist, i - prev)\\n                prev = i\\n        return mdist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519288,
                "title": "fastest-100-passed-c-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis =0, max_dis = 0,flag =0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                flag =1;\\n                max_dis = max(max_dis,dis);\\n                dis = 1;\\n            }\\n            else if(flag)\\n            {\\n                dis++;\\n            }\\n            \\n            n = n>>1;\\n        }\\n        \\n        return max_dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis =0, max_dis = 0,flag =0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                flag =1;\\n                max_dis = max(max_dis,dis);\\n                dis = 1;\\n            }\\n            else if(flag)\\n            {\\n                dis++;\\n            }\\n            \\n            n = n>>1;\\n        }\\n        \\n        return max_dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467446,
                "title": "simple-c-o-log-n-constant-space",
                "content": "\\n    int binaryGap(int n) {\\n        \\n        int temp{0}, ans{0}, curr{INT_MAX};\\n        \\n        while(n){\\n            temp++;\\n            if(n&1){\\n                ans=max(ans, temp-curr);\\n                curr=temp;                \\n            } \\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int binaryGap(int n) {\\n        \\n        int temp{0}, ans{0}, curr{INT_MAX};\\n        \\n        while(n){\\n            temp++;\\n            if(n&1){\\n                ans=max(ans, temp-curr);\\n                curr=temp;                \\n            } \\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1410829,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int binaryGap(int n) {\\n        String p=Integer.toBinaryString(n);\\n        int i,c=0,k=0,j=0;\\n        for(i=0;i<p.length();i++)\\n        {\\n            if(p.charAt(i)==\\'1\\'&&c>0)\\n            {\\n                k=Math.max(k,(i-j));\\n                j=i;\\n                c++;\\n            }\\n            else if(p.charAt(i)==\\'1\\')\\n            {\\n                j=i;\\n                c++;\\n            }\\n        }\\n        return k;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int binaryGap(int n) {\\n        String p=Integer.toBinaryString(n);\\n        int i,c=0,k=0,j=0;\\n        for(i=0;i<p.length();i++)\\n        {\\n            if(p.charAt(i)==\\'1\\'&&c>0)\\n            {\\n                k=Math.max(k,(i-j));\\n                j=i;\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1405152,
                "title": "fast-c-solution-o-1-space-0-ms-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dig, cur = 0, max = 0;\\n        if(n == 0) {\\n            return 0;\\n        }\\n        while(n > 0 && n % 2 == 0) {\\n            n /= 2;\\n        }\\n        if(n == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                cur++;\\n            } else {\\n                max = std::max(cur, max);\\n                count++;\\n                cur = 0;\\n            }\\n            n /= 2;\\n        }\\n        if(count == 1) {\\n            return 0;\\n        }\\n        return max + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dig, cur = 0, max = 0;\\n        if(n == 0) {\\n            return 0;\\n        }\\n        while(n > 0 && n % 2 == 0) {\\n            n /= 2;\\n        }\\n        if(n == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                cur++;\\n            } else {\\n                max = std::max(cur, max);\\n                count++;\\n                cur = 0;\\n            }\\n            n /= 2;\\n        }\\n        if(count == 1) {\\n            return 0;\\n        }\\n        return max + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362260,
                "title": "o-n-0ms-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int k=INT_MIN,count=0;\\n        while(n!=0){\\n            if(n%2==1){\\n                count=max(count,k); k=0;\\n            }\\n            k+=1; n/=2;\\n        }\\n    \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int k=INT_MIN,count=0;\\n        while(n!=0){\\n            if(n%2==1){\\n                count=max(count,k); k=0;\\n            }\\n            k+=1; n/=2;\\n        }\\n    \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337314,
                "title": "simple-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ons = []\\n        for i in range(len(bin(n)[2:])):\\n            if bin(n)[2:][i] == \\'1\\': ons.append(i)\\n        if len(ons) >= 2:\\n            maxi = -1\\n            for i in range(len(ons)-1):\\n                if ons[i+1] - ons[i] > maxi: maxi = ons[i+1] - ons[i]\\n            return maxi\\n        else:return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ons = []\\n        for i in range(len(bin(n)[2:])):\\n            if bin(n)[2:][i] == \\'1\\': ons.append(i)\\n        if len(ons) >= 2:\\n            maxi = -1\\n            for i in range(len(ons)-1):\\n                if ons[i+1] - ons[i] > maxi: maxi = ons[i+1] - ons[i]\\n            return maxi\\n        else:return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263330,
                "title": "c-simple-solution-0ms",
                "content": "```\\nint binaryGap(int n){\\n    int max=0, i=0, pre=-1;\\n    while(n > 0){\\n        if(n & 1){\\n            if(pre > -1 && max < i - pre)\\n                max = i - pre;\\n            pre = i;\\n        }\\n        i++;\\n        n = n >> 1;\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint binaryGap(int n){\\n    int max=0, i=0, pre=-1;\\n    while(n > 0){\\n        if(n & 1){\\n            if(pre > -1 && max < i - pre)\\n                max = i - pre;\\n            pre = i;\\n        }\\n        i++;\\n        n = n >> 1;\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200055,
                "title": "hashing-steps-explanation-0ms-c",
                "content": "**STEPS:-**\\n**1) convert the number in binary format and store it in a string (LSB at 0 index)**\\n**2) declare a  map( key = char, value = int) and define an int dist = 0**\\n**3) then just iterate over the string, if map does not contain key = \\'1\\' , then just insert it with value = index**\\n**4) if key = \\'1\\', already present then simply update the dist as max(dist,abs(map[\\'1\\']-index))**\\n**5) return the dist**\\n**NOTE: Why its working ??, you got it by now :)**\\n```\\n    int binaryGap(int n) {\\n        string s;\\n        while(n!=0){\\n            s+=to_string(n%2);\\n            n/=2;\\n        }\\n        unordered_map<char,int> mp;\\n        int dist=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'&&mp.count(s[i])!=0)\\n                dist=max(dist,abs(mp[s[i]]-i));\\n            mp[s[i]]=i;\\n        }\\n        return dist;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int binaryGap(int n) {\\n        string s;\\n        while(n!=0){\\n            s+=to_string(n%2);\\n            n/=2;\\n        }\\n        unordered_map<char,int> mp;\\n        int dist=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'&&mp.count(s[i])!=0)\\n                dist=max(dist,abs(mp[s[i]]-i));\\n            mp[s[i]]=i;\\n        }\\n        return dist;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156816,
                "title": "super-simple-and-easy-cpp-solution-must-check",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        \\n        int flag =0;\\n        int dis =0;\\n        int maxi =0;\\n        while(n> 0)\\n        {\\n            if(n %2==1 and flag ==0)\\n                flag =1;\\n            \\n            else if( n %2 and flag)\\n            {\\n                dis++;\\n                maxi = max(dis,maxi);\\n                dis =0;\\n            }\\n            else if(flag)\\n                dis++;\\n            n = n>>1;    \\n        }\\n        return maxi;\\n    }\\n};\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int n) {\\n        \\n        int flag =0;\\n        int dis =0;\\n        int maxi =0;\\n        while(n> 0)\\n        {\\n            if(n %2==1 and flag ==0)\\n                flag =1;\\n            \\n            else if( n %2 and flag)\\n            {\\n                dis++;\\n                maxi = max(dis,maxi);\\n                dis =0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1081801,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        \\n        lst = list(bin(n)[2:])\\n        max_length = -float(\\'inf\\')\\n        flag = False\\n        \\n        for idx,val in enumerate(lst):\\n            if(val == \\'1\\'):\\n                if(flag == False):\\n                    start = idx\\n                    flag = True\\n                else:\\n                    max_length = max(max_length,idx-start)\\n                    start = idx\\n                    \\n        if(max_length == -float(\\'inf\\')):\\n            return 0\\n        \\n        return max_length\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        \\n        lst = list(bin(n)[2:])\\n        max_length = -float(\\'inf\\')\\n        flag = False\\n        \\n        for idx,val in enumerate(lst):\\n            if(val == \\'1\\'):\\n                if(flag == False):\\n                    start = idx\\n                    flag = True\\n                else:\\n                    max_length = max(max_length,idx-start)\\n                    start = idx\\n                    \\n        if(max_length == -float(\\'inf\\')):\\n            return 0\\n        \\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030187,
                "title": "python-solution",
                "content": "```\\ndef binary_gap(n: int):\\n    dist = 0\\n    x = float(\\'-inf\\')\\n\\n    while n > 0:\\n        if n % 2 == 1:\\n            dist = max(dist, x)\\n            x = 0\\n\\n        n//=2\\n        x+=1\\n\\n    return dist\\n```",
                "solutionTags": [],
                "code": "```\\ndef binary_gap(n: int):\\n    dist = 0\\n    x = float(\\'-inf\\')\\n\\n    while n > 0:\\n        if n % 2 == 1:\\n            dist = max(dist, x)\\n            x = 0\\n\\n        n//=2\\n        x+=1\\n\\n    return dist\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1020460,
                "title": "python-bitwise-95-faster",
                "content": "Every odd value will have a 1 on the right hand side of the binary digit (because this is the ones digit and all factors of 2 are even except 2 raised to the 0 power).  We can then bitwise right shift by 1 (i.e. integer division by 2, effectively dropping the right digit) to \\'traverse\\' across the binary and count the times until we obtain another odd (1) value.\\n\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        while n > 1:\\n            if n % 2 == 1:\\n                count = 1\\n                n >>= 1\\n                while n % 2 == 0:\\n                    count += 1\\n                    n >>= 1\\n                ans = max(ans, count)\\n            else:\\n                n >>= 1\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        while n > 1:\\n            if n % 2 == 1:\\n                count = 1\\n                n >>= 1\\n                while n % 2 == 0:\\n                    count += 1\\n                    n >>= 1\\n                ans = max(ans, count)\\n            else:\\n                n >>= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017556,
                "title": "clean-js-solution",
                "content": "Remove the first \\'1\\' in the binary, then loop through the string. If we hit a \\'1\\', record the gap and compare it to the max gap then reset the gap to 0.\\n```\\nvar binaryGap = function (n) {\\n  const binary = n.toString(2).substring(1)\\n  let [maxGap, gap] = [0, 0];\\n\\n  for (let num of binary) {\\n    gap++;\\n    if (num === \\'1\\') {\\n      maxGap = Math.max(maxGap, gap);\\n      gap = 0;\\n    }\\n  }\\n\\n  return maxGap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar binaryGap = function (n) {\\n  const binary = n.toString(2).substring(1)\\n  let [maxGap, gap] = [0, 0];\\n\\n  for (let num of binary) {\\n    gap++;\\n    if (num === \\'1\\') {\\n      maxGap = Math.max(maxGap, gap);\\n      gap = 0;\\n    }\\n  }\\n\\n  return maxGap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989270,
                "title": "simple-java-solution-1-ms-with-explanation",
                "content": "- Intially store the first occur \\'1\\'\\n- Next if the current value is \\'1\\' then minu the previous value with current index and change the previous value\\n\\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String b  = Integer.toBinaryString(N);\\n        \\n        int n = b.length();\\n        int dif = 0;\\n        int prev = b.indexOf(\"1\"); \\n        \\n        for(int i=prev+1;i<n;i++){\\n            if(b.charAt(i) == \\'1\\'){\\n                dif = Integer.max(dif,i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        String b  = Integer.toBinaryString(N);\\n        \\n        int n = b.length();\\n        int dif = 0;\\n        int prev = b.indexOf(\"1\"); \\n        \\n        for(int i=prev+1;i<n;i++){\\n            if(b.charAt(i) == \\'1\\'){\\n                dif = Integer.max(dif,i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982479,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int binaryGap(int n) {\\n        while(n%2==0)\\n            n/=2;\\n        if(n==1)\\n            return 0;\\n        int tot=0,max=0;\\n        while(n!=0){\\n            if(n%2==0)\\n                tot++;\\n            else{\\n                if(tot>max)\\n                    max=tot;\\n                tot=0;\\n            }\\n            n/=2;\\n        }\\n        return max+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int binaryGap(int n) {\\n        while(n%2==0)\\n            n/=2;\\n        if(n==1)\\n            return 0;\\n        int tot=0,max=0;\\n        while(n!=0){\\n            if(n%2==0)\\n                tot++;\\n            else{\\n                if(tot>max)\\n                    max=tot;\\n                tot=0;\\n            }\\n            n/=2;\\n        }\\n        return max+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964373,
                "title": "ugly-code-but-one-pass-without-casting-to-string",
                "content": "```\\nvar binaryGap = function(n) {\\n    let max = 0;\\n    let counter = 0;\\n    let found = false;\\n    while(n){\\n        if(!found && !(n%2 == 0)){\\n          found = true;\\n          n = n>>1;\\n        } else if(found && (n%2 == 0)){\\n            counter++;\\n            n = n>>1;\\n        } else if(found && !(n%2 == 0)) {\\n            counter++;\\n            max = counter > max ? counter : max;\\n            counter = 0;\\n            found = false;\\n        } else {\\n            n = n>>1\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nvar binaryGap = function(n) {\\n    let max = 0;\\n    let counter = 0;\\n    let found = false;\\n    while(n){\\n        if(!found && !(n%2 == 0)){\\n          found = true;\\n          n = n>>1;\\n        } else if(found && (n%2 == 0)){\\n            counter++;\\n            n = n>>1;\\n        } else if(found && !(n%2 == 0)) {\\n            counter++;\\n            max = counter > max ? counter : max;\\n            counter = 0;\\n            found = false;\\n        } else {\\n            n = n>>1\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929372,
                "title": "3-solutions",
                "content": "**two indices**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{0}, j{32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i-j), j=i;\\n\\treturn out;\\n}\\n```\\n**distance**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{-32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i), i=0;              // if(n&1) out=max(out, exchange(i, 0));\\n\\treturn out;\\n}\\n```\\n\\n**`builtin_ctz` \\u2014 `gcc` builtin function that counts the number of trailing zeroes**\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tout = max(out, __builtin_ctz(n)-i);\\n\\t\\ti   = __builtin_ctz(n);\\n\\t}\\n\\treturn out;\\n}\\n```\\nor\\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tauto j = exchange(i, __builtin_ctz(n));\\n        out    = max(out, i - j);\\n\\t}\\n\\treturn out;\\n}\\n```\\n\\nHere https://leetcode.com/problems/get-maximum-in-generated-array/discuss/930626/elegant-o1-space you can  different recipes on how to write `__builtin_ctz` function yourself.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{0}, j{32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i-j), j=i;\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{-32}; n; n>>=1, ++i)\\n\\t\\tif(n&1) out=max(out, i), i=0;              // if(n&1) out=max(out, exchange(i, 0));\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tout = max(out, __builtin_ctz(n)-i);\\n\\t\\ti   = __builtin_ctz(n);\\n\\t}\\n\\treturn out;\\n}\\n```\n```\\nint binaryGap(int n)\\n{\\n\\tint out{0};\\n\\tfor(auto i{32}; n; n&=n-1)\\n\\t{\\n\\t\\tauto j = exchange(i, __builtin_ctz(n));\\n        out    = max(out, i - j);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806074,
                "title": "faster-than-100-c-online-submisssion",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int count=0,pos=0, maxDist =INT_MIN;\\n        while(N){\\n            count++;\\n            if(N&1){\\n                if(pos){\\n                    maxDist = max(maxDist, count-pos);\\n                    pos =count;\\n                }else{\\n                    pos =count;\\n                }\\n            }\\n            N = N>>1;\\n        }\\n        \\n        return maxDist==INT_MIN?0:maxDist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int count=0,pos=0, maxDist =INT_MIN;\\n        while(N){\\n            count++;\\n            if(N&1){\\n                if(pos){\\n                    maxDist = max(maxDist, count-pos);\\n                    pos =count;\\n                }else{\\n                    pos =count;\\n                }\\n            }\\n            N = N>>1;\\n        }\\n        \\n        return maxDist==INT_MIN?0:maxDist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798058,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        \\n        def findbinary(x):\\n            if x//2 < 2:\\n                return str(x//2)+str(x%2)\\n            else:\\n                return findbinary(x//2)+str(x%2)\\n            \\n        num = findbinary(N)\\n        l = [i for i in range(len(num)) if num[i] == \\'1\\']\\n        \\n        if len(l) <= 1:\\n            return 0\\n        \\n        return max([l[i]-l[i-1] for i in range(1,len(l))])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        \\n        def findbinary(x):\\n            if x//2 < 2:\\n                return str(x//2)+str(x%2)\\n            else:\\n                return findbinary(x//2)+str(x%2)\\n            \\n        num = findbinary(N)\\n        l = [i for i in range(len(num)) if num[i] == \\'1\\']\\n        \\n        if len(l) <= 1:\\n            return 0\\n        \\n        return max([l[i]-l[i-1] for i in range(1,len(l))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730010,
                "title": "python3-easy-soln",
                "content": "class Solution:\\n\\n\\n    def binaryGap(self, N: int) -> int:\\n        x=str(bin(N))[2:]\\n        l=[]\\n        prev=0\\n        \\n        for i in range(len(x)):\\n            if x[i]==\\'1\\':\\n                l.append(i-prev)\\n                prev=i\\n                \\n        return max(l)\\n        \\n            \\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n\\n    def binaryGap(self, N: int) -> int:\\n        x=str(bin(N))[2:]\\n        l=[]\\n        prev=0\\n        \\n        for i in range(len(x)):\\n            if x[i]==\\'1\\':\\n                l.append(i-prev)\\n                prev=i\\n                \\n        return max(l)\\n        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 696308,
                "title": "java-simple-neat-solution-with-two-pointers-beat-100",
                "content": "\\t// Two pointers\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        \\n        int i = 0, j = -1;\\n        while (N != 0) {\\n            if ((N & 1) > 0) {\\n                if (j >= 0) {\\n                    max = Math.max(max, i - j);\\n                }\\n                j = i;\\n            }\\n            \\n            N >>>= 1;\\n            i++;\\n        }\\n        \\n        return max;\\n    }\\n",
                "solutionTags": [],
                "code": "\\t// Two pointers\\n    public int binaryGap(int N) {\\n        int max = 0;\\n        \\n        int i = 0, j = -1;\\n        while (N != 0) {\\n            if ((N & 1) > 0) {\\n                if (j >= 0) {\\n                    max = Math.max(max, i - j);\\n                }\\n                j = i;\\n            }\\n            \\n            N >>>= 1;\\n            i++;\\n        }\\n        \\n        return max;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 654605,
                "title": "simple-c-solution-o-n-easy-to-understand-with-explain",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Gap.\\nMemory Usage: 5.9 MB, less than 100.00% of C++ online submissions for Binary Gap.\\n**The problem is that find longest distance between two 1\\'s such that between them all the characters are 0;\\ne.g; 110000110 ans=5\\n11101 ans=2\\n100000001 ans=8\\n1001000100001 ans=5**\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n       string s=\"\";  //convert it into binary string\\n        while(N)\\n        {\\n            int p=N%2;\\n            if(p) s=\\'1\\'+s;\\n            else\\n                s=\\'0\\'+s;\\n            N/=2;\\n        }\\n        cout<<s<<\"\\\\n\";\\n        int i=0,k=0;\\n        while(s[i]!=\\'1\\')  //find position of first one in string\\n            i++;\\n        for(int j=i+1;j<s.length();j++)\\n            \\n        {  //cout<<i<<\" \";\\n            while(s[j]==\\'0\\') j++;  //find next position of one\\n          if(j>=s.size()) break; \\n            k=max(k,j-i); //store maximum length difference\\n            i=j;\\n         //cout<<j<<\" \\\\n\";\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n       string s=\"\";  //convert it into binary string\\n        while(N)\\n        {\\n            int p=N%2;\\n            if(p) s=\\'1\\'+s;\\n            else\\n                s=\\'0\\'+s;\\n            N/=2;\\n        }\\n        cout<<s<<\"\\\\n\";\\n        int i=0,k=0;\\n        while(s[i]!=\\'1\\')  //find position of first one in string\\n            i++;\\n        for(int j=i+1;j<s.length();j++)\\n            \\n        {  //cout<<i<<\" \";\\n            while(s[j]==\\'0\\') j++;  //find next position of one\\n          if(j>=s.size()) break; \\n            k=max(k,j-i); //store maximum length difference\\n            i=j;\\n         //cout<<j<<\" \\\\n\";\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 645879,
                "title": "o-log-binary-n-time-o-log-binary-n-space-java-solution",
                "content": "```\\n//O(log binary(N)) time where binary(N) is the binary string representation of N\\n    //O(log binary(N)) space taken by the string\\n    public int binaryGap(int N) {\\n        String n = Integer.toString(N,2);\\n        int first =-1, second =-1;\\n        int diff = 0;\\n        \\n        for(int i=0;i<n.length();i++){\\n            if(n.charAt(i) ==\\'1\\'){\\n                if(first == -1)\\n                    first = i;\\n                else if(second == -1){\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n                else{\\n                    first = second;\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n            }\\n        }\\n        \\n        return diff;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//O(log binary(N)) time where binary(N) is the binary string representation of N\\n    //O(log binary(N)) space taken by the string\\n    public int binaryGap(int N) {\\n        String n = Integer.toString(N,2);\\n        int first =-1, second =-1;\\n        int diff = 0;\\n        \\n        for(int i=0;i<n.length();i++){\\n            if(n.charAt(i) ==\\'1\\'){\\n                if(first == -1)\\n                    first = i;\\n                else if(second == -1){\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n                else{\\n                    first = second;\\n                    second = i;\\n                    diff = Math.max(diff, second - first);\\n                }\\n            }\\n        }\\n        \\n        return diff;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 639188,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public int binaryGap(int n)\\n    {\\n         int[] a = new int[1000]; \\n   \\n        \\n        int i = 0; \\n        while (n > 0)  \\n        { \\n           \\n            a[i] = n % 2; \\n            n = n / 2; \\n            i++; \\n        } \\n       \\n         int k=i-1;\\n         int d=0;\\n        int b=0;\\n        int c=0;\\n        int co=0;\\n        int max=0;\\n        for (int j = i - 1; j >= 0; j--) \\n        {\\n            if(a[j]==1 && co==0)\\n            {\\n                b=j;\\n                co++;\\n            }\\n            else\\n                if(a[j]==1)\\n                {\\n                  int t=b;\\n                    c=j;\\n                    d=t-c;\\n                    max=(max>=d)?max:d;\\n                    \\n                    b=c;                    \\n                }\\n                  \\n        }\\n        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int binaryGap(int n)\\n    {\\n         int[] a = new int[1000]; \\n   \\n        \\n        int i = 0; \\n        while (n > 0)  \\n        { \\n           \\n            a[i] = n % 2; \\n            n = n / 2; \\n            i++; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 628726,
                "title": "0ms-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n         vector<int>pos;\\n        for(int i=0;i<32;i++)\\n        {\\n            if((N&(1<<i)))\\n                pos.push_back(i);\\n        }\\n        int mx = 0;\\n        for(int i=1;i<pos.size();i++)\\n        {\\n            mx = max(mx,pos[i]-pos[i-1]);\\n        }\\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int binaryGap(int N) {\\n         vector<int>pos;\\n        for(int i=0;i<32;i++)\\n        {\\n            if((N&(1<<i)))\\n                pos.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 608977,
                "title": "go-solution-clean-and-fast-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Gap.\\nMemory Usage: 2.1 MB, less than 100.00% of Go online submissions for Binary Gap.\\n```\\nfunc binaryGap(N int) int {\\n    cnt, maxOnes := 0, 0\\n\\t// strip \\n    for N != 0 && N & 1 != 1 {\\n        N >>= 1\\n    }\\n    for N != 0 {\\n        if N&1 == 1 {\\n            maxOnes = max(maxOnes, cnt)\\n            cnt = 0\\n        }\\n        N >>= 1\\n        cnt++\\n    }\\n    return maxOnes \\n}\\n\\nfunc max(x, y int) int {\\n    if x > y { return x }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(N int) int {\\n    cnt, maxOnes := 0, 0\\n\\t// strip \\n    for N != 0 && N & 1 != 1 {\\n        N >>= 1\\n    }\\n    for N != 0 {\\n        if N&1 == 1 {\\n            maxOnes = max(maxOnes, cnt)\\n            cnt = 0\\n        }\\n        N >>= 1\\n        cnt++\\n    }\\n    return maxOnes \\n}\\n\\nfunc max(x, y int) int {\\n    if x > y { return x }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578704,
                "title": "java-solution-use-bit-operation",
                "content": "```\\npublic int binaryGap(int N) {\\n    int gap = 0;\\n\\n    int cur = 0;\\n    int last = 33;\\n    while (N > 0) {\\n        if ((N & 1) == 1) {\\n            gap = Math.max(cur - last, gap);\\n            last = cur;\\n        }\\n\\n        cur++;\\n        N >>>= 1;\\n    }\\n\\n    return gap;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int binaryGap(int N) {\\n    int gap = 0;\\n\\n    int cur = 0;\\n    int last = 33;\\n    while (N > 0) {\\n        if ((N & 1) == 1) {\\n            gap = Math.max(cur - last, gap);\\n            last = cur;\\n        }\\n\\n        cur++;\\n        N >>>= 1;\\n    }\\n\\n    return gap;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537449,
                "title": "c-simple-solution-beats-100-100-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int last = -1;\\n        int max = 0;\\n        // Run through each bit \\n        for (int i = 0; i < 32; i++) {\\n            // If the bit is a 1\\n            if (N & (1 << i))  {\\n                // If this isn\\'t the first bit, check to see if the\\n                // this bit defines the new max distance\\n                if (last != -1) max = std::max(max, i - last);\\n                // Change this bit to last\\n                last = i;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int last = -1;\\n        int max = 0;\\n        // Run through each bit \\n        for (int i = 0; i < 32; i++) {\\n            // If the bit is a 1\\n            if (N & (1 << i))  {\\n                // If this isn\\'t the first bit, check to see if the\\n                // this bit defines the new max distance\\n                if (last != -1) max = std::max(max, i - last);\\n                // Change this bit to last\\n                last = i;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528358,
                "title": "c-100-space-100-time-solution-o-log-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int gap = 0;\\n        int gap_so_far = 0;\\n        while(N % 2 == 0) {\\n            N /= 2;\\n        }\\n        while(N) {\\n            if (N % 2) {\\n                gap = max(gap, gap_so_far);\\n                gap_so_far = 1;\\n            } else {\\n                gap_so_far++;\\n            }\\n            N /= 2;\\n        }\\n        return gap;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        int gap = 0;\\n        int gap_so_far = 0;\\n        while(N % 2 == 0) {\\n            N /= 2;\\n        }\\n        while(N) {\\n            if (N % 2) {\\n                gap = max(gap, gap_so_far);\\n                gap_so_far = 1;\\n            } else {\\n                gap_so_far++;\\n            }\\n            N /= 2;\\n        }\\n        return gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515335,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        while ((N&0x1) == 0)\\n            N = N>>1;\\n        \\n        int d = 1;\\n        int max = 0;\\n        while (N>0) {\\n            N = N>>1;\\n            if ((N&0x1) == 0) {\\n                d++;\\n            }\\n            else {\\n                max = Math.max(max, d);\\n                d = 1;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        while ((N&0x1) == 0)\\n            N = N>>1;\\n        \\n        int d = 1;\\n        int max = 0;\\n        while (N>0) {\\n            N = N>>1;\\n            if ((N&0x1) == 0) {\\n                d++;\\n            }\\n            else {\\n                max = Math.max(max, d);\\n                d = 1;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410886,
                "title": "c-0ms-solution-using-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        bitset<32>b(N);\\n        int last=-1,ans=0;\\n        for(int i=0;i<32;++i){\\n            if(b[i]){\\n                ans=last==-1?0:max(ans,i-last);\\n                last=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int N) {\\n        bitset<32>b(N);\\n        int last=-1,ans=0;\\n        for(int i=0;i<32;++i){\\n            if(b[i]){\\n                ans=last==-1?0:max(ans,i-last);\\n                last=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402093,
                "title": "java-0ms-100",
                "content": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n       int lastpos = -1;\\n\\t\\tint currentpos = -1;\\n\\t\\tint max = 0;\\n\\t\\twhile (N > 0) {\\n\\t\\t\\tint a = N % 2;\\n\\t\\t\\tcurrentpos++;\\n\\t\\t\\tif (a == 1) {\\n\\t\\t\\t\\tif (lastpos >= 0)\\n\\t\\t\\t\\t\\tmax = Math.max(max, currentpos - lastpos);\\n\\t\\t\\t\\tlastpos = currentpos;\\n\\t\\t\\t}\\n\\t\\t\\tN = N / 2;\\n\\n\\t\\t}\\n\\n\\t\\treturn max;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int N) {\\n       int lastpos = -1;\\n\\t\\tint currentpos = -1;\\n\\t\\tint max = 0;\\n\\t\\twhile (N > 0) {\\n\\t\\t\\tint a = N % 2;\\n\\t\\t\\tcurrentpos++;\\n\\t\\t\\tif (a == 1) {\\n\\t\\t\\t\\tif (lastpos >= 0)\\n\\t\\t\\t\\t\\tmax = Math.max(max, currentpos - lastpos);\\n\\t\\t\\t\\tlastpos = currentpos;\\n\\t\\t\\t}\\n\\t\\t\\tN = N / 2;\\n\\n\\t\\t}\\n\\n\\t\\treturn max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377082,
                "title": "simple-solution-using-bit-manipulation-java-0ms",
                "content": "Used a very simple concept of Bitwise AND (&) to check the last bit and Right shift (>>).\\n\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        int index = -1;\\n        int i=0;\\n        \\n        while(N>0){\\n            \\n            if((N&1) == 1){\\n                if(index >= 0){\\n                    res = Math.max(res, (i-index));\\n                }\\n                index = i;\\n            }\\n            \\n            N = N >> 1;\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int binaryGap(int N) {\\n        int res = 0;\\n        int index = -1;\\n        int i=0;\\n        \\n        while(N>0){\\n            \\n            if((N&1) == 1){\\n                if(index >= 0){\\n                    res = Math.max(res, (i-index));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 360221,
                "title": "go-golang-0ms-clean-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Gap.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Binary Gap.\\n\\n```go\\nfunc binaryGap(N int) int {\\n\\n\\ts := strconv.FormatInt(int64(N), 2)\\n\\tone := \"1\"\\n\\tindexArr := []int{}\\n\\tgap := []int{}\\n\\ttmp := 0\\n\\n\\tfor i, v := range s {\\n\\t\\tif string(v) == one {\\n\\t\\t\\tindexArr = append(indexArr, i)\\n\\t\\t}\\n\\t}\\n\\tfor i := len(indexArr); i > 0; i-- {\\n\\t\\tif i-2 >= 0 {\\n\\t\\t\\tgap = append(gap, indexArr[i-1]-indexArr[i-2])\\n\\t\\t}\\n\\t}\\n\\tfor _, v := range gap {\\n\\t\\tif v > tmp {\\n\\t\\t\\ttmp = v\\n\\t\\t}\\n\\t}\\n\\treturn tmp\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc binaryGap(N int) int {\\n\\n\\ts := strconv.FormatInt(int64(N), 2)\\n\\tone := \"1\"\\n\\tindexArr := []int{}\\n\\tgap := []int{}\\n\\ttmp := 0\\n\\n\\tfor i, v := range s {\\n\\t\\tif string(v) == one {\\n\\t\\t\\tindexArr = append(indexArr, i)\\n\\t\\t}\\n\\t}\\n\\tfor i := len(indexArr); i > 0; i-- {\\n\\t\\tif i-2 >= 0 {\\n\\t\\t\\tgap = append(gap, indexArr[i-1]-indexArr[i-2])\\n\\t\\t}\\n\\t}\\n\\tfor _, v := range gap {\\n\\t\\tif v > tmp {\\n\\t\\t\\ttmp = v\\n\\t\\t}\\n\\t}\\n\\treturn tmp\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 297792,
                "title": "simple-python-solution-faster-than-94-64-and-less-than-83-31-of-python3",
                "content": "it\\'s pretty simple solution and easy to understand \\n\\n```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        BinaryN =bin(N)\\n        BinaryN = BinaryN[2::]\\n        FoundOne = False\\n        Max=0\\n        count=0\\n\\n        for i in BinaryN:\\n            \\n            if(i == \\'1\\'):\\n                if(FoundOne == True):\\n                    Max = max(count,Max)\\n                    count =0   \\n\\n                else:\\n                    FoundOne = True\\n                    \\n            if(FoundOne):\\n                count = count+1\\n            \\n                \\n        return Max\\n                    \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        BinaryN =bin(N)\\n        BinaryN = BinaryN[2::]\\n        FoundOne = False\\n        Max=0\\n        count=0\\n\\n        for i in BinaryN:\\n            \\n            if(i == \\'1\\'):\\n                if(FoundOne == True):\\n                    Max = max(count,Max)\\n                    count =0   \\n\\n                else:\\n                    FoundOne = True\\n                    \\n            if(FoundOne):\\n                count = count+1\\n            \\n                \\n        return Max\\n                    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 293442,
                "title": "o-log-log-n",
                "content": "```\\nint binaryGap(int x){\\n    x>>=__builtin_ctz(x);\\n    if (x==1)return 0;\\n    int y=x,s=0; y|=y>>1; y|=y>>2; y|=y>>4; y|=y>>8; y|=y>>16;\\n    if (x==y)return 1;\\n    if ((x|x>>1)!=y)x|=x>>1,s+=1;else goto l3;\\n    if ((x|x>>2)!=y)x|=x>>2,s+=2;else goto l2;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;else goto l1;\\n    if ((x|x>>8)!=y)x|=x>>8,s+=8;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;\\n    l1:if ((x|x>>2)!=y)x|=x>>2,s+=2;\\n    l2:if ((x|x>>1)!=y)x|=x>>1,s+=1;\\n    l3:return s+2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint binaryGap(int x){\\n    x>>=__builtin_ctz(x);\\n    if (x==1)return 0;\\n    int y=x,s=0; y|=y>>1; y|=y>>2; y|=y>>4; y|=y>>8; y|=y>>16;\\n    if (x==y)return 1;\\n    if ((x|x>>1)!=y)x|=x>>1,s+=1;else goto l3;\\n    if ((x|x>>2)!=y)x|=x>>2,s+=2;else goto l2;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;else goto l1;\\n    if ((x|x>>8)!=y)x|=x>>8,s+=8;\\n    if ((x|x>>4)!=y)x|=x>>4,s+=4;\\n    l1:if ((x|x>>2)!=y)x|=x>>2,s+=2;\\n    l2:if ((x|x>>1)!=y)x|=x>>1,s+=1;\\n    l3:return s+2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 286322,
                "title": "python-split-bin-n-by-1",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        a = bin(N)[2:].split(\\'1\\')[1:-1]\\n        if len(a) == 0:\\n            return 0\\n        else:\\n            return max(map(len, a)) + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N: int) -> int:\\n        a = bin(N)[2:].split(\\'1\\')[1:-1]\\n        if len(a) == 0:\\n            return 0\\n        else:\\n            return max(map(len, a)) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260480,
                "title": "functional-js-solution-faster-than-90",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar binaryGap = function(N) {\\n    const str = N.toString(2);\\n    const bits = str.split(\\'\\');\\n    \\n    let maxDist = 0;\\n    let countBeginIndex = 0;\\n    bits.forEach((bit, index) => {\\n        if (bit !== \\'1\\') {\\n            return;\\n        }\\n        \\n        maxDist = Math.max(index - countBeginIndex, maxDist);\\n        countBeginIndex = index;\\n    });\\n    \\n    return maxDist;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar binaryGap = function(N) {\\n    const str = N.toString(2);\\n    const bits = str.split(\\'\\');\\n    \\n    let maxDist = 0;\\n    let countBeginIndex = 0;\\n    bits.forEach((bit, index) => {\\n        if (bit !== \\'1\\') {\\n            return;\\n        }\\n        \\n        maxDist = Math.max(index - countBeginIndex, maxDist);\\n        countBeginIndex = index;\\n    });\\n    \\n    return maxDist;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 160233,
                "title": "fast-swift-solution",
                "content": "```\\nclass Solution {\\n    func binaryGap(_ N: Int) -> Int {\\n        let str = String(N, radix: 2)\\n\\n        let position = str.enumerated().compactMap {\\n            $0.element == \"1\" ? $0.offset : nil\\n        }\\n\\n        if position.count <= 1  {\\n            return 0\\n        } else {\\n            var curGap = abs(position[0] - position[1])\\n\\n            for index in 1..<position.count - 1 {\\n                curGap = max(curGap, abs(position[index] - position[index + 1]))\\n            }\\n\\n            return curGap\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func binaryGap(_ N: Int) -> Int {\\n        let str = String(N, radix: 2)\\n\\n        let position = str.enumerated().compactMap {\\n            $0.element == \"1\" ? $0.offset : nil\\n        }\\n\\n        if position.count <= 1  {\\n            return 0\\n        } else {\\n            var curGap = abs(position[0] - position[1])\\n\\n            for index in 1..<position.count - 1 {\\n                curGap = max(curGap, abs(position[index] - position[index + 1]))\\n            }\\n\\n            return curGap\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158803,
                "title": "c-solution-using-while-loop",
                "content": "```\\npublic class Solution\\n{\\n    public int BinaryGap(int N)\\n    {\\n        if ((N & (N - 1)) == 0) // Checks for N == 0 and N being a power of two\\n            return 0;\\n        // If the preceding condition was false then N has at leat two 1s\\n        while ((N & 1) == 0) // Find the first 1\\n            N >>= 1;\\n        N >>= 1; // Since we\\'re intrested in the gap between 1s the first 1 is skipped\\n\\t\\t\\t\\t//(otherwise it would cause an additional meaningless iteration of the following loop)\\n        int maxGap = 0;\\n        int gap = 0;\\n        while (N != 0)\\n        {\\n            if ((N & 1) == 0) // If it\\'s 0 then increase the current gap\\n                gap++;\\n            else // If it\\'s 1\\n            {\\n                if (gap > maxGap) // If current gap is bigger than the max one we change the max\\n                    maxGap = gap;\\n                gap = 0; // Reset the counter\\n            }\\n            N >>= 1;\\n        }\\n        return maxGap + 1; // Because maxGap holds the number of 0s between two 1s we increment it to represent the gap\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int BinaryGap(int N)\\n    {\\n        if ((N & (N - 1)) == 0) // Checks for N == 0 and N being a power of two\\n            return 0;\\n        // If the preceding condition was false then N has at leat two 1s\\n        while ((N & 1) == 0) // Find the first 1\\n            N >>= 1;\\n        N >>= 1; // Since we\\'re intrested in the gap between 1s the first 1 is skipped\\n\\t\\t\\t\\t//(otherwise it would cause an additional meaningless iteration of the following loop)\\n        int maxGap = 0;\\n        int gap = 0;\\n        while (N != 0)\\n        {\\n            if ((N & 1) == 0) // If it\\'s 0 then increase the current gap\\n                gap++;\\n            else // If it\\'s 1\\n            {\\n                if (gap > maxGap) // If current gap is bigger than the max one we change the max\\n                    maxGap = gap;\\n                gap = 0; // Reset the counter\\n            }\\n            N >>= 1;\\n        }\\n        return maxGap + 1; // Because maxGap holds the number of 0s between two 1s we increment it to represent the gap\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151314,
                "title": "simple-java-solution",
                "content": "```\\npublic int binaryGap(int N) {\\n        int max = 0, lastSeen=-1, tmp = 0, curr = 0;\\n        while(N != 0){\\n            tmp = N % 2;\\n            if(tmp == 1){\\n                if(lastSeen != -1) /*do not calc distance for first \\'1\\'*/\\n                    max = Math.max(max, curr-lastSeen);\\n                lastSeen = curr;\\n            }\\n            N/=2;\\n            ++curr;\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int binaryGap(int N) {\\n        int max = 0, lastSeen=-1, tmp = 0, curr = 0;\\n        while(N != 0){\\n            tmp = N % 2;\\n            if(tmp == 1){\\n                if(lastSeen != -1) /*do not calc distance for first \\'1\\'*/\\n                    max = Math.max(max, curr-lastSeen);\\n                lastSeen = curr;\\n            }\\n            N/=2;\\n            ++curr;\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150926,
                "title": "c-average-case-faster-than-simple-right-shifting-0-ms",
                "content": "```\\n\\nclass Solution {\\n   \\n    constexpr inline int trailing_zero(int n) {\\n    \\n        constexpr int table[] = {32, 0, 1,\\n            26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11,\\n            0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29,\\n            10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19,\\n            18};\\n        \\n        \\n        return table[(-n & n) % 37];        \\n    }\\n    \\npublic:\\n    int binaryGap(int N) {\\n        int m = 0;\\n        \\n        int last = trailing_zero(N);\\n        while(N) {\\n            int t = trailing_zero(N);  // computes the number of zeros to the right of the rightmost one\\n            \\n            m = max(m, t - last);\\n            last = t;\\n                        \\n            N -= (1 << t);  // Zeroes out the rightmost one\\n        }\\n        \\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n   \\n    constexpr inline int trailing_zero(int n) {\\n    \\n        constexpr int table[] = {32, 0, 1,\\n            26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11,\\n            0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29,\\n            10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19,\\n            18};\\n        \\n        \\n        return table[(-n & n) % 37];        \\n    }\\n    \\npublic:\\n    int binaryGap(int N) {\\n        int m = 0;\\n        \\n        int last = trailing_zero(N);\\n        while(N) {\\n            int t = trailing_zero(N);  // computes the number of zeros to the right of the rightmost one\\n            \\n            m = max(m, t - last);\\n            last = t;\\n                        \\n            N -= (1 << t);  // Zeroes out the rightmost one\\n        }\\n        \\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150846,
                "title": "python-solution-using-3-if-statements-and-a-counter",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        max_num = 0\\n        counting = False\\n        counter = 0\\n        binary = bin(N)\\n        \\n        for index in range(0, len(binary)):\\n            \\n            if (binary[index] == \\'1\\') and (counting == False):\\n                counting = True\\n                \\n            elif (binary[index] != \\'1\\') and (counting == True):\\n                counter += 1\\n                \\n            elif (binary[index] == \\'1\\') and (counting == True):\\n                counter += 1\\n                if counter > max_num:\\n                    max_num = counter\\n                counter = 0\\n                \\n        return max_num\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        max_num = 0\\n        counting = False\\n        counter = 0\\n        binary = bin(N)\\n        \\n        for index in range(0, len(binary)):\\n            \\n            if (binary[index] == \\'1\\') and (counting == False):\\n                counting = True\\n                \\n            elif (binary[index] != \\'1\\') and (counting == True):\\n                counter += 1\\n                \\n            elif (binary[index] == \\'1\\') and (counting == True):\\n                counter += 1\\n                if counter > max_num:\\n                    max_num = counter\\n                counter = 0\\n                \\n        return max_num\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 149904,
                "title": "c-like-languages-o-1-simple-solution",
                "content": "In fact, I realized that it\\'s O(log N) thanks to [@sasha.pad](https://leetcode.com/sashapad) reminded me. Sorry to showed an inaccurate statement to you.\\n```C\\nint binaryGap(int N) {\\n    int max = 0;\\n    int dis = 0;\\n    // get the rightmost 1\\n    while (N % 2 == 0)\\n        N >>= 1;\\n    // find the max distance\\n    while (N != 0) {\\n        N >>= 1;\\n        ++dis;\\n        if (N % 2 == 1) {\\n            if (dis > max)\\n                max = dis;\\n            dis = 0;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [],
                "code": "```C\\nint binaryGap(int N) {\\n    int max = 0;\\n    int dis = 0;\\n    // get the rightmost 1\\n    while (N % 2 == 0)\\n        N >>= 1;\\n    // find the max distance\\n    while (N != 0) {\\n        N >>= 1;\\n        ++dis;\\n        if (N % 2 == 1) {\\n            if (dis > max)\\n                max = dis;\\n            dis = 0;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149841,
                "title": "simple-java-o-1-time",
                "content": "Just maintain a variable which is a power of 2 (i.e. contains only 1 one). We right shift this every time in a loop taking at max 32 right shfift for an integer. Simply keep track of `lastPosition` where we found a one and a `max` distance between 1\\'s. \\n```\\nclass  Solution {\\n    public int binaryGap(int N) {\\n        int dist = 1, lastPos = -1, incr = 0 ; \\n        int max = Integer.MIN_VALUE; \\n        while(dist <= N){\\n            dist = 1 << incr; \\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr; \\n            }\\n            incr++; \\n        }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```\\n\\nA bit more compact version \\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = Integer.MIN_VALUE; \\n        for(int dist = 1, lastPos = -1, incr = 0; (dist = (1 << incr)) <= N; incr++)\\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr ;\\n            }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass  Solution {\\n    public int binaryGap(int N) {\\n        int dist = 1, lastPos = -1, incr = 0 ; \\n        int max = Integer.MIN_VALUE; \\n        while(dist <= N){\\n            dist = 1 << incr; \\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr; \\n            }\\n            incr++; \\n        }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int binaryGap(int N) {\\n        int max = Integer.MIN_VALUE; \\n        for(int dist = 1, lastPos = -1, incr = 0; (dist = (1 << incr)) <= N; incr++)\\n            if((dist & N) > 0 ){\\n                if(lastPos != -1)max = Math.max(max, incr - lastPos); \\n                lastPos = incr ;\\n            }\\n        return max==Integer.MIN_VALUE ? 0 : max; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086691,
                "title": "bitset-lib",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n      bitset<sizeof(int) * 8> binary(n);\\n      string binaryStr = binary.to_string();\\n      int last1 = -1;\\n      int gap = 0;\\n      for (int i = 0; i < binaryStr.size(); ++i) {\\n        char cur = binaryStr[i];\\n        if (cur == \\'1\\') {\\n          if (last1 >= 0) {\\n            int diff = i - last1;\\n            gap = max(gap,diff);\\n          }\\n          last1 = i;\\n        }\\n      }\\n      return gap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n      bitset<sizeof(int) * 8> binary(n);\\n      string binaryStr = binary.to_string();\\n      int last1 = -1;\\n      int gap = 0;\\n      for (int i = 0; i < binaryStr.size(); ++i) {\\n        char cur = binaryStr[i];\\n        if (cur == \\'1\\') {\\n          if (last1 >= 0) {\\n            int diff = i - last1;\\n            gap = max(gap,diff);\\n          }\\n          last1 = i;\\n        }\\n      }\\n      return gap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055804,
                "title": "c-easy-and-readable-solution-faster-than-70",
                "content": "![image.png](https://assets.leetcode.com/users/images/aaf78b84-c2d4-40bf-89c6-7aa0d31faa17_1694955763.498142.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int previouse = 32;\\n        int distance = 0;\\n        int pos = 0;\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                distance = Math.Max(distance, pos - previouse);\\n                previouse = pos;\\n            }\\n            n /= 2;\\n            pos++;\\n        }\\n        return distance;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int previouse = 32;\\n        int distance = 0;\\n        int pos = 0;\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                distance = Math.Max(distance, pos - previouse);\\n                previouse = pos;\\n            }\\n            n /= 2;\\n            pos++;\\n        }\\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054572,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n     public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n     public int binaryGap(int n) {\\n        int lastPos =-1;\\n        int max = 0;\\n        int pos =0;\\n        \\n       while(n>0){\\n         pos++;\\n           if((n&1)==1){\\n               if(lastPos!=-1){\\n                   max = Math.max(max, pos-lastPos);\\n               }\\n               lastPos = pos;\\n           }\\n           n= n/2;\\n       }\\n        return max;\\n        \\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\n public:\\n  int BinaryGap(int n) {\\n    int index = 0, prev_index = -1;\\n    int max_distance = 0;\\n\\n    while (n) {\\n      if (n & 1) {\\n        if (prev_index != -1)\\n          max_distance = std::max(max_distance, index - prev_index);\\n        prev_index = index;\\n      }\\n      n >>= 1, index++;\\n    }\\n\\n    return max_distance;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048317,
                "title": "fastest-c-single-pass-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) { \\n        int distance=0;\\n        int last=-1;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                if(i-last!=i+1)\\n                distance=max(distance,i-last);\\n                last=i;\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) { \\n        int distance=0;\\n        int last=-1;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                if(i-last!=i+1)\\n                distance=max(distance,i-last);\\n                last=i;\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048241,
                "title": "fastest-c-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        vector<int> positions;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                positions.push_back(i);\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<positions.size();i++)\\n        ans=max(ans,positions[i]-positions[i-1]);\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        vector<int> positions;\\n        int i=1;\\n        while(n)\\n        {\\n            if((n&1)==1)\\n            {\\n                positions.push_back(i);\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<positions.size();i++)\\n        ans=max(ans,positions[i]-positions[i-1]);\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037525,
                "title": "100-faster-with-branchless-techniques",
                "content": "# Intuition\\nMy attempt to get rid of as much branching as possible, even though the compiler will probably do better with optimization flags.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        auto max_distance = 0;\\n        while (!(n & 1)) n >>= 1;\\n        auto distance = 0;\\n        while (n != 0) {\\n            const bool increase = (max_distance - distance) & (1 << 31);\\n            max_distance = increase * distance + (!increase) * max_distance;\\n            distance = !(n & 1) * distance + 1;\\n            n >>= 1;\\n        }\\n        return max_distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        auto max_distance = 0;\\n        while (!(n & 1)) n >>= 1;\\n        auto distance = 0;\\n        while (n != 0) {\\n            const bool increase = (max_distance - distance) & (1 << 31);\\n            max_distance = increase * distance + (!increase) * max_distance;\\n            distance = !(n & 1) * distance + 1;\\n            n >>= 1;\\n        }\\n        return max_distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031355,
                "title": "for-loop-java-sol",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n            String b = Integer.toBinaryString(n);\\n    int max = 0, t = 0, j = b.indexOf(\\'1\\');\\n\\n    // System.out.println(b);\\n    // System.out.println(b.indexOf(\\'1\\'));\\n\\n    for (int i = j + 1; i < b.length(); i++) {\\n      if (b.charAt(i) == \\'1\\') {\\n        t = i - j;\\n        max = Math.max(t, max);\\n        j = i;\\n      }\\n    }\\n    return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n            String b = Integer.toBinaryString(n);\\n    int max = 0, t = 0, j = b.indexOf(\\'1\\');\\n\\n    // System.out.println(b);\\n    // System.out.println(b.indexOf(\\'1\\'));\\n\\n    for (int i = j + 1; i < b.length(); i++) {\\n      if (b.charAt(i) == \\'1\\') {\\n        t = i - j;\\n        max = Math.max(t, max);\\n        j = i;\\n      }\\n    }\\n    return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030878,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans=0;\\n        int count=0;\\n        if((n&(n-1))==0){\\n            return 0;\\n        }\\n        boolean yes=false;\\n        while(n>0){\\n            if((n&1)==1){\\n                if(count>ans){\\n                    ans=count;\\n                }\\n                count=1;\\n                yes=true;\\n            }\\n            if((n&1)==0){\\n                if(yes==true){\\n                    count++;\\n                }  \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans=0;\\n        int count=0;\\n        if((n&(n-1))==0){\\n            return 0;\\n        }\\n        boolean yes=false;\\n        while(n>0){\\n            if((n&1)==1){\\n                if(count>ans){\\n                    ans=count;\\n                }\\n                count=1;\\n                yes=true;\\n            }\\n            if((n&1)==0){\\n                if(yes==true){\\n                    count++;\\n                }  \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024404,
                "title": "easy-python-solution-using-list-comprehension-and-bin-function-beats-81",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/b25e8437-66c7-427b-9cf4-7703085d7645_1694311239.7161283.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=(bin(n))[2:]\\n        l=[i for i in range(len(a)) if a[i]==\"1\"]\\n        temp=0\\n        for i in range(len(l)-1):\\n            x=l[i+1]-l[i]\\n            if x>temp:\\n                temp=x\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        a=(bin(n))[2:]\\n        l=[i for i in range(len(a)) if a[i]==\"1\"]\\n        temp=0\\n        for i in range(len(l)-1):\\n            x=l[i+1]-l[i]\\n            if x>temp:\\n                temp=x\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017029,
                "title": "java-solution-using-bit-manipulation",
                "content": "# Intuition\\nUsing bit operations like and operation with 1 followed by right shift of 1 we can solve this.\\n\\n# Approach\\n(n & 1) will yeild right most bit. Whenever we see right most bit as 1, we will compare is there any max previous distance. If it is not 1 then we increment the distance.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int count = 0;\\n        int max = 0;\\n        while(n > 0) {\\n            if ((n & 1) == 1) {\\n                max = Math.max(count, max);\\n                count = 1;\\n            } else if(count > 0) {\\n                count++;\\n            }\\n            n >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int count = 0;\\n        int max = 0;\\n        while(n > 0) {\\n            if ((n & 1) == 1) {\\n                max = Math.max(count, max);\\n                count = 1;\\n            } else if(count > 0) {\\n                count++;\\n            }\\n            n >>= 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011074,
                "title": "python-rust-solutions",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        result, prev = 0, None\\n        for index, char in enumerate(f\"{n:b}\"):\\n            if char == \"1\":\\n                if prev is not None:\\n                    result = max(result, index - prev)\\n                prev = index\\n\\n        return result\\n```\\n```rust []\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut result = usize::MIN;\\n        let mut prev: Option<usize> = None;\\n\\n        for (index, char) in format!(\"{:b}\", n).char_indices() {\\n            if char == \\'1\\' {\\n                if let Some(x) = prev {\\n                    result = result.max(index - x);\\n                }\\n                prev = Some(index);\\n            }\\n        }\\n\\n        result as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        result, prev = 0, None\\n        for index, char in enumerate(f\"{n:b}\"):\\n            if char == \"1\":\\n                if prev is not None:\\n                    result = max(result, index - prev)\\n                prev = index\\n\\n        return result\\n```\n```rust []\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut result = usize::MIN;\\n        let mut prev: Option<usize> = None;\\n\\n        for (index, char) in format!(\"{:b}\", n).char_indices() {\\n            if char == \\'1\\' {\\n                if let Some(x) = prev {\\n                    result = result.max(index - x);\\n                }\\n                prev = Some(index);\\n            }\\n        }\\n\\n        result as _\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010516,
                "title": "typescript-javascript-regex-solution",
                "content": "```ts\\nfunction binaryGap(n: number): number {\\n    const bin = n.toString(2);\\n    const timeAppear: number = `${bin}`.match(/1/g)?.length || 0;\\n    if(timeAppear < 2) return 0;\\n    let maxGap: number = 0;\\n    let gap: number = 0;\\n    const binArr = bin.replace(/^0+|0+$/g, \"\").split(\\'\\');\\n    for(let num of binArr){\\n        gap++;\\n        if(gap > maxGap) maxGap = gap;\\n        if(num == \\'1\\') gap = 0;\\n    }\\n    return maxGap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction binaryGap(n: number): number {\\n    const bin = n.toString(2);\\n    const timeAppear: number = `${bin}`.match(/1/g)?.length || 0;\\n    if(timeAppear < 2) return 0;\\n    let maxGap: number = 0;\\n    let gap: number = 0;\\n    const binArr = bin.replace(/^0+|0+$/g, \"\").split(\\'\\');\\n    for(let num of binArr){\\n        gap++;\\n        if(gap > maxGap) maxGap = gap;\\n        if(num == \\'1\\') gap = 0;\\n    }\\n    return maxGap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004034,
                "title": "the-best-available-solution-that-beats-100-of-existing-solution",
                "content": "# Intuition\\nThe problem requires finding the maximum distance between two \\'1\\'s in the binary representation of a given integer \\'n\\'. To solve this problem, you can first convert the integer \\'n\\' to its binary representation as a string, and then iterate through the string to find the maximum gap between two \\'1\\'s. This gap represents the distance between two consecutive \\'1\\'s in the binary representation.\\n\\n# Approach\\n1. Initialize an empty string \\'bin\\' to store the binary representation of \\'n\\'.\\n2. Initialize a variable \\'result\\' to store the maximum binary gap, initially set to 0.\\n3. Use a while loop to convert \\'n\\' to its binary representation:\\n   a. Check if \\'n\\' is even (n % 2 == 0), and if so, insert \\'0\\' at the beginning of the \\'bin\\' string.\\n   b. Otherwise, insert \\'1\\' at the beginning of the \\'bin\\' string.\\n   c. Update \\'n\\' by performing integer division by 2 (n /= 2).\\n4. Initialize a temporary variable \\'temp\\' to 0, which will be used to keep track of the current binary gap.\\n5. Iterate through the \\'bin\\' string:\\n   a. If the current character is \\'1\\' and \\'temp\\' is 0, increment \\'temp\\' by 1.\\n   b. If the current character is \\'0\\', increment \\'temp\\' by 1.\\n   c. If the current character is \\'1\\' and \\'temp\\' is not 0, update \\'result\\' with the maximum of \\'result\\' and \\'temp\\', then reset \\'temp\\' to 1.\\n6. After the loop, return \\'result\\' as the maximum binary gap.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution depends on the number of bits in the binary representation of \\'n\\'. In the worst case, \\'n\\' has \\'log2(n)\\' bits. Therefore, the time complexity is O(log n) for converting \\'n\\' to its binary representation and O(log n) for iterating through the binary representation, resulting in an overall time complexity of O(log n).\\n\\n- Space complexity: Space Complexity: The space complexity is determined by the space needed for the \\'bin\\' string, which stores the binary representation of \\'n\\'. In the worst case, the length of the binary representation is \\'log2(n)\\' characters. Thus, the space complexity is O(log n) for the \\'bin\\' string, and O(1) for other variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        int result = 0;\\n        while(n > 0)\\n        {\\n            if(n % 2 == 0){\\n                bin.insert(bin.begin() + 0, \\'0\\');\\n            }\\n            else{\\n                bin.insert(bin.begin() + 0, \\'1\\');\\n            }\\n            n /= 2;\\n        }\\n        int temp = 0;\\n        for(int i = 0; i < bin.length(); ++i)\\n        {\\n            if((bin[i] == \\'1\\' && temp == 0) || bin[i] == \\'0\\')\\n            {\\n                ++temp;\\n            }\\n            else{\\n                if(result < temp)\\n                    result = temp;\\n                temp = 1;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}; \\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        string bin;\\n        int result = 0;\\n        while(n > 0)\\n        {\\n            if(n % 2 == 0){\\n                bin.insert(bin.begin() + 0, \\'0\\');\\n            }\\n            else{\\n                bin.insert(bin.begin() + 0, \\'1\\');\\n            }\\n            n /= 2;\\n        }\\n        int temp = 0;\\n        for(int i = 0; i < bin.length(); ++i)\\n        {\\n            if((bin[i] == \\'1\\' && temp == 0) || bin[i] == \\'0\\')\\n            {\\n                ++temp;\\n            }\\n            else{\\n                if(result < temp)\\n                    result = temp;\\n                temp = 1;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}; \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980521,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        def adjDif(arr):\\n            ans = 0\\n            for i in range(len(arr) - 1):\\n                if arr[i + 1] - arr[i] > ans:\\n                    ans = arr[i + 1] - arr[i]\\n            return ans\\n\\n\\n        index = []\\n        arr = list(str(bin(n))[2:])\\n\\n        for i in range(len(arr)):\\n            if arr[i] == \\'1\\':\\n                index.append(i)\\n                \\n        return adjDif(index)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        def adjDif(arr):\\n            ans = 0\\n            for i in range(len(arr) - 1):\\n                if arr[i + 1] - arr[i] > ans:\\n                    ans = arr[i + 1] - arr[i]\\n            return ans\\n\\n\\n        index = []\\n        arr = list(str(bin(n))[2:])\\n\\n        for i in range(len(arr)):\\n            if arr[i] == \\'1\\':\\n                index.append(i)\\n                \\n        return adjDif(index)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967409,
                "title": "c-solution-with-tc-o-logn-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int ans=0;\\n        bool countS=false;\\n        int i=0;\\n        while(n>0){\\n            if((n&1)==1){\\n                countS=true;\\n                ans=Math.Max(ans,i);\\n                i=1;\\n            }else{\\n                if(countS)\\n                   i++;     \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) {\\n        int ans=0;\\n        bool countS=false;\\n        int i=0;\\n        while(n>0){\\n            if((n&1)==1){\\n                countS=true;\\n                ans=Math.Max(ans,i);\\n                i=1;\\n            }else{\\n                if(countS)\\n                   i++;     \\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960208,
                "title": "ugly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nMy ugly solution\\n```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut res_vec: Vec<i32> = Vec::new();\\n        let mut res: i32 = 0;\\n        let str = format!(\"{:b}\", n);\\n        if str.matches(\\'1\\').count() > 1 {\\n            for i in 0..str.len() {\\n                res += 1;\\n                if str.as_bytes()[i] as char == \\'1\\' {\\n                    res_vec.push(res);\\n                    res = 0;\\n                }\\n            }\\n            match res_vec.iter().max() {\\n                Some(max) => return *max,\\n                None => {},\\n            }\\n        } \\n        0\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let mut res_vec: Vec<i32> = Vec::new();\\n        let mut res: i32 = 0;\\n        let str = format!(\"{:b}\", n);\\n        if str.matches(\\'1\\').count() > 1 {\\n            for i in 0..str.len() {\\n                res += 1;\\n                if str.as_bytes()[i] as char == \\'1\\' {\\n                    res_vec.push(res);\\n                    res = 0;\\n                }\\n            }\\n            match res_vec.iter().max() {\\n                Some(max) => return *max,\\n                None => {},\\n            }\\n        } \\n        0\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952135,
                "title": "mom-we-have-java-solution-at-home-java-solution-at-home",
                "content": "# Approach\\nIn this solution, we are processing the input in multiple steps. First, we are converting the integer value to a binary string (I felt like it will be easier to check every characters). Then chop off the zeros before and after the \\'1\\'s.\\n\\nAt this point, we have to see if there is only a single \\'1\\' character in the string. If so, there can\\'t be a distance value.\\n\\nWe define an ArrayList to keep all distances we counted with the for loop. After that, if there is at least a distance element in the arraylist, we are finding the maximum and return the result. \\u2615\\n\\nThis may seem ugly but I think this is a really simple and easy to understand solution. \\uD83D\\uDE4C\\n\\nPlease leave an upvote, to keep a random person motivated \\uD83D\\uDC7D\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(log(n))$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        // Convert n to binary string.\\n        String binaryString = Integer.toBinaryString(n);\\n        \\n        // Remove the leading and the trailing zeros.\\n        int start = binaryString.indexOf(\\'1\\');\\n        int end = binaryString.lastIndexOf(\\'1\\');\\n        binaryString = binaryString.substring(start, end + 1);\\n\\n        // Check the cases where there is zero or one \\'1\\'.\\n        if (binaryString.length() <= 1) { return 0; }\\n\\n        // Count zeros and store the distances in an arraylist.\\n        ArrayList<Integer> distances = new ArrayList<>();\\n        int counter = 1;\\n        for (int i = 1; i < binaryString.length(); i++) {\\n            if (binaryString.charAt(i) == \\'1\\') {\\n                distances.add(counter);\\n                counter = 0;\\n            }\\n            counter += 1;\\n        }\\n\\n        // If there was no gap between ones, return 1.\\n        if (distances.size() == 0) { return 1; }\\n\\n        // Get the max distance.\\n        int max = 1;\\n        for (int distance : distances) {\\n            if (distance > max) {\\n                max = distance;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        // Convert n to binary string.\\n        String binaryString = Integer.toBinaryString(n);\\n        \\n        // Remove the leading and the trailing zeros.\\n        int start = binaryString.indexOf(\\'1\\');\\n        int end = binaryString.lastIndexOf(\\'1\\');\\n        binaryString = binaryString.substring(start, end + 1);\\n\\n        // Check the cases where there is zero or one \\'1\\'.\\n        if (binaryString.length() <= 1) { return 0; }\\n\\n        // Count zeros and store the distances in an arraylist.\\n        ArrayList<Integer> distances = new ArrayList<>();\\n        int counter = 1;\\n        for (int i = 1; i < binaryString.length(); i++) {\\n            if (binaryString.charAt(i) == \\'1\\') {\\n                distances.add(counter);\\n                counter = 0;\\n            }\\n            counter += 1;\\n        }\\n\\n        // If there was no gap between ones, return 1.\\n        if (distances.size() == 0) { return 1; }\\n\\n        // Get the max distance.\\n        int max = 1;\\n        for (int distance : distances) {\\n            if (distance > max) {\\n                max = distance;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949547,
                "title": "python-beats-100-get-1s-indices",
                "content": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ones = [i for i,v in enumerate(bin(n)) if v==\\'1\\']\\n        maxi = 0\\n        for i in range(1,len(ones)):\\n            maxi = max(maxi, ones[i]-ones[i-1])\\n        return maxi\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2eb9ab23-c46f-475e-8683-48b3aa516616_1692786972.5100787.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        ones = [i for i,v in enumerate(bin(n)) if v==\\'1\\']\\n        maxi = 0\\n        for i in range(1,len(ones)):\\n            maxi = max(maxi, ones[i]-ones[i-1])\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943485,
                "title": "optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int maxDistance = 0;\\n        int lastOnePos = -1;\\n        int bitPos = 0;\\n        \\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                if (lastOnePos != -1) {\\n                    maxDistance = Math.max(maxDistance, bitPos - lastOnePos);\\n                }\\n                lastOnePos = bitPos;\\n            }\\n            n >>= 1;\\n            bitPos++;\\n        }\\n        \\n        return maxDistance;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int maxDistance = 0;\\n        int lastOnePos = -1;\\n        int bitPos = 0;\\n        \\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                if (lastOnePos != -1) {\\n                    maxDistance = Math.max(maxDistance, bitPos - lastOnePos);\\n                }\\n                lastOnePos = bitPos;\\n            }\\n            n >>= 1;\\n            bitPos++;\\n        }\\n        \\n        return maxDistance;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939109,
                "title": "1ms-o-n-time-complexity-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int largest = 0;\\n        int lastOne = -1;\\n        char[] digits = Integer.toBinaryString(n).toCharArray();\\n        for (int i =0; i < digits.length; i++ ) {\\n            if (digits[i] == \\'1\\') {\\n                if (lastOne > -1) {\\n                    largest = Math.max(largest, i - lastOne);\\n                    lastOne = i;\\n                }\\n                if (lastOne == -1) { lastOne = i;}\\n            }\\n        }\\n\\n        return largest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int largest = 0;\\n        int lastOne = -1;\\n        char[] digits = Integer.toBinaryString(n).toCharArray();\\n        for (int i =0; i < digits.length; i++ ) {\\n            if (digits[i] == \\'1\\') {\\n                if (lastOne > -1) {\\n                    largest = Math.max(largest, i - lastOne);\\n                    lastOne = i;\\n                }\\n                if (lastOne == -1) { lastOne = i;}\\n            }\\n        }\\n\\n        return largest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929262,
                "title": "python-beats-100-time",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/74782748-f21c-4d2a-bd3d-9b8be148fde0_1692415205.3358538.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        s = bin(n)[2:]\\n        track = False\\n        res = 0\\n        curr = 0\\n        for c in s:\\n            if int(c) == 1 and track:\\n                res = max(curr, res)\\n                curr = 1\\n            elif int(c) == 1 and not track:\\n                track = True\\n                curr += 1\\n            else:\\n                curr += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def binaryGap(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        s = bin(n)[2:]\\n        track = False\\n        res = 0\\n        curr = 0\\n        for c in s:\\n            if int(c) == 1 and track:\\n                res = max(curr, res)\\n                curr = 1\\n            elif int(c) == 1 and not track:\\n                track = True\\n                curr += 1\\n            else:\\n                curr += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914260,
                "title": "step-by-step",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        w = bin(n)[2:]\\n        mx = 0\\n        start = 0\\n        i = 0\\n        zero = False\\n        for ch in w:\\n            # print(zero, ch)\\n            if ch == \\'1\\':\\n                mx = max(mx, i-start)\\n                start = i\\n\\n            i += 1\\n        return mx\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        w = bin(n)[2:]\\n        mx = 0\\n        start = 0\\n        i = 0\\n        zero = False\\n        for ch in w:\\n            # print(zero, ch)\\n            if ch == \\'1\\':\\n                mx = max(mx, i-start)\\n                start = i\\n\\n            i += 1\\n        return mx\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903222,
                "title": "c-easy-sol-without-storing-the-binary-in-a-variable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int rem,result=0,dis=0,i=0,flag=0;\\n        while(n){\\n            rem=n%2;\\n            if(rem==1){\\n                if(flag!=0){\\n                    result=max(result,i-dis);\\n                    dis=i;\\n                }\\n                if(flag==0){\\n                    flag=1;\\n                    dis=i;\\n                }\\n            }\\n            n=n/2;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int rem,result=0,dis=0,i=0,flag=0;\\n        while(n){\\n            rem=n%2;\\n            if(rem==1){\\n                if(flag!=0){\\n                    result=max(result,i-dis);\\n                    dis=i;\\n                }\\n                if(flag==0){\\n                    flag=1;\\n                    dis=i;\\n                }\\n            }\\n            n=n/2;\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892743,
                "title": "python-beats-90",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        n = list(bin(n)[2:])\\n\\n        if n.count(\\'1\\') == 1 or n.count(\\'1\\') == 0:\\n            return 0\\n\\n        output = 0\\n        for i in range(len(n)):\\n            temp = 0\\n            if n[i] == \\'1\\':\\n                for x in range(i+1,len(n)):\\n                    if n[x] == \\'1\\':\\n                        temp+=1\\n                        output = max(output,temp)\\n                        break\\n                    else:\\n                        temp+=1                    \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        n = list(bin(n)[2:])\\n\\n        if n.count(\\'1\\') == 1 or n.count(\\'1\\') == 0:\\n            return 0\\n\\n        output = 0\\n        for i in range(len(n)):\\n            temp = 0\\n            if n[i] == \\'1\\':\\n                for x in range(i+1,len(n)):\\n                    if n[x] == \\'1\\':\\n                        temp+=1\\n                        output = max(output,temp)\\n                        break\\n                    else:\\n                        temp+=1                    \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889546,
                "title": "quick-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int counter = 0;\\n        int maxCount = 0;\\n        int mask = 1;\\n        bool flag = false;\\n        while(n > 0) {\\n            // getting the first bit from the right\\n            if(n&mask == 1) {\\n                // there is one\\n                flag = true;\\n                maxCount = max(maxCount, counter);\\n                counter = 0;\\n            }\\n            if(flag == true){\\n                counter++;\\n            }\\n            n = n >> 1;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int counter = 0;\\n        int maxCount = 0;\\n        int mask = 1;\\n        bool flag = false;\\n        while(n > 0) {\\n            // getting the first bit from the right\\n            if(n&mask == 1) {\\n                // there is one\\n                flag = true;\\n                maxCount = max(maxCount, counter);\\n                counter = 0;\\n            }\\n            if(flag == true){\\n                counter++;\\n            }\\n            n = n >> 1;\\n        }\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888853,
                "title": "c-simplest-solution-using-bit-manipulation",
                "content": "# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n\\n        int ans = 0;\\n        int cnt = 0;\\n        int flag = 0;\\n\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                if(flag == 1) {\\n                    cnt++;\\n                }\\n            }\\n            else {\\n                if(flag == 0) \\n                    flag = 1;\\n                else {\\n                    ans = max(cnt+1, ans);\\n                    cnt = 0;\\n                }\\n            }\\n            n = n/2;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n\\n        int ans = 0;\\n        int cnt = 0;\\n        int flag = 0;\\n\\n        while(n > 0) {\\n            if(n % 2 == 0) {\\n                if(flag == 1) {\\n                    cnt++;\\n                }\\n            }\\n            else {\\n                if(flag == 0) \\n                    flag = 1;\\n                else {\\n                    ans = max(cnt+1, ans);\\n                    cnt = 0;\\n                }\\n            }\\n            n = n/2;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855124,
                "title": "strictly-bit-manipulation-beats-100-explained-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBroke the problem down into steps:\\n\\n1. Iterate through each bit of the number\\n2. Count the number of zeroes between each pair of ones\\n3. return the greatest \\'gap\\'.\\n\\n---\\nThe following code iterates through the each bit from right to left:\\n```\\nwhile(n != 0){\\n    int a = n & 1; // retrieves the rightmost bit.\\n    n >>= 1; // performs a logical bitewise shift right.\\n}\\n```\\nThis boolean variable ensures that the counter \"runningCount\" does not begin counting the zeroes until the first \"1\" is encountered:\\n```\\nboolean first = true;\\n```\\nWhen a second \"1\" bit is encountered, a check is made to see if the \"runningCount\" is greater than the recorded \"max\" count and \"max\" is updated accordingly.\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\n        int max = 0;\\n        int runningCount = 0;\\n        boolean first = true;\\n\\n        if(Integer.bitCount(n) == 1){\\n            return 0;\\n        }\\n\\n        while(n != 0){\\n            int a = n & 1;\\n            n>>=1;\\n            if(a == 1){\\n                if(runningCount > max){\\n                    max = runningCount;\\n                }\\n                runningCount = 1;\\n                first = false;\\n            }\\n            else if(first == false){\\n                runningCount++; \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nwhile(n != 0){\\n    int a = n & 1; // retrieves the rightmost bit.\\n    n >>= 1; // performs a logical bitewise shift right.\\n}\\n```\n```\\nboolean first = true;\\n```\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n\\n        int max = 0;\\n        int runningCount = 0;\\n        boolean first = true;\\n\\n        if(Integer.bitCount(n) == 1){\\n            return 0;\\n        }\\n\\n        while(n != 0){\\n            int a = n & 1;\\n            n>>=1;\\n            if(a == 1){\\n                if(runningCount > max){\\n                    max = runningCount;\\n                }\\n                runningCount = 1;\\n                first = false;\\n            }\\n            else if(first == false){\\n                runningCount++; \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847840,
                "title": "go-bits-shift",
                "content": "```\\nfunc binaryGap(n int) int {\\n    max := 0\\n\\n    for counter := 0 ;n > 0; n >>= 1 {\\n        if n & 1 == 0 {\\n            if counter > 0 {\\n                counter++\\n            }\\n            continue\\n        }\\n        \\n        if max < counter {\\n            max = counter\\n        }\\n        \\n        counter = 1\\n    }\\n\\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc binaryGap(n int) int {\\n    max := 0\\n\\n    for counter := 0 ;n > 0; n >>= 1 {\\n        if n & 1 == 0 {\\n            if counter > 0 {\\n                counter++\\n            }\\n            continue\\n        }\\n        \\n        if max < counter {\\n            max = counter\\n        }\\n        \\n        counter = 1\\n    }\\n\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833523,
                "title": "explained-js-ts-solution",
                "content": "# Intuition\\nThe intuition behind this solution is to convert the given positive integer n to its binary representation as a string and then traverse the binary string to find the longest distance between any two adjacent 1\\'s. We keep track of the count of consecutive zeros after each \\'1\\', and whenever we encounter a \\'1\\', we update the maximum distance found so far.\\n\\n# Approach\\n1) Convert n to its binary representation as a string using toString(2).\\n\\n2) Initialize variables isOpen as false (to keep track of whether we have encountered a \\'1\\' yet), count to 0 (to track the number of consecutive zeros after each \\'1\\'), and max to 0 (to store the maximum distance found).\\n\\n3) Traverse the binary string character by character using a for-loop.\\n\\n4) When we encounter a \\'0\\' and isOpen is true (indicating we have seen a \\'1\\' already), increment the count.\\n\\n5) When we encounter a \\'1\\' and isOpen is true, update the max distance by taking the maximum of the current count + 1 and the existing max, and reset the count to 0.\\n\\n6) If we encounter a \\'1\\' and isOpen is false, set isOpen to true.\\n\\n7) After the loop, return the max, which represents the longest distance between any two adjacent 1\\'s in the binary representation of n.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is dominated by the conversion of n to its binary representation, which takes O(log n) time.\\nThe subsequent loop to traverse the binary string takes linear time, but its complexity is bounded by O(log n) since the binary representation of n has O(log n) digits.\\n\\n- Space complexity:\\nThe space complexity is mainly determined by the binary string representation of n, which has O(log n) bits in the worst case.\\n\\n# Code\\n```\\nfunction binaryGap(n: number): number {\\n    let chars = n.toString(2)\\n    let isOpen = false\\n    let count = 0\\n    let max = count\\n    for (let char of chars) {\\n        if (char === \\'0\\' && isOpen) {\\n            count++\\n        }\\n        if (char === \\'1\\' && isOpen) {\\n            max = Math.max(count + 1, max)\\n            count = 0\\n        } else {\\n            isOpen = true\\n        }\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction binaryGap(n: number): number {\\n    let chars = n.toString(2)\\n    let isOpen = false\\n    let count = 0\\n    let max = count\\n    for (let char of chars) {\\n        if (char === \\'0\\' && isOpen) {\\n            count++\\n        }\\n        if (char === \\'1\\' && isOpen) {\\n            max = Math.max(count + 1, max)\\n            count = 0\\n        } else {\\n            isOpen = true\\n        }\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806424,
                "title": "fast-solution-on-bit-operations-runtime-96-62",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        while n%2 == 0:\\n            n //= 2\\n        if n == 1:\\n            return 0\\n        count = 1\\n        while n&(n+1) != 0:\\n            n = n|(n>>1)\\n            count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        while n%2 == 0:\\n            n //= 2\\n        if n == 1:\\n            return 0\\n        count = 1\\n        while n&(n+1) != 0:\\n            n = n|(n>>1)\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801920,
                "title": "java-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to find the farthest adjacent 1\\'s, we actually need the longest sequence of 0\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can start by getting rid of the trailing 0\\'s in the binary string representation of the number and then finding the longest sequence of 0\\'s.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int i = 0, j = s.length() - 1, cnt = 0, maxCnt = Integer.MIN_VALUE;\\n        while (s.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (s.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        while (i < j) {\\n            char c = s.charAt(i);\\n            if (c == \\'1\\') {\\n                cnt = 0;\\n            } else if (c == \\'0\\') {\\n                cnt++;\\n            }\\n            maxCnt = Math.max(maxCnt, cnt);\\n            i++;\\n        }\\n        return (Math.abs(maxCnt - s.length()) <= 1 || \\n        maxCnt == Integer.MIN_VALUE) ? 0 : maxCnt + 1;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int i = 0, j = s.length() - 1, cnt = 0, maxCnt = Integer.MIN_VALUE;\\n        while (s.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (s.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        while (i < j) {\\n            char c = s.charAt(i);\\n            if (c == \\'1\\') {\\n                cnt = 0;\\n            } else if (c == \\'0\\') {\\n                cnt++;\\n            }\\n            maxCnt = Math.max(maxCnt, cnt);\\n            i++;\\n        }\\n        return (Math.abs(maxCnt - s.length()) <= 1 || \\n        maxCnt == Integer.MIN_VALUE) ? 0 : maxCnt + 1;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801129,
                "title": "java-bit-manipulation-0ms-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr_dis=0;\\n        int max_dis=0;\\n        while(n!=0){\\n            if((n&1)==1)break;\\n            n >>= 1;\\n        }\\n        n >>= 1;\\n        while(n!=0)\\n        {\\n            curr_dis++;\\n            if( (n&1) == 1)\\n            {\\n                max_dis=Math.max(max_dis,curr_dis);\\n                curr_dis=0;\\n            }\\n            n >>= 1;\\n        }\\n        return max_dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int curr_dis=0;\\n        int max_dis=0;\\n        while(n!=0){\\n            if((n&1)==1)break;\\n            n >>= 1;\\n        }\\n        n >>= 1;\\n        while(n!=0)\\n        {\\n            curr_dis++;\\n            if( (n&1) == 1)\\n            {\\n                max_dis=Math.max(max_dis,curr_dis);\\n                curr_dis=0;\\n            }\\n            n >>= 1;\\n        }\\n        return max_dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784102,
                "title": "convert-to-string-first-then-get-a-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let s = format!(\"{:b}\", n);\\n        let s = s\\n            .char_indices()\\n            .filter(|n| n.1 == \\'1\\')\\n            .collect::<Vec<(_, _)>>();\\n\\n        s.windows(2).map(|n| n[1].0 - n[0].0).max().unwrap_or(0) as i32\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn binary_gap(n: i32) -> i32 {\\n        let s = format!(\"{:b}\", n);\\n        let s = s\\n            .char_indices()\\n            .filter(|n| n.1 == \\'1\\')\\n            .collect::<Vec<(_, _)>>();\\n\\n        s.windows(2).map(|n| n[1].0 - n[0].0).max().unwrap_or(0) as i32\\n    \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753700,
                "title": "using-math-max-and-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BinaryGap(int n) \\n    {\\n        string s = Convert.ToString(n,2);\\n\\n        int max = 0;\\n        int startPoint = 0;\\n        int endPoint = 0;\\n        for(int i = 0 ; i < s.Length ;)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                startPoint=1;\\n            }\\n            i++;\\n            while(i < s.Length && s[i] != \\'1\\' && startPoint == 1)\\n            {\\n                endPoint++;\\n                i++;\\n            }            \\n            if(i < s.Length && s[i] == \\'1\\' && startPoint == 1)\\n            {\\n                    max = Math.Max(max, endPoint+startPoint);\\n                    endPoint = 0;\\n            }\\n        }\\n\\n        return max;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BinaryGap(int n) \\n    {\\n        string s = Convert.ToString(n,2);\\n\\n        int max = 0;\\n        int startPoint = 0;\\n        int endPoint = 0;\\n        for(int i = 0 ; i < s.Length ;)\\n        {\\n            if(s[i] == \\'1\\')\\n            {\\n                startPoint=1;\\n            }\\n            i++;\\n            while(i < s.Length && s[i] != \\'1\\' && startPoint == 1)\\n            {\\n                endPoint++;\\n                i++;\\n            }            \\n            if(i < s.Length && s[i] == \\'1\\' && startPoint == 1)\\n            {\\n                    max = Math.Max(max, endPoint+startPoint);\\n                    endPoint = 0;\\n            }\\n        }\\n\\n        return max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738607,
                "title": "easy-to-understand-java-beginner-s-need",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int[] binary =new int[50];\\n        int i=0,max=0,start=0,length=0;\\n        while(n>0)\\n        {\\n            binary[i++]= n%2;\\n            n/=2;\\n            if(binary[i-1]==1)\\n            start=i-1;\\n        }\\nstart=i-start-1;//0\\n        for(int j=i-1;j>=0;j--)\\n        {\\n            \\n            if(binary[j]==1)\\n            {\\n                \\n                length=(i-1-j)-start;\\n                start=i-1-j;\\n                if(length>max)\\n                {\\n                    System.out.println(length);\\n                max=length;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int[] binary =new int[50];\\n        int i=0,max=0,start=0,length=0;\\n        while(n>0)\\n        {\\n            binary[i++]= n%2;\\n            n/=2;\\n            if(binary[i-1]==1)\\n            start=i-1;\\n        }\\nstart=i-start-1;//0\\n        for(int j=i-1;j>=0;j--)\\n        {\\n            \\n            if(binary[j]==1)\\n            {\\n                \\n                length=(i-1-j)-start;\\n                start=i-1-j;\\n                if(length>max)\\n                {\\n                    System.out.println(length);\\n                max=length;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735371,
                "title": "100-beats-eaisest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int maxi=0;\\n        int start=n&1;\\n        int prev=n&1;\\n        int cnt=0;\\n        int temp=n;\\n        n=n>>1;\\n        while(n>0)\\n        {\\n            if(prev==0 && start==1)\\n            { \\n                cnt++;\\n                maxi=max(maxi,cnt);\\n            }\\n            else\\n            {\\n                cnt=0;\\n                start=prev;\\n            }\\n            prev=n&1;\\n            n=n>>1;\\n        }\\n        if(maxi!=0)\\n        return maxi+1;\\n        else if(start==1 && temp!=1) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int maxi=0;\\n        int start=n&1;\\n        int prev=n&1;\\n        int cnt=0;\\n        int temp=n;\\n        n=n>>1;\\n        while(n>0)\\n        {\\n            if(prev==0 && start==1)\\n            { \\n                cnt++;\\n                maxi=max(maxi,cnt);\\n            }\\n            else\\n            {\\n                cnt=0;\\n                start=prev;\\n            }\\n            prev=n&1;\\n            n=n>>1;\\n        }\\n        if(maxi!=0)\\n        return maxi+1;\\n        else if(start==1 && temp!=1) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729550,
                "title": "easy-solution-in-ts",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction binaryGap(n: number): number {\\n    const binary = (n >>> 0).toString(2);\\n    let first = -1;\\n    let second = -1;\\n    let dist = 0;\\n\\n    for(let i = 0 ; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(first < 0) first = i;\\n            else second = i;\\n        }\\n\\n        if(first >= 0 && second >= 0){\\n            const auxDist = second - first;\\n            if(auxDist > dist) {\\n                dist = auxDist;\\n            }\\n            first = second;\\n            second = undefined;\\n        }\\n    }\\n\\n    return dist;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "String"
                ],
                "code": "```\\nfunction binaryGap(n: number): number {\\n    const binary = (n >>> 0).toString(2);\\n    let first = -1;\\n    let second = -1;\\n    let dist = 0;\\n\\n    for(let i = 0 ; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(first < 0) first = i;\\n            else second = i;\\n        }\\n\\n        if(first >= 0 && second >= 0){\\n            const auxDist = second - first;\\n            if(auxDist > dist) {\\n                dist = auxDist;\\n            }\\n            first = second;\\n            second = undefined;\\n        }\\n    }\\n\\n    return dist;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728531,
                "title": "aniruddha-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int nm = n;\\n        int cnt = 0;\\n        int cnt1 = 0;\\n        int mx = 0;\\n        bool f = false;\\n        while(nm){\\n            if(nm & 1){\\n                f = true;\\n                cnt1++;\\n                if(mx < cnt ){\\n                    mx = cnt;\\n                }\\n                cnt = 0;\\n            }else if(f){\\n                cnt++;\\n            }\\n            nm = nm >> 1;   \\n\\n        }\\n        int ans = 0;\\n        if(mx>0 ){\\n            ans = mx + 1;\\n        }else if(cnt1 > 1){\\n            ans = 1;\\n        }else{\\n            ans = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int nm = n;\\n        int cnt = 0;\\n        int cnt1 = 0;\\n        int mx = 0;\\n        bool f = false;\\n        while(nm){\\n            if(nm & 1){\\n                f = true;\\n                cnt1++;\\n                if(mx < cnt ){\\n                    mx = cnt;\\n                }\\n                cnt = 0;\\n            }else if(f){\\n                cnt++;\\n            }\\n            nm = nm >> 1;   \\n\\n        }\\n        int ans = 0;\\n        if(mx>0 ){\\n            ans = mx + 1;\\n        }else if(cnt1 > 1){\\n            ans = 1;\\n        }else{\\n            ans = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724037,
                "title": "nothing-special",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        n = bin(n) # to binary\\n        n = n.replace(\\'0b\\', \\'\\')\\n        print(n)\\n        if n.count(\\'1\\') == 1:\\n            return 0\\n        x = 0\\n        y = 0\\n        count_on = 0\\n        for i in range(0,len(n)):\\n            if n[i] == \\'1\\' and count_on == 0:\\n                count_on = 1\\n            if n[i] == \\'1\\' and count_on == 1:\\n                y = max(x,y)\\n                x = 0\\n            if n[i] == \\'0\\' and count_on == 1:\\n                x += 1\\n        return y+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        n = bin(n) # to binary\\n        n = n.replace(\\'0b\\', \\'\\')\\n        print(n)\\n        if n.count(\\'1\\') == 1:\\n            return 0\\n        x = 0\\n        y = 0\\n        count_on = 0\\n        for i in range(0,len(n)):\\n            if n[i] == \\'1\\' and count_on == 0:\\n                count_on = 1\\n            if n[i] == \\'1\\' and count_on == 1:\\n                y = max(x,y)\\n                x = 0\\n            if n[i] == \\'0\\' and count_on == 1:\\n                x += 1\\n        return y+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721068,
                "title": "c-one-pass-beats-100-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis = 0, prev = -1;\\n        for(int i=0;i<31;i++)\\n        {\\n            int curr = n&(1<<i);\\n            if(curr!=0)\\n            {\\n                if(prev!=-1)\\n                    dis = max(dis, i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int dis = 0, prev = -1;\\n        for(int i=0;i<31;i++)\\n        {\\n            int curr = n&(1<<i);\\n            if(curr!=0)\\n            {\\n                if(prev!=-1)\\n                    dis = max(dis, i-prev);\\n                prev = i;\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716617,
                "title": "straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n    let firstIndexOf1 = undefined\\n    let secondIndexOf1 = undefined\\n    let longestDis = 0\\n    let binary = \\'\\'\\n    let newNum = n\\n    while (newNum > 0) {\\n        newNum = newNum / 2\\n        let isInt = Number(newNum) === newNum && newNum % 1 === 0;\\n        if(!isInt) {\\n        newNum = newNum.toString().substring(0, newNum.toString().indexOf(\".\"));\\n        }\\n        binary += isInt ? \\'0\\' : \\'1\\'\\n    }\\n    for (let i = 0; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(firstIndexOf1 || firstIndexOf1 === 0) {\\n                secondIndexOf1 = i\\n            } else {\\n                firstIndexOf1 = i\\n            }\\n        } \\n        if (secondIndexOf1 && (firstIndexOf1 || firstIndexOf1 === 0)) {\\n        let dis = secondIndexOf1 - firstIndexOf1\\n        longestDis = dis > longestDis ? dis : longestDis\\n        firstIndexOf1 = secondIndexOf1\\n        secondIndexOf1 = undefined\\n        }\\n    }\\n\\n    return longestDis\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n    let firstIndexOf1 = undefined\\n    let secondIndexOf1 = undefined\\n    let longestDis = 0\\n    let binary = \\'\\'\\n    let newNum = n\\n    while (newNum > 0) {\\n        newNum = newNum / 2\\n        let isInt = Number(newNum) === newNum && newNum % 1 === 0;\\n        if(!isInt) {\\n        newNum = newNum.toString().substring(0, newNum.toString().indexOf(\".\"));\\n        }\\n        binary += isInt ? \\'0\\' : \\'1\\'\\n    }\\n    for (let i = 0; i < binary.length; i++) {\\n        if(binary[i] === \\'1\\') {\\n            if(firstIndexOf1 || firstIndexOf1 === 0) {\\n                secondIndexOf1 = i\\n            } else {\\n                firstIndexOf1 = i\\n            }\\n        } \\n        if (secondIndexOf1 && (firstIndexOf1 || firstIndexOf1 === 0)) {\\n        let dis = secondIndexOf1 - firstIndexOf1\\n        longestDis = dis > longestDis ? dis : longestDis\\n        firstIndexOf1 = secondIndexOf1\\n        secondIndexOf1 = undefined\\n        }\\n    }\\n\\n    return longestDis\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3714117,
                "title": "java-solution-with-detailed-explanation-beats-100",
                "content": "# Approach\\nHere, we need to track when we get the first 1 of the pair (if there is any) and the last 1 of the pair (the last 1 would be the first 1 of the next pair if there is any, and so on). Also, we need to count the in-between 0s of the pair.\\nTo do so, we will initialize two variables that will track the current (say, `currGap`) and maximum (say, `largestGap`) gaps between the pairs. Both will be initialized as 0, which will indicate that no pairs of 1 are still found. Then, we will run a loop that will run until the number becomes 0 (we will right shift the number to 1 position on each iteration).\\nIf we find a 1, that means it could be the start of a new pair (if there is any) or the end of an existing pair (also the start of a new pair if there is any). In both cases, we need to update the `currGap` to 1 (which will indicate that the start of a pair is found). And, if it\\'s the end of the existing pair, we need to update the `largestGap`, if applicable.\\nOn the other hand, if we encounter a 0 and the `currGap` is not 0, it means that the 0 resides in-between the pair (if there is any) of 1s. In this case, we need to increment the `currGap` by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n  public int binaryGap(int n) {\\n    int currGap = 0;\\n    int largestGap = 0;\\n    while (n != 0) {\\n      if ((n & 1) == 1) {\\n        if (currGap != 0) { // Last 1 of the pair and the beginning of a new pair\\n          largestGap = currGap > largestGap ? currGap : largestGap;\\n        }\\n        currGap = 1; // First 1 of the pair \\n      } else if (currGap != 0) {\\n        currGap += 1;\\n      }\\n      n >>= 1;\\n    }\\n    return largestGap;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int binaryGap(int n) {\\n    int currGap = 0;\\n    int largestGap = 0;\\n    while (n != 0) {\\n      if ((n & 1) == 1) {\\n        if (currGap != 0) { // Last 1 of the pair and the beginning of a new pair\\n          largestGap = currGap > largestGap ? currGap : largestGap;\\n        }\\n        currGap = 1; // First 1 of the pair \\n      } else if (currGap != 0) {\\n        currGap += 1;\\n      }\\n      n >>= 1;\\n    }\\n    return largestGap;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713538,
                "title": "easy-sol-100-faster-95-in-space-bitwise-left-shift-c",
                "content": "# Complexity\\n- Time complexity:\\nO(N) where N is number of bits.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int arr[2]={-1,-1};\\n        long long a=1,i=0;\\n        int ans=INT_MIN;\\n\\n        while(i<32)\\n        {\\n            if(n&a)\\n            {\\n                arr[0]=arr[1];\\n                arr[1]=i;\\n\\n                if(arr[0]!=-1 && arr[1]!=-1)\\n                {\\n                    ans=max(ans,arr[1]-arr[0]);\\n                }\\n            }\\n            a=a<<1;\\n            i++;\\n        }\\n        if(arr[0]==-1 || arr[1]==-1)\\n            return 0;\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryGap(int n) {\\n        int arr[2]={-1,-1};\\n        long long a=1,i=0;\\n        int ans=INT_MIN;\\n\\n        while(i<32)\\n        {\\n            if(n&a)\\n            {\\n                arr[0]=arr[1];\\n                arr[1]=i;\\n\\n                if(arr[0]!=-1 && arr[1]!=-1)\\n                {\\n                    ans=max(ans,arr[1]-arr[0]);\\n                }\\n            }\\n            a=a<<1;\\n            i++;\\n        }\\n        if(arr[0]==-1 || arr[1]==-1)\\n            return 0;\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710994,
                "title": "868-binary-gap-100-beats-than-all-java-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition for finding the longest distance between adjacent 1\\'s in the binary representation of a positive integer:\\n\\n**-** Initialize variables: Set the longest distance and the current distance between adjacent 1\\'s to 0. Also, set a flag to keep track of the existence of the first 1 bit.\\n\\n**-** Iterate through the binary representation: Start from the least significant bit and move towards the most significant bit.\\n\\n**-** Handling 0 bits: If a 0 bit is encountered, shift the bits to the right. If the first 1 bit has been found (flag is true), increment the current distance between adjacent 1\\'s.\\n\\n**-** Handling 1 bits: If a 1 bit is encountered, update the longest distance with the maximum value between the current distance and the longest distance found so far. Set the first 1 bit flag to true and reset the current distance to 0.\\n\\n**-** Continue iteration: Repeat steps 3 and 4 until all bits have been processed.\\n\\n**-** Return the longest distance: After iterating through all bits, return the longest distance as the result.\\n\\nThe intuition behind this approach is to identify consecutive 1 bits and calculate the distance between them. By using bitwise operations and maintaining appropriate variables, the code tracks the longest distance between adjacent 1\\'s. It handles the case when there are no adjacent 1\\'s by returning 0.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a bitwise operation to calculate the binary gap of a given integer. It iterates over the binary representation of the number, keeping track of the longest distance between consecutive 1 bits. It uses a distance variable to keep track of the current distance between 1 bits and updates the longestDistance variable whenever a new longest distance is found. The code also uses a **firstOneBitExist boolean flag to handle the case when the first 1 bit is encountered**. Overall, the approach is to shift the bits to the right and perform bitwise operations to identify the binary gap.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates over the bits of the given integer, which takes O(log n) time, where n is the value of the integer.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of extra space, so the space complexity is O(1).\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int longestDistance = 0, distance = 0;\\n        boolean firstOneBitExist = false;\\n        while(n != 0){\\n            if((n & 1) == 0){\\n                n >>= 1;\\n                if(firstOneBitExist)\\n                    distance++;\\n            } else {\\n                if(firstOneBitExist)\\n                    distance++;\\n                longestDistance = Math.max(distance, longestDistance);\\n                firstOneBitExist = true;\\n                distance = 0;\\n                n >>= 1;\\n            }\\n        }\\n        return longestDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int longestDistance = 0, distance = 0;\\n        boolean firstOneBitExist = false;\\n        while(n != 0){\\n            if((n & 1) == 0){\\n                n >>= 1;\\n                if(firstOneBitExist)\\n                    distance++;\\n            } else {\\n                if(firstOneBitExist)\\n                    distance++;\\n                longestDistance = Math.max(distance, longestDistance);\\n                firstOneBitExist = true;\\n                distance = 0;\\n                n >>= 1;\\n            }\\n        }\\n        return longestDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705608,
                "title": "beats-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int dis=0, i=0,j=0;\\n        while(n>0){\\n            if((n&1)!=0){\\n                if(j==0){\\n                    j=1;\\n                    // i++;\\n                }\\n                else{\\n                    // j=0;\\n                    if(dis<i){\\n                        dis=i;\\n                        // i=0;\\n                    }\\n                    i=0;\\n                }\\n                // i++;\\n                \\n            }\\n            if(j==1){\\n                i++;\\n            }\\n            n=n>>1;\\n        }\\n        return dis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int dis=0, i=0,j=0;\\n        while(n>0){\\n            if((n&1)!=0){\\n                if(j==0){\\n                    j=1;\\n                    // i++;\\n                }\\n                else{\\n                    // j=0;\\n                    if(dis<i){\\n                        dis=i;\\n                        // i=0;\\n                    }\\n                    i=0;\\n                }\\n                // i++;\\n                \\n            }\\n            if(j==1){\\n                i++;\\n            }\\n            n=n>>1;\\n        }\\n        return dis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697621,
                "title": "fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int binaryGap(int n) \\n    {\\n        int i=0;\\n        int li=-1;\\n        int ans = 0;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            {\\n                if(li==-1)\\n                {\\n                    li=i;\\n                }\\n                else\\n                {\\n                    ans = max(i-li, ans);\\n                    li=i;\\n                }            \\n            }\\n            n/=2;\\n            i++;\\n        }\\n        \\n\\n        // std::cout<<;        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int binaryGap(int n) \\n    {\\n        int i=0;\\n        int li=-1;\\n        int ans = 0;\\n        while(n>0)\\n        {\\n            if(n%2)\\n            {\\n                if(li==-1)\\n                {\\n                    li=i;\\n                }\\n                else\\n                {\\n                    ans = max(i-li, ans);\\n                    li=i;\\n                }            \\n            }\\n            n/=2;\\n            i++;\\n        }\\n        \\n\\n        // std::cout<<;        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3687494,
                "title": "100-100-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int max = 0;\\n        int k = -1;\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            if((n&1) == 1)\\n            {\\n               if(k != -1)\\n               {\\n                    max = Math.max(max,i-k);\\n               }\\n                k = i;\\n            }\\n            i++;\\n            n>>=1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int max = 0;\\n        int k = -1;\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            if((n&1) == 1)\\n            {\\n               if(k != -1)\\n               {\\n                    max = Math.max(max,i-k);\\n               }\\n                k = i;\\n            }\\n            i++;\\n            n>>=1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675230,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        l = list(bin(n)[2:])\\n        lg=[]\\n        while \"1\" in l:\\n            indice = l.index(\"1\")\\n            lg.append(indice)\\n            l[indice]=\"0\"\\n        maximo=0\\n        for i in range(1,len(lg)):\\n            var=lg[i]-lg[i-1]\\n            if maximo<var:\\n                maximo=var\\n        return maximo\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n\\n        l = list(bin(n)[2:])\\n        lg=[]\\n        while \"1\" in l:\\n            indice = l.index(\"1\")\\n            lg.append(indice)\\n            l[indice]=\"0\"\\n        maximo=0\\n        for i in range(1,len(lg)):\\n            var=lg[i]-lg[i-1]\\n            if maximo<var:\\n                maximo=var\\n        return maximo\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669421,
                "title": "javascript-bit-manipulation",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n\\n    let prevIndex = -1;\\n    let diff = 0;\\n    \\n    let index = 0;\\n    while(n > 0) {\\n        const bit = n & 1;\\n        if(bit === 1) {\\n            if(prevIndex === -1) {\\n                prevIndex = index; \\n            }\\n            else{\\n                diff = Math.max(diff, index - prevIndex);\\n                prevIndex = index;\\n            }\\n        }\\n\\n        n >>= 1;\\n        index++;\\n    }\\n\\n    return diff;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar binaryGap = function(n) {\\n\\n    let prevIndex = -1;\\n    let diff = 0;\\n    \\n    let index = 0;\\n    while(n > 0) {\\n        const bit = n & 1;\\n        if(bit === 1) {\\n            if(prevIndex === -1) {\\n                prevIndex = index; \\n            }\\n            else{\\n                diff = Math.max(diff, index - prevIndex);\\n                prevIndex = index;\\n            }\\n        }\\n\\n        n >>= 1;\\n        index++;\\n    }\\n\\n    return diff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3644406,
                "title": "easy-to-understand-beats-100-0ms-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int last = -1 , MaxGap = 0;\\n\\n        for(int i =0 ; i<32 ; i++){\\n            if((n&1) !=0){\\n                if(last==-1){\\n                    last=i;\\n                }else{\\n                    MaxGap=Math.max(MaxGap,i-last);\\n                    last=i;\\n                }\\n            }\\n            n>>=1;\\n        }\\n        return MaxGap; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int last = -1 , MaxGap = 0;\\n\\n        for(int i =0 ; i<32 ; i++){\\n            if((n&1) !=0){\\n                if(last==-1){\\n                    last=i;\\n                }else{\\n                    MaxGap=Math.max(MaxGap,i-last);\\n                    last=i;\\n                }\\n            }\\n            n>>=1;\\n        }\\n        return MaxGap; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636123,
                "title": "bitwise-operation-play-with-bits",
                "content": "# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans = 0;\\n        int cur = 0;\\n        while( n > 0 ){\\n            int lsb = (n&1);\\n            if( lsb == 1 && cur == 0 ) cur++;\\n            else if( lsb == 1 && cur != 0 ) {\\n                ans = Math.max( ans , cur );\\n                cur = 1;\\n            }\\n            else if( cur != 0 ) cur++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n        int ans = 0;\\n        int cur = 0;\\n        while( n > 0 ){\\n            int lsb = (n&1);\\n            if( lsb == 1 && cur == 0 ) cur++;\\n            else if( lsb == 1 && cur != 0 ) {\\n                ans = Math.max( ans , cur );\\n                cur = 1;\\n            }\\n            else if( cur != 0 ) cur++;\\n            n = n >> 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623422,
                "title": "doing-it-in-a-normal-way-thinking",
                "content": "# Intuition\\nThis is probably the first idea that comes to mind.\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(n) + O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun binaryGap(n: Int): Int {\\n      val binaryString = Integer.toBinaryString(n)\\n        var max = 0\\n        var count = 0\\n        for (i in binaryString.indices) {\\n            if (binaryString[i] == \\'1\\') {\\n                if (count > max) max = count\\n                count = 1\\n            } else {\\n                count++\\n            }\\n        }\\n        return max  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun binaryGap(n: Int): Int {\\n      val binaryString = Integer.toBinaryString(n)\\n        var max = 0\\n        var count = 0\\n        for (i in binaryString.indices) {\\n            if (binaryString[i] == \\'1\\') {\\n                if (count > max) max = count\\n                count = 1\\n            } else {\\n                count++\\n            }\\n        }\\n        return max  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617317,
                "title": "easy-solution-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint binaryGap(int n){\\n    int max = 0 , cnt = 0, flag = 0;\\n    while ( n > 0){\\n        if ( ( n & 1) == 1 ){\\n            if ( flag == 1 ){\\n                if ( max < cnt){\\n                    max  = cnt;\\n                }\\n                cnt = 1;\\n            } else {\\n                flag = 1;\\n                cnt = 1;\\n            }\\n            n >>= 1;\\n        } else {\\n            cnt++;\\n            n >>= 1;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint binaryGap(int n){\\n    int max = 0 , cnt = 0, flag = 0;\\n    while ( n > 0){\\n        if ( ( n & 1) == 1 ){\\n            if ( flag == 1 ){\\n                if ( max < cnt){\\n                    max  = cnt;\\n                }\\n                cnt = 1;\\n            } else {\\n                flag = 1;\\n                cnt = 1;\\n            }\\n            n >>= 1;\\n        } else {\\n            cnt++;\\n            n >>= 1;\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605910,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->so the approach is i take an pointer start which is the first bit and take another pointer end if character at start is equal to character at end then start pointer is equal to end pointer and the end will be incremented \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binaryGap(int n) {\\n         String s = Integer.toBinaryString(n);\\n          int ans = 0;\\n          int temp =0;\\n          //so first I took an initial pointer start that is equal to first index that is always one//\\n        int start = 0;\\n        //then I will take another pointer that will point to the one //\\n        int end  = start+1;\\n\\n        while(end<s.length()){\\n              if(s.charAt(start)!=s.charAt(end))\\n              {\\n                  end=end+1;\\n              }else{\\n                  temp = end-start;\\n                  start = end ;\\n                  end = end +1;\\n                  ans = Math.max(ans,temp);\\n              }\\n            }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int binaryGap(int n) {\\n         String s = Integer.toBinaryString(n);\\n          int ans = 0;\\n          int temp =0;\\n          //so first I took an initial pointer start that is equal to first index that is always one//\\n        int start = 0;\\n        //then I will take another pointer that will point to the one //\\n        int end  = start+1;\\n\\n        while(end<s.length()){\\n              if(s.charAt(start)!=s.charAt(end))\\n              {\\n                  end=end+1;\\n              }else{\\n                  temp = end-start;\\n                  start = end ;\\n                  end = end +1;\\n                  ans = Math.max(ans,temp);\\n              }\\n            }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565853,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1859732,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1633657,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1685912,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1573579,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 2058642,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            },
            {
                "id": 1945810,
                "content": [
                    {
                        "username": "1creation",
                        "content": "distance between \\'1\\' and \\'1\\'\\nlet`s check all distances in binary representation\\n10010001101\\n\\t1. first distance 1001 (from 0 to 3 index) -> distance 3\\n2.10001 (from 3 to 7) -> distance 4\\n3.11 (from 7 to 8) -> distance 1\\n4.101 (from 8 to 10) -> distance 2"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Why does this problem has so many dislikes? Think it is a good problem."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The solution is wrong:\\n\\ncheck out 1041 as a test case. The solution in the editorial returns 6, but the answer should be 5"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "so why is the  test case of n=6\\nhave expected output of 1 when 6 ie. 0110, has two adjacent st bits with no 0s in between?\\ndoesnt the prob description say that return result should be 0 if thats\\'s the case?\\nany help?"
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "The problem description says return 0 if there are no adjacent 1 bits . For n = 6(0110) there are two adjacent 1 bits which are at a distance of 1 apart."
                    },
                    {
                        "username": "mo7",
                        "content": "Xodility also have a question like this with different define of the distance."
                    },
                    {
                        "username": "saiful007",
                        "content": "I am struggling with the problem desciption can anyone help me with that?"
                    },
                    {
                        "username": "Adiyadav23",
                        "content": "The question is asking for absolute difference between the indices of 1's, not the number of 0's between them.\nEg: '11' = 1, not 0."
                    },
                    {
                        "username": "ajbeach2",
                        "content": "The editorial solution is wrong for 1041\\n\\n10000010001 is 1041 in binary.\\n\\nThe solution should be 5, but the editorial solution, 6 is returned. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Reordered Power of 2",
        "question_content": "<p>You are given an integer <code>n</code>. We reorder the digits in any order (including the original order) such that the leading digit is not zero.</p>\n\n<p>Return <code>true</code> <em>if and only if we can do this so that the resulting number is a power of two</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 149843,
                "title": "c-java-python-straight-forward",
                "content": "`counter` will counter the number of digits 9876543210 in the given number.\\nThen I just compare `counter(N)` with all `counter(power of 2)`.\\n`1 <= N <= 10^9`, so up to 8 same digits.\\nIf `N > 10^9`, we can use a hash map.\\n\\n**C++:**\\n```\\n    bool reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n\\n    long counter(int N) {\\n        long res = 0;\\n        for (; N; N /= 10) res += pow(10, N % 10);\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n    public long counter(int N) {\\n        long res = 0;\\n        for (; N > 0; N /= 10) res += (int)Math.pow(10, N % 10);\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def reorderedPowerOf2(self, N):\\n        c = collections.Counter(str(N))\\n        return any(c == collections.Counter(str(1 << i)) for i in xrange(30))\\n```\\n\\n\\n**Python 1-line**\\nsuggested by @urashima9616, bests 80%\\n```\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1 << i)) for i in range(30)]\\n```",
                "solutionTags": [],
                "code": "```\\n    bool reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n\\n    long counter(int N) {\\n        long res = 0;\\n        for (; N; N /= 10) res += pow(10, N % 10);\\n        return res;\\n    }\\n```\n```\\n    public boolean reorderedPowerOf2(int N) {\\n        long c = counter(N);\\n        for (int i = 0; i < 32; i++)\\n            if (counter(1 << i) == c) return true;\\n        return false;\\n    }\\n    public long counter(int N) {\\n        long res = 0;\\n        for (; N > 0; N /= 10) res += (int)Math.pow(10, N % 10);\\n        return res;\\n    }\\n```\n```\\n    def reorderedPowerOf2(self, N):\\n        c = collections.Counter(str(N))\\n        return any(c == collections.Counter(str(1 << i)) for i in xrange(30))\\n```\n```\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1 << i)) for i in range(30)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 151949,
                "title": "simple-java-solution-based-on-string-sorting",
                "content": "The idea here is similar to that of group Anagrams problem (Leetcode #49). \\n\\nFirst, we convert the input number (N) into a string and sort the string. Next, we get the digits that form the power of 2 (by using 1 << i and vary i), convert them into a string, and then sort them. As we convert the powers of 2 (and there are only 31 that are <= 10^9), for each power of 2, we compare if the string is equal to that of string based on N. If the two strings are equal, then we return true.\\n\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] a1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(a1);\\n        String s1 = new String(a1);\\n        \\n        for (int i = 0; i < 31; i++) {\\n            char[] a2 = String.valueOf((int)(1 << i)).toCharArray();\\n            Arrays.sort(a2);\\n            String s2 = new String(a2);\\n            if (s1.equals(s2)) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] a1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(a1);\\n        String s1 = new String(a1);\\n        \\n        for (int i = 0; i < 31; i++) {\\n            char[] a2 = String.valueOf((int)(1 << i)).toCharArray();\\n            Arrays.sort(a2);\\n            String s2 = new String(a2);\\n            if (s1.equals(s2)) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120153,
                "title": "c-super-simple-and-short-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string N_str = sorted_num(N);\\n        for (int i = 0; i < 32; i++)\\n            if (N_str == sorted_num(1 << i)) return true;\\n        return false;\\n    }\\n    \\n    string sorted_num(int n) {\\n        string res = to_string(n);\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string N_str = sorted_num(N);\\n        for (int i = 0; i < 32; i++)\\n            if (N_str == sorted_num(1 << i)) return true;\\n        return false;\\n    }\\n    \\n    string sorted_num(int n) {\\n        string res = to_string(n);\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480899,
                "title": "c-100-fast-0ms",
                "content": "```\\nbool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120106,
                "title": "js-python-java-c-easy-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest way to check if two things are shuffled versions of each other, which is what this problem is asking us to do, is to sort them both and the compare the result.\\n\\nIn that sense, the easiest solution here is to do exactly that: we can convert **N** to an array of its digits, sort it, then compare that result to the result of the same process on each power of **2**.\\n\\nSince the constraint upon **N** is **10e9**, we only need to check powers in the range **[0,29]**.\\n\\nTo make things easier to compare, we can always **join()** the resulting digit arrays into strings before comparison.\\n\\nThere are ways to very slightly improve the run time and memory here, but with an operation this small, it\\'s honestly not very necessary.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can directly compare the lists and Java can directly compare the char arrays without needing to join them into strings. C++ can sort the strings in-place without needing to convert to an array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.8MB** (beats 100% / 44).\\n```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 98% / 76%).\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 35.8MB** (beats 97% / 88%).\\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481219,
                "title": "quick-math",
                "content": "The main idea is what powers of 2 look like in binary form:\\n\\n<img width=\"200\" src=\"https://assets.leetcode.com/users/images/ae9964b4-ffbd-40a5-a934-e3dc1de49d28_1661482426.3498342.png\">\\n\\nthis will help easily iterate over all powers of two\\n\\nSo all we need is to convert n to sorted digits and then compare them with the sorted digits for each power of two.\\n`n <= 10e9`, we only need to check powers in the range `[0,29]`\\n\\na little explanation of how the shift operation `<< `works: \\n\\n<img src=\"https://assets.leetcode.com/users/images/df39060e-624d-4fb8-abe2-e3f1da6d0bf9_1661486107.3084147.png\">\\n\\n\\n##### Java\\n\\n```java\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = sortedDigits(1 << i);\\n            if (Arrays.equals(number, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private char[] sortedDigits(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n```\\n\\n##### C++\\n\\n```\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            string powerOfTwo = sortedDigits(1 << i);\\n            if (number == powerOfTwo)\\n                return true;\\n        }\\n\\n        return false;\\n    }\\n\\nprivate:\\n    string sortedDigits(int n) {\\n        string digits = to_string(n);\\n        sort(digits.begin(), digits.end());\\n        return digits;\\n    }\\n```\\n\\n##### Python\\n```python\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            powerOfTwo = str(1 << i)\\n            if digits == Counter(powerOfTwo):\\n                return True\\n        return False\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = sortedDigits(1 << i);\\n            if (Arrays.equals(number, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private char[] sortedDigits(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n```\n```\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string number = sortedDigits(n);\\n\\n        for (int i = 0; i < 30; ++i) {\\n            string powerOfTwo = sortedDigits(1 << i);\\n            if (number == powerOfTwo)\\n                return true;\\n        }\\n\\n        return false;\\n    }\\n\\nprivate:\\n    string sortedDigits(int n) {\\n        string digits = to_string(n);\\n        sort(digits.begin(), digits.end());\\n        return digits;\\n    }\\n```\n```python\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            powerOfTwo = str(1 << i)\\n            if digits == Counter(powerOfTwo):\\n                return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1120216,
                "title": "reordered-power-of-2-short-easy-w-explanation-beats-100",
                "content": "***Solution - I (Counting Digits Frequency)***\\n\\nA simple solution is to check if frequency of digits in N and all powers of 2 less than `10^9` are equal. In our case, we need to check for all powers of 2 from `2^0` to `2^29` and if any of them matches with digits in `N`, return true.\\n\\n```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\\n\\n**Time Complexity :** **`O(logn)`**, where `n` is maximum power of 2 for which digits are counted (2^30). More specifically the time complexity can be written as `O(logN + log2 + log4 + ... + log(2^30))` which after ignoring the constant factors and lower order terms comes out to `O(logn)`.\\n**Time Complexity :** **`O(1)`**. We are using vector to store digits of `N` and powers of 2 but they are taking constant space and don\\'t depend on the input `N`.\\n\\n---------\\n---------\\n\\n***Solution - II (Convert to string & sort)***\\n\\nWe can convert `N` to string, sort it and compare it with every power of 2 by converting and sorting that as well.\\n\\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n-------\\n\\nBoth solutions have the same run-time -\\n\\n![image](https://assets.leetcode.com/users/images/ec72eb4f-071d-4c4f-91b1-c6c098015f29_1616318669.6588662.png)\\n\\n-------\\n-------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481714,
                "title": "easy-java-solution-100-faster-1ms-with-basic-explanation",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\nbasically we are finding occurrence of each digit in n after that we are finding same occurrence of each digit of each power of 2 which is in range between (2^0 to 2^30) if any power of 2 matches same occurence than we can return true if none of the power of 2 matches with occurence of our number n we return false\\n\\n```\\npublic boolean reorderedPowerOf2(int n) {\\n        int Count[] = Count(n);\\n        int power = 1;\\n        for (int i = 0; i < 31; i++) {\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            power *= 2;\\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { // Counting Occurence of each digit\\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Counting"
                ],
                "code": "```\\npublic boolean reorderedPowerOf2(int n) {\\n        int Count[] = Count(n);\\n        int power = 1;\\n        for (int i = 0; i < 31; i++) {\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            power *= 2;\\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { // Counting Occurence of each digit\\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482894,
                "title": "python-easily-understood-faster-than-96-fast",
                "content": "**Appreciate if you could upvote this solution**\\n\\nSince the maximun of `n` is 10^9 and the `len(str(10**9))` is 10 which is complicated to get all the combinations of the digits.\\n\\nThus, we resolved this questions to:\\n**If the digit combination of n match the digit combinations of all the power of 2**\\n\\nThen, it is much more easier as we need to compare n with 30 numbers only which are\\n```\\n2^0\\n2^1\\n... \\n2^30\\n```\\n\\nFor the digit combinations, there are 2 methons to handle:\\n\\n1) Dict: Count the occurrences of all digits\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [Counter(str(1 << i)) for i in range(30)] \\n```\\n\\n2) String: Sort all the digits\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [sorted(str(1 << i)) for i in range(30)] \\n```\\n\\n**Time Complexity**: \\n - Counter -  `O(n)`\\n - Sort - `O(nlogn)`\\n\\n**Space Complexity**: `O(1)`\\n<br />\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n2^0\\n2^1\\n... \\n2^30\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [Counter(str(1 << i)) for i in range(30)] \\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return sorted(str(n)) in [sorted(str(1 << i)) for i in range(30)] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482392,
                "title": "python-one-liner-bit-shift-detailed-explain-beginner-friendly-easy-understand",
                "content": "**Main idea:**\\n1. We loop through 1 to 2^29 using Bit shift.\\n2. And using Counter() to check if every digit in n is in power of two.\\n\\n**One-liner code:**\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return Counter(str(n)) in [Counter(str(1 << i)) for i in range(30)]\\n```\\n\\nAnd here\\'s the code for better understand:\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            if digits == Counter(str(1 << i)):\\n                return True\\n        return False\\n```\\n\\nFor those who don\\'t know bit shift:\\nThis is how power of 2 in binary looks like:\\nAnd we keep left shift the number to get every power of 2.\\n```\\n1  -> 1\\n2  -> 10\\n4  -> 100\\n8  -> 1000\\n16 -> 10000\\n32 -> 100000\\n64 -> 1000000\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        return Counter(str(n)) in [Counter(str(1 << i)) for i in range(30)]\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        digits = Counter(str(n))\\n        \\n        for i in range(30):\\n            if digits == Counter(str(1 << i)):\\n                return True\\n        return False\\n```\n```\\n1  -> 1\\n2  -> 10\\n4  -> 100\\n8  -> 1000\\n16 -> 10000\\n32 -> 100000\\n64 -> 1000000\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120606,
                "title": "python-solution-detailed-explanation-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that in this question, the input n is less and equal to 10\\u2079 so the powers of 2 can be 1, 2, 4, and 8 all the way up to 2 to the power of 29 since 2\\xB2\\u2079 is less than 10\\u2079 and 10\\u2079 is less than 2\\xB3\\u2070.\\n\\n![image.png](https://assets.leetcode.com/users/images/19613664-10f3-4d4f-8440-7c0698bba38c_1675118248.3209496.png)\\n\\nSince We can reorder the digits in any order, input 218 can be reordered into 128 which is 2 to the power of 7. On the other hand, input 123 returns false since all the combinations of 123 [213, 123, 132, 231, 213, 312, 321] are not the power of 2.\\n\\nThe observation we can make is that reordering digits of a number in any order does not change the number of occurrences of its digits. So the main idea behind solving this question is that we want to count the occurrence of each digit in the input N and compare it with the occurrence of each digit in the powers of 2. If the occurrences are the same, it means that we can reorder the digits of N to have the resulting number as a power of 2. If the occurrence is not the same, it means we can\\u2019t reorder the digits to become a power of 2.\\n\\n![image.png](https://assets.leetcode.com/users/images/e85c5861-3926-4f48-8adc-f48a3336c06c_1675118345.1014912.png)\\n\\nIf we consider the previous example, 218 returns true since 218 and 128 = 2\\u2077 both have one 1, one 2, and one 8. 123 returns false since it does not match any powers of 2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by converting the given number ```N``` to a string and then using the counter method to count the occurrences of each digit in ```N```. We use the variable ```occurrence``` to store the result. \\nNext, we will use a for loop to iterate through the range of 0 to 29. In each iteration, we compare the occurrence of each digit in 2 to the power of i to the occurrences of each digit of the given number ```N```. if they are the same, we return ```True```, otherwise, we increment i and keep comparing. \\nIf the loop completes and no match is found, it means the digits of ```N``` cannot be reordered to form a power of 2, we return ```False```.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        occurrence = Counter(str(n))\\n        for i in range(30):\\n            if (occurrence == Counter(str(2**i))):\\n                return True\\n        return False\\n\\n\\n```\\n\\nCheck out the video solution for this problem:\\nhttps://www.youtube.com/watch?v=4FAdMIoqRes\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```N```\n```N```\n```occurrence```\n```N```\n```True```\n```N```\n```False```\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        occurrence = Counter(str(n))\\n        for i in range(30):\\n            if (occurrence == Counter(str(2**i))):\\n                return True\\n        return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120214,
                "title": "simple-easy-w-explanation-beats-100-shortest-clean-code",
                "content": "***Solution - I (Counting Digits Frequency)***\\n\\nA simple solution is to check if frequency of digits in N and all powers of 2 less than `10^9` are equal. In our case, we need to check for all powers of 2 from `2^0` to `2^29` and if any of them matches with digits in `N`, return true.\\n\\n```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\\n\\n**Time Complexity :** **`O(logn)`**, where `n` is maximum power of 2 for which digits are counted (2^30). More specifically the time complexity can be written as `O(logN + log2 + log4 + ... + log(2^30))` which after ignoring the constant factors and lower order terms comes out to `O(logn)`.\\n**Time Complexity :** **`O(1)`**. We are using vector to store digits of `N` and powers of 2 but they are taking constant space and don\\'t depend on the input `N`.\\n\\n---------\\n---------\\n\\n***Solution - II (Convert to string & sort)***\\n\\nWe can convert `N` to string, sort it and compare it with every power of 2 by converting and sorting that as well.\\n\\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n-------\\n\\nBoth solutions have the same run-time -\\n\\n![image](https://assets.leetcode.com/users/images/ec72eb4f-071d-4c4f-91b1-c6c098015f29_1616318669.6588662.png)\\n\\n-------\\n-------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120130,
                "title": "python-find-anagram-explained",
                "content": "This is in fact question about anagrams: given string we need to find if we have another string from list of powers of too, which is anagram of original string. Let us iterate through all powers of two and check if count of this number is equal to count of given number `N`. \\n\\n**Complexity**: time complexity will be `O(log^2 N)`: we check `O(log N)` numbers, each of them have `O(log N)` digits at most. In fact it can be improved to `O(log^2N)`, because there can be at most `4` numbers with given number of digits, but here it just not worth it. Space complexity is `O(log N)`.\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        cnt = Counter(str(N))\\n        return any(cnt == Counter(str(1<<i)) for i in range(30))\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        cnt = Counter(str(N))\\n        return any(cnt == Counter(str(1<<i)) for i in range(30))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120107,
                "title": "reordered-power-of-2-js-python-java-c-easy-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest way to check if two things are shuffled versions of each other, which is what this problem is asking us to do, is to sort them both and the compare the result.\\n\\nIn that sense, the easiest solution here is to do exactly that: we can convert **N** to an array of its digits, sort it, then compare that result to the result of the same process on each power of **2**.\\n\\nSince the constraint upon **N** is **10e9**, we only need to check powers in the range **[0,29]**.\\n\\nTo make things easier to compare, we can always **join()** the resulting digit arrays into strings before comparison.\\n\\nThere are ways to very slightly improve the run time and memory here, but with an operation this small, it\\'s honestly not very necessary.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can directly compare the lists and Java can directly compare the char arrays without needing to join them into strings. C++ can sort the strings in-place without needing to convert to an array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.8MB** (beats 100% / 44).\\n```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 98% / 76%).\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 35.8MB** (beats 97% / 88%).\\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481906,
                "title": "from-brute-force-to-optimziation-fully-explained",
                "content": "In this post, I shared my full thought process behind the question, and how I arrived at the optimal solution.\\n\\nIn contrast to just posting the answer, I try to teach and show how to tackle problems and arrive progressively at the optimal solution, instead of memorizing them :)\\n\\n<hr />\\n\\nThe problem states that we are given an integer `n` and we can rearrange it in any order, except leading zero. And we need to check whether we can arrive at a valid power of 2.\\n\\nIn such questions, it\\'s very important to look at the **constraints** because a lot of times it can contradict/hint toward specific solutions. In our case `1 <= n <= 10^9`\\n\\nGiven the constraints, we know that we can have at most 10 digits in n. So generating all permutations will cost us n!, which is **10!** => **3,628,800** (A little less because 0 is invalid in the first position. But that\\'s an upper bound)\\n\\nAlso, we know that a 32-bit integer has 31 powers of 2. You can just shift the active bit to the left. (1 bit it taken for the sign)\\n\\nSo the initial idea can be to generate a set containing all the powers of 2, and to generate a set of all the permutations, and then check whether there is an element that is intersecting between both sets.\\n\\n# Naive brute force\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        int32_powers_of_two = set()\\n        for i in range(31):\\n            int32_powers_of_two.add(1<<i)\\n        \\n        n_numbers = []\\n        while n > 0:\\n            n_numbers.append(n % 10)\\n            n //= 10\\n        \\n        permutations = set()\\n        def generate_permutations(cur_permutation, options):\\n            if not options:\\n                permutations.add(int(cur_permutation))\\n                return\\n            \\n            for i in range(len(options)):\\n                if cur_permutation == \"\" and options[i] == 0: continue\\n                generate_permutations(cur_permutation + str(options[i]), [*options[:i], *options[i+1:]])\\n        \\n        generate_permutations(\"\", n_numbers)\\n        return permutations.intersection(int32_powers_of_two)\\n```\\n\\nThat will TLE on the last test cases. Let\\'s optimize\\n\\n# Optimization\\n\\nOne observation that we can make is that we don\\'t need to generate all the permutations for n. \\n\\nLet\\'s say `n` is `4210`\\n\\nIt\\'s enough for us to look at the powers of two that have 4 digits. i.e. [1024, 2048, 4096, 8192]\\n\\nTake a look, can `n` be reordered to a power of 2? how would you know that efficiently?\\n\\nWhenever you are asked about ordering/shuffling and equality, think about sorting. Sorting will represent the lexicographical order, and if both lexicographical orders are equal, you can reshuffle A to get B.\\n\\nIf we sort `n` = `4210` -> `0124`\\nIf we sort `1024` (a power of 2) -> `0124`\\n\\nBoth are equal, hence we can reorder n to get a power of two.\\n\\n# Algorithm\\n1. We will generate all permutations of 2 within the 32-bit integer range, but store them in buckets relevant to their digit count. This will allow us to look at the powers of 2 that have the same digit count as n\\n2. We will sort `n` (transform to string and sort) and compare against all powers of 2 with the same digit count sorted.\\n3. If we find the same lexicographical order, we can reorder to a valid power of 2. \\n4. If non-matched, we return false after the iteration.\\n\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        buckets = [[] for _ in range(11)]\\n        for i in range(31):\\n            power_of_two = 1<<i\\n            digits_count = math.floor(math.log10(power_of_two)) + 1\\n            buckets[digits_count].append(power_of_two)\\n        \\n        n_str_sorted = \"\".join(sorted(str(n)))\\n        n_digits_count = math.floor(math.log10(n)) + 1\\n        for power_of_two in buckets[n_digits_count]:\\n            if n_str_sorted == \"\".join(sorted(str(power_of_two))):\\n                return True\\n        return False\\n```\\n\\n# Further notes\\n* Instead of sorting you could also count the character frequency and check whether any power of 2 has the same count character count as `n`\\n* Feel free to add a comment with the code in a different language so I\\'ll add them to the post and mention your name.\\n\\n<hr />\\nHave a great day!\\n\\nIf you found this read helpful, please upvote.\\nIt motivates me to do more of them, and also shows me that these posts are helpful for some folks.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        int32_powers_of_two = set()\\n        for i in range(31):\\n            int32_powers_of_two.add(1<<i)\\n        \\n        n_numbers = []\\n        while n > 0:\\n            n_numbers.append(n % 10)\\n            n //= 10\\n        \\n        permutations = set()\\n        def generate_permutations(cur_permutation, options):\\n            if not options:\\n                permutations.add(int(cur_permutation))\\n                return\\n            \\n            for i in range(len(options)):\\n                if cur_permutation == \"\" and options[i] == 0: continue\\n                generate_permutations(cur_permutation + str(options[i]), [*options[:i], *options[i+1:]])\\n        \\n        generate_permutations(\"\", n_numbers)\\n        return permutations.intersection(int32_powers_of_two)\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        buckets = [[] for _ in range(11)]\\n        for i in range(31):\\n            power_of_two = 1<<i\\n            digits_count = math.floor(math.log10(power_of_two)) + 1\\n            buckets[digits_count].append(power_of_two)\\n        \\n        n_str_sorted = \"\".join(sorted(str(n)))\\n        n_digits_count = math.floor(math.log10(n)) + 1\\n        for power_of_two in buckets[n_digits_count]:\\n            if n_str_sorted == \"\".join(sorted(str(power_of_two))):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149825,
                "title": "java-naive-backtracking-15-lines",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length]);\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used){\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```\\nIt would be faster if you use memo to prune.\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length], new HashSet<Integer>());\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used, HashSet<Integer> vis){\\n        if (!vis.add(cur)) return false;\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used, vis)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length]);\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used){\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] ca=(N+\"\").toCharArray();\\n        return helper(ca, 0, new boolean[ca.length], new HashSet<Integer>());\\n    }\\n    public boolean helper(char[] ca, int cur, boolean[] used, HashSet<Integer> vis){\\n        if (!vis.add(cur)) return false;\\n        if (cur!=0 && (cur+\"\").length()==ca.length){\\n            if (Integer.bitCount(cur)==1) return true;\\n            return false;\\n        }\\n        for (int i=0; i<ca.length; i++){\\n            if (used[i]) continue;\\n            used[i]=true;\\n            if (helper(ca, cur*10+ca[i]-\\'0\\', used, vis)) return true;\\n            used[i]=false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481202,
                "title": "java-easy-solution-using-hashset",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        Set<Long> two = new HashSet<>();\\n        for (int i = 1; i <= (int)1e9; i <<= 1){\\n            two.add(transform(i));\\n        }\\n\\n        return two.contains(transform(n));\\n    }\\n\\n    private long transform(int n){\\n        long sum = 0;\\n        while(n > 0){\\n            int d = n % 10;\\n            sum += 1L << (d*3);\\n            n /= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        Set<Long> two = new HashSet<>();\\n        for (int i = 1; i <= (int)1e9; i <<= 1){\\n            two.add(transform(i));\\n        }\\n\\n        return two.contains(transform(n));\\n    }\\n\\n    private long transform(int n){\\n        long sum = 0;\\n        while(n > 0){\\n            int d = n % 10;\\n            sum += 1L << (d*3);\\n            n /= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120407,
                "title": "clean-and-easy-to-understand-digits-anagram",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int i = 0, num = 1; i < 32; i++, num <<= 1)\\n            if(Arrays.equals(digitFreq(N), digitFreq(num)))\\n                return true;\\n        \\n        return false;\\n    }\\n    \\n    private int[] digitFreq(int N) {\\n        int[] f = new int[10];\\n        while(N > 0) {\\n            f[N % 10]++;\\n            N /= 10;\\n        }\\n        \\n        return f;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int i = 0, num = 1; i < 32; i++, num <<= 1)\\n            if(Arrays.equals(digitFreq(N), digitFreq(num)))\\n                return true;\\n        \\n        return false;\\n    }\\n    \\n    private int[] digitFreq(int N) {\\n        int[] f = new int[10];\\n        while(N > 0) {\\n            f[N % 10]++;\\n            N /= 10;\\n        }\\n        \\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149827,
                "title": "simple-python-check-upto-2-power-30",
                "content": "```\\n    def reorderedPowerOf2(self, N):\\n        c1 = Counter(str(N))\\n        for i in range(30):\\n            n = int(math.pow(2, i))\\n            if Counter(str(n)) == c1: return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    def reorderedPowerOf2(self, N):\\n        c1 = Counter(str(N))\\n        for i in range(30):\\n            n = int(math.pow(2, i))\\n            if Counter(str(n)) == c1: return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2481055,
                "title": "python-27-ms-faster-than-100-new-idea-to-improve-other-s-solutions",
                "content": "Like others solutions, i use the same idea of counting the digits and then compare with digits of candidates: ```1, 2, 4, 8, 16, 32, 64 ... 2^30```.\\nBut i noticed that if our input is for example ```251``` we need to compare it only with power of 2 numbers that have exact 3 digits: ```128, 256, 512```, but how can we find out what numbers we need?\\nLet\\'s look for numbers that are powers of 2, their length(number of digits) and their power:\\n```\\nnumbers: 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192\\nlength:  1 1 1 1  2  2  2   3   3   3    4    4    4    4 \\npower:   0 1 2 3  4  5  6   7   8   9   10   11   12   13\\n```\\nLet\\'s see the pattern between ```length``` and ```power```:\\nIf length of number is 1, power lies between 0 and 3, if length is 2 , power lies between 4 and 6 and etc.\\nSo all we need is to find the formula to know in what boundaries numbers lie.\\nFirst of all what i thought is that power lies in ```((length - 1) * 3 + 1, length * 3 + 1)```, for example for ```length = 2``` range will be ```range(4, 7) = (4, 5, 6)``` is what we needed, but this formula doesn\\'t work for ```length = 1, 4, 7 etc```, because every third length(or every 10th power) there are 4 numbers with this length, that ruins the formula, so i thought \"okay, what if we will add 1 every time when we our numbers length reaches 1, 4, 7 etc...\", or in another words: ```add length // 3```, but now our length of range will always be 4, that is still better than 30.\\nSo now our formula for range is ```((length - 1) * 3 + length // 3, length * 3 + length // 3 + 1)```, maybe there\\'s a way to simplify the formula, but i think it\\'s fine, so the final code is:\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        from collections import Counter\\n        length = len(str(n))\\n        c = Counter(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            candidate = str(1 << i)\\n            if c == Counter(candidate):\\n                return True\\n        return False\\n```\\n\\nIf we replace the Counter with sorted, it can be even faster:\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        length = len(str(n))\\n        c = sorted(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            if c == sorted(str(1 << i)):\\n                return True\\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/4b1d106b-c511-4fc9-af8c-8c610e325fab_1661479742.4333918.png)\\n\\n```\\nP.S. The formula was obtained by trial and error, \\nbut i came up with the main idea with connection length and power.\\n```\\n\\n```\\nP.P.S. Feel free to ask about something if it\\'s unclear, \\nwrite an improve ment if you have an idea, \\nor point on mistakes(including english) :)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Sorting"
                ],
                "code": "```1, 2, 4, 8, 16, 32, 64 ... 2^30```\n```251```\n```128, 256, 512```\n```\\nnumbers: 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192\\nlength:  1 1 1 1  2  2  2   3   3   3    4    4    4    4 \\npower:   0 1 2 3  4  5  6   7   8   9   10   11   12   13\\n```\n```length```\n```power```\n```((length - 1) * 3 + 1, length * 3 + 1)```\n```length = 2```\n```range(4, 7) = (4, 5, 6)```\n```length = 1, 4, 7 etc```\n```add length // 3```\n```((length - 1) * 3 + length // 3, length * 3 + length // 3 + 1)```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        from collections import Counter\\n        length = len(str(n))\\n        c = Counter(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            candidate = str(1 << i)\\n            if c == Counter(candidate):\\n                return True\\n        return False\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        length = len(str(n))\\n        c = sorted(str(n))\\n        for i in range((length-1) * 3 + length // 3, length * 3 + length // 3 + 1):\\n            if c == sorted(str(1 << i)):\\n                return True\\n        return False\\n```\n```\\nP.S. The formula was obtained by trial and error, \\nbut i came up with the main idea with connection length and power.\\n```\n```\\nP.P.S. Feel free to ask about something if it\\'s unclear, \\nwrite an improve ment if you have an idea, \\nor point on mistakes(including english) :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120140,
                "title": "python-go-o-log-n-by-digit-occurrence-mapping-w-comment",
                "content": "For example:\\n\\nGiven power of 2 = 2 ^ 6 = 64\\n\\n64 => {6: 1, 4: 1}\\n6 shows up one time\\n4 shows up one time\\n\\n---\\n\\nN=46 or N=64 return **true** because their **digit - occurrence mapping** are the same with 64\\n\\n46 => {4: 1, 6: 1}\\n4 shows up one time\\n6 shows up one time\\n\\n64 => {6: 1, 4: 1}\\n6 shows up one time\\n4 shows up one time\\n\\n---\\n\\n**Implementation** by digit - occurrence mapping\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        # digit <-> occurrence mapping of N\\n        signature_of_N = Counter(str(N))\\n        \\n        \\n        # check each possible power of 2\\n        for i in range(32):\\n            \\n            # get power of 2 by bitwise operation\\n            power_of_2 = 1 << i\\n                \\n            if Counter( str(power_of_2) ) == signature_of_N:\\n                \\n                # Accept if at least one power of 2\\'s mapping is the same with N\\'s mapping\\n                return True\\n        \\n        # Reject otherwise\\n        return False\\n```\\n\\n---\\n\\n**Implementation** by digit - occurrence mapping based on recursion and decimal representation\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        def make_signature(n: int):\\n            \\n\\t\\t\\t## base case\\n            if n == 0:\\n                return 0\\n            \\n\\t\\t\\t\\n\\t\\t\\t## general case\\n\\t\\t\\t\\n            leading, remaining = divmod(n, 10)\\n            return make_signature(leading) + ( 10 ** remaining )\\n        \\n        # ---------------------------------------------------------\\n        \\n        signature_of_N = make_signature(N)\\n        \\n\\t\\t# check each possible power of 2\\n        for i in range(32):\\n            \\n\\t\\t\\t# get power of 2 by bitwise operation, and check signature\\n            if make_signature( 1 << i ) == signature_of_N:\\n\\t\\t\\t\\n\\t\\t\\t\\t# Accept if at least one power of 2\\'s signature is the same with N\\'s signature\\n                return True\\n        \\n\\t\\t# Reject otherwise\\n        return False\\n```\\n\\n---\\n\\n**Implementation** by digit - occurrence mapping based on recursion and decimal representation\\n\\nGo:\\n\\n```\\nfunc reorderedPowerOf2(N int) bool {\\n \\n    var makeSignature func(n int) int\\n    \\n    makeSignature = func(n int) int {\\n        \\n        if n == 0{\\n            // base case\\n            return 0\\n        }\\n        \\n        // general case\\n        leading, remaining := n / 10, n % 10\\n        return makeSignature( leading ) + int( math.Pow(10, float64(remaining) ) )\\n        \\n    }\\n    \\n    // -----------------------------------------------------\\n    \\n    signatureN := makeSignature( N )\\n    \\n    // check each possible power of 2\\n    for i := 0 ; i < 32 ; i++ {\\n        \\n        if makeSignature( 1 << i ) == signatureN{\\n            \\n            // Accept if at least one power of 2\\'s signature is the smae with N\\'s\\n            return true\\n        }\\n        \\n    }\\n    \\n    // Reject otherwise\\n    return false\\n}\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about specialized dictionary Counter( ... )](https://docs.python.org/3/library/collections.html#collections.Counter)\\n\\n[2] [Python official docs about bitwise operation](https://wiki.python.org/moin/BitwiseOperators)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        # digit <-> occurrence mapping of N\\n        signature_of_N = Counter(str(N))\\n        \\n        \\n        # check each possible power of 2\\n        for i in range(32):\\n            \\n            # get power of 2 by bitwise operation\\n            power_of_2 = 1 << i\\n                \\n            if Counter( str(power_of_2) ) == signature_of_N:\\n                \\n                # Accept if at least one power of 2\\'s mapping is the same with N\\'s mapping\\n                return True\\n        \\n        # Reject otherwise\\n        return False\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        \\n        def make_signature(n: int):\\n            \\n\\t\\t\\t## base case\\n            if n == 0:\\n                return 0\\n            \\n\\t\\t\\t\\n\\t\\t\\t## general case\\n\\t\\t\\t\\n            leading, remaining = divmod(n, 10)\\n            return make_signature(leading) + ( 10 ** remaining )\\n        \\n        # ---------------------------------------------------------\\n        \\n        signature_of_N = make_signature(N)\\n        \\n\\t\\t# check each possible power of 2\\n        for i in range(32):\\n            \\n\\t\\t\\t# get power of 2 by bitwise operation, and check signature\\n            if make_signature( 1 << i ) == signature_of_N:\\n\\t\\t\\t\\n\\t\\t\\t\\t# Accept if at least one power of 2\\'s signature is the same with N\\'s signature\\n                return True\\n        \\n\\t\\t# Reject otherwise\\n        return False\\n```\n```\\nfunc reorderedPowerOf2(N int) bool {\\n \\n    var makeSignature func(n int) int\\n    \\n    makeSignature = func(n int) int {\\n        \\n        if n == 0{\\n            // base case\\n            return 0\\n        }\\n        \\n        // general case\\n        leading, remaining := n / 10, n % 10\\n        return makeSignature( leading ) + int( math.Pow(10, float64(remaining) ) )\\n        \\n    }\\n    \\n    // -----------------------------------------------------\\n    \\n    signatureN := makeSignature( N )\\n    \\n    // check each possible power of 2\\n    for i := 0 ; i < 32 ; i++ {\\n        \\n        if makeSignature( 1 << i ) == signatureN{\\n            \\n            // Accept if at least one power of 2\\'s signature is the smae with N\\'s\\n            return true\\n        }\\n        \\n    }\\n    \\n    // Reject otherwise\\n    return false\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159513,
                "title": "c-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        set<string> si = {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\",\\n                          \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\",\\n                          \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\",\\n        };\\n        string t = to_string(N);\\n        sort(t.begin(), t.end());\\n        return si.count(t) > 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        set<string> si = {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\",\\n                          \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\",\\n                          \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\",\\n        };\\n        string t = to_string(N);\\n        sort(t.begin(), t.end());\\n        return si.count(t) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481179,
                "title": "c-easy-solution-of-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        \\n        while(n){\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# **Please share and Upvote it keeps me motivated**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        \\n        while(n){\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150340,
                "title": "possibly-fastest-c-solution-using-multiset-0ms-runtime",
                "content": "**So, the idea is very simple:**\\n1. Convert `N` into a multiset of its digits, for an example, if `N = 426412` then the multiset will contain `{1, 2, 2, 4, 4, 6}`.\\n2. Now, we will generate some 2\\'s power and will convert them into another multiset as well, **if both multiset are same**, function will return **true**\\n3. To speed up the process we don\\'t need to find all `2`\\'s power. In fact, it will depent on `N`, if `N` has `6` digits, I compute `2^12 to 2^20`, the above number is `2^18`, when both set matches, we just return true.\\n\\n```\\nprivate:    \\n    multiset<int> convert(int num) {        //  this function converts a number into a multiset of its digit.\\n        multiset<int> allDigit;\\n        while(num) { allDigit.insert(num%10); num /= 10; }\\n        return allDigit;\\n    }\\n    \\npublic:\\n    bool reorderedPowerOf2(int N) {\\n    \\n        if(N<10) {                                          //  for single digit\\n            if (N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n\\n        multiset<int> digitN;\\n        int num = N, cc=0, powerOf2=8;\\n\\n        while(num) { digitN.insert(num%10); num /= 10; cc++;}\\n\\n        for(int i=4; i <= 4*cc; i++) {      //  number of digit in decimal <= 4 * number of digit in binary\\n            powerOf2 *= 2;\\n            multiset<int> digitNum = convert(powerOf2);\\n            if(digitNum == digitN) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate:    \\n    multiset<int> convert(int num) {        //  this function converts a number into a multiset of its digit.\\n        multiset<int> allDigit;\\n        while(num) { allDigit.insert(num%10); num /= 10; }\\n        return allDigit;\\n    }\\n    \\npublic:\\n    bool reorderedPowerOf2(int N) {\\n    \\n        if(N<10) {                                          //  for single digit\\n            if (N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n\\n        multiset<int> digitN;\\n        int num = N, cc=0, powerOf2=8;\\n\\n        while(num) { digitN.insert(num%10); num /= 10; cc++;}\\n\\n        for(int i=4; i <= 4*cc; i++) {      //  number of digit in decimal <= 4 * number of digit in binary\\n            powerOf2 *= 2;\\n            multiset<int> digitNum = convert(powerOf2);\\n            if(digitNum == digitN) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481234,
                "title": "leetcode-the-hard-way-easy-sorting-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string sortStr(int n) {\\n        // since the input is an integer,\\n        // we convert it to a string first\\n        string t = to_string(n);\\n        // use STL to sort\\n        sort(t.begin(), t.end());\\n        // return the string\\n        return t;\\n    }\\n    \\n    // the idea is to sort `n` and compare all sorted power of two\\n    // if they are matched, then it means they can be reordered to each other\\n    bool reorderedPowerOf2(int n) {\\n        // since the sorted string of n is always same\\n        // so we convert it here instead of doing it in the loop\\n        string s = sortStr(n);\\n        for (int i = 0; i < 30; i++) {\\n            // power of 2 = 1 << i\\n            // we sort each power of 2 string\\n            string t = sortStr(1 << i);\\n            // and compare with `s`\\n            // if they are matched, then return true\\n            if (s == t) return true;\\n        }\\n        // otherwise it is not possible to reorder to a power of 2\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string sortStr(int n) {\\n        // since the input is an integer,\\n        // we convert it to a string first\\n        string t = to_string(n);\\n        // use STL to sort\\n        sort(t.begin(), t.end());\\n        // return the string\\n        return t;\\n    }\\n    \\n    // the idea is to sort `n` and compare all sorted power of two\\n    // if they are matched, then it means they can be reordered to each other\\n    bool reorderedPowerOf2(int n) {\\n        // since the sorted string of n is always same\\n        // so we convert it here instead of doing it in the loop\\n        string s = sortStr(n);\\n        for (int i = 0; i < 30; i++) {\\n            // power of 2 = 1 << i\\n            // we sort each power of 2 string\\n            string t = sortStr(1 << i);\\n            // and compare with `s`\\n            // if they are matched, then return true\\n            if (s == t) return true;\\n        }\\n        // otherwise it is not possible to reorder to a power of 2\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121867,
                "title": "javascript-easy-to-understand-4-solutions",
                "content": "For this problem, there are 2 main strategies to solve it:\\n- One is following the rules in the description and try every possible option.\\n- Another one is to try to find a way to serialize the number and check whether the serialization for `N` matches any serialization of power of 2.\\n\\n## SOLUTION 1\\n\\nFirst, we try the most straight forward solution - validate every reordered sequence of `N` and check if it\\'s the power of 2.\\n\\n```js\\nconst set = new Set();\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(String(cur));\\n}\\n\\nconst validate = (left, cur = \"\") => {\\n  if (left.length === 1) return set.has(cur + left[0]);\\n  for (let i = 0; i < left.length; ++i) {\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    if (validate(next, cur + left[i])) return true;\\n  }\\n  return false;\\n};\\n\\nconst reorderedPowerOf2 = (n) => validate(String(n));\\n```\\n\\n## SOLUTION 2\\n\\nWe could find out all the possible sequences for the power of 2 between 1 and 10 ** 9 first. And then just check the mapping for the result.\\n\\n```js\\nconst set = new Set();\\n\\nconst permute = (left, cur = \"\") => {\\n  if (left.length === 1) {\\n    set.add(Number(cur + left[0]));\\n    return;\\n  }\\n  for (let i = 0; i < left.length; ++i) {\\n    if (left[i] === \"0\" && cur.length === 0) continue;\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    permute(next, cur + left[i]);\\n  }\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  permute(String(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(n);\\n```\\n\\n## SOLUTION 3\\n\\nThis solution follows the second strategy. We achieve serialization by counting the occurrences of each number.\\n\\n```js\\nconst set = new Set();\\n\\nconst serialize = str => {\\n  const count = new Uint8Array(10);\\n  const BASE = 48;\\n  for (let i = 0; i < str.length; ++i) {\\n    ++count[str.charCodeAt(i) - BASE];\\n  }\\n  return count.join(\\':\\');\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(String(cur)));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(String(n)));\\n```\\n\\n## SOLUTION 4\\n\\nHere we use a more efficient serialization approach.\\nSince the range is `[1, 10 ** 9]`, so for every number, the occurrences must small than 10, which means we could use a number to represent the serialization value. For example, `4510` means there are 4 number 4, 5 number 3, 1 number 2 and 0 number 1.\\n\\n```js\\nconst set = new Set();\\n\\nconst serialize = num => {\\n  let val = 0;\\n  while (num >= 1) {\\n    val += 1 << num % 10;\\n    num /= 10;\\n  }\\n  return val;\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(n));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst set = new Set();\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(String(cur));\\n}\\n\\nconst validate = (left, cur = \"\") => {\\n  if (left.length === 1) return set.has(cur + left[0]);\\n  for (let i = 0; i < left.length; ++i) {\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    if (validate(next, cur + left[i])) return true;\\n  }\\n  return false;\\n};\\n\\nconst reorderedPowerOf2 = (n) => validate(String(n));\\n```\n```js\\nconst set = new Set();\\n\\nconst permute = (left, cur = \"\") => {\\n  if (left.length === 1) {\\n    set.add(Number(cur + left[0]));\\n    return;\\n  }\\n  for (let i = 0; i < left.length; ++i) {\\n    if (left[i] === \"0\" && cur.length === 0) continue;\\n    const next = left.slice(0, i) + left.slice(i + 1);\\n    permute(next, cur + left[i]);\\n  }\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  permute(String(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(n);\\n```\n```js\\nconst set = new Set();\\n\\nconst serialize = str => {\\n  const count = new Uint8Array(10);\\n  const BASE = 48;\\n  for (let i = 0; i < str.length; ++i) {\\n    ++count[str.charCodeAt(i) - BASE];\\n  }\\n  return count.join(\\':\\');\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(String(cur)));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(String(n)));\\n```\n```js\\nconst set = new Set();\\n\\nconst serialize = num => {\\n  let val = 0;\\n  while (num >= 1) {\\n    val += 1 << num % 10;\\n    num /= 10;\\n  }\\n  return val;\\n};\\n\\nfor (let cur = 1; cur < 10 ** 9; cur <<= 1) {\\n  set.add(serialize(cur));\\n}\\n\\nconst reorderedPowerOf2 = (n) => set.has(serialize(n));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2483824,
                "title": "c-efficient-solution-easy",
                "content": "```\\nbool reorderedPowerOf2(int n) {\\n        \\n    if(n==1)\\n        return true;\\n    \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    unordered_map<string,int> powers;\\n    \\n    //creating all 0 to 29 possible powers of 2;\\n    for(int i =0 ; i<=29; i++){\\n        string str = to_string((int)pow(2,i));      //pow function returns float so we need to convert\\n        sort(str.begin(),str.end());\\n        powers[str] = 1;\\n    }        \\n    \\n    if(powers[num]==1)\\n        return 1;\\n    else\\n        return 0;\\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n        \\n    if(n==1)\\n        return true;\\n    \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    unordered_map<string,int> powers;\\n    \\n    //creating all 0 to 29 possible powers of 2;\\n    for(int i =0 ; i<=29; i++){\\n        string str = to_string((int)pow(2,i));      //pow function returns float so we need to convert\\n        sort(str.begin(),str.end());\\n        powers[str] = 1;\\n    }        \\n    \\n    if(powers[num]==1)\\n        return 1;\\n    else\\n        return 0;\\n    \\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2483623,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nbool isPowerOfTwo(int n) {        \\n    if(n==0)\\n        return 0;\\n        \\n    if(ceil(log2(n)) == floor(log2(n)))\\n        return 1;\\n    else\\n        return 0;            \\n}\\n    \\n    \\nbool reorderedPowerOf2(int n) {\\n        \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    do{ \\n        if(num[0]==\\'0\\')                //edge case\\n            continue;\\n\\t\\t\\t\\n        if(isPowerOfTwo(stoi(num)))\\n            return 1;        \\n    }while(next_permutation(num.begin(),num.end()));     \\n    \\n\\treturn 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nbool isPowerOfTwo(int n) {        \\n    if(n==0)\\n        return 0;\\n        \\n    if(ceil(log2(n)) == floor(log2(n)))\\n        return 1;\\n    else\\n        return 0;            \\n}\\n    \\n    \\nbool reorderedPowerOf2(int n) {\\n        \\n    string num = to_string(n);\\n    sort(num.begin(),num.end());\\n    \\n    do{ \\n        if(num[0]==\\'0\\')                //edge case\\n            continue;\\n\\t\\t\\t\\n        if(isPowerOfTwo(stoi(num)))\\n            return 1;        \\n    }while(next_permutation(num.begin(),num.end()));     \\n    \\n\\treturn 0;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480861,
                "title": "daily-leetcoding-challenge-august-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reordered-power-of-2/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Permutations\n\n  \n**Approach 2:** Counting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reordered-power-of-2/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1011051,
                "title": "python-3",
                "content": "```\\ndef reorderedPowerOf2(self, N: int) -> bool:\\n        c, l = collections.Counter(str(N)), len(str(N))\\n        n = 1\\n        while len(str(n)) <= l:\\n            if collections.Counter(str(n)) == c:\\n                return True\\n            n *= 2\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef reorderedPowerOf2(self, N: int) -> bool:\\n        c, l = collections.Counter(str(N)), len(str(N))\\n        n = 1\\n        while len(str(n)) <= l:\\n            if collections.Counter(str(n)) == c:\\n                return True\\n            n *= 2\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 172840,
                "title": "one-line-python-beats-70",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1<<i)) for i in range(33)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        return sorted(str(N)) in [sorted(str(1<<i)) for i in range(33)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484879,
                "title": "lightining-fast-high-iq-marvel-approach",
                "content": "**Logic?**\\n\\nWe have used a special operation here  \" **<<** \" , which is know as **binary left operator**.  The left operands value is moved left by the number of bits specified by the right operand.\\n\\nSo ,\\n*1      = 00000000 00000000 00000000 00000001 = 1*\\n*1 << 1 = 00000000 00000000 00000000 00000010 = 2*\\n*1 << 8 = 00000000 00000000 00000001 00000000 = 256*\\n\\n***for e.g., 1<<6 will be 1(2^6)= 64***\\n\\n***So here we are just trying to store, 2 to the power i***\\n\\nHence, for each value of **i** in for loop it will give us the corresponding **power of 2** which we store in a string as digits!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n       //Create a string to store the number as individual digits\\n       string num = to_string(n);\\n       \\n       //Sort the string of digits\\n       sort(num.begin(), num.end());\\n        \\n        //It is given that n lies in range [ 1 <= n <= 10^9 ]\\n        //So, if n is a power of 2 it must exist between 2^0(=1) to 2^30(1073741824)\\n        \\n        //Hence, we loop from 0 to 29 and find all corresponding powers of 2\\n        \\n        for(int i = 0; i < 30; i++){\\n            \\n            //For each i, the respective power of 2 can be calculated as:\\n            //**Logic is discussed above**\\n            string powerOf2 = to_string(1 << i);\\n            \\n            //We again convert that number to string and sort its digits\\n            sort(powerOf2.begin(), powerOf2.end());\\n            \\n            //If the resulting sorted string of digits is equal to num string then return True\\n            if(num == powerOf2){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        // Else, that number isn\\'t a power of 2 and so return False\\n        return false;\\n    }\\n};\\n```\\n\\n**@Credits to @rahulvarma5297 and @divyamRai for the original answers!**\\n\\n![image](https://assets.leetcode.com/users/images/eb61f3be-ac79-49cd-9415-6fa8dc469155_1661541899.0942814.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n       //Create a string to store the number as individual digits\\n       string num = to_string(n);\\n       \\n       //Sort the string of digits\\n       sort(num.begin(), num.end());\\n        \\n        //It is given that n lies in range [ 1 <= n <= 10^9 ]\\n        //So, if n is a power of 2 it must exist between 2^0(=1) to 2^30(1073741824)\\n        \\n        //Hence, we loop from 0 to 29 and find all corresponding powers of 2\\n        \\n        for(int i = 0; i < 30; i++){\\n            \\n            //For each i, the respective power of 2 can be calculated as:\\n            //**Logic is discussed above**\\n            string powerOf2 = to_string(1 << i);\\n            \\n            //We again convert that number to string and sort its digits\\n            sort(powerOf2.begin(), powerOf2.end());\\n            \\n            //If the resulting sorted string of digits is equal to num string then return True\\n            if(num == powerOf2){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        // Else, that number isn\\'t a power of 2 and so return False\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484240,
                "title": "best-java-solution",
                "content": "\\n**TC : Calculating the frequency Count for a no would be O(no of digits in N). Also,there could a case where it matches with 2^31 (last power of 2).So the complexity would be O(32*length(2^32) + O(no of digits in N)**\\n```\\nclass Solution { \\n    \\n    public boolean reorderedPowerOf2(int n) \\n    {\\n\\t\\tint [] nFreq=digitFreq(n);\\n        \\n        for(int i=0;i<31;i++) //Within the integer range max power of 2 that lies is 2^31\\n        {\\n            int powerOf2=(int)Math.pow(2,i);\\n            int [] powerOf2FreqCount = digitFreq(powerOf2);            \\n            if(compareFreq(nFreq,powerOf2FreqCount)) \\n                return true;            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean compareFreq (int []nFreq ,int []powerOf2FreqCount){\\n        boolean match=true;\\n        \\n        for(int i=0;i<10;i++){\\n            if(nFreq[i]!=powerOf2FreqCount[i])\\n                return false;            \\n        }\\n        return true;\\n    }\\n    \\n    private int [] digitFreq(int num){\\n        int [] digitFreq=new int [10];\\n        while(num>0){\\n            digitFreq[num%10]++;    //counting freq for each digit so here we extracted the last digit from number ( from right side )\\n            num /= 10; \\n        }\\n        return digitFreq;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution { \\n    \\n    public boolean reorderedPowerOf2(int n) \\n    {\\n\\t\\tint [] nFreq=digitFreq(n);\\n        \\n        for(int i=0;i<31;i++) //Within the integer range max power of 2 that lies is 2^31\\n        {\\n            int powerOf2=(int)Math.pow(2,i);\\n            int [] powerOf2FreqCount = digitFreq(powerOf2);            \\n            if(compareFreq(nFreq,powerOf2FreqCount)) \\n                return true;            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean compareFreq (int []nFreq ,int []powerOf2FreqCount){\\n        boolean match=true;\\n        \\n        for(int i=0;i<10;i++){\\n            if(nFreq[i]!=powerOf2FreqCount[i])\\n                return false;            \\n        }\\n        return true;\\n    }\\n    \\n    private int [] digitFreq(int num){\\n        int [] digitFreq=new int [10];\\n        while(num>0){\\n            digitFreq[num%10]++;    //counting freq for each digit so here we extracted the last digit from number ( from right side )\\n            num /= 10; \\n        }\\n        return digitFreq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483526,
                "title": "one-easy-way-to-solve",
                "content": "```\\nvar reorderedPowerOf2 = function(n) {\\n    let str = n.toString();\\n   let initialString =  str.split(\\'\\').sort().join(\\'\\');\\n    \\n    \\n    for(let i=0; i<30; i++){\\n        let tempString = (1<<i).toString();\\n       let finalString = tempString.split(\\'\\').sort().join(\\'\\');\\n        if(initialString===finalString){\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderedPowerOf2 = function(n) {\\n    let str = n.toString();\\n   let initialString =  str.split(\\'\\').sort().join(\\'\\');\\n    \\n    \\n    for(let i=0; i<30; i++){\\n        let tempString = (1<<i).toString();\\n       let finalString = tempString.split(\\'\\').sort().join(\\'\\');\\n        if(initialString===finalString){\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482638,
                "title": "100-00-of-c-2-approach-using-map-and-sorting-optimise-space",
                "content": "**1st approach using only sorting function**\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n        vector<string>v;\\n        \\n        for(int i=0;i<=30;i++){\\n            int p = pow(2 , i);\\n            v.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(v[i].begin() , v[i].end());\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin() , s.end());\\n        \\n        for(int i=0;i<=30;i++){\\n            if(v[i]==s) return true;\\n        }\\n        return false;\\n    }\\n};   \\n```\\n\\n**2nd approach using map**\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n\\n         int x = pow(10 , 9);\\n         map<int ,vector<int>>word;\\n         for(int i=1;i<=x;i=i*2){\\n             int k =i;\\n             vector<int>v(10 , 0);\\n             while(k){\\n                 int l = k%10;\\n                 v[l]++;\\n                 k=k/10;\\n             }\\n             word[i]=v;\\n         }\\n        \\n         vector<int> v(10 , 0);\\n         while(n){\\n             int l = n%10;\\n             v[l]++;\\n             n=n/10;\\n         }\\n        \\n         for(int i=1;i<=x;i=i*2){\\n            \\n             vector<int> m=word[i];\\n             bool flag=0;\\n             for(int j=0;j<=9;j++){\\n                if(v[j]!=m[j]){\\n                    flag=1;\\n                }\\n             }\\n             if(flag==0){\\n                 return 1;\\n             }\\n         }\\n         return 0; \\n    }\\n};   \\n```\\n\\n**If you found this solution helpful a upvote is highly appreciated**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n        vector<string>v;\\n        \\n        for(int i=0;i<=30;i++){\\n            int p = pow(2 , i);\\n            v.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(v[i].begin() , v[i].end());\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin() , s.end());\\n        \\n        for(int i=0;i<=30;i++){\\n            if(v[i]==s) return true;\\n        }\\n        return false;\\n    }\\n};   \\n```\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) { \\n\\n         int x = pow(10 , 9);\\n         map<int ,vector<int>>word;\\n         for(int i=1;i<=x;i=i*2){\\n             int k =i;\\n             vector<int>v(10 , 0);\\n             while(k){\\n                 int l = k%10;\\n                 v[l]++;\\n                 k=k/10;\\n             }\\n             word[i]=v;\\n         }\\n        \\n         vector<int> v(10 , 0);\\n         while(n){\\n             int l = n%10;\\n             v[l]++;\\n             n=n/10;\\n         }\\n        \\n         for(int i=1;i<=x;i=i*2){\\n            \\n             vector<int> m=word[i];\\n             bool flag=0;\\n             for(int j=0;j<=9;j++){\\n                if(v[j]!=m[j]){\\n                    flag=1;\\n                }\\n             }\\n             if(flag==0){\\n                 return 1;\\n             }\\n         }\\n         return 0; \\n    }\\n};   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482021,
                "title": "c-0-ms-faster-than-100-00",
                "content": "**C++:**\\n```\\nvector<string> arr = {\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"};\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n       string s =  to_string(n);\\n       sort(s.begin(),s.end());\\n       return s == arr[lower_bound(arr.begin(),arr.end(),s)\\n\\t   - arr.begin()];\\n        \\n    }\\n};\\n```\\n\\nStep 1: Convert each power of 2 (upto 30) to string and sort all strings. \\nStep 2: Push the resultant strings to global vector `arr`  in the sorted fashion.\\n\\nYour vector will look like something like this -\\n```\\n[\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"]\\n```\\n\\nNow simply convert `n` to string `s`, sort it and apply binary search to find  `s` in `arr`\\nEg - \\nn = 251\\ns = \"251\"\\nafter sorting : s = \"125\"\\nfind index of \"125\" in `arr` and retrive the index\\nhere index will be 16,\\nNow simply check whether string exists or not by `arr[index]==s`\\nreturn it ;)\\n\\n*Upvote if it helped you*\\n\\n",
                "solutionTags": [],
                "code": "```\\nvector<string> arr = {\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"};\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n       string s =  to_string(n);\\n       sort(s.begin(),s.end());\\n       return s == arr[lower_bound(arr.begin(),arr.end(),s)\\n\\t   - arr.begin()];\\n        \\n    }\\n};\\n```\n```\\n[\"0112344778\",\"011237\",\"0122579\",\\n\"012356789\",\"0124\",\"0134449\",\"0145678\",\"01466788\",\"0248\",\\n\"0368888\",\"0469\",\"1\",\"112234778\",\"11266777\",\"122446\",\\n\"125\",\"128\",\"1289\",\"13468\",\"16\",\"2\",\"224588\",\"23\",\"23334455\",\\n\"234455668\",\"23678\",\"256\",\"35566\",\"4\",\"46\",\"8\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481482,
                "title": "javascript-easy-to-understand-fully-explained-power-of-2-simple",
                "content": "```\\n//Main function\\nvar reorderedPowerOf2 = function(n) {\\n let arr = FindDigitMapArray(n);\\n    \\n for(let i=0;i<31;i++){ //Till value of power of 2 is less than 10^9 or 2^32 find all such power of 2\\n      let num = Math.pow(2,i);\\n      let twoArray = FindDigitMapArray(num);\\n       if(CheckTwoArraysAreEqual(arr,twoArray)) return true;\\n }\\n    return false;\\n}\\n\\n//Function to generate digit map\\nvar FindDigitMapArray = function(n){ //For a given number it stores the count of digit on respective index.\\n    let arr = Array(10).fill(0);\\n    while(n>0){\\n        arr[n%10]+=1;\\n        n/=10;\\n        n=Math.floor(n);\\n    }\\n    return arr;\\n}\\n\\n//Function to check if two arrays are equal\\nvar CheckTwoArraysAreEqual = function(arr,twoArray){\\n     let count = 0;\\n    for(let i=0;i<10;i++){ //Check if digit map of both numbers are equal\\n     if(twoArray[i]==arr[i]){\\n            count++;\\n        }\\n    }\\n    if(count==10) return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//Main function\\nvar reorderedPowerOf2 = function(n) {\\n let arr = FindDigitMapArray(n);\\n    \\n for(let i=0;i<31;i++){ //Till value of power of 2 is less than 10^9 or 2^32 find all such power of 2\\n      let num = Math.pow(2,i);\\n      let twoArray = FindDigitMapArray(num);\\n       if(CheckTwoArraysAreEqual(arr,twoArray)) return true;\\n }\\n    return false;\\n}\\n\\n//Function to generate digit map\\nvar FindDigitMapArray = function(n){ //For a given number it stores the count of digit on respective index.\\n    let arr = Array(10).fill(0);\\n    while(n>0){\\n        arr[n%10]+=1;\\n        n/=10;\\n        n=Math.floor(n);\\n    }\\n    return arr;\\n}\\n\\n//Function to check if two arrays are equal\\nvar CheckTwoArraysAreEqual = function(arr,twoArray){\\n     let count = 0;\\n    for(let i=0;i<10;i++){ //Check if digit map of both numbers are equal\\n     if(twoArray[i]==arr[i]){\\n            count++;\\n        }\\n    }\\n    if(count==10) return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481467,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(Constant * logN)***\\n\\n* ***Space Complexity :- O(Constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for checking is two numbers have identiacal digits\\n    \\n    bool is_possible(int num1, int num2)\\n    {\\n        vector<int> mp(10, 0);\\n        \\n        // increment the count of digits by num1 \\n        \\n        while(num1)\\n        {\\n            int r = num1 % 10;\\n            \\n            mp[r]++;\\n            \\n            num1 = num1 / 10;\\n        }\\n        \\n        // decrement the count of digits by num2\\n        \\n        while(num2)\\n        {\\n            int r = num2 % 10;\\n            \\n            mp[r]--;\\n            \\n            num2 = num2 / 10;\\n        }\\n        \\n        // check if both are idenical of not\\n        \\n        for(int i = 0; i < 10; i++)\\n        {\\n            if(mp[i] != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        // first of all find all the power of 2 <= 1e9 and store in power array\\n        \\n        int num = 1;\\n        \\n        vector<int> power;\\n        \\n        power.push_back(1);\\n        \\n        while(num * 2 <= 1e9)\\n        {\\n            power.push_back(num * 2);\\n            \\n            num = num * 2;\\n        }\\n        \\n        // compare the number with every element of power array, if any of them have the identical digits \\n        \\n        // then we can reorder the number to power of 2\\n        \\n        for(int i = 0; i < power.size(); i++)\\n        {\\n            if(is_possible(power[i], n))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for checking is two numbers have identiacal digits\\n    \\n    bool is_possible(int num1, int num2)\\n    {\\n        vector<int> mp(10, 0);\\n        \\n        // increment the count of digits by num1 \\n        \\n        while(num1)\\n        {\\n            int r = num1 % 10;\\n            \\n            mp[r]++;\\n            \\n            num1 = num1 / 10;\\n        }\\n        \\n        // decrement the count of digits by num2\\n        \\n        while(num2)\\n        {\\n            int r = num2 % 10;\\n            \\n            mp[r]--;\\n            \\n            num2 = num2 / 10;\\n        }\\n        \\n        // check if both are idenical of not\\n        \\n        for(int i = 0; i < 10; i++)\\n        {\\n            if(mp[i] != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        // first of all find all the power of 2 <= 1e9 and store in power array\\n        \\n        int num = 1;\\n        \\n        vector<int> power;\\n        \\n        power.push_back(1);\\n        \\n        while(num * 2 <= 1e9)\\n        {\\n            power.push_back(num * 2);\\n            \\n            num = num * 2;\\n        }\\n        \\n        // compare the number with every element of power array, if any of them have the identical digits \\n        \\n        // then we can reorder the number to power of 2\\n        \\n        for(int i = 0; i < power.size(); i++)\\n        {\\n            if(is_possible(power[i], n))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481411,
                "title": "java-sort",
                "content": "We can do the hash thing or we can also just sort it.\\nI think sorting is easier. \\n```Java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        for (int i = 0; i <= 30; i++){\\n            char[] a = (\"\"+(1<<i)).toCharArray();\\n            char[] b = (\"\"+n).toCharArray();\\n            Arrays.sort(a);\\n            Arrays.sort(b);\\n            if (Arrays.equals(a, b)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        for (int i = 0; i <= 30; i++){\\n            char[] a = (\"\"+(1<<i)).toCharArray();\\n            char[] b = (\"\"+n).toCharArray();\\n            Arrays.sort(a);\\n            Arrays.sort(b);\\n            if (Arrays.equals(a, b)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481019,
                "title": "c-easy-to-understand-beginner-friendly",
                "content": "\\tbool check(string str)\\n\\t{\\n\\t\\tint x = 0;\\n\\t\\tfor(int i=0;i<str.size();i++)\\n\\t\\t{\\n\\t\\t\\tx=x*10+(str[i]-\\'0\\');\\n\\t\\t}\\n\\t\\tint z = (x&(x-1));\\n\\t\\tif(z==0)return true;\\n\\t\\treturn false;\\n\\t}\\n\\tvoid permute(string &str,int index,bool &ans)\\n\\t{\\n\\t\\tif(index==str.size())\\n\\t\\t{\\n\\t\\t\\tif(str[0]!=\\'0\\' && check(str))ans = true;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor(int i=index;i<str.size();i++)\\n\\t\\t{\\n\\t\\t\\tswap(str[i],str[index]);\\n\\t\\t\\tpermute(str,index+1,ans);\\n\\t\\t\\tswap(str[i],str[index]);\\n\\t\\t}\\n\\t}\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool reorderedPowerOf2(int n) \\n\\t\\t{\\n\\t\\t\\tbool ans = false;\\n\\t\\t\\tstring str = to_string(n);\\n\\t\\t\\tpermute(str,0,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool reorderedPowerOf2(int n) \\n\\t\\t{\\n\\t\\t\\tbool ans = false;\\n\\t\\t\\tstring str = to_string(n);\\n\\t\\t\\tpermute(str,0,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2481005,
                "title": "python-my-soln",
                "content": "class Solution:\\n\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n1 = sorted(str(n))\\n        \\n        for i in range(30):\\n            res = sorted(str(2 ** i))\\n            if res == n1:\\n                return True\\n            \\n            \\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n1 = sorted(str(n))\\n        \\n        for i in range(30):\\n            res = sorted(str(2 ** i))\\n            if res == n1:\\n                return True\\n            \\n            \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1120308,
                "title": "c-linear-time-constant-space-solution-explained-100-time-100-space",
                "content": "Great problem to tackle and, since it was pretty straightforward, I gave myself a few extra challenges:\\n* no conversion to string (that will not look cool to most interviewers anyway);\\n* no sorting;\\n* getting there with constant space.\\n\\nAnd it looks like I did it \\uD83C\\uDF8A !\\n\\nIn order to proceed, first of all I declared as a `static constexpr` a 2D array with all the powers of 2 up to the given limit (`9` digits), grouped by number of digits, so that I could have a smoother lookup later.\\n\\nIn the main function, we will declare 2 support variables:\\n* `digits` is an array of `9` elements (again, the maximum we might have to consider;\\n* `pos` is a pointer that will tell us where to write or up to where to read in `digits`, preset to `0`.\\n\\nWe will then proceed to destructure `n` into its base digits, proceeding until it is reduced to `0` and:\\n* assign its quotient and remainder to the aptly named `qr`;\\n* store the remainder in `digits`, while also increasing `pos` by `1`;\\n* update `n` to be the quotient - ie: functionally shaving off the least significant/leftmost digit that we just store.\\n\\nOnce done, we will call `verifyDigits` with all the non-`0` values that we have in `powers[pos]` (ie: all the powers of 2 we pre-stored), returning `true` if anyone of them matches the content of digits (ie: the initial number was an \"anagram\" of any power of 2 with the same amount of digits).\\n\\n`verifyDigits` takes 3 parameters (our array/pointer `digits`, `pos` which doubles now as the size of `digits` and `n`, the pre-stored power of 2 to verify) and:\\n* declare a support variable `check` as an array of `10` elements, all preset to `0`;\\n* increase each matching cell of `check` by `1` for each element in `digits` up to `pos` - so, for example, if we had `digits = {3, 5, 6, 6, 5}`, `check` would be `{0, 0, 0, 1, 0, 2, 2, 0, 0, 0}`;\\n* proceed to destructure `n` in a similar fashion to what we did before and:\\n\\t* put quotient and remainder into `qr`;\\n\\t* return `false` if any cell of `check` matching the remainder (ie: the least significant digits) ends up being reduced below `0`;\\n\\t* update `n` to be the quotient, shaving off again the least significant digit and moving on;\\n* return `true` if we reach the end of the loop, since we successfully reduced `pos` elements in `check` without any of them going below `0`, which implies a perfect match!\\n\\nIf we are back in the main function, we will then return `false` at this point, since all the `digits` from the original `n` could not be used to make any known power of 2.\\n\\nThe code:\\n\\n```cpp\\n// precomputed values of powers, grouped by number of digits\\nstatic constexpr int powers[10][4] = {{}, {1, 2, 4, 8}, {16, 32, 64}, {128, 256, 512}, {1024, 2048, 4096, 8192}, {16384, 32768, 65536}, {131072, 262144, 524288}, {1048576, 2097152, 4194304, 8388608}, {16777216, 33554432, 67108864}, {134217728, 268435456, 536870912}};\\n\\nclass Solution {\\n    bool verifyDigits(int *digits, int pos, int n) {\\n        // support variables\\n        int check[10] = {};\\n        // preparing check\\n        for (int i = 0; i < pos; i++) check[digits[i]]++;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // verifying if the matching least significant digit can be used\\n            if (--check[qr.rem] < 0) return false;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        // support variables\\n        int digits[9], pos = 0;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // storing the least significant digit of n\\n            digits[pos++] = qr.rem;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        // checking if we have a match for any known power of 2 with the same amount of digits\\n        for (int n: powers[pos]) if (n && verifyDigits(digits, pos, n)) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n// precomputed values of powers, grouped by number of digits\\nstatic constexpr int powers[10][4] = {{}, {1, 2, 4, 8}, {16, 32, 64}, {128, 256, 512}, {1024, 2048, 4096, 8192}, {16384, 32768, 65536}, {131072, 262144, 524288}, {1048576, 2097152, 4194304, 8388608}, {16777216, 33554432, 67108864}, {134217728, 268435456, 536870912}};\\n\\nclass Solution {\\n    bool verifyDigits(int *digits, int pos, int n) {\\n        // support variables\\n        int check[10] = {};\\n        // preparing check\\n        for (int i = 0; i < pos; i++) check[digits[i]]++;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // verifying if the matching least significant digit can be used\\n            if (--check[qr.rem] < 0) return false;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        // support variables\\n        int digits[9], pos = 0;\\n        // destructuring n into its digits\\n        while (n) {\\n            auto qr = div(n, 10);\\n            // storing the least significant digit of n\\n            digits[pos++] = qr.rem;\\n            // updating n\\n            n = qr.quot;\\n        }\\n        // checking if we have a match for any known power of 2 with the same amount of digits\\n        for (int n: powers[pos]) if (n && verifyDigits(digits, pos, n)) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149975,
                "title": "a-java-solution-which-easy-understand",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int ans=1;ans<=Math.pow(10,9);ans*=2)\\n            if(equal(N,ans))\\n                return true;\\n        return false;\\n    }\\n    public boolean equal(int num1,int num2){\\n        char[] str1 = Integer.toString(num1).toCharArray(),str2 = Integer.toString(num2).toCharArray();\\n        int[] nums = new int[10];\\n        for(int i=0;i<str1.length;i++) nums[str1[i] - \\'0\\']--;\\n        for(int i=0;i<str2.length;i++) nums[str2[i] - \\'0\\']++;\\n        for(int i:nums)\\n            if(i!=0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        for(int ans=1;ans<=Math.pow(10,9);ans*=2)\\n            if(equal(N,ans))\\n                return true;\\n        return false;\\n    }\\n    public boolean equal(int num1,int num2){\\n        char[] str1 = Integer.toString(num1).toCharArray(),str2 = Integer.toString(num2).toCharArray();\\n        int[] nums = new int[10];\\n        for(int i=0;i<str1.length;i++) nums[str1[i] - \\'0\\']--;\\n        for(int i=0;i<str2.length;i++) nums[str2[i] - \\'0\\']++;\\n        for(int i:nums)\\n            if(i!=0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233498,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        while(n)\\n        {\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n)\\n     {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> Helper(long n){\\n        vector<int>num(10);\\n        while(n)\\n        {\\n            num[n%10]++;\\n            n=n/10;\\n        }\\n        return num;\\n    }\\n    bool reorderedPowerOf2(int n)\\n     {\\n        vector<int>v=Helper(n);\\n        for(int i=0;i<31;i++){\\n            if(v==Helper(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930717,
                "title": "c-clear-solution-with-explanation-runtime-0-ms-faster-than-100-00",
                "content": "1.**Brute force Approach:** Find all possible combinations of numbers that can be formed from the Given Target number\\'s digits  and for each combination check if it is a\\n power of 2 or not . (Hint :   Convert the number to string )\\n 2. **Optimised/Efficient Approach:** We can see the constraint for n is *1 <= n <= 10^9* \\n*   If somehow we can show that , with the given number\\'s digits we can form a number which is a power of 2 , then our job is done!\\n*   First of all , We will keep the count of the frequency of digits  of the given number and then we will check if the frequency count matches or not for every power of 2 within the given constraint.\\n*   Linear Time Complexity Solution \\n```\\nclass Solution {\\npublic:\\n    vector<int>nfreq;\\n    vector<int> util(int n)  // To find the freqeuncy of digits of a number\\n    {\\n        vector<int>digitFreq(10,0); \\n        \\n        while(n>0)\\n        {\\n            int rem = n%10;\\n            n = n/10;\\n            digitFreq[rem]++;\\n        }\\n        return digitFreq;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n     \\n        nfreq = util(n);\\n        for(int i= 0;i<32;++i)\\n        {\\n            if(nfreq == util(1<<i))   // Checking condition \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>nfreq;\\n    vector<int> util(int n)  // To find the freqeuncy of digits of a number\\n    {\\n        vector<int>digitFreq(10,0); \\n        \\n        while(n>0)\\n        {\\n            int rem = n%10;\\n            n = n/10;\\n            digitFreq[rem]++;\\n        }\\n        return digitFreq;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n     \\n        nfreq = util(n);\\n        for(int i= 0;i<32;++i)\\n        {\\n            if(nfreq == util(1<<i))   // Checking condition \\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485025,
                "title": "python-short-and-precise-answer",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        for i in range(32):\\n            if Counter(str(n))==Counter(str(2**i)):\\n                return True\\n        return False\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        for i in range(32):\\n            if Counter(str(n))==Counter(str(2**i)):\\n                return True\\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 2483872,
                "title": "easy-6-line-c-code-beginner-friendly-bitwise",
                "content": "class Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n      string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if( s[0]==\\'0\\') continue;\\n          int k=stoi(s);\\n            if(!(k&k-1)) return true;\\n        }while(next_permutation(s.begin(),s.end()) );\\n            return false;\\n    }\\n};\\n*Upvote if you liked the solution*",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n      string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if( s[0]==\\'0\\') continue;\\n          int k=stoi(s);\\n            if(!(k&k-1)) return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2483557,
                "title": "python-o-log-n-time-o-1-space-faster-than-100-explained-and-compared",
                "content": "# Approach\\nFor all the solutions presented here, the general approach is as follows:\\n- **Step #1**: Identify the digits `n` is made of.\\n- **Step #2**: Identify the powers of 2 that have the same number of digits as `n`; there are maximum four of them.\\n- **Step #3**: Check whether any of the powers of 2 from step **#2** are made of the same digits as identified in step **#1**.\\n\\n# Solution with the lowest time and space theoretical complexity\\n**Description**\\nThis solution uses:\\n- Integer division by 10 and modulo base 10 to identify the digits making up a given integer value.\\n- A `dict` to count the number of occurrences of each digit in a given integer value.\\n  Such a dict has maximum 10 entries.\\n- The comparison between such `dict` instances to check whether two integer values are made up the same digits.\\n\\n**Complexity**\\n- Time: `O(log(n))`\\n- Space: `O(1)`\\n\\n**Code**\\nThe code below gave me: `Runtime: 26 ms, faster than 100.00% of Python3 online submissions`\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `digitCounts` has maximum 10 entries\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `powerOf2DigitCounts` has maximum 10 entries\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\\n\\n# Faster solution: Use string conversion to get the digits\\n**Description**\\nThis solution uses:\\n- String conversion to identify the digits making up a given integer value.\\n- A `dict` to count the number of occurrences of each digit in a given integer value.\\n  Such a dict has maximum 10 entries.\\n- The comparison between such `dict` instances to check whether two integer values are made up the same digits.\\n\\n**Complexity**\\n- Time: `O(log(n))`\\n- Space: `O(log(n))`\\n\\n**Code**\\nThe code below gave me: `Runtime: 28 ms, faster than 100.00% of Python3 online submissions`\\nAgainst LeetCode\\'s test suite, this timing does not look as good as the previous solution, **BUT** this is due to LeetCode\\'s:\\n- Huge variance in running times, even for the exact same code.\\n- Test suites often no being comprehensive enough to properly differentiate algorithms.\\n\\nPlease see the *comparison* section at the end of this post to get a clear picture that this solution is globally faster than the previous one.\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate string\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate strings\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\\n\\n# Fastest solution: Sort the digits rather than counting their occurrences\\n**Description**\\nThis solution uses:\\n- String conversion to identify the digits making up a given integer value.\\n- Sorting of the digits.\\n- The comparison between such sorted lists to check whether two integer values are made up the same digits.\\n\\n**Complexity**\\n- Time: `O(log(n)*log(log(n)))`\\n- Space: `O(log(n))`\\n\\nAlthough the theoretical time complexity is worse than the previous solutions, in practice this performs noticeable faster, as:\\n- We are talking about a relatively small number of digits, so the sorting is actually very fast.\\n- The building of a list structure is much faster than the building of a counter dictionary structure.\\n\\n**Code**\\nThe code below gave me: `Runtime: 23 ms, faster than 100.00% of Python3 online submissions`\\nPlease see the *comparison* section at the end of this post to get a better sense of how much faster this solution actually is.\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and sort them\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we sort the digits and compare to the ones from step #1\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\\n\\n# Timings comparison\\nAs mentioned previously, one cannot rely on LeetCode\\'s test suites or LeetCode\\'s inconsistent running times to get a proper picture of how different algorithms actually compare.\\n\\nSo, here is some code that compares the 3 solutions presented above, and that anyone can run on their own machine.\\nIt generates 1,000,000 test cases with integers of varying sizes; out of these, 332 can be reordered into a power of 2.\\n\\n**Code**\\n```\\n# ==================================================================================================\\n# Solution with the lowest time and space theoretical complexity\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_1:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Faster solution: Use string conversion to get the digits\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_2:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Fastest solution: Sort the digits rather than counting their occurrences\\n# ==================================================================================================\\n\\nfrom math import ceil, log2\\n\\nclass Solution_3:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Testing\\n# ==================================================================================================\\n\\nfrom time import perf_counter\\n\\npowersOf2sortedDigits = frozenset(tuple(sorted(str(powerOf2))) for powerOf2 in (2 ** i for i in range(31)))\\ntestCases = [(n, tuple(sorted(str(n))) in powersOf2sortedDigits) for n in (137 * i for i in range(1, 1000001))]\\nprint(f\"{len(testCases)} test cases out of which {sum(1 for _, expected in testCases if expected is True)} return `True`\")\\n\\nfor Solution in [Solution_1, Solution_2, Solution_3]:\\n    print(f\"*** {Solution.__name__} ***\")\\n    startPerfCounter = perf_counter()\\n    for n, expected in testCases:\\n        actual = Solution().reorderedPowerOf2(n)\\n        assert actual == expected, f\"ERROR for arg {n}:\\\\n- Expected: {expected}\\\\n- Got: {actual}\"\\n    else:\\n        endPerfCounter = perf_counter()\\n        print(f\"Completed in {(endPerfCounter - startPerfCounter)}s\")\\n```\\n\\n**Results**\\nRunning this code on my laptop, I got:\\n```\\n1000000 test cases out of which 332 return `True`\\n*** Solution_1 ***\\nCompleted in 10.228865999999925s\\n*** Solution_2 ***\\nCompleted in 7.209750700000313s\\n*** Solution_3 ***\\nCompleted in 3.2113036999999167s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `digitCounts` has maximum 10 entries\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(1), as `powerOf2DigitCounts` has maximum 10 entries\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and count their occurrences\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate string\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we count digit occurrences and compare to the ones from step #1\\n        # - Time: O(log(n))\\n        # - Space: O(log(n)) for the intermediate strings\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        # Step #1: Get the digits of `n` and sort them\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        # Step #2: Identify the smallest power of 2 that has the same number of digits as `n`\\n        # - Time: O(log(n))\\n        # - Space: O(1)\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        # Step #3: Out of the powers of 2 that have the same number of digits as `n` (there are maximum four), check if any has the same digits as `n`\\n        # For this, we sort the digits and compare to the ones from step #1\\n        # - Time: O(log(n)*log(log(n)))\\n        # - Space: O(log(n))\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n```\n```\\n# ==================================================================================================\\n# Solution with the lowest time and space theoretical complexity\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_1:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        tmpValue, numDigits, digitCounts = n, 0, defaultdict(int)\\n        while tmpValue != 0:\\n            numDigits += 1\\n            tmpValue, digit = divmod(tmpValue, 10)\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            tmpValue, powerOf2DigitCounts = powerOf2, defaultdict(int)\\n            while tmpValue != 0:\\n                numDigits += 1\\n                tmpValue, digit = divmod(tmpValue, 10)\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Faster solution: Use string conversion to get the digits\\n# ==================================================================================================\\n\\nfrom collections import defaultdict\\nfrom math import ceil, log2\\n\\nclass Solution_2:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits = len(nStr)\\n        digitCounts = defaultdict(int)\\n        for digit in nStr:\\n            digitCounts[digit] += 1\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            powerOf2DigitCounts = defaultdict(int)\\n            for digit in powerOf2Str:\\n                powerOf2DigitCounts[digit] += 1\\n            if powerOf2DigitCounts == digitCounts:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Fastest solution: Sort the digits rather than counting their occurrences\\n# ==================================================================================================\\n\\nfrom math import ceil, log2\\n\\nclass Solution_3:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        nStr = str(n)\\n        numDigits, sortedDigits = len(nStr), sorted(nStr)\\n\\n        minTargetValue = 10 ** (numDigits - 1)\\n        powerOf2 = 1 << ceil(log2(minTargetValue))\\n\\n        maxTargetValue = 10 * minTargetValue - 1\\n        while powerOf2 <= maxTargetValue:\\n            powerOf2Str = str(powerOf2)\\n            if sorted(powerOf2Str) == sortedDigits:\\n                return True\\n            powerOf2 <<= 1\\n\\n        return False\\n\\n# ==================================================================================================\\n# Testing\\n# ==================================================================================================\\n\\nfrom time import perf_counter\\n\\npowersOf2sortedDigits = frozenset(tuple(sorted(str(powerOf2))) for powerOf2 in (2 ** i for i in range(31)))\\ntestCases = [(n, tuple(sorted(str(n))) in powersOf2sortedDigits) for n in (137 * i for i in range(1, 1000001))]\\nprint(f\"{len(testCases)} test cases out of which {sum(1 for _, expected in testCases if expected is True)} return `True`\")\\n\\nfor Solution in [Solution_1, Solution_2, Solution_3]:\\n    print(f\"*** {Solution.__name__} ***\")\\n    startPerfCounter = perf_counter()\\n    for n, expected in testCases:\\n        actual = Solution().reorderedPowerOf2(n)\\n        assert actual == expected, f\"ERROR for arg {n}:\\\\n- Expected: {expected}\\\\n- Got: {actual}\"\\n    else:\\n        endPerfCounter = perf_counter()\\n        print(f\"Completed in {(endPerfCounter - startPerfCounter)}s\")\\n```\n```\\n1000000 test cases out of which 332 return `True`\\n*** Solution_1 ***\\nCompleted in 10.228865999999925s\\n*** Solution_2 ***\\nCompleted in 7.209750700000313s\\n*** Solution_3 ***\\nCompleted in 3.2113036999999167s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482545,
                "title": "c-10-4bit-counters-packet-into-64bit-integer-fast-0ms",
                "content": "**Please upvote if you like the solution, it motivates me to post more of them**\\n\\n**Solution 1: 10 4bit counters packet into a 64bit integer**\\n\\nThis solution is basically do a frequency count. Since any digit (0 to 9) is for sure less frequent than 16 in a 32bit integer we can use 4 bits to count the frequency the digitis. With that we can pack 10 4bit counters easily into a 64bit integer. The solution has to functions:\\n\\nWe just need to compare the signature of ```n``` with the signature of all powers of 2.\\n\\n```\\n    bool reorderedPowerOf2(int n) {\\n        const uint64_t sig_n = signatur(n);\\n        // Compare to all powers of 2.\\n        for (int i = 0; i < 32; ++i) {\\n            if (sig_n == signatur(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n```\\n\\nThe more interesting part is to compute the singatures:\\n\\n```\\n    // We use 4 bits to count each digit.\\n    static uint64_t signatur(uint32_t n) {\\n        uint64_t sig = 0;\\n        while (n) {\\n            sig += 1UL << ((n % 10) * 4);\\n            n /= 10;\\n        }\\n        return sig;\\n    }\\n```\\n\\nAlternative to an ```uint64_t``` signature we could have used an ```array<char, 10>``` (or a similar structure) or just use a ```string``` and just sort the digits.\\n\\nAs always feedback is welcome.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```n```\n```\\n    bool reorderedPowerOf2(int n) {\\n        const uint64_t sig_n = signatur(n);\\n        // Compare to all powers of 2.\\n        for (int i = 0; i < 32; ++i) {\\n            if (sig_n == signatur(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n```\n```\\n    // We use 4 bits to count each digit.\\n    static uint64_t signatur(uint32_t n) {\\n        uint64_t sig = 0;\\n        while (n) {\\n            sig += 1UL << ((n % 10) * 4);\\n            n /= 10;\\n        }\\n        return sig;\\n    }\\n```\n```uint64_t```\n```array<char, 10>```\n```string```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482451,
                "title": "java-simplest-solution-so-far-no-bitwise",
                "content": "```\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] num = String.valueOf(n).toCharArray();\\n        Arrays.sort(num);\\n        for(int i=0;i<30;i++){\\n            int intCur = (int)Math.pow(2,i);\\n            char[] charCur = String.valueOf(intCur).toCharArray();\\n            Arrays.sort(charCur);\\n            if(Arrays.equals(num,charCur))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic boolean reorderedPowerOf2(int n) {\\n        char[] num = String.valueOf(n).toCharArray();\\n        Arrays.sort(num);\\n        for(int i=0;i<30;i++){\\n            int intCur = (int)Math.pow(2,i);\\n            char[] charCur = String.valueOf(intCur).toCharArray();\\n            Arrays.sort(charCur);\\n            if(Arrays.equals(num,charCur))\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481969,
                "title": "daily-challenge-c-100-faster-easy-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int arr[10];\\n        memset(arr,0,sizeof(arr));\\n        \\n        int x =n;\\n        for(;x>0;){\\n            int rem = x%10;\\n            arr[rem]++;\\n            x = x/10;\\n        }\\n        for(int i=0; i<31; i++){\\n            int check[10];\\n            memset(check,0,sizeof(check));\\n            int y = pow(2,i);\\n            while(y>0){\\n                int rem = y%10;\\n                check[rem]++;\\n                y = y/10;\\n            }\\n            bool flag = true;\\n            for(int j=0; j<10; j++){\\n                if(arr[j]!=check[j]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int arr[10];\\n        memset(arr,0,sizeof(arr));\\n        \\n        int x =n;\\n        for(;x>0;){\\n            int rem = x%10;\\n            arr[rem]++;\\n            x = x/10;\\n        }\\n        for(int i=0; i<31; i++){\\n            int check[10];\\n            memset(check,0,sizeof(check));\\n            int y = pow(2,i);\\n            while(y>0){\\n                int rem = y%10;\\n                check[rem]++;\\n                y = y/10;\\n            }\\n            bool flag = true;\\n            for(int j=0; j<10; j++){\\n                if(arr[j]!=check[j]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481830,
                "title": "c-easy-understand",
                "content": "# core concept\\nWe can use `2147483648%num`to determine` num` is power of 2 or not.\\nI hope this concept can help you~~~\\nif you think this is useful, please upvoted it to let more people see this article.\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if(2147483648%stoi(s)==0&&s[0]!=\\'0\\') return 1;\\n        }while(next_permutation(s.begin(), s.end()));\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        do{\\n            if(2147483648%stoi(s)==0&&s[0]!=\\'0\\') return 1;\\n        }while(next_permutation(s.begin(), s.end()));\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481280,
                "title": "c-simple-solution",
                "content": "1.  Convert our given number to string (`to_string()`)\\n2.  Sort it (`sort()`)\\n3.  Compare it will all sorted string forms of 2 power numbers upto 30 ( 2^31 > 10^9)\\n4.  If equals to anyone return `true`\\n5.  else if no-match found return `false`\\n\\n**PLEASE UPVOTE IF YOU LIKED THIS \\uD83D\\uDE09\\uD83D\\uDE4C**\\n\\n\\n\\n\\n\\n```\\nbool reorderedPowerOf2(int n) {\\n\\tstring s = sortedString(n);\\n\\tfor(int i = 0; i < 30; ++i){\\n\\t\\tif(s == sortedString(1<<i)) return true;\\n\\t}\\n\\treturn false;\\n}\\nstring sortedString(int n){\\n\\tstring s = to_string(n);\\n\\tsort(s.begin(),s.end());\\n\\treturn s;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n\\tstring s = sortedString(n);\\n\\tfor(int i = 0; i < 30; ++i){\\n\\t\\tif(s == sortedString(1<<i)) return true;\\n\\t}\\n\\treturn false;\\n}\\nstring sortedString(int n){\\n\\tstring s = to_string(n);\\n\\tsort(s.begin(),s.end());\\n\\treturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481061,
                "title": "python3-easy-understanding-sort",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        i, arr = 0, []\\n        v = 2**i\\n        while v <= 10**9: arr.append(sorted(str(v))); i+=1; v = 2**i\\n        return sorted(str(n)) in arr\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        i, arr = 0, []\\n        v = 2**i\\n        while v <= 10**9: arr.append(sorted(str(v))); i+=1; v = 2**i\\n        return sorted(str(n)) in arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481013,
                "title": "go-golang-solution",
                "content": "```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tstr := strconv.Itoa(n)\\n\\tstrByte := []byte(str)\\n\\tsort.Slice(strByte, func(i, j int) bool { return strByte[i] < strByte[j] })\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\ttmp := strconv.Itoa(1 << i)\\n\\t\\ttmpByte := []byte(tmp)\\n\\t\\tsort.Slice(tmpByte, func(i, j int) bool { return tmpByte[i] < tmpByte[j] })\\n\\t\\tif string(strByte) == string(tmpByte) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\\n\\nuse slice as counter (can\\'t use == to compare two slice)\\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) []int {\\n\\t\\tresult := make([]int, 10)\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tcompare := func(s1, s2 []int) bool {\\n\\t\\tfor i := 0; i < 10; i++ {\\n\\t\\t\\tif s1[i] != s2[i] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif compare(nCnt, count(1<<i)) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\\n\\nuse array as counter (can use == to compare two array)\\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) [10]int {\\n\\t\\tvar result [10]int\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif nCnt == count(1<<i) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tstr := strconv.Itoa(n)\\n\\tstrByte := []byte(str)\\n\\tsort.Slice(strByte, func(i, j int) bool { return strByte[i] < strByte[j] })\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\ttmp := strconv.Itoa(1 << i)\\n\\t\\ttmpByte := []byte(tmp)\\n\\t\\tsort.Slice(tmpByte, func(i, j int) bool { return tmpByte[i] < tmpByte[j] })\\n\\t\\tif string(strByte) == string(tmpByte) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) []int {\\n\\t\\tresult := make([]int, 10)\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tcompare := func(s1, s2 []int) bool {\\n\\t\\tfor i := 0; i < 10; i++ {\\n\\t\\t\\tif s1[i] != s2[i] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif compare(nCnt, count(1<<i)) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```\n```\\nfunc reorderedPowerOf2(n int) bool {\\n\\tcount := func(n int) [10]int {\\n\\t\\tvar result [10]int\\n\\t\\tfor n > 0 {\\n\\t\\t\\tresult[n%10]++\\n\\t\\t\\tn /= 10\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n\\tnCnt := count(n)\\n\\tfor i := 0; i < 31; i++ {\\n\\t\\tif nCnt == count(1<<i) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824308,
                "title": "track-with-hashmap-easy-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> powers;\\n        for(int i=1;i<=1e9;i*=2){\\n            powers.push_back(i);\\n        }\\n        \\n        map<int,int> demand;\\n        while(n>0){\\n            demand[n%10]++;\\n            n/=10;\\n        }\\n        \\n        for(auto& num:powers){\\n            map<int,int> curr;\\n            while(num>0){\\n                curr[num%10]++;\\n                num/=10;\\n            }\\n            \\n            if(curr==demand){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> powers;\\n        for(int i=1;i<=1e9;i*=2){\\n            powers.push_back(i);\\n        }\\n        \\n        map<int,int> demand;\\n        while(n>0){\\n            demand[n%10]++;\\n            n/=10;\\n        }\\n        \\n        for(auto& num:powers){\\n            map<int,int> curr;\\n            while(num>0){\\n                curr[num%10]++;\\n                num/=10;\\n            }\\n            \\n            if(curr==demand){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617077,
                "title": "easy-to-understand-python-solution",
                "content": "```\\n\\t\\tl = sorted(list(str(n)))\\n        for i in range(30):\\n            a = 2**i\\n            b = sorted(list(str(a)))\\n            if l == b:\\n                return True\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tl = sorted(list(str(n)))\\n        for i in range(30):\\n            a = 2**i\\n            b = sorted(list(str(a)))\\n            if l == b:\\n                return True\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1545432,
                "title": "java-1ms-97-25-faster",
                "content": "**Explanation**\\n1) Store the count of digits of given n in an array.\\n2) Store the count of digits of every power of 2 from 1 to 30.\\n3) If the count of digits in any of the power of 2 matches with the count of digits of given n, then return true. \\n4) If a match is not found after all iterations, that means the given number cannot be arranged in the form of a power of 2. Hence, return false.\\n```\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        int[] cnt = new int[10];\\n        int num = n;\\n        while(num != 0)\\n        {\\n            cnt[num % 10]++;\\n            num /= 10;\\n        }\\n        \\n        int two = 1;\\n        int pow = 1;\\n        while(pow <= 30)\\n        {\\n            int cur[] = new int[10];\\n            num = two;\\n            while(num != 0)\\n            {\\n                cur[num % 10]++;\\n                num /= 10;\\n            }\\n            \\n            boolean powOfTwo = true;\\n            for(int i=0; i<10; i++)\\n            {\\n                if(cnt[i] != cur[i])\\n                {\\n                    powOfTwo = false;\\n                    break;\\n                }\\n            }\\n            if(powOfTwo)\\n                return true;\\n            two *= 2;\\n            pow++;\\n        }\\n        return false;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        int[] cnt = new int[10];\\n        int num = n;\\n        while(num != 0)\\n        {\\n            cnt[num % 10]++;\\n            num /= 10;\\n        }\\n        \\n        int two = 1;\\n        int pow = 1;\\n        while(pow <= 30)\\n        {\\n            int cur[] = new int[10];\\n            num = two;\\n            while(num != 0)\\n            {\\n                cur[num % 10]++;\\n                num /= 10;\\n            }\\n            \\n            boolean powOfTwo = true;\\n            for(int i=0; i<10; i++)\\n            {\\n                if(cnt[i] != cur[i])\\n                {\\n                    powOfTwo = false;\\n                    break;\\n                }\\n            }\\n            if(powOfTwo)\\n                return true;\\n            two *= 2;\\n            pow++;\\n        }\\n        return false;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121404,
                "title": "java-simple-and-easy-solution-1-ms-faster-than-96-64-t-o-1-s-o-1-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    //store all the power of 2 digits,\\n    //only do this operation 1 time\\n    static PowerOfTwo powerOfTwo = new PowerOfTwo();\\n    \\n    public boolean reorderedPowerOf2(int N) {\\n        String numDigit = String.valueOf(N);\\n        \\n        /*\\n            Approach\\n            1. calculate one time only, power of 2\\n               and store \\n            2. for given number, if its digit is anagram of any\\n               stored power of 2 digits, return true otherwise false\\n            3. Time O(1), Space O(1)\\n        */\\n        \\n        \\n        for(String power : powerOfTwo.digits){\\n            if(isAnagrams(power, numDigit)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    private boolean isAnagrams(String str1, String str2){\\n        if(str1.length() != str2.length()) return false;\\n        \\n        int[] counts = new int[10];\\n        \\n        for(char digit : str1.toCharArray()){\\n            counts[digit - \\'0\\']++;\\n        }\\n        \\n        for(char digit : str2.toCharArray()){\\n            counts[digit - \\'0\\']--;\\n        }\\n        \\n        for(int count : counts){\\n            if(count != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nclass PowerOfTwo{\\n    String[]  digits;\\n    \\n    public PowerOfTwo(){\\n        digits = new String[30];\\n        \\n        for(int i = 0; i < digits.length; i++){\\n            digits[i] = String.valueOf((1 << i));\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //store all the power of 2 digits,\\n    //only do this operation 1 time\\n    static PowerOfTwo powerOfTwo = new PowerOfTwo();\\n    \\n    public boolean reorderedPowerOf2(int N) {\\n        String numDigit = String.valueOf(N);\\n        \\n        /*\\n            Approach\\n            1. calculate one time only, power of 2\\n               and store \\n            2. for given number, if its digit is anagram of any\\n               stored power of 2 digits, return true otherwise false\\n            3. Time O(1), Space O(1)\\n        */\\n        \\n        \\n        for(String power : powerOfTwo.digits){\\n            if(isAnagrams(power, numDigit)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    private boolean isAnagrams(String str1, String str2){\\n        if(str1.length() != str2.length()) return false;\\n        \\n        int[] counts = new int[10];\\n        \\n        for(char digit : str1.toCharArray()){\\n            counts[digit - \\'0\\']++;\\n        }\\n        \\n        for(char digit : str2.toCharArray()){\\n            counts[digit - \\'0\\']--;\\n        }\\n        \\n        for(int count : counts){\\n            if(count != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nclass PowerOfTwo{\\n    String[]  digits;\\n    \\n    public PowerOfTwo(){\\n        digits = new String[30];\\n        \\n        for(int i = 0; i < digits.length; i++){\\n            digits[i] = String.valueOf((1 << i));\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120965,
                "title": "simplest-explaned-solution",
                "content": "\\nlet say we are given a number 46. So we need to check for 46 or 64 . If anyone of them is power of two then we will return true that there exist a permutation who is Power of 2.\\n\\nDoes we need to **calculate every Permutaion :( ?**\\n**NO :)** we just need to make a digit frequency map. and then compare that to power of two\\'s .\\n As digit can have only value 0 to 9 .  So instead of map can have a array of length 10.(0 to 9)\\nTry to **understand through example :**\\nLet say N=46 \\n`InputDigit= [0,0,0,0,1,0,1,0,0,0]`\\n**Start comparing it with Powers of 2.**\\n2^0 =1 \\n`digitArray=[0,1,0,0,0,0,0,0,0,0]`\\n\\n2^1=2\\n`digitArray=[0,0,1,0,0,0,0,0,0,0]`\\n\\n2^2=4\\n`digitArray=[0,0,0,0,1,0,0,0,0,0]`\\n\\n2^3=8\\n`digitArray=[0,0,0,0,0,0,0,0,1,0]`\\n\\n2^4=16\\n`digitArray=[0,1,0,0,0,0,1,0,0,0]`\\n\\n2^5=32\\n`digitArray=[0,0,1,1,0,0,0,0,0,0]`\\n\\n2^6=64\\n`digitArray=[0,0,0,0,1,0,1,0,0,0]`**SAME AS OF INPUT DIGITS ARRAY** return true\\n\\n\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        int[] InputDigits=count(N);\\n         \\n        int powerOfTwo=1;\\n        for(int i=0;i<31;i++){\\n            int[] powerDigits=count(powerOfTwo);\\n            if(isEqual(InputDigits,powerDigits)) return true;\\n            powerOfTwo<<=1;  // leftShift basically multiplying by 2\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isEqual(int[] arr1,int[] arr2){\\n        for(int i=0;i<arr1.length;i++){\\n            if(arr1[i]!=arr2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int[] count(int n){\\n        int[] digitMap=new int[10];\\n        while(n>0){\\n            digitMap[n%10]++;\\n            n/=10;\\n        }\\n        return digitMap;\\n    }\\n}\\n```\\nPlease **UPVOTE** if found it helpful :)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        int[] InputDigits=count(N);\\n         \\n        int powerOfTwo=1;\\n        for(int i=0;i<31;i++){\\n            int[] powerDigits=count(powerOfTwo);\\n            if(isEqual(InputDigits,powerDigits)) return true;\\n            powerOfTwo<<=1;  // leftShift basically multiplying by 2\\n        }\\n        return false;\\n    }\\n    \\n    private boolean isEqual(int[] arr1,int[] arr2){\\n        for(int i=0;i<arr1.length;i++){\\n            if(arr1[i]!=arr2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int[] count(int n){\\n        int[] digitMap=new int[10];\\n        while(n>0){\\n            digitMap[n%10]++;\\n            n/=10;\\n        }\\n        return digitMap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120773,
                "title": "c-python-direct-simulation-indirect-checking-all-possibilities-of-power-of-2",
                "content": "Idea1:  Direct simulation of Permutations [1]\\nIntuition\\n\\nFor each permutation of the digits of N, let\\'s check if that permutation is a power of 2.\\n\\nAlgorithm\\n\\nThis approach has two steps: how will we generate the permutations of the digits, and how will we check that the permutation represents a power of 2?\\n\\nTo generate permutations of the digits, we place any digit into the first position (start = 0), then any of the remaining digits into the second position (start = 1), and so on. In Python, we can use the builtin function itertools.permutations.\\n\\nTo check whether a permutation represents a power of 2, we check that there is no leading zero, and divide out all factors of 2. If the result is 1 (that is, it contained no other factors besides 2), then it was a power of 2. In Python, we can use the check bin(N).count(\\'1\\') == 1.\\n\\n```\\nTime Complexity: O((logN)!\\u2217logN). Note that logN is the number of digits in the binary representation of N. For each of (logN)! permutations of the digits of N, we need to check that it is a power of 2 in O(logN) time.\\n\\nSpace Complexity: O(logN), the space used by A (or cand in Python).\\n```\\n\\nApproach 1: C++\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digits;\\n        while(N>0){\\n            digits.push_back(N%10);\\n            N /= 10;\\n        }\\n        \\n        sort(digits.begin(), digits.end());        \\n        do{\\n            if( digits[0] != 0 && __builtin_popcount(digit2num(digits)) == 1)\\n                return true;\\n        }while(next_permutation(digits.begin(), digits.end()));\\n        return false;\\n    }\\n    \\nprivate:\\n    int digit2num(vector<int>& digits){\\n        int ans = 0;\\n        for(auto digit: digits)\\n            ans = ans * 10 + digit;\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2: Python\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        for cand in itertools.permutations(str(N)):\\n            if cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1:\\n                return True\\n        return False\\n        #return any( cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1\\n        #           for cand in itertools.permutations(str(N)))\\n            #for cand in iterationtools.permutation(str(N)))\\n```\\n\\n\\n\\nIdea2: Counting\\nIntuition and Algorithm\\n\\nWe can check whether two numbers have the same digits by comparing the count of their digits. For example, 338 and 833 have the same digits because they both have exactly two 3\\'s and one 8.\\nSince NN could only be a power of 2 with 9 digits or less (namely, 2^0, 2^1, 2^31), we can just check whether NN has the same digits as any of these possibilities.\\n\\nComplexity Analysis\\n\\nTime Complexity: O( (logN)^2). There are logN different candidate powers of 2, and each comparison has O(logN) time complexity.\\nSpace Complexity: O(logN).\\n\\n\\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, N):\\n        count = collections.Counter(str(N))\\n        return any(count == collections.Counter(str(1 << b))\\n                   for b in xrange(31))\\n```\\n\\nReference:\\n[1] https://leetcode.com/problems/reordered-power-of-2/solution/\\n[2] itertools.permutations:\\nIllustration:\\n\\nN=128\\n\\n>>> for cand in itertools.permutations(str(N)):print(cand)\\n...\\n(\\'1\\', \\'2\\', \\'8\\')\\n(\\'1\\', \\'8\\', \\'2\\')\\n(\\'2\\', \\'1\\', \\'8\\')\\n(\\'2\\', \\'8\\', \\'1\\')\\n(\\'8\\', \\'1\\', \\'2\\')\\n(\\'8\\', \\'2\\', \\'1\\')\\n>>> for cand in itertools.permutations([1,2,8]):print(cand)\\n...\\n(1, 2, 8)\\n(1, 8, 2)\\n(2, 1, 8)\\n(2, 8, 1)\\n(8, 1, 2)\\n(8, 2, 1)",
                "solutionTags": [
                    "Python",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nTime Complexity: O((logN)!\\u2217logN). Note that logN is the number of digits in the binary representation of N. For each of (logN)! permutations of the digits of N, we need to check that it is a power of 2 in O(logN) time.\\n\\nSpace Complexity: O(logN), the space used by A (or cand in Python).\\n```\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digits;\\n        while(N>0){\\n            digits.push_back(N%10);\\n            N /= 10;\\n        }\\n        \\n        sort(digits.begin(), digits.end());        \\n        do{\\n            if( digits[0] != 0 && __builtin_popcount(digit2num(digits)) == 1)\\n                return true;\\n        }while(next_permutation(digits.begin(), digits.end()));\\n        return false;\\n    }\\n    \\nprivate:\\n    int digit2num(vector<int>& digits){\\n        int ans = 0;\\n        for(auto digit: digits)\\n            ans = ans * 10 + digit;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        for cand in itertools.permutations(str(N)):\\n            if cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1:\\n                return True\\n        return False\\n        #return any( cand[0]!=\\'0\\' and bin(int(\"\".join(cand))).count(\\'1\\') ==1\\n        #           for cand in itertools.permutations(str(N)))\\n            #for cand in iterationtools.permutation(str(N)))\\n```\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, N):\\n        count = collections.Counter(str(N))\\n        return any(count == collections.Counter(str(1 << b))\\n                   for b in xrange(31))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120255,
                "title": "reordered-power-of-2-beats-100-c",
                "content": "The steps for solution to this problem are :\\n* Store all the powers of 2 in a vector\\n* Compare each numbner in vector with the given number to check if both have same digits .\\n* If both have same digits , return true\\n* else return false .\\nPls upvote if u feel it is correct and suggest if it can be improved .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int comp(int a,int b)\\n    {\\n        bool A[10]={0},B[10]={0};\\n        int lena=0,lenb=0;\\n        while(a>0 || b>0)\\n        {\\n            if(a>0)\\n            {\\n                A[a%10]=1;\\n                a/=10;\\n                lena++;\\n            }\\n            if(b>0)\\n            {\\n                B[b%10]=1;\\n                b/=10;\\n                lenb++;\\n            }\\n        }\\n        \\n        if(lena!=lenb)\\n            return false;\\n        \\n        for(int i=0 ;i<10 ;i++)\\n            if(A[i]!=B[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int N) {\\n        int k=1;\\n        vector<int> v;\\n        for(int i=0 ;i<30 ;i++)\\n        {\\n            v.push_back(k);\\n            k*=2;\\n        }\\n        \\n        for(int i=0 ;i<=30 ;i++)\\n        {\\n            if(comp(N,v[i]))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int comp(int a,int b)\\n    {\\n        bool A[10]={0},B[10]={0};\\n        int lena=0,lenb=0;\\n        while(a>0 || b>0)\\n        {\\n            if(a>0)\\n            {\\n                A[a%10]=1;\\n                a/=10;\\n                lena++;\\n            }\\n            if(b>0)\\n            {\\n                B[b%10]=1;\\n                b/=10;\\n                lenb++;\\n            }\\n        }\\n        \\n        if(lena!=lenb)\\n            return false;\\n        \\n        for(int i=0 ;i<10 ;i++)\\n            if(A[i]!=B[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int N) {\\n        int k=1;\\n        vector<int> v;\\n        for(int i=0 ;i<30 ;i++)\\n        {\\n            v.push_back(k);\\n            k*=2;\\n        }\\n        \\n        for(int i=0 ;i<=30 ;i++)\\n        {\\n            if(comp(N,v[i]))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120112,
                "title": "rust-counting-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        let digit_counts = |n: i32| -> [usize; 10] {\\n            let mut n = n;\\n            let mut d = [0; 10];\\n            while n > 0 {\\n                d[(n % 10) as usize] += 1;\\n                n /= 10;\\n            }\\n            d\\n        };\\n        let counts = digit_counts(n);\\n        (0..31).any(|i| digit_counts(1 << i) == counts)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        let digit_counts = |n: i32| -> [usize; 10] {\\n            let mut n = n;\\n            let mut d = [0; 10];\\n            while n > 0 {\\n                d[(n % 10) as usize] += 1;\\n                n /= 10;\\n            }\\n            d\\n        };\\n        let counts = digit_counts(n);\\n        (0..31).any(|i| digit_counts(1 << i) == counts)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120035,
                "title": "python",
                "content": "As `N` is bounded by 10^9 we need to check at most the 30-th power of 2. For each power of 2 we count the occurrence of every digit and store it in an array of size 10 (from 0,...,9). If for any power of 2 the count matches that of `N` we return True. Else return False.\\n\\nTime: `O(1)`\\nSpace: `O(1)`\\n\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        def is_equal(c1, c2):\\n            return sum(abs(x-y) for x,y in zip(c1,c2))==0\\n        \\n        \\n        def count(n):\\n            c = [0]*10\\n            while n:\\n                c[n % 10] += 1\\n                n //= 10\\n            return c\\n        \\n        \\n        c1 = count(N)\\n        for i in range(31):\\n            c2 = count(2**i)\\n            if is_equal(c1, c2):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N):\\n        def is_equal(c1, c2):\\n            return sum(abs(x-y) for x,y in zip(c1,c2))==0\\n        \\n        \\n        def count(n):\\n            c = [0]*10\\n            while n:\\n                c[n % 10] += 1\\n                n //= 10\\n            return c\\n        \\n        \\n        c1 = count(N)\\n        for i in range(31):\\n            c2 = count(2**i)\\n            if is_equal(c1, c2):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980748,
                "title": "easy-short-understandable-code-in-c",
                "content": "#using compare function for removing 0 as first digit\\n```\\nstatic bool com(char a,char b){\\n        return a>b;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n       string s= to_string(N);\\n        int n=s.size();\\n        int k=1;\\n        string p;\\n        sort(s.begin(),s.end(),com);\\n        while(n>=p.size())\\n        {\\n            p=to_string(k);\\n            sort(p.begin(),p.end(),com);  //sort every power of twofor checking \\n            if(s==p)\\n                return 1;\\n            k=k<<1; //using for finding next power of two\\n        }\\n        return 0;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic bool com(char a,char b){\\n        return a>b;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n       string s= to_string(N);\\n        int n=s.size();\\n        int k=1;\\n        string p;\\n        sort(s.begin(),s.end(),com);\\n        while(n>=p.size())\\n        {\\n            p=to_string(k);\\n            sort(p.begin(),p.end(),com);  //sort every power of twofor checking \\n            if(s==p)\\n                return 1;\\n            k=k<<1; //using for finding next power of two\\n        }\\n        return 0;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149928,
                "title": "python-easy-to-understand-with-explanation",
                "content": "Since the leading digit is not zero, the reordered number shares the same number of digits with original one.\\nThe search base can be greatly reduced.\\nReturn true if `Counter(N) == Counter(power of 2) and NumberOfDigits(N) == NumberOfDigits(power of 2)`\\n\\n```python\\n    def reorderedPowerOf2(self, N):\\n        from collections import Counter\\n\\n        digits_of_n = len(str(N))\\n        counter = Counter(str(N))\\n        power = 1\\n\\n        while True:\\n            digits_of_power = len(str(power))\\n\\n            if digits_of_power > digits_of_n:\\n                break\\n            \\n            if digits_of_power == digits_of_n and Counter(str(power)) == counter:\\n                return True\\n\\n            power = power*2\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\n    def reorderedPowerOf2(self, N):\\n        from collections import Counter\\n\\n        digits_of_n = len(str(N))\\n        counter = Counter(str(N))\\n        power = 1\\n\\n        while True:\\n            digits_of_power = len(str(power))\\n\\n            if digits_of_power > digits_of_n:\\n                break\\n            \\n            if digits_of_power == digits_of_n and Counter(str(power)) == counter:\\n                return True\\n\\n            power = power*2\\n\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2952889,
                "title": "js-easiest-to-follow-one-glance-you-will-get-it-fastest",
                "content": "Have fun :)\\n\\n# Intuition\\nhttps://onlinenumbertools.com/sort-digits\\n\\n\\n# Code\\n```\\nvar reorderedPowerOf2 = function (n) {\\n  const vals = new Set([\"1\",\"2\",\"4\",\"8\",\"16\",\"23\",\"46\",\"128\",\"256\",\"125\",\"0124\",\"0248\",\"0469\",\"1289\",\"13468\",\"23678\",\"35566\",\"011237\",\"122446\",\"224588\",\"0145678\",\"0122579\",\"0134449\",\"0368888\",\"11266777\",\"23334455\",\"01466788\",\"112234778\",\"234455668\",\"012356789\",]);\\n   return vals.has((\"\" + n).split(\"\").sort((a, b) => a - b).join(\"\"))\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderedPowerOf2 = function (n) {\\n  const vals = new Set([\"1\",\"2\",\"4\",\"8\",\"16\",\"23\",\"46\",\"128\",\"256\",\"125\",\"0124\",\"0248\",\"0469\",\"1289\",\"13468\",\"23678\",\"35566\",\"011237\",\"122446\",\"224588\",\"0145678\",\"0122579\",\"0134449\",\"0368888\",\"11266777\",\"23334455\",\"01466788\",\"112234778\",\"234455668\",\"012356789\",]);\\n   return vals.has((\"\" + n).split(\"\").sort((a, b) => a - b).join(\"\"))\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2827694,
                "title": "java-100-faster-1-ms-solution-explained",
                "content": "# Approach\\nExplanation.\\n\\n**Occur** is an 2d array which stores occurrences of all digits of each number (power of 2). \\n\\nExample: 2^16 = 65536, array with occurences of digits for it will be: [0,0,0,1,0,2,2,0,0,0], because we have one occurence of 3, two occurences of 5, and two occurences of 6.\\n\\n**Occur** is $$static$$ because I fill it only once and use for each test case.\\n\\nThe names of methods are self explainable.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static byte[][] ocurr;\\n\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            //increment digits frequency for number pow\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static byte[][] ocurr;\\n\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            //increment digits frequency for number pow\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783380,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n\\t\\t\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int p = pow(2,i);\\n            power.push_back(to_string(p));\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        \\n        for(int i=0;i<=30;i++){\\n            if(power[i] == s ) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516026,
                "title": "understanding-reordered-power-of-2-in-3-basic-steps",
                "content": "I broke it down into 3 core parts:\\n1. Identify individual digits of the number\\n2. Identify valid permutations of the digits\\n3. Test to see if a permutation is a power of 2.\\n\\n**Step 1:  Identify the Digits**\\nIf I as a human see the number 1,024, I\\'ll list the digits from left-to-right:  1, 0, 2, 4.  But if I want a computer to do it, I\\'m better off going from right-to-left:  4, 2, 0, 1.  How can we make the computer do this?  How can we ask it to tell us, \"What\\'s in the 1\\'s column?\"\\n\\n1. Divide the number by 10:  `1024 / 10 = 102`\\n2. Multiply by it by 10:  `102 * 10 = 1020`\\n3. Subtract this result from the original value:  `1024 - 1020 = 4`\\n\\nJust divide the original number by 10 and repeat the process until you run out of digits!\\n\\n**Step 2:  Identify Valid Permutations**\\nHow many different ways can we arrange these digits, and what are they?  Well, do we actually care?  We don\\'t really need to *enumerate* the permutations, we just need to *identify* them.  That\\'s a boolean test.  If I ask you, \"Is 4210 a permutation of the digits in 1024?\" how do you answer that question?  If you\\'re like me, you just check to see if all digits have been used. \\n\\nYou can use an integer array of length 10 to count the digits in the input number.  For each digit observed in step 1, increment the corresponding index in the array.  Using 1024 (or 4210!) as our example, the resulting array should be:  `[1, 1, 1, 0, 1, 0, 0, 0, 0, 0]`\\n\\nIf our input number was `55,963,220`, the array would be:   `[1, 0, 2, 1, 0, 2, 1, 0, 0, 1]`\\n\\nIf two numbers\\' arrays are equal, then the digits of one number can be rearranged to make the other!\\n\\n**Step 3: Test Powers of 2**\\nWho remembers their big O times?  What grows faster:  `O(x^2)`, or `O(2^x)`?  The anwer is the latter. `2^x` grows pretty quickly.  In fact, `2^30 == 1,073,741,824`, and that\\'s greater than a billion.  The problem statement says that n will be less than 10 to the 9th, which means we only have 30 dfferent powers of 2 that we\\'d need to test.  That\\'s a pretty small data set to test!  Just generate powers of 2, and extract their digits into an array, and compare to the array of digits for our given number.  If they match, it means our number can be rearranged to make a power of 2.",
                "solutionTags": [],
                "code": "I broke it down into 3 core parts:\\n1. Identify individual digits of the number\\n2. Identify valid permutations of the digits\\n3. Test to see if a permutation is a power of 2.\\n\\n**Step 1:  Identify the Digits**\\nIf I as a human see the number 1,024, I\\'ll list the digits from left-to-right:  1, 0, 2, 4.  But if I want a computer to do it, I\\'m better off going from right-to-left:  4, 2, 0, 1.  How can we make the computer do this?  How can we ask it to tell us, \"What\\'s in the 1\\'s column?\"\\n\\n1. Divide the number by 10:  `1024 / 10 = 102`\\n2. Multiply by it by 10:  `102 * 10 = 1020`\\n3. Subtract this result from the original value:  `1024 - 1020 = 4`\\n\\nJust divide the original number by 10 and repeat the process until you run out of digits!\\n\\n**Step 2:  Identify Valid Permutations**\\nHow many different ways can we arrange these digits, and what are they?  Well, do we actually care?  We don\\'t really need to *enumerate* the permutations, we just need to *identify* them.  That\\'s a boolean test.  If I ask you, \"Is 4210 a permutation of the digits in 1024?\" how do you answer that question?  If you\\'re like me, you just check to see if all digits have been used. \\n\\nYou can use an integer array of length 10 to count the digits in the input number.  For each digit observed in step 1, increment the corresponding index in the array.  Using 1024 (or 4210!) as our example, the resulting array should be:  `[1, 1, 1, 0, 1, 0, 0, 0, 0, 0]`\\n\\nIf our input number was `55,963,220`, the array would be:   `[1, 0, 2, 1, 0, 2, 1, 0, 0, 1]`\\n\\nIf two numbers\\' arrays are equal, then the digits of one number can be rearranged to make the other!\\n\\n**Step 3: Test Powers of 2**\\nWho remembers their big O times?  What grows faster:  `O(x^2)`, or `O(2^x)`?  The anwer is the latter. `2^x` grows pretty quickly.  In fact, `2^30 == 1,073,741,824`, and that\\'s greater than a billion.  The problem statement says that n will be less than 10 to the 9th, which means we only have 30 dfferent powers of 2 that we\\'d need to test.  That\\'s a pretty small data set to test!  Just generate powers of 2, and extract their digits into an array, and compare to the array of digits for our given number.  If they match, it means our number can be rearranged to make a power of 2.",
                "codeTag": "Unknown"
            },
            {
                "id": 2484929,
                "title": "simple-solution-using-next-permutation-to-find-the-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> tovector(int n){\\n        vector<int> ans;\\n        while(n!=0){\\n            ans.push_back(n%10);\\n            n = n/10;\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    // [5,2,1]\\n    \\n    int toInteger(vector<int> &ans){\\n        int nums = 0;\\n        for(auto x : ans){\\n            nums = nums*10 + x;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n      vector<int> vec = tovector(n);\\n      do{\\n          if(vec.size() == 1 && vec[0] == 1) return true;\\n          if(vec[0] == 0 ||((vec[vec.size()-1]%2 ==1))){\\n              continue;\\n          }\\n          int n = toInteger(vec);\\n          if((n &(n-1)) == 0) return true;\\n          \\n      }while(next_permutation(vec.begin(),vec.end()));\\n      return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> tovector(int n){\\n        vector<int> ans;\\n        while(n!=0){\\n            ans.push_back(n%10);\\n            n = n/10;\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    // [5,2,1]\\n    \\n    int toInteger(vector<int> &ans){\\n        int nums = 0;\\n        for(auto x : ans){\\n            nums = nums*10 + x;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n      vector<int> vec = tovector(n);\\n      do{\\n          if(vec.size() == 1 && vec[0] == 1) return true;\\n          if(vec[0] == 0 ||((vec[vec.size()-1]%2 ==1))){\\n              continue;\\n          }\\n          int n = toInteger(vec);\\n          if((n &(n-1)) == 0) return true;\\n          \\n      }while(next_permutation(vec.begin(),vec.end()));\\n      return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484157,
                "title": "ruby-set-of-strings",
                "content": "## Leetcode: 869. Reordered Power of 2.\\n\\n\\n**Ruby: Set of strings.**\\n\\n1. Need to get an array of powers of two till `10**9`.\\n2. Convert these numbers to strings and sort chars. Create a set from the array.\\n3. Convert inpur to string sort chars join and check does in include in the set.\\n\\nLet\\'s try.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 869. Reordered Power of 2.\\n# https://leetcode.com/problems/reordered-power-of-2/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 82 ms, faster than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# Memory Usage: 210.9 MB, less than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# @param {Integer} n\\n# @return {Boolean}\\ndef reordered_power_of2(n)\\n  require \"set\"\\n  @two ||= get_powers_of_2()\\n    .map{|x| x.to_s.chars.sort.join}.to_set\\n  @two.include?(n.to_s.chars.sort.join)\\nend\\n\\ndef get_powers_of_2()\\n  answer = []\\n  value = 1\\n  border = 10**9 \\n  while value <= border\\n    answer.push value\\n    value *= 2\\n  end\\n  answer\\nend\\n\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Ordered Set"
                ],
                "code": "```Ruby\\n# Leetcode: 869. Reordered Power of 2.\\n# https://leetcode.com/problems/reordered-power-of-2/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 82 ms, faster than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# Memory Usage: 210.9 MB, less than 100.00% of Ruby online submissions for Reordered Power of 2.\\n# @param {Integer} n\\n# @return {Boolean}\\ndef reordered_power_of2(n)\\n  require \"set\"\\n  @two ||= get_powers_of_2()\\n    .map{|x| x.to_s.chars.sort.join}.to_set\\n  @two.include?(n.to_s.chars.sort.join)\\nend\\n\\ndef get_powers_of_2()\\n  answer = []\\n  value = 1\\n  border = 10**9 \\n  while value <= border\\n    answer.push value\\n    value *= 2\\n  end\\n  answer\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2484091,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] num = getArr(n);\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = getArr(1 << i);\\n            if (Arrays.equals(num, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public char[] getArr(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] num = getArr(n);\\n        for (int i = 0; i < 30; ++i) {\\n            char[] powerOfTwo = getArr(1 << i);\\n            if (Arrays.equals(num, powerOfTwo))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    public char[] getArr(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        Arrays.sort(digits);\\n        return digits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484063,
                "title": "c-0ms-solution-easy-to-understand-short-code",
                "content": "1) Create a vector of strings \"v\" of size 30 where each string represents a power of 2 (from 0 to 30) with its digits in sorted form.\\n2) Convert the given number to string \"s\" and sort its digits as well.\\n3) Compare the resultant string \"s\" with each element of the vector of strings \"v\".\\n4) Return true if a match is found else return false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> v;\\n        for(int i=0;i<30;i++)\\n        {\\n            int k=pow(2,i);\\n            string c=to_string(k);\\n            sort(c.begin(),c.end());\\n            v.push_back(c);\\n        }\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(auto it:v)\\n        {\\n            if(s==it)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> v;\\n        for(int i=0;i<30;i++)\\n        {\\n            int k=pow(2,i);\\n            string c=to_string(k);\\n            sort(c.begin(),c.end());\\n            v.push_back(c);\\n        }\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(auto it:v)\\n        {\\n            if(s==it)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482968,
                "title": "rust-solution",
                "content": "```\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n\\n        let mut log = (n as f32).log2();\\n        if n == i32::pow(2, log as u32) {\\n            return true;\\n        }\\n\\n        let mut n_s = n.to_string().chars().collect::<Vec<char>>();\\n\\n        n_s.sort();\\n\\n        for i in 0..30 {\\n            let pow_2 = i64::pow(2, i);\\n            \\n\\n            let mut pow_2_s = pow_2.to_string().chars().collect::<Vec<char>>();\\n\\n            pow_2_s.sort();\\n\\n            if pow_2_s == n_s {\\n                println!(\"found at {}\", pow_2);\\n                return true;\\n            }\\n            \\n            \\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n\\n        let mut log = (n as f32).log2();\\n        if n == i32::pow(2, log as u32) {\\n            return true;\\n        }\\n\\n        let mut n_s = n.to_string().chars().collect::<Vec<char>>();\\n\\n        n_s.sort();\\n\\n        for i in 0..30 {\\n            let pow_2 = i64::pow(2, i);\\n            \\n\\n            let mut pow_2_s = pow_2.to_string().chars().collect::<Vec<char>>();\\n\\n            pow_2_s.sort();\\n\\n            if pow_2_s == n_s {\\n                println!(\"found at {}\", pow_2);\\n                return true;\\n            }\\n            \\n            \\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482867,
                "title": "python-simple-python-solution-using-two-different-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# 1. First Apporach Using Permutation Concept : \\n# Runtime: 8288 ms, faster than 5.35% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 28.1 MB, less than 11.23% of Python3 online submissions for Reordered Power of 2.\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tall_permutations = [] \\n\\n\\t\\t\\tfor single_number in itertools.permutations(str(n)):\\n\\n\\t\\t\\t\\tif single_number[0] != \\'0\\':\\n\\n\\t\\t\\t\\t\\tnum = int(\\'\\'.join(single_number))\\n\\n\\t\\t\\t\\t\\tall_permutations.append(num)\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tif 2**i in all_permutations:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# 2. Second Approach With HashMap Or Dictionary with Sorting : \\n# Runtime: 56 ms, faster than 60.96% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 13.7 MB, less than 96.79% of Python3 online submissions for Reordered Power of 2.\\n\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tnum = sorted(str(n))\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tcurrent_num = sorted(str(2**i))\\n\\n\\t\\t\\t\\tif num == current_num:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Probability and Statistics"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# 1. First Apporach Using Permutation Concept : \\n# Runtime: 8288 ms, faster than 5.35% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 28.1 MB, less than 11.23% of Python3 online submissions for Reordered Power of 2.\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tall_permutations = [] \\n\\n\\t\\t\\tfor single_number in itertools.permutations(str(n)):\\n\\n\\t\\t\\t\\tif single_number[0] != \\'0\\':\\n\\n\\t\\t\\t\\t\\tnum = int(\\'\\'.join(single_number))\\n\\n\\t\\t\\t\\t\\tall_permutations.append(num)\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tif 2**i in all_permutations:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# 2. Second Approach With HashMap Or Dictionary with Sorting : \\n# Runtime: 56 ms, faster than 60.96% of Python3 online submissions for Reordered Power of 2.\\n# Memory Usage: 13.7 MB, less than 96.79% of Python3 online submissions for Reordered Power of 2.\\n\\n\\tclass Solution:\\n\\t\\tdef reorderedPowerOf2(self, n: int) -> bool:\\n\\n\\t\\t\\tnum = sorted(str(n))\\n\\n\\t\\t\\tfor i in range(32):\\n\\n\\t\\t\\t\\tcurrent_num = sorted(str(2**i))\\n\\n\\t\\t\\t\\tif num == current_num:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2482646,
                "title": "easy-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        char[] car1 = (\"\" + n).toCharArray(); \\n\\t\\tArrays.sort(car1);\\n\\n        for(int i = 0; i < 30;i++){\\n            char[] car2 = (\"\" + (1 << i)).toCharArray(); \\n\\t\\t\\tArrays.sort(car2);\\n            if(Arrays.equals(car1, car2)) return true;\\n        }\\n\\n        return false;",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482476,
                "title": "asymptotic-o-1-constant-time-solution-faster-than-100-explanation",
                "content": "```\\nclass Solution { // 0ms - 100.00% Faster \\n    static HashSet<String> set;\\n    Solution(){ // this checks if the set is null, or it computes all the powers of 2 and stores it in the set(this operation occurs only once)\\n        if(set==null){\\n            set = new HashSet<String>();\\n            for(long i=1;i<=1000000000;i=i<<1){\\n                String s = getFrequencyChart(i);\\n                set.add(s);\\n            }\\n        }\\n    }\\n    private String getFrequencyChart(long n){ // this is the function to calculate the frequency of all the digits in the array\\n        int[] freq = new int[10];\\n        while(n>0){\\n            freq[(int)n%10]++;\\n            n/=10;\\n        }\\n        return Arrays.toString(freq);\\n    }\\n    \\n    public boolean reorderedPowerOf2(int n) {\\n        return set.contains(getFrequencyChart((long)n));\\n    }\\n}\\n```\\nExplanation:\\n* Which we are setting the map as static, it creates only one `set` map object for all the object of the Solution class. Thus reducing the time to recalculate the set\\n* `getFrequencyChart generates a frequency map of a number\\'s digits and returns it which is used as a hashset key\\n* In the Main Function we are just checking if the frequencies of the given numbers matches with the any power of 2.\\n\\n`Please Upvote if you find it helpful` \\uD83D\\uDE4F\\uD83D\\uDE4F",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution { // 0ms - 100.00% Faster \\n    static HashSet<String> set;\\n    Solution(){ // this checks if the set is null, or it computes all the powers of 2 and stores it in the set(this operation occurs only once)\\n        if(set==null){\\n            set = new HashSet<String>();\\n            for(long i=1;i<=1000000000;i=i<<1){\\n                String s = getFrequencyChart(i);\\n                set.add(s);\\n            }\\n        }\\n    }\\n    private String getFrequencyChart(long n){ // this is the function to calculate the frequency of all the digits in the array\\n        int[] freq = new int[10];\\n        while(n>0){\\n            freq[(int)n%10]++;\\n            n/=10;\\n        }\\n        return Arrays.toString(freq);\\n    }\\n    \\n    public boolean reorderedPowerOf2(int n) {\\n        return set.contains(getFrequencyChart((long)n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482244,
                "title": "100-faster-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n\\n    bool equal(vector<int>&a,vector<int>&b ){\\n        for(int i=0;i<10;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    vector<int> freq(int n){\\n        vector<int>f(10,0);\\n        while(n>0){\\n            f[n%10]++;\\n            n/=10;\\n        }\\n        return f;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        vector<int>a(10,0);\\n        vector<int>b(10,0);\\n        a=freq(n);\\n        for(int i=0;i<31;i++){\\n            b=freq(pow(2,i));\\n            if(equal(a,b))return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool equal(vector<int>&a,vector<int>&b ){\\n        for(int i=0;i<10;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    vector<int> freq(int n){\\n        vector<int>f(10,0);\\n        while(n>0){\\n            f[n%10]++;\\n            n/=10;\\n        }\\n        return f;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        vector<int>a(10,0);\\n        vector<int>b(10,0);\\n        a=freq(n);\\n        for(int i=0;i<31;i++){\\n            b=freq(pow(2,i));\\n            if(equal(a,b))return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482202,
                "title": "rust-run-time-one-liner-and-the-nerdiest-approach-you-will-ever-see-p-with-comments",
                "content": "So I wasn\\'t the only one to think about precomputation here... Anyway, my \"standard\" solution is below, and then we\\'ll go really crazy with an idea I had below that, which you really don\\'t want to miss :D.\\n\\nI love how easy it is to compute things at compile time in Rust compared to C++\\'s `constexpr`. So for the \"standard\" solution I use that to build a look-up table with the digit histograms of all the powers of two <= 10^9 (there are 30). At runtime, I only have to build the histogram of the given number, and check if it is in the lookup table.\\n\\n**\"Standard\" Solution**\\n\\n```\\nconst N_DIGITS: usize = 10;\\n\\nconst fn build_histogram(mut n: i32) -> [u8; N_DIGITS] {\\n    let mut rez = [0; N_DIGITS];\\n    while n > 0 {\\n        rez[(n % 10) as usize] += 1;\\n        n /= 10;\\n    }\\n    rez\\n}\\n\\nconst N_POWERS: usize = 30;\\n\\nconst fn compute_power_histograms() -> [[u8; N_DIGITS]; N_POWERS] {\\n    let mut i = 0;\\n    let mut rez = [[0; N_DIGITS]; N_POWERS];\\n    while i < N_POWERS {\\n        rez[i] = build_histogram(1 << i);\\n        i += 1;\\n    }\\n    rez\\n}\\n\\nconst POWER_HISTOGRAMS: [[u8; N_DIGITS]; N_POWERS] = compute_power_histograms();\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        POWER_HISTOGRAMS.contains(&build_histogram(n))\\n    }\\n}\\n```\\n\\n**Graph Solution**\\n\\nSo, what if we build a graph of all the valid paths we can take given the digits as edges? We\\'ll mark whether each node is a valid leaf or not. The result is that when we traverse the graph e.g. 64 and 46 both end up at the same leaf node. The benefit of this approach is that we will be able to weed out a number as soon as we encounter a digit that is not on a valid path, since the tail node won\\'t have an edge for the next digit. Compare that to the \"standard\" solution where we *have* to have all the digits of `n` before checking if it\\'s a valid power of two (yeah, yeah, big-O time complexities are the same, but let\\'s have some fun :) ) We\\'ll use a separate program to compute the graph (I have pasted that in at the very bottom of this post), and we\\'ll use the computed graph as a constant that gets compiled into our program for solving the problem. Here is the finished solution (it\\'s long :) ):\\n\\n```\\nconst N_DIGITS: usize = 10;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(mut n: i32) -> bool {\\n        let mut node = 0;\\n        while n > 0 {\\n            let digit = (n % 10) as usize;\\n            match GRAPH[node].0[digit] {\\n                0 => return false,\\n                next_node => node = next_node,\\n            }\\n            n /= 10;\\n        }\\n        GRAPH[node].1\\n    }\\n}\\n\\nconst GRAPH: [([usize; N_DIGITS], bool); 1203] = [\\n    ([31, 1, 2, 7, 3, 17, 5, 87, 4, 38], false),\\n    ([30, 139, 13, 75, 25, 20, 6, 123, 12, 54], true),\\n    ([29, 13, 162, 8, 21, 18, 16, 94, 10, 52], true),\\n    ([27, 25, 21, 73, 154, 184, 9, 261, 32, 43], true),\\n    ([37, 12, 10, 66, 32, 176, 55, 76, 164, 48], true),\\n    ([47, 6, 16, 71, 9, 14, 96, 88, 55, 39], false),\\n    ([273, 460, 153, 72, 70, 269, 457, 250, 62, 1072], true),\\n    ([136, 75, 8, 512, 73, 107, 71, 92, 66, 363], false),\\n    ([132, 128, 733, 515, 511, 501, 95, 93, 86, 1082], true),\\n    ([46, 70, 147, 68, 141, 265, 581, 246, 56, 40], true),\\n    ([36, 11, 183, 86, 33, 180, 85, 83, 174, 49], false),\\n    ([1153, 672, 670, 667, 661, 1147, 1138, 649, 0, 50], true),\\n    ([237, 673, 11, 67, 65, 233, 62, 215, 557, 51], false),\\n    ([28, 137, 163, 128, 22, 19, 153, 118, 11, 53], false),\\n    ([271, 269, 15, 104, 265, 102, 97, 238, 218, 1044], false),\\n    ([1190, 1188, 0, 868, 867, 860, 842, 1162, 792, 1053], true),\\n    ([1196, 153, 151, 95, 147, 15, 454, 91, 85, 1068], false),\\n    ([278, 20, 18, 107, 184, 105, 14, 253, 176, 303], false),\\n    ([338, 19, 187, 501, 185, 482, 15, 322, 180, 304], false),\\n    ([337, 0, 334, 1197, 0, 0, 1188, 327, 1147, 309], true),\\n    ([277, 0, 19, 1200, 274, 0, 269, 258, 233, 312], false),\\n    ([24, 22, 160, 511, 155, 185, 147, 713, 33, 0], false),\\n    ([23, 731, 161, 727, 158, 0, 150, 717, 661, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 23, 0, 0, 0, 0, 0, 0, 34, 0], false),\\n    ([26, 732, 22, 74, 159, 274, 70, 262, 65, 361], false),\\n    ([0, 0, 23, 381, 379, 275, 272, 263, 236, 362], false),\\n    ([0, 26, 24, 382, 380, 276, 46, 264, 35, 44], false),\\n    ([0, 138, 339, 131, 23, 337, 1195, 121, 1153, 319], false),\\n    ([0, 28, 340, 132, 24, 338, 1196, 122, 36, 320], false),\\n    ([0, 140, 28, 135, 26, 277, 273, 126, 237, 321], false),\\n    ([0, 30, 29, 136, 27, 278, 47, 127, 37, 45], false),\\n    ([35, 65, 33, 63, 819, 177, 56, 211, 171, 0], false),\\n    ([34, 661, 182, 652, 822, 178, 798, 632, 172, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 236, 34, 0, 0, 232, 227, 214, 556, 0], false),\\n    ([0, 1153, 0, 1151, 34, 1149, 1140, 1124, 0, 993], false),\\n    ([0, 237, 36, 407, 35, 235, 229, 217, 405, 995], false),\\n    ([45, 54, 52, 363, 43, 303, 39, 279, 48, 0], false),\\n    ([42, 1072, 1068, 1060, 40, 1044, 0, 996, 936, 0], false),\\n    ([41, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 1073, 1071, 1067, 41, 1059, 0, 1027, 967, 0], false),\\n    ([44, 361, 0, 357, 341, 0, 40, 0, 0, 0], false),\\n    ([0, 362, 0, 360, 356, 0, 41, 0, 0, 0], false),\\n    ([0, 321, 320, 366, 44, 314, 42, 302, 995, 0], false),\\n    ([0, 272, 0, 0, 0, 268, 584, 249, 227, 41], false),\\n    ([0, 273, 1196, 408, 46, 271, 586, 252, 229, 42], false),\\n    ([995, 51, 49, 984, 0, 968, 936, 872, 0, 0], false),\\n    ([993, 50, 0, 985, 0, 977, 961, 929, 0, 0], false),\\n    ([992, 0, 0, 986, 0, 978, 962, 930, 0, 0], true),\\n    ([994, 0, 50, 989, 0, 981, 965, 933, 0, 0], false),\\n    ([320, 53, 315, 1082, 0, 304, 1068, 292, 49, 0], false),\\n    ([319, 0, 316, 1083, 0, 309, 1069, 297, 50, 0], false),\\n    ([321, 0, 53, 364, 361, 312, 1072, 300, 51, 0], false),\\n    ([229, 62, 85, 60, 56, 218, 567, 77, 399, 936], false),\\n    ([227, 59, 798, 57, 793, 219, 568, 196, 548, 0], false),\\n    ([0, 58, 797, 0, 794, 787, 765, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([226, 0, 0, 58, 0, 220, 569, 197, 549, 0], false),\\n    ([406, 61, 84, 0, 57, 790, 768, 78, 400, 953], false),\\n    ([1137, 0, 1134, 0, 58, 1128, 0, 1101, 0, 958], false),\\n    ([228, 0, 1138, 61, 59, 223, 572, 200, 552, 965], false),\\n    ([0, 64, 652, 0, 820, 815, 57, 623, 0, 0], false),\\n    ([0, 658, 656, 0, 0, 0, 58, 630, 0, 0], false),\\n    ([236, 663, 661, 64, 0, 230, 59, 212, 554, 0], false),\\n    ([407, 67, 86, 0, 63, 817, 60, 81, 403, 984], false),\\n    ([1152, 669, 667, 0, 64, 1144, 61, 644, 0, 989], false),\\n    ([0, 69, 871, 0, 869, 865, 847, 0, 57, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 58, 0], false),\\n    ([272, 0, 150, 69, 146, 266, 582, 247, 59, 0], false),\\n    ([408, 72, 95, 0, 68, 104, 101, 89, 60, 1060], false),\\n    ([1194, 0, 1191, 0, 69, 1185, 0, 1169, 61, 1065], false),\\n    ([382, 74, 511, 507, 375, 491, 68, 704, 63, 357], false),\\n    ([381, 729, 727, 0, 376, 0, 69, 711, 64, 358], false),\\n    ([135, 133, 128, 0, 74, 1200, 72, 113, 67, 364], false),\\n    ([217, 215, 83, 81, 211, 203, 77, 587, 516, 872], false),\\n    ([202, 200, 80, 78, 196, 188, 559, 0, 517, 873], false),\\n    ([1103, 1101, 79, 0, 0, 1086, 0, 0, 0, 890], false),\\n    ([1100, 1098, 0, 0, 0, 1087, 0, 0, 0, 891], true),\\n    ([1106, 1104, 0, 79, 0, 1094, 0, 0, 0, 898], false),\\n    ([1122, 644, 82, 0, 623, 1107, 78, 606, 0, 921], false),\\n    ([1120, 642, 639, 0, 624, 1108, 79, 607, 0, 922], false),\\n    ([1124, 649, 646, 82, 632, 1115, 80, 615, 0, 929], false),\\n    ([1136, 1134, 0, 0, 797, 791, 769, 79, 0, 954], false),\\n    ([1140, 1138, 0, 84, 798, 792, 770, 80, 0, 961], false),\\n    ([1151, 667, 664, 0, 652, 818, 84, 82, 0, 985], false),\\n    ([127, 123, 94, 92, 261, 253, 88, 409, 76, 279], false),\\n    ([252, 250, 91, 89, 246, 238, 445, 428, 77, 996], false),\\n    ([1171, 1169, 90, 0, 0, 1154, 0, 0, 78, 1013], false),\\n    ([1168, 1166, 0, 0, 0, 1155, 0, 0, 79, 1014], false),\\n    ([1173, 451, 0, 90, 0, 1162, 446, 435, 80, 1021], false),\\n    ([117, 113, 93, 0, 704, 1174, 89, 692, 81, 1036], false),\\n    ([112, 108, 720, 0, 705, 1175, 90, 693, 82, 1037], false),\\n    ([122, 118, 330, 93, 713, 322, 91, 440, 83, 292], false),\\n    ([1193, 1191, 0, 0, 871, 868, 850, 90, 84, 1061], false),\\n    ([586, 457, 454, 101, 581, 97, 0, 445, 567, 0], false),\\n    ([0, 0, 842, 100, 833, 98, 0, 0, 737, 0], false),\\n    ([0, 0, 832, 99, 823, 0, 0, 0, 738, 0], false),\\n    ([0, 0, 831, 0, 828, 0, 0, 0, 747, 0], true),\\n    ([0, 0, 841, 0, 838, 99, 0, 0, 758, 0], false),\\n    ([0, 0, 850, 0, 847, 100, 0, 0, 768, 0], false),\\n    ([0, 0, 860, 103, 851, 0, 98, 0, 771, 0], false),\\n    ([0, 0, 859, 0, 856, 0, 99, 0, 780, 0], false),\\n    ([1187, 1185, 868, 0, 865, 103, 100, 1154, 790, 1045], false),\\n    ([0, 0, 482, 106, 461, 0, 102, 0, 799, 0], false),\\n    ([0, 0, 481, 477, 470, 0, 103, 0, 808, 0], false),\\n    (\\n        [1202, 1200, 501, 497, 491, 106, 104, 1174, 817, 1074],\\n        false,\\n    ),\\n    ([111, 109, 721, 0, 709, 1176, 1166, 697, 642, 1038], false),\\n    ([110, 0, 722, 0, 710, 0, 0, 698, 643, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 110, 0, 0, 0, 1177, 1167, 0, 1119, 1039], false),\\n    ([0, 111, 0, 0, 0, 1178, 1168, 0, 1120, 1040], false),\\n    ([116, 114, 108, 0, 711, 1179, 1169, 699, 644, 1041], false),\\n    ([115, 0, 109, 0, 712, 0, 0, 700, 645, 0], false),\\n    ([0, 0, 110, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 115, 111, 0, 0, 1180, 1170, 0, 1121, 1042], false),\\n    ([0, 116, 112, 0, 0, 1181, 1171, 0, 1122, 1043], false),\\n    ([121, 119, 331, 108, 717, 327, 451, 441, 649, 297], false),\\n    ([120, 0, 723, 109, 718, 0, 452, 442, 650, 0], false),\\n    ([0, 0, 0, 110, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 120, 332, 111, 0, 328, 1172, 0, 1123, 298], false),\\n    ([0, 121, 333, 112, 0, 329, 1173, 0, 1124, 299], false),\\n    ([126, 124, 118, 113, 262, 258, 250, 443, 215, 300], false),\\n    ([125, 0, 119, 114, 719, 0, 453, 444, 651, 0], false),\\n    ([0, 0, 120, 115, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 125, 121, 116, 263, 259, 251, 0, 216, 301], false),\\n    ([0, 126, 122, 117, 264, 260, 252, 0, 217, 302], false),\\n    ([131, 129, 734, 0, 727, 1197, 1191, 108, 667, 1083], false),\\n    ([130, 0, 735, 0, 728, 0, 0, 109, 668, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 110, 0, 0], false),\\n    ([0, 130, 0, 0, 0, 1198, 1192, 111, 1150, 1084], false),\\n    ([0, 131, 0, 0, 0, 1199, 1193, 112, 1151, 1085], false),\\n    ([134, 0, 129, 0, 729, 0, 0, 114, 669, 0], false),\\n    ([0, 0, 130, 0, 0, 0, 0, 115, 0, 0], false),\\n    ([0, 134, 131, 0, 381, 1201, 1194, 116, 1152, 365], false),\\n    ([0, 135, 132, 0, 382, 1202, 408, 117, 407, 366], false),\\n    ([138, 0, 736, 129, 731, 0, 459, 119, 672, 0], false),\\n    ([0, 0, 0, 130, 0, 0, 0, 120, 0, 0], false),\\n    ([140, 0, 137, 133, 732, 0, 460, 124, 673, 0], false),\\n    ([0, 0, 138, 134, 0, 0, 0, 125, 0, 0], false),\\n    ([0, 146, 142, 869, 0, 861, 843, 0, 793, 0], false),\\n    ([0, 145, 143, 870, 0, 864, 846, 0, 796, 0], false),\\n    ([0, 144, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 144, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 145, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 150, 148, 871, 142, 867, 849, 0, 798, 0], false),\\n    ([0, 149, 0, 0, 143, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 144, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 149, 0, 145, 0, 0, 0, 0, 0], false),\\n    ([0, 152, 0, 0, 148, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 149, 0, 0, 0, 0, 0], false),\\n    (\\n        [1195, 459, 152, 1191, 150, 1188, 455, 451, 1138, 1069],\\n        false,\\n    ),\\n    ([380, 159, 155, 375, 367, 483, 141, 0, 819, 341], false),\\n    ([0, 158, 156, 506, 0, 490, 142, 0, 822, 0], false),\\n    ([0, 157, 0, 0, 0, 0, 143, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 144, 0, 0, 0], false),\\n    ([0, 0, 157, 0, 0, 0, 145, 0, 0, 0], false),\\n    ([379, 0, 158, 376, 372, 0, 146, 0, 0, 354], false),\\n    ([0, 161, 0, 724, 156, 186, 148, 714, 182, 0], false),\\n    ([0, 730, 0, 725, 157, 0, 149, 715, 659, 0], false),\\n    ([340, 163, 0, 733, 160, 187, 151, 330, 183, 315], false),\\n    ([339, 736, 0, 734, 161, 334, 152, 331, 670, 316], false),\\n    ([405, 557, 174, 403, 171, 165, 399, 516, 383, 0], false),\\n    ([0, 0, 169, 0, 166, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 167, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 168, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 170, 0, 167, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 168, 0, 0, 0, 0, 0], false),\\n    ([556, 554, 172, 0, 0, 166, 548, 533, 0, 0], false),\\n    ([0, 0, 173, 0, 0, 167, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 168, 0, 0, 0, 0], false),\\n    ([0, 0, 175, 0, 172, 169, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 173, 170, 0, 0, 0, 0], false),\\n    ([235, 233, 180, 817, 177, 799, 218, 203, 165, 968], false),\\n    ([232, 230, 178, 815, 811, 800, 219, 204, 166, 0], false),\\n    ([0, 0, 179, 816, 814, 807, 789, 0, 167, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 168, 0], false),\\n    ([1149, 1147, 181, 818, 178, 810, 792, 1115, 169, 977], false),\\n    ([0, 0, 0, 0, 179, 0, 0, 0, 170, 0], false),\\n    ([0, 659, 0, 653, 0, 179, 0, 633, 173, 0], false),\\n    ([0, 670, 0, 664, 182, 181, 0, 646, 175, 0], false),\\n    ([276, 274, 185, 491, 483, 461, 265, 254, 177, 0], false),\\n    ([0, 0, 186, 496, 490, 476, 867, 0, 178, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 179, 0], false),\\n    ([336, 334, 0, 0, 186, 0, 0, 323, 181, 305], false),\\n    ([195, 193, 1094, 1086, 189, 0, 0, 0, 0, 874], false),\\n    ([192, 190, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([191, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 191, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([194, 0, 1095, 1091, 190, 0, 0, 0, 0, 887], false),\\n    ([0, 0, 1096, 1092, 191, 0, 0, 0, 0, 888], false),\\n    ([0, 194, 1097, 1093, 192, 0, 0, 0, 0, 889], false),\\n    ([199, 197, 0, 0, 0, 189, 560, 0, 526, 0], false),\\n    ([198, 0, 0, 0, 0, 190, 561, 0, 527, 0], false),\\n    ([0, 0, 0, 0, 0, 191, 562, 0, 528, 0], false),\\n    ([0, 198, 0, 0, 0, 192, 563, 0, 529, 0], false),\\n    ([201, 0, 1104, 1101, 197, 193, 564, 0, 530, 902], false),\\n    ([0, 0, 1105, 1102, 198, 194, 565, 0, 531, 903], false),\\n    ([0, 201, 1106, 1103, 199, 195, 566, 0, 532, 904], false),\\n    ([210, 208, 1115, 1107, 204, 0, 188, 0, 0, 905], false),\\n    ([207, 205, 0, 0, 0, 0, 189, 0, 0, 0], false),\\n    ([206, 0, 0, 0, 0, 0, 190, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 191, 0, 0, 0], false),\\n    ([0, 206, 0, 0, 0, 0, 192, 0, 0, 0], false),\\n    ([209, 0, 1116, 1112, 205, 0, 193, 0, 0, 918], false),\\n    ([0, 0, 1117, 1113, 206, 0, 194, 0, 0, 919], false),\\n    ([0, 209, 1118, 1114, 207, 0, 195, 0, 0, 920], false),\\n    ([214, 212, 632, 623, 0, 204, 196, 588, 533, 0], false),\\n    ([213, 638, 636, 630, 0, 205, 197, 604, 534, 0], false),\\n    ([0, 0, 0, 0, 0, 206, 198, 0, 535, 0], false),\\n    ([0, 213, 0, 0, 0, 207, 199, 0, 536, 0], false),\\n    ([216, 651, 649, 644, 212, 208, 200, 621, 537, 933], false),\\n    ([0, 0, 1123, 1121, 213, 209, 201, 0, 538, 934], false),\\n    ([0, 216, 1124, 1122, 214, 210, 202, 0, 539, 935], false),\\n    ([225, 223, 792, 790, 219, 771, 737, 188, 0, 937], false),\\n    ([222, 220, 789, 787, 783, 772, 750, 189, 0, 0], false),\\n    ([221, 0, 0, 0, 0, 0, 0, 190, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 191, 0, 0], false),\\n    ([0, 221, 0, 0, 0, 0, 0, 192, 0, 0], false),\\n    ([224, 0, 1131, 1128, 220, 0, 0, 193, 0, 950], false),\\n    ([0, 0, 1132, 1129, 221, 0, 0, 194, 0, 951], false),\\n    ([0, 224, 1133, 1130, 222, 0, 0, 195, 0, 952], false),\\n    ([0, 0, 0, 0, 0, 221, 570, 198, 550, 0], false),\\n    ([0, 226, 0, 0, 0, 222, 571, 199, 551, 0], false),\\n    ([0, 0, 1139, 1137, 226, 224, 573, 201, 553, 966], false),\\n    ([0, 228, 1140, 406, 227, 225, 574, 202, 402, 967], false),\\n    ([231, 0, 0, 0, 0, 0, 220, 205, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 221, 206, 0, 0], false),\\n    ([0, 231, 0, 0, 0, 0, 222, 207, 0, 0], false),\\n    ([234, 0, 1147, 1144, 230, 0, 223, 208, 0, 981], false),\\n    ([0, 0, 1148, 1145, 231, 0, 224, 209, 0, 982], false),\\n    ([0, 234, 1149, 1146, 232, 0, 225, 210, 0, 983], false),\\n    ([0, 0, 0, 0, 0, 231, 226, 213, 555, 0], false),\\n    ([0, 0, 1153, 1152, 236, 234, 228, 216, 558, 994], false),\\n    ([245, 243, 1162, 1154, 239, 0, 0, 0, 188, 997], false),\\n    ([242, 240, 0, 0, 0, 0, 0, 0, 189, 0], false),\\n    ([241, 0, 0, 0, 0, 0, 0, 0, 190, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 191, 0], false),\\n    ([0, 241, 0, 0, 0, 0, 0, 0, 192, 0], false),\\n    ([244, 0, 1163, 1159, 240, 0, 0, 0, 193, 1010], false),\\n    ([0, 0, 1164, 1160, 241, 0, 0, 0, 194, 1011], false),\\n    ([0, 244, 1165, 1161, 242, 0, 0, 0, 195, 1012], false),\\n    ([249, 247, 0, 0, 0, 239, 575, 0, 196, 0], false),\\n    ([248, 0, 0, 0, 0, 240, 576, 0, 197, 0], false),\\n    ([0, 0, 0, 0, 0, 241, 577, 0, 198, 0], false),\\n    ([0, 248, 0, 0, 0, 242, 578, 0, 199, 0], false),\\n    ([251, 453, 451, 1169, 247, 243, 449, 438, 200, 1025], false),\\n    ([0, 0, 1172, 1170, 248, 244, 579, 0, 201, 1026], false),\\n    ([0, 251, 1173, 1171, 249, 245, 580, 0, 202, 1027], false),\\n    ([260, 258, 322, 1174, 254, 0, 238, 0, 203, 280], false),\\n    ([257, 255, 0, 0, 0, 0, 239, 0, 204, 0], false),\\n    ([256, 0, 0, 0, 0, 0, 240, 0, 205, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 241, 0, 206, 0], false),\\n    ([0, 256, 0, 0, 0, 0, 242, 0, 207, 0], false),\\n    ([259, 0, 327, 1179, 255, 0, 243, 0, 208, 289], false),\\n    ([0, 0, 328, 1180, 256, 0, 244, 0, 209, 290], false),\\n    ([0, 259, 329, 1181, 257, 0, 245, 0, 210, 291], false),\\n    ([264, 262, 713, 704, 0, 254, 246, 674, 211, 0], false),\\n    ([263, 719, 717, 711, 0, 255, 247, 690, 212, 0], false),\\n    ([0, 0, 0, 0, 0, 256, 248, 0, 213, 0], false),\\n    ([0, 263, 0, 0, 0, 257, 249, 0, 214, 0], false),\\n    ([268, 266, 867, 865, 861, 851, 833, 239, 219, 0], false),\\n    ([267, 0, 0, 0, 0, 0, 0, 240, 220, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 241, 221, 0], false),\\n    ([0, 267, 0, 0, 0, 0, 0, 242, 222, 0], false),\\n    ([270, 0, 1188, 1185, 266, 0, 0, 243, 223, 1057], false),\\n    ([0, 0, 1189, 1186, 267, 0, 0, 244, 224, 1058], false),\\n    ([0, 270, 1190, 1187, 268, 0, 0, 245, 225, 1059], false),\\n    ([0, 0, 0, 0, 0, 267, 583, 248, 226, 0], false),\\n    ([0, 0, 1195, 1194, 272, 270, 585, 251, 228, 1073], false),\\n    ([275, 0, 0, 0, 0, 0, 266, 255, 230, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 267, 256, 231, 0], false),\\n    ([0, 275, 0, 0, 0, 0, 268, 257, 232, 0], false),\\n    ([0, 0, 337, 1201, 275, 0, 270, 259, 234, 313], false),\\n    ([0, 277, 338, 1202, 276, 0, 271, 260, 235, 314], false),\\n    ([302, 300, 292, 1036, 0, 280, 996, 0, 872, 0], false),\\n    ([291, 289, 281, 1028, 0, 0, 997, 0, 905, 0], false),\\n    ([288, 286, 282, 1029, 0, 0, 1006, 0, 914, 0], false),\\n    ([285, 283, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([284, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 284, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([287, 0, 283, 1030, 0, 0, 1007, 0, 915, 0], false),\\n    ([0, 0, 284, 1031, 0, 0, 1008, 0, 916, 0], false),\\n    ([0, 287, 285, 1032, 0, 0, 1009, 0, 917, 0], false),\\n    ([290, 0, 286, 1033, 0, 0, 1010, 0, 918, 0], false),\\n    ([0, 0, 287, 1034, 0, 0, 1011, 0, 919, 0], false),\\n    ([0, 290, 288, 1035, 0, 0, 1012, 0, 920, 0], false),\\n    ([299, 297, 293, 1037, 0, 281, 1021, 0, 929, 0], false),\\n    ([296, 294, 0, 0, 0, 282, 0, 0, 0, 0], false),\\n    ([295, 0, 0, 0, 0, 283, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 284, 0, 0, 0, 0], false),\\n    ([0, 295, 0, 0, 0, 285, 0, 0, 0, 0], false),\\n    ([298, 0, 294, 1038, 0, 286, 1022, 0, 930, 0], false),\\n    ([0, 0, 295, 1039, 0, 287, 1023, 0, 931, 0], false),\\n    ([0, 298, 296, 1040, 0, 288, 1024, 0, 932, 0], false),\\n    ([301, 0, 297, 1041, 0, 289, 1025, 0, 933, 0], false),\\n    ([0, 0, 298, 1042, 0, 290, 1026, 0, 934, 0], false),\\n    ([0, 301, 299, 1043, 0, 291, 1027, 0, 935, 0], false),\\n    ([314, 312, 304, 1074, 0, 0, 1044, 280, 968, 0], false),\\n    ([311, 309, 305, 1075, 0, 0, 1053, 281, 977, 0], false),\\n    ([308, 306, 0, 0, 0, 0, 0, 282, 0, 0], false),\\n    ([307, 0, 0, 0, 0, 0, 0, 283, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 284, 0, 0], false),\\n    ([0, 307, 0, 0, 0, 0, 0, 285, 0, 0], false),\\n    ([310, 0, 306, 1076, 0, 0, 1054, 286, 978, 0], false),\\n    ([0, 0, 307, 1077, 0, 0, 1055, 287, 979, 0], false),\\n    ([0, 310, 308, 1078, 0, 0, 1056, 288, 980, 0], false),\\n    ([313, 0, 309, 1079, 0, 0, 1057, 289, 981, 0], false),\\n    ([0, 0, 310, 1080, 0, 0, 1058, 290, 982, 0], false),\\n    ([0, 313, 311, 1081, 0, 0, 1059, 291, 983, 0], false),\\n    ([318, 316, 0, 0, 0, 305, 0, 293, 0, 0], false),\\n    ([317, 0, 0, 0, 0, 306, 0, 294, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 307, 0, 295, 0, 0], false),\\n    ([0, 317, 0, 0, 0, 308, 0, 296, 0, 0], false),\\n    ([0, 0, 317, 1084, 0, 310, 1070, 298, 992, 0], false),\\n    ([0, 319, 318, 1085, 0, 311, 1071, 299, 993, 0], false),\\n    ([0, 0, 319, 365, 362, 313, 1073, 301, 994, 0], false),\\n    ([329, 327, 323, 1175, 0, 0, 1162, 0, 1115, 281], false),\\n    ([326, 324, 0, 0, 0, 0, 0, 0, 0, 282], false),\\n    ([325, 0, 0, 0, 0, 0, 0, 0, 0, 283], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 284], false),\\n    ([0, 325, 0, 0, 0, 0, 0, 0, 0, 285], false),\\n    ([328, 0, 324, 1176, 0, 0, 1163, 0, 1116, 286], false),\\n    ([0, 0, 325, 1177, 0, 0, 1164, 0, 1117, 287], false),\\n    ([0, 328, 326, 1178, 0, 0, 1165, 0, 1118, 288], false),\\n    ([333, 331, 0, 720, 714, 323, 0, 701, 646, 293], false),\\n    ([332, 723, 0, 721, 715, 324, 0, 702, 647, 294], false),\\n    ([0, 0, 0, 0, 0, 325, 0, 0, 0, 295], false),\\n    ([0, 332, 0, 0, 0, 326, 0, 0, 0, 296], false),\\n    ([335, 0, 0, 0, 0, 0, 0, 324, 0, 306], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 325, 0, 307], false),\\n    ([0, 335, 0, 0, 0, 0, 0, 326, 0, 308], false),\\n    ([0, 0, 335, 1198, 0, 0, 1189, 328, 1148, 310], false),\\n    ([0, 337, 336, 1199, 0, 0, 1190, 329, 1149, 311], false),\\n    ([0, 0, 0, 0, 0, 335, 0, 332, 0, 317], false),\\n    ([0, 339, 0, 0, 0, 336, 0, 333, 0, 318], false),\\n    ([356, 354, 0, 350, 342, 0, 0, 0, 0, 0], false),\\n    ([349, 347, 0, 343, 0, 0, 0, 0, 0, 0], false),\\n    ([346, 344, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([345, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 345, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([348, 0, 0, 344, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 345, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 348, 0, 346, 0, 0, 0, 0, 0, 0], false),\\n    ([353, 351, 0, 0, 343, 0, 0, 0, 0, 0], false),\\n    ([352, 0, 0, 0, 344, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 345, 0, 0, 0, 0, 0], false),\\n    ([0, 352, 0, 0, 346, 0, 0, 0, 0, 0], false),\\n    ([355, 0, 0, 351, 347, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 352, 348, 0, 0, 0, 0, 0], false),\\n    ([0, 355, 0, 353, 349, 0, 0, 0, 0, 0], false),\\n    ([360, 358, 0, 0, 350, 0, 0, 0, 0, 0], false),\\n    ([359, 0, 0, 0, 351, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 352, 0, 0, 0, 0, 0], false),\\n    ([0, 359, 0, 0, 353, 0, 0, 0, 0, 0], false),\\n    ([362, 0, 0, 358, 354, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 359, 355, 0, 0, 0, 0, 0], false),\\n    ([366, 364, 1082, 0, 357, 1074, 1060, 1036, 984, 0], false),\\n    ([365, 0, 1083, 0, 358, 1079, 1065, 1041, 989, 0], false),\\n    ([0, 0, 1084, 0, 359, 1080, 1066, 1042, 990, 0], false),\\n    ([0, 365, 1085, 0, 360, 1081, 1067, 1043, 991, 0], false),\\n    ([374, 372, 0, 368, 0, 0, 0, 0, 0, 342], false),\\n    ([371, 369, 0, 0, 0, 0, 0, 0, 0, 343], false),\\n    ([370, 0, 0, 0, 0, 0, 0, 0, 0, 344], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 345], false),\\n    ([0, 370, 0, 0, 0, 0, 0, 0, 0, 346], false),\\n    ([373, 0, 0, 369, 0, 0, 0, 0, 0, 347], false),\\n    ([0, 0, 0, 370, 0, 0, 0, 0, 0, 348], false),\\n    ([0, 373, 0, 371, 0, 0, 0, 0, 0, 349], false),\\n    ([378, 376, 506, 502, 368, 484, 869, 0, 820, 350], false),\\n    ([377, 0, 0, 0, 369, 0, 0, 0, 0, 351], false),\\n    ([0, 0, 0, 0, 370, 0, 0, 0, 0, 352], false),\\n    ([0, 377, 0, 0, 371, 0, 0, 0, 0, 353], false),\\n    ([0, 0, 0, 377, 373, 0, 0, 0, 0, 355], false),\\n    ([0, 379, 0, 378, 374, 0, 0, 0, 0, 356], false),\\n    ([0, 0, 0, 0, 377, 0, 0, 0, 0, 359], false),\\n    ([0, 381, 0, 0, 378, 0, 0, 0, 0, 360], false),\\n    ([398, 0, 0, 396, 0, 0, 392, 0, 384, 0], false),\\n    ([391, 0, 0, 389, 0, 0, 385, 0, 0, 0], false),\\n    ([388, 0, 0, 386, 0, 0, 0, 0, 0, 0], false),\\n    ([387, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 387, 0, 0, 0, 0, 0, 0], false),\\n    ([390, 0, 0, 0, 0, 0, 386, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 387, 0, 0, 0], false),\\n    ([0, 0, 0, 390, 0, 0, 388, 0, 0, 0], false),\\n    ([395, 0, 0, 393, 0, 0, 0, 0, 385, 0], false),\\n    ([394, 0, 0, 0, 0, 0, 0, 0, 386, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 387, 0], false),\\n    ([0, 0, 0, 394, 0, 0, 0, 0, 388, 0], false),\\n    ([397, 0, 0, 0, 0, 0, 393, 0, 389, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 394, 0, 390, 0], false),\\n    ([0, 0, 0, 397, 0, 0, 395, 0, 391, 0], false),\\n    ([402, 552, 0, 400, 548, 0, 540, 517, 392, 0], false),\\n    ([401, 0, 0, 0, 0, 0, 0, 0, 393, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 394, 0], false),\\n    ([0, 553, 0, 401, 551, 0, 547, 532, 395, 0], false),\\n    ([404, 0, 0, 0, 0, 0, 400, 0, 396, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 401, 0, 397, 0], false),\\n    ([0, 558, 0, 404, 556, 0, 402, 539, 398, 0], false),\\n    ([0, 1137, 1136, 0, 0, 1130, 0, 1103, 401, 960], false),\\n    ([0, 1152, 1151, 0, 0, 1146, 406, 1122, 404, 991], false),\\n    ([0, 1194, 1193, 0, 0, 1187, 0, 1171, 406, 1067], false),\\n    ([0, 443, 440, 692, 674, 0, 428, 410, 587, 0], false),\\n    ([0, 426, 423, 0, 0, 0, 411, 0, 0, 0], false),\\n    ([0, 421, 418, 0, 0, 0, 412, 0, 0, 0], false),\\n    ([0, 416, 413, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 414, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 415, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 417, 414, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 415, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 419, 0, 0, 0, 0, 413, 0, 0, 0], false),\\n    ([0, 420, 0, 0, 0, 0, 414, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 415, 0, 0, 0], false),\\n    ([0, 422, 419, 0, 0, 0, 416, 0, 0, 0], false),\\n    ([0, 0, 420, 0, 0, 0, 417, 0, 0, 0], false),\\n    ([0, 424, 0, 0, 0, 0, 418, 0, 0, 0], false),\\n    ([0, 425, 0, 0, 0, 0, 419, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 420, 0, 0, 0], false),\\n    ([0, 427, 424, 0, 0, 0, 421, 0, 0, 0], false),\\n    ([0, 0, 425, 0, 0, 0, 422, 0, 0, 0], false),\\n    ([0, 438, 435, 0, 0, 0, 429, 411, 0, 0], false),\\n    ([0, 433, 430, 0, 0, 0, 0, 412, 0, 0], false),\\n    ([0, 431, 0, 0, 0, 0, 0, 413, 0, 0], false),\\n    ([0, 432, 0, 0, 0, 0, 0, 414, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 415, 0, 0], false),\\n    ([0, 434, 431, 0, 0, 0, 0, 416, 0, 0], false),\\n    ([0, 0, 432, 0, 0, 0, 0, 417, 0, 0], false),\\n    ([0, 436, 0, 0, 0, 0, 430, 418, 0, 0], false),\\n    ([0, 437, 0, 0, 0, 0, 431, 419, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 432, 420, 0, 0], false),\\n    ([0, 439, 436, 0, 0, 0, 433, 421, 0, 0], false),\\n    ([0, 0, 437, 0, 0, 0, 434, 422, 0, 0], false),\\n    ([0, 441, 701, 693, 684, 0, 435, 423, 615, 0], false),\\n    ([0, 442, 702, 697, 688, 0, 436, 424, 619, 0], false),\\n    ([0, 0, 703, 698, 689, 0, 437, 425, 620, 0], false),\\n    ([0, 444, 441, 699, 690, 0, 438, 426, 621, 0], false),\\n    ([0, 0, 442, 700, 691, 0, 439, 427, 622, 0], false),\\n    ([580, 449, 446, 0, 575, 0, 0, 429, 559, 0], false),\\n    ([0, 447, 0, 0, 0, 0, 0, 430, 0, 0], false),\\n    ([0, 448, 0, 0, 0, 0, 0, 431, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 432, 0, 0], false),\\n    ([579, 450, 447, 0, 576, 0, 0, 433, 564, 0], false),\\n    ([0, 0, 448, 0, 0, 0, 0, 434, 0, 0], false),\\n    ([1172, 452, 0, 1166, 0, 1163, 447, 436, 1104, 1022], false),\\n    ([0, 0, 0, 0, 0, 0, 448, 437, 0, 0], false),\\n    ([0, 0, 452, 0, 0, 0, 450, 439, 0, 0], false),\\n    ([0, 455, 0, 850, 849, 842, 0, 446, 770, 0], false),\\n    ([0, 456, 0, 0, 0, 0, 0, 447, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 448, 0, 0], false),\\n    ([585, 458, 455, 0, 582, 0, 0, 449, 572, 0], false),\\n    ([0, 0, 456, 0, 0, 0, 0, 450, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 456, 452, 0, 0], false),\\n    ([0, 0, 459, 0, 0, 0, 458, 453, 0, 0], false),\\n    ([0, 0, 476, 470, 462, 0, 851, 0, 800, 0], false),\\n    ([0, 0, 469, 463, 0, 0, 852, 0, 801, 0], false),\\n    ([0, 0, 468, 464, 0, 0, 853, 0, 802, 0], false),\\n    ([0, 0, 467, 465, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 466, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 466, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 467, 0, 0, 854, 0, 803, 0], false),\\n    ([0, 0, 0, 468, 0, 0, 855, 0, 804, 0], false),\\n    ([0, 0, 475, 471, 463, 0, 856, 0, 805, 0], false),\\n    ([0, 0, 474, 472, 464, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 473, 0, 465, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 466, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 473, 467, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 474, 468, 0, 857, 0, 806, 0], false),\\n    ([0, 0, 0, 475, 469, 0, 858, 0, 807, 0], false),\\n    ([0, 0, 480, 478, 471, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 479, 0, 472, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 473, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 479, 474, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 480, 475, 0, 859, 0, 809, 0], false),\\n    ([0, 0, 0, 481, 476, 0, 860, 0, 810, 0], false),\\n    ([0, 0, 490, 484, 0, 462, 861, 0, 811, 0], false),\\n    ([0, 0, 489, 485, 0, 463, 862, 0, 812, 0], false),\\n    ([0, 0, 488, 486, 0, 464, 0, 0, 0, 0], false),\\n    ([0, 0, 487, 0, 0, 465, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 466, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 487, 0, 467, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 488, 0, 468, 863, 0, 813, 0], false),\\n    ([0, 0, 0, 489, 0, 469, 864, 0, 814, 0], false),\\n    ([0, 0, 496, 492, 484, 470, 865, 0, 815, 0], false),\\n    ([0, 0, 495, 493, 485, 471, 0, 0, 0, 0], false),\\n    ([0, 0, 494, 0, 486, 472, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 487, 473, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 494, 488, 474, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 495, 489, 475, 866, 0, 816, 0], false),\\n    ([0, 0, 500, 498, 492, 477, 0, 0, 0, 0], false),\\n    ([0, 0, 499, 0, 493, 478, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 494, 479, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 499, 495, 480, 0, 0, 0, 0], false),\\n    ([1199, 1197, 0, 500, 496, 481, 868, 1175, 818, 1075], false),\\n    ([0, 0, 505, 503, 0, 485, 0, 0, 0, 0], false),\\n    ([0, 0, 504, 0, 0, 486, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 487, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 504, 0, 488, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 505, 0, 489, 870, 0, 821, 0], false),\\n    ([0, 0, 510, 508, 502, 492, 0, 0, 0, 0], false),\\n    ([0, 0, 509, 0, 503, 493, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 504, 494, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 509, 505, 495, 0, 0, 0, 0], false),\\n    ([0, 727, 724, 510, 506, 496, 871, 705, 652, 0], false),\\n    ([0, 0, 515, 513, 507, 497, 0, 0, 0, 0], false),\\n    ([0, 0, 514, 0, 508, 498, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 509, 499, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 514, 510, 500, 0, 0, 0, 0], false),\\n    ([539, 537, 0, 0, 533, 0, 517, 0, 0, 0], false),\\n    ([532, 530, 0, 0, 526, 0, 518, 0, 0, 0], false),\\n    ([525, 523, 0, 0, 519, 0, 0, 0, 0, 0], false),\\n    ([522, 520, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([521, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 521, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([524, 0, 0, 0, 520, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 521, 0, 0, 0, 0, 0], false),\\n    ([0, 524, 0, 0, 522, 0, 0, 0, 0, 0], false),\\n    ([529, 527, 0, 0, 0, 0, 519, 0, 0, 0], false),\\n    ([528, 0, 0, 0, 0, 0, 520, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 521, 0, 0, 0], false),\\n    ([0, 528, 0, 0, 0, 0, 522, 0, 0, 0], false),\\n    ([531, 0, 0, 0, 527, 0, 523, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 528, 0, 524, 0, 0, 0], false),\\n    ([0, 531, 0, 0, 529, 0, 525, 0, 0, 0], false),\\n    ([536, 534, 0, 0, 0, 0, 526, 0, 0, 0], false),\\n    ([535, 0, 0, 0, 0, 0, 527, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 528, 0, 0, 0], false),\\n    ([0, 535, 0, 0, 0, 0, 529, 0, 0, 0], false),\\n    ([538, 0, 0, 0, 534, 0, 530, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 535, 0, 531, 0, 0, 0], false),\\n    ([0, 538, 0, 0, 536, 0, 532, 0, 0, 0], false),\\n    ([547, 545, 0, 0, 541, 0, 0, 518, 0, 0], false),\\n    ([544, 542, 0, 0, 0, 0, 0, 519, 0, 0], false),\\n    ([543, 0, 0, 0, 0, 0, 0, 520, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 521, 0, 0], false),\\n    ([0, 543, 0, 0, 0, 0, 0, 522, 0, 0], false),\\n    ([546, 0, 0, 0, 542, 0, 0, 523, 0, 0], false),\\n    ([0, 0, 0, 0, 543, 0, 0, 524, 0, 0], false),\\n    ([0, 546, 0, 0, 544, 0, 0, 525, 0, 0], false),\\n    ([551, 549, 0, 0, 0, 0, 541, 526, 0, 0], false),\\n    ([550, 0, 0, 0, 0, 0, 542, 527, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 543, 528, 0, 0], false),\\n    ([0, 550, 0, 0, 0, 0, 544, 529, 0, 0], false),\\n    ([553, 0, 0, 0, 549, 0, 545, 530, 0, 0], false),\\n    ([0, 0, 0, 0, 550, 0, 546, 531, 0, 0], false),\\n    ([555, 0, 0, 0, 0, 0, 549, 534, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 550, 535, 0, 0], false),\\n    ([0, 555, 0, 0, 0, 0, 551, 536, 0, 0], false),\\n    ([558, 0, 0, 0, 554, 0, 552, 537, 0, 0], false),\\n    ([0, 0, 0, 0, 555, 0, 553, 538, 0, 0], false),\\n    ([566, 564, 0, 0, 560, 0, 0, 0, 518, 0], false),\\n    ([563, 561, 0, 0, 0, 0, 0, 0, 519, 0], false),\\n    ([562, 0, 0, 0, 0, 0, 0, 0, 520, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 521, 0], false),\\n    ([0, 562, 0, 0, 0, 0, 0, 0, 522, 0], false),\\n    ([565, 0, 0, 0, 561, 0, 0, 0, 523, 0], false),\\n    ([0, 0, 0, 0, 562, 0, 0, 0, 524, 0], false),\\n    ([0, 565, 0, 0, 563, 0, 0, 0, 525, 0], false),\\n    ([574, 572, 770, 768, 568, 737, 0, 559, 540, 0], false),\\n    ([571, 569, 767, 765, 761, 750, 0, 560, 541, 0], false),\\n    ([570, 0, 0, 0, 0, 0, 0, 561, 542, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 562, 543, 0], false),\\n    ([0, 570, 0, 0, 0, 0, 0, 563, 544, 0], false),\\n    ([573, 0, 0, 0, 569, 0, 0, 564, 545, 0], false),\\n    ([0, 0, 0, 0, 570, 0, 0, 565, 546, 0], false),\\n    ([0, 573, 0, 0, 571, 0, 0, 566, 547, 0], false),\\n    ([578, 576, 0, 0, 0, 0, 0, 0, 560, 0], false),\\n    ([577, 0, 0, 0, 0, 0, 0, 0, 561, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 562, 0], false),\\n    ([0, 577, 0, 0, 0, 0, 0, 0, 563, 0], false),\\n    ([0, 0, 0, 0, 577, 0, 0, 0, 565, 0], false),\\n    ([0, 579, 0, 0, 578, 0, 0, 0, 566, 0], false),\\n    ([584, 582, 849, 847, 843, 833, 0, 575, 568, 0], false),\\n    ([583, 0, 0, 0, 0, 0, 0, 576, 569, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 577, 570, 0], false),\\n    ([0, 583, 0, 0, 0, 0, 0, 578, 571, 0], false),\\n    ([0, 0, 0, 0, 583, 0, 0, 579, 573, 0], false),\\n    ([0, 585, 0, 0, 584, 0, 0, 580, 574, 0], false),\\n    ([0, 621, 615, 606, 588, 0, 0, 0, 0, 0], false),\\n    ([0, 604, 598, 589, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 596, 590, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 594, 591, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 592, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 593, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 595, 592, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 593, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 597, 594, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 595, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 602, 599, 590, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 600, 0, 591, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 601, 0, 592, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 593, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 603, 600, 594, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 601, 595, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 605, 602, 596, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 603, 597, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 613, 607, 0, 589, 0, 0, 0, 0, 0], false),\\n    ([0, 611, 608, 0, 590, 0, 0, 0, 0, 0], false),\\n    ([0, 609, 0, 0, 591, 0, 0, 0, 0, 0], false),\\n    ([0, 610, 0, 0, 592, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 593, 0, 0, 0, 0, 0], false),\\n    ([0, 612, 609, 0, 594, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 610, 0, 595, 0, 0, 0, 0, 0], false),\\n    ([0, 614, 611, 0, 596, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 612, 0, 597, 0, 0, 0, 0, 0], false),\\n    ([0, 619, 616, 607, 598, 0, 0, 0, 0, 0], false),\\n    ([0, 617, 0, 608, 599, 0, 0, 0, 0, 0], false),\\n    ([0, 618, 0, 609, 600, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 610, 601, 0, 0, 0, 0, 0], false),\\n    ([0, 620, 617, 611, 602, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 618, 612, 603, 0, 0, 0, 0, 0], false),\\n    ([0, 622, 619, 613, 604, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 620, 614, 605, 0, 0, 0, 0, 0], false),\\n    ([0, 630, 624, 0, 0, 0, 0, 589, 0, 0], false),\\n    ([0, 628, 625, 0, 0, 0, 0, 590, 0, 0], false),\\n    ([0, 626, 0, 0, 0, 0, 0, 591, 0, 0], false),\\n    ([0, 627, 0, 0, 0, 0, 0, 592, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 593, 0, 0], false),\\n    ([0, 629, 626, 0, 0, 0, 0, 594, 0, 0], false),\\n    ([0, 0, 627, 0, 0, 0, 0, 595, 0, 0], false),\\n    ([0, 631, 628, 0, 0, 0, 0, 596, 0, 0], false),\\n    ([0, 0, 629, 0, 0, 0, 0, 597, 0, 0], false),\\n    ([0, 636, 633, 624, 0, 0, 0, 598, 0, 0], false),\\n    ([0, 634, 0, 625, 0, 0, 0, 599, 0, 0], false),\\n    ([0, 635, 0, 626, 0, 0, 0, 600, 0, 0], false),\\n    ([0, 0, 0, 627, 0, 0, 0, 601, 0, 0], false),\\n    ([0, 637, 634, 628, 0, 0, 0, 602, 0, 0], false),\\n    ([0, 0, 635, 629, 0, 0, 0, 603, 0, 0], false),\\n    ([0, 0, 637, 631, 0, 0, 0, 605, 0, 0], false),\\n    ([0, 640, 0, 0, 625, 0, 0, 608, 0, 0], false),\\n    ([0, 641, 0, 0, 626, 0, 0, 609, 0, 0], false),\\n    ([0, 0, 0, 0, 627, 0, 0, 610, 0, 0], false),\\n    ([1119, 643, 640, 0, 628, 1109, 1098, 611, 0, 923], false),\\n    ([0, 0, 641, 0, 629, 0, 0, 612, 0, 0], false),\\n    ([1121, 645, 642, 0, 630, 1112, 1101, 613, 0, 926], false),\\n    ([0, 0, 643, 0, 631, 0, 0, 614, 0, 0], false),\\n    ([0, 647, 0, 639, 633, 0, 0, 616, 0, 0], false),\\n    ([0, 648, 0, 640, 634, 0, 0, 617, 0, 0], false),\\n    ([0, 0, 0, 641, 635, 0, 0, 618, 0, 0], false),\\n    ([1123, 650, 647, 642, 636, 1116, 1104, 619, 0, 930], false),\\n    ([0, 0, 648, 643, 637, 0, 0, 620, 0, 0], false),\\n    ([0, 0, 650, 645, 638, 0, 0, 622, 0, 0], false),\\n    ([0, 656, 653, 0, 821, 816, 797, 624, 0, 0], false),\\n    ([0, 654, 0, 0, 0, 0, 0, 625, 0, 0], false),\\n    ([0, 655, 0, 0, 0, 0, 0, 626, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 627, 0, 0], false),\\n    ([0, 657, 654, 0, 0, 0, 0, 628, 0, 0], false),\\n    ([0, 0, 655, 0, 0, 0, 0, 629, 0, 0], false),\\n    ([0, 0, 657, 0, 0, 0, 0, 631, 0, 0], false),\\n    ([0, 660, 0, 654, 0, 0, 0, 634, 0, 0], false),\\n    ([0, 0, 0, 655, 0, 0, 0, 635, 0, 0], false),\\n    ([0, 662, 659, 656, 0, 0, 0, 636, 0, 0], false),\\n    ([0, 0, 660, 657, 0, 0, 0, 637, 0, 0], false),\\n    ([0, 0, 662, 658, 0, 0, 0, 638, 0, 0], false),\\n    ([0, 665, 0, 0, 653, 0, 0, 639, 0, 0], false),\\n    ([0, 666, 0, 0, 654, 0, 0, 640, 0, 0], false),\\n    ([0, 0, 0, 0, 655, 0, 0, 641, 0, 0], false),\\n    ([1150, 668, 665, 0, 656, 1141, 1134, 642, 0, 986], false),\\n    ([0, 0, 666, 0, 657, 0, 0, 643, 0, 0], false),\\n    ([0, 0, 668, 0, 658, 0, 0, 645, 0, 0], false),\\n    ([0, 671, 0, 665, 659, 0, 0, 647, 0, 0], false),\\n    ([0, 0, 0, 666, 660, 0, 0, 648, 0, 0], false),\\n    ([0, 0, 671, 668, 662, 0, 0, 650, 0, 0], false),\\n    ([0, 0, 672, 669, 663, 0, 0, 651, 0, 0], false),\\n    ([0, 690, 684, 675, 0, 0, 0, 0, 588, 0], false),\\n    ([0, 682, 676, 0, 0, 0, 0, 0, 589, 0], false),\\n    ([0, 680, 677, 0, 0, 0, 0, 0, 590, 0], false),\\n    ([0, 678, 0, 0, 0, 0, 0, 0, 591, 0], false),\\n    ([0, 679, 0, 0, 0, 0, 0, 0, 592, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 593, 0], false),\\n    ([0, 681, 678, 0, 0, 0, 0, 0, 594, 0], false),\\n    ([0, 0, 679, 0, 0, 0, 0, 0, 595, 0], false),\\n    ([0, 683, 680, 0, 0, 0, 0, 0, 596, 0], false),\\n    ([0, 0, 681, 0, 0, 0, 0, 0, 597, 0], false),\\n    ([0, 688, 685, 676, 0, 0, 0, 0, 598, 0], false),\\n    ([0, 686, 0, 677, 0, 0, 0, 0, 599, 0], false),\\n    ([0, 687, 0, 678, 0, 0, 0, 0, 600, 0], false),\\n    ([0, 0, 0, 679, 0, 0, 0, 0, 601, 0], false),\\n    ([0, 689, 686, 680, 0, 0, 0, 0, 602, 0], false),\\n    ([0, 0, 687, 681, 0, 0, 0, 0, 603, 0], false),\\n    ([0, 691, 688, 682, 0, 0, 0, 0, 604, 0], false),\\n    ([0, 0, 689, 683, 0, 0, 0, 0, 605, 0], false),\\n    ([0, 699, 693, 0, 675, 0, 0, 0, 606, 0], false),\\n    ([0, 697, 694, 0, 676, 0, 0, 0, 607, 0], false),\\n    ([0, 695, 0, 0, 677, 0, 0, 0, 608, 0], false),\\n    ([0, 696, 0, 0, 678, 0, 0, 0, 609, 0], false),\\n    ([0, 0, 0, 0, 679, 0, 0, 0, 610, 0], false),\\n    ([0, 698, 695, 0, 680, 0, 0, 0, 611, 0], false),\\n    ([0, 0, 696, 0, 681, 0, 0, 0, 612, 0], false),\\n    ([0, 700, 697, 0, 682, 0, 0, 0, 613, 0], false),\\n    ([0, 0, 698, 0, 683, 0, 0, 0, 614, 0], false),\\n    ([0, 702, 0, 694, 685, 0, 0, 0, 616, 0], false),\\n    ([0, 703, 0, 695, 686, 0, 0, 0, 617, 0], false),\\n    ([0, 0, 0, 696, 687, 0, 0, 0, 618, 0], false),\\n    ([0, 711, 705, 0, 0, 0, 0, 675, 623, 0], false),\\n    ([0, 709, 706, 0, 0, 0, 0, 676, 624, 0], false),\\n    ([0, 707, 0, 0, 0, 0, 0, 677, 625, 0], false),\\n    ([0, 708, 0, 0, 0, 0, 0, 678, 626, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 679, 627, 0], false),\\n    ([0, 710, 707, 0, 0, 0, 0, 680, 628, 0], false),\\n    ([0, 0, 708, 0, 0, 0, 0, 681, 629, 0], false),\\n    ([0, 712, 709, 0, 0, 0, 0, 682, 630, 0], false),\\n    ([0, 0, 710, 0, 0, 0, 0, 683, 631, 0], false),\\n    ([0, 717, 714, 705, 0, 0, 0, 684, 632, 0], false),\\n    ([0, 715, 0, 706, 0, 0, 0, 685, 633, 0], false),\\n    ([0, 716, 0, 707, 0, 0, 0, 686, 634, 0], false),\\n    ([0, 0, 0, 708, 0, 0, 0, 687, 635, 0], false),\\n    ([0, 718, 715, 709, 0, 0, 0, 688, 636, 0], false),\\n    ([0, 0, 716, 710, 0, 0, 0, 689, 637, 0], false),\\n    ([0, 0, 718, 712, 0, 0, 0, 691, 638, 0], false),\\n    ([0, 721, 0, 0, 706, 0, 0, 694, 639, 0], false),\\n    ([0, 722, 0, 0, 707, 0, 0, 695, 640, 0], false),\\n    ([0, 0, 0, 0, 708, 0, 0, 696, 641, 0], false),\\n    ([0, 0, 0, 722, 716, 0, 0, 703, 648, 0], false),\\n    ([0, 725, 0, 0, 0, 0, 0, 706, 653, 0], false),\\n    ([0, 726, 0, 0, 0, 0, 0, 707, 654, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 708, 655, 0], false),\\n    ([0, 728, 725, 0, 0, 0, 0, 709, 656, 0], false),\\n    ([0, 0, 726, 0, 0, 0, 0, 710, 657, 0], false),\\n    ([0, 0, 728, 0, 0, 0, 0, 712, 658, 0], false),\\n    ([0, 0, 0, 726, 0, 0, 0, 716, 660, 0], false),\\n    ([0, 0, 730, 728, 0, 0, 0, 718, 662, 0], false),\\n    ([0, 0, 731, 729, 0, 0, 0, 719, 663, 0], false),\\n    ([0, 734, 0, 0, 724, 0, 0, 720, 664, 0], false),\\n    ([0, 735, 0, 0, 725, 0, 0, 721, 665, 0], false),\\n    ([0, 0, 0, 0, 726, 0, 0, 722, 666, 0], false),\\n    ([0, 0, 0, 735, 730, 0, 0, 723, 671, 0], false),\\n    ([0, 0, 760, 758, 750, 738, 0, 0, 0, 0], false),\\n    ([0, 0, 749, 747, 739, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 746, 744, 740, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 743, 741, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 742, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 742, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 745, 0, 741, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 742, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 745, 743, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 748, 0, 744, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 745, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 748, 746, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 757, 755, 751, 739, 0, 0, 0, 0], false),\\n    ([0, 0, 754, 752, 0, 740, 0, 0, 0, 0], false),\\n    ([0, 0, 753, 0, 0, 741, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 742, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 753, 0, 743, 0, 0, 0, 0], false),\\n    ([0, 0, 756, 0, 752, 744, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 753, 745, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 756, 754, 746, 0, 0, 0, 0], false),\\n    ([0, 0, 759, 0, 755, 747, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 756, 748, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 759, 757, 749, 0, 0, 0, 0], false),\\n    ([0, 0, 764, 762, 0, 751, 0, 0, 0, 0], false),\\n    ([0, 0, 763, 0, 0, 752, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 753, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 763, 0, 754, 0, 0, 0, 0], false),\\n    ([0, 0, 766, 0, 762, 755, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 763, 756, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 766, 764, 757, 0, 0, 0, 0], false),\\n    ([0, 0, 769, 0, 765, 758, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 766, 759, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 769, 767, 760, 0, 0, 0, 0], false),\\n    ([0, 0, 782, 780, 772, 0, 738, 0, 0, 0], false),\\n    ([0, 0, 779, 777, 773, 0, 739, 0, 0, 0], false),\\n    ([0, 0, 776, 774, 0, 0, 740, 0, 0, 0], false),\\n    ([0, 0, 775, 0, 0, 0, 741, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 742, 0, 0, 0], false),\\n    ([0, 0, 0, 775, 0, 0, 743, 0, 0, 0], false),\\n    ([0, 0, 778, 0, 774, 0, 744, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 775, 0, 745, 0, 0, 0], false),\\n    ([0, 0, 0, 778, 776, 0, 746, 0, 0, 0], false),\\n    ([0, 0, 781, 0, 777, 0, 747, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 778, 0, 748, 0, 0, 0], false),\\n    ([0, 0, 0, 781, 779, 0, 749, 0, 0, 0], false),\\n    ([0, 0, 786, 784, 0, 773, 751, 0, 0, 0], false),\\n    ([0, 0, 785, 0, 0, 774, 752, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 775, 753, 0, 0, 0], false),\\n    ([0, 0, 0, 785, 0, 776, 754, 0, 0, 0], false),\\n    ([0, 0, 788, 0, 784, 777, 755, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 785, 778, 756, 0, 0, 0], false),\\n    ([0, 0, 0, 788, 786, 779, 757, 0, 0, 0], false),\\n    ([1130, 1128, 791, 0, 787, 780, 758, 1086, 0, 938], false),\\n    ([1127, 1125, 0, 0, 788, 781, 759, 1087, 0, 939], false),\\n    ([1133, 1131, 0, 791, 789, 782, 760, 1094, 0, 946], false),\\n    ([0, 0, 796, 794, 0, 783, 761, 0, 0, 0], false),\\n    ([0, 0, 795, 0, 0, 784, 762, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 785, 763, 0, 0, 0], false),\\n    ([0, 0, 0, 795, 0, 786, 764, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 795, 788, 766, 0, 0, 0], false),\\n    ([0, 0, 0, 797, 796, 789, 767, 0, 0, 0], false),\\n    ([0, 0, 810, 808, 800, 0, 771, 0, 0, 0], false),\\n    ([0, 0, 807, 805, 801, 0, 772, 0, 0, 0], false),\\n    ([0, 0, 804, 802, 0, 0, 773, 0, 0, 0], false),\\n    ([0, 0, 803, 0, 0, 0, 774, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 775, 0, 0, 0], false),\\n    ([0, 0, 0, 803, 0, 0, 776, 0, 0, 0], false),\\n    ([0, 0, 806, 0, 802, 0, 777, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 803, 0, 778, 0, 0, 0], false),\\n    ([0, 0, 0, 806, 804, 0, 779, 0, 0, 0], false),\\n    ([0, 0, 809, 0, 805, 0, 780, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 806, 0, 781, 0, 0, 0], false),\\n    ([0, 0, 0, 809, 807, 0, 782, 0, 0, 0], false),\\n    ([0, 0, 814, 812, 0, 801, 783, 0, 0, 0], false),\\n    ([0, 0, 813, 0, 0, 802, 784, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 803, 785, 0, 0, 0], false),\\n    ([0, 0, 0, 813, 0, 804, 786, 0, 0, 0], false),\\n    ([0, 0, 816, 0, 812, 805, 787, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 813, 806, 788, 0, 0, 0], false),\\n    ([1146, 1144, 818, 0, 815, 808, 790, 1107, 0, 969], false),\\n    ([1143, 1141, 0, 0, 816, 809, 791, 1108, 0, 970], false),\\n    ([0, 0, 822, 820, 0, 811, 793, 0, 0, 0], false),\\n    ([0, 0, 821, 0, 0, 812, 794, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 813, 795, 0, 0, 0], false),\\n    ([0, 0, 0, 821, 0, 814, 796, 0, 0, 0], false),\\n    ([0, 0, 830, 828, 824, 0, 0, 0, 739, 0], false),\\n    ([0, 0, 827, 825, 0, 0, 0, 0, 740, 0], false),\\n    ([0, 0, 826, 0, 0, 0, 0, 0, 741, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 742, 0], false),\\n    ([0, 0, 0, 826, 0, 0, 0, 0, 743, 0], false),\\n    ([0, 0, 829, 0, 825, 0, 0, 0, 744, 0], false),\\n    ([0, 0, 0, 0, 826, 0, 0, 0, 745, 0], false),\\n    ([0, 0, 0, 829, 827, 0, 0, 0, 746, 0], false),\\n    ([0, 0, 0, 0, 829, 0, 0, 0, 748, 0], false),\\n    ([0, 0, 0, 831, 830, 0, 0, 0, 749, 0], false),\\n    ([0, 0, 840, 838, 834, 823, 0, 0, 750, 0], false),\\n    ([0, 0, 837, 835, 0, 824, 0, 0, 751, 0], false),\\n    ([0, 0, 836, 0, 0, 825, 0, 0, 752, 0], false),\\n    ([0, 0, 0, 0, 0, 826, 0, 0, 753, 0], false),\\n    ([0, 0, 0, 836, 0, 827, 0, 0, 754, 0], false),\\n    ([0, 0, 839, 0, 835, 828, 0, 0, 755, 0], false),\\n    ([0, 0, 0, 0, 836, 829, 0, 0, 756, 0], false),\\n    ([0, 0, 0, 839, 837, 830, 0, 0, 757, 0], false),\\n    ([0, 0, 0, 0, 839, 831, 0, 0, 759, 0], false),\\n    ([0, 0, 0, 841, 840, 832, 0, 0, 760, 0], false),\\n    ([0, 0, 846, 844, 0, 834, 0, 0, 761, 0], false),\\n    ([0, 0, 845, 0, 0, 835, 0, 0, 762, 0], false),\\n    ([0, 0, 0, 0, 0, 836, 0, 0, 763, 0], false),\\n    ([0, 0, 0, 845, 0, 837, 0, 0, 764, 0], false),\\n    ([0, 0, 848, 0, 844, 838, 0, 0, 765, 0], false),\\n    ([0, 0, 0, 0, 845, 839, 0, 0, 766, 0], false),\\n    ([0, 0, 0, 848, 846, 840, 0, 0, 767, 0], false),\\n    ([0, 0, 0, 0, 848, 841, 0, 0, 769, 0], false),\\n    ([0, 0, 858, 856, 852, 0, 823, 0, 772, 0], false),\\n    ([0, 0, 855, 853, 0, 0, 824, 0, 773, 0], false),\\n    ([0, 0, 854, 0, 0, 0, 825, 0, 774, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 826, 0, 775, 0], false),\\n    ([0, 0, 0, 854, 0, 0, 827, 0, 776, 0], false),\\n    ([0, 0, 857, 0, 853, 0, 828, 0, 777, 0], false),\\n    ([0, 0, 0, 0, 854, 0, 829, 0, 778, 0], false),\\n    ([0, 0, 0, 857, 855, 0, 830, 0, 779, 0], false),\\n    ([0, 0, 0, 0, 857, 0, 831, 0, 781, 0], false),\\n    ([0, 0, 0, 859, 858, 0, 832, 0, 782, 0], false),\\n    ([0, 0, 864, 862, 0, 852, 834, 0, 783, 0], false),\\n    ([0, 0, 863, 0, 0, 853, 835, 0, 784, 0], false),\\n    ([0, 0, 0, 0, 0, 854, 836, 0, 785, 0], false),\\n    ([0, 0, 0, 863, 0, 855, 837, 0, 786, 0], false),\\n    ([0, 0, 866, 0, 862, 856, 838, 0, 787, 0], false),\\n    ([0, 0, 0, 0, 863, 857, 839, 0, 788, 0], false),\\n    ([0, 0, 0, 866, 864, 858, 840, 0, 789, 0], false),\\n    ([1184, 1182, 0, 0, 866, 859, 841, 1155, 791, 1046], false),\\n    ([0, 0, 870, 0, 0, 862, 844, 0, 794, 0], false),\\n    ([0, 0, 0, 0, 0, 863, 845, 0, 795, 0], false),\\n    ([0, 0, 0, 0, 870, 866, 848, 0, 797, 0], false),\\n    ([935, 933, 929, 921, 0, 905, 873, 0, 0, 0], false),\\n    ([904, 902, 898, 890, 0, 874, 0, 0, 0, 0], false),\\n    ([889, 887, 883, 875, 0, 0, 0, 0, 0, 0], false),\\n    ([882, 880, 876, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([879, 877, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([878, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 878, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([881, 0, 877, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 878, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 881, 879, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([886, 884, 0, 876, 0, 0, 0, 0, 0, 0], false),\\n    ([885, 0, 0, 877, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 878, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 885, 0, 879, 0, 0, 0, 0, 0, 0], false),\\n    ([888, 0, 884, 880, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 885, 881, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 888, 886, 882, 0, 0, 0, 0, 0, 0], false),\\n    ([897, 895, 891, 0, 0, 875, 0, 0, 0, 0], false),\\n    ([894, 892, 0, 0, 0, 876, 0, 0, 0, 0], false),\\n    ([893, 0, 0, 0, 0, 877, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 878, 0, 0, 0, 0], false),\\n    ([0, 893, 0, 0, 0, 879, 0, 0, 0, 0], false),\\n    ([896, 0, 892, 0, 0, 880, 0, 0, 0, 0], false),\\n    ([0, 0, 893, 0, 0, 881, 0, 0, 0, 0], false),\\n    ([0, 896, 894, 0, 0, 882, 0, 0, 0, 0], false),\\n    ([901, 899, 0, 891, 0, 883, 0, 0, 0, 0], false),\\n    ([900, 0, 0, 892, 0, 884, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 893, 0, 885, 0, 0, 0, 0], false),\\n    ([0, 900, 0, 894, 0, 886, 0, 0, 0, 0], false),\\n    ([903, 0, 899, 895, 0, 887, 0, 0, 0, 0], false),\\n    ([0, 0, 900, 896, 0, 888, 0, 0, 0, 0], false),\\n    ([0, 903, 901, 897, 0, 889, 0, 0, 0, 0], false),\\n    ([920, 918, 914, 906, 0, 0, 874, 0, 0, 0], false),\\n    ([913, 911, 907, 0, 0, 0, 875, 0, 0, 0], false),\\n    ([910, 908, 0, 0, 0, 0, 876, 0, 0, 0], false),\\n    ([909, 0, 0, 0, 0, 0, 877, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 878, 0, 0, 0], false),\\n    ([0, 909, 0, 0, 0, 0, 879, 0, 0, 0], false),\\n    ([912, 0, 908, 0, 0, 0, 880, 0, 0, 0], false),\\n    ([0, 0, 909, 0, 0, 0, 881, 0, 0, 0], false),\\n    ([0, 912, 910, 0, 0, 0, 882, 0, 0, 0], false),\\n    ([917, 915, 0, 907, 0, 0, 883, 0, 0, 0], false),\\n    ([916, 0, 0, 908, 0, 0, 884, 0, 0, 0], false),\\n    ([0, 0, 0, 909, 0, 0, 885, 0, 0, 0], false),\\n    ([0, 916, 0, 910, 0, 0, 886, 0, 0, 0], false),\\n    ([919, 0, 915, 911, 0, 0, 887, 0, 0, 0], false),\\n    ([0, 0, 916, 912, 0, 0, 888, 0, 0, 0], false),\\n    ([0, 919, 917, 913, 0, 0, 889, 0, 0, 0], false),\\n    ([928, 926, 922, 0, 0, 906, 890, 0, 0, 0], false),\\n    ([925, 923, 0, 0, 0, 907, 891, 0, 0, 0], false),\\n    ([924, 0, 0, 0, 0, 908, 892, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 909, 893, 0, 0, 0], false),\\n    ([0, 924, 0, 0, 0, 910, 894, 0, 0, 0], false),\\n    ([927, 0, 923, 0, 0, 911, 895, 0, 0, 0], false),\\n    ([0, 0, 924, 0, 0, 912, 896, 0, 0, 0], false),\\n    ([0, 927, 925, 0, 0, 913, 897, 0, 0, 0], false),\\n    ([932, 930, 0, 922, 0, 914, 898, 0, 0, 0], false),\\n    ([931, 0, 0, 923, 0, 915, 899, 0, 0, 0], false),\\n    ([0, 0, 0, 924, 0, 916, 900, 0, 0, 0], false),\\n    ([0, 931, 0, 925, 0, 917, 901, 0, 0, 0], false),\\n    ([934, 0, 930, 926, 0, 918, 902, 0, 0, 0], false),\\n    ([0, 0, 931, 927, 0, 919, 903, 0, 0, 0], false),\\n    ([0, 934, 932, 928, 0, 920, 904, 0, 0, 0], false),\\n    ([967, 965, 961, 953, 0, 937, 0, 873, 0, 0], false),\\n    ([952, 950, 946, 938, 0, 0, 0, 874, 0, 0], false),\\n    ([945, 943, 939, 0, 0, 0, 0, 875, 0, 0], false),\\n    ([942, 940, 0, 0, 0, 0, 0, 876, 0, 0], false),\\n    ([941, 0, 0, 0, 0, 0, 0, 877, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 878, 0, 0], false),\\n    ([0, 941, 0, 0, 0, 0, 0, 879, 0, 0], false),\\n    ([944, 0, 940, 0, 0, 0, 0, 880, 0, 0], false),\\n    ([0, 0, 941, 0, 0, 0, 0, 881, 0, 0], false),\\n    ([0, 944, 942, 0, 0, 0, 0, 882, 0, 0], false),\\n    ([949, 947, 0, 939, 0, 0, 0, 883, 0, 0], false),\\n    ([948, 0, 0, 940, 0, 0, 0, 884, 0, 0], false),\\n    ([0, 0, 0, 941, 0, 0, 0, 885, 0, 0], false),\\n    ([0, 948, 0, 942, 0, 0, 0, 886, 0, 0], false),\\n    ([951, 0, 947, 943, 0, 0, 0, 887, 0, 0], false),\\n    ([0, 0, 948, 944, 0, 0, 0, 888, 0, 0], false),\\n    ([0, 951, 949, 945, 0, 0, 0, 889, 0, 0], false),\\n    ([960, 958, 954, 0, 0, 938, 0, 890, 0, 0], false),\\n    ([957, 955, 0, 0, 0, 939, 0, 891, 0, 0], false),\\n    ([956, 0, 0, 0, 0, 940, 0, 892, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 941, 0, 893, 0, 0], false),\\n    ([0, 956, 0, 0, 0, 942, 0, 894, 0, 0], false),\\n    ([959, 0, 955, 0, 0, 943, 0, 895, 0, 0], false),\\n    ([0, 0, 956, 0, 0, 944, 0, 896, 0, 0], false),\\n    ([0, 959, 957, 0, 0, 945, 0, 897, 0, 0], false),\\n    ([964, 962, 0, 954, 0, 946, 0, 898, 0, 0], false),\\n    ([963, 0, 0, 955, 0, 947, 0, 899, 0, 0], false),\\n    ([0, 0, 0, 956, 0, 948, 0, 900, 0, 0], false),\\n    ([0, 963, 0, 957, 0, 949, 0, 901, 0, 0], false),\\n    ([966, 0, 962, 958, 0, 950, 0, 902, 0, 0], false),\\n    ([0, 0, 963, 959, 0, 951, 0, 903, 0, 0], false),\\n    ([0, 966, 964, 960, 0, 952, 0, 904, 0, 0], false),\\n    ([983, 981, 977, 969, 0, 0, 937, 905, 0, 0], false),\\n    ([976, 974, 970, 0, 0, 0, 938, 906, 0, 0], false),\\n    ([973, 971, 0, 0, 0, 0, 939, 907, 0, 0], false),\\n    ([972, 0, 0, 0, 0, 0, 940, 908, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 941, 909, 0, 0], false),\\n    ([0, 972, 0, 0, 0, 0, 942, 910, 0, 0], false),\\n    ([975, 0, 971, 0, 0, 0, 943, 911, 0, 0], false),\\n    ([0, 0, 972, 0, 0, 0, 944, 912, 0, 0], false),\\n    ([0, 975, 973, 0, 0, 0, 945, 913, 0, 0], false),\\n    ([980, 978, 0, 970, 0, 0, 946, 914, 0, 0], false),\\n    ([979, 0, 0, 971, 0, 0, 947, 915, 0, 0], false),\\n    ([0, 0, 0, 972, 0, 0, 948, 916, 0, 0], false),\\n    ([0, 979, 0, 973, 0, 0, 949, 917, 0, 0], false),\\n    ([982, 0, 978, 974, 0, 0, 950, 918, 0, 0], false),\\n    ([0, 0, 979, 975, 0, 0, 951, 919, 0, 0], false),\\n    ([0, 982, 980, 976, 0, 0, 952, 920, 0, 0], false),\\n    ([991, 989, 985, 0, 0, 969, 953, 921, 0, 0], false),\\n    ([988, 986, 0, 0, 0, 970, 954, 922, 0, 0], false),\\n    ([987, 0, 0, 0, 0, 971, 955, 923, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 972, 956, 924, 0, 0], false),\\n    ([0, 987, 0, 0, 0, 973, 957, 925, 0, 0], false),\\n    ([990, 0, 986, 0, 0, 974, 958, 926, 0, 0], false),\\n    ([0, 0, 987, 0, 0, 975, 959, 927, 0, 0], false),\\n    ([0, 990, 988, 0, 0, 976, 960, 928, 0, 0], false),\\n    ([0, 0, 0, 987, 0, 979, 963, 931, 0, 0], false),\\n    ([0, 992, 0, 988, 0, 980, 964, 932, 0, 0], false),\\n    ([0, 0, 992, 990, 0, 982, 966, 934, 0, 0], false),\\n    ([0, 994, 993, 991, 0, 983, 967, 935, 0, 0], false),\\n    ([1027, 1025, 1021, 1013, 0, 997, 0, 0, 873, 0], false),\\n    ([1012, 1010, 1006, 998, 0, 0, 0, 0, 874, 0], false),\\n    ([1005, 1003, 999, 0, 0, 0, 0, 0, 875, 0], false),\\n    ([1002, 1000, 0, 0, 0, 0, 0, 0, 876, 0], false),\\n    ([1001, 0, 0, 0, 0, 0, 0, 0, 877, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 878, 0], false),\\n    ([0, 1001, 0, 0, 0, 0, 0, 0, 879, 0], false),\\n    ([1004, 0, 1000, 0, 0, 0, 0, 0, 880, 0], false),\\n    ([0, 0, 1001, 0, 0, 0, 0, 0, 881, 0], false),\\n    ([0, 1004, 1002, 0, 0, 0, 0, 0, 882, 0], false),\\n    ([1009, 1007, 0, 999, 0, 0, 0, 0, 883, 0], false),\\n    ([1008, 0, 0, 1000, 0, 0, 0, 0, 884, 0], false),\\n    ([0, 0, 0, 1001, 0, 0, 0, 0, 885, 0], false),\\n    ([0, 1008, 0, 1002, 0, 0, 0, 0, 886, 0], false),\\n    ([1011, 0, 1007, 1003, 0, 0, 0, 0, 887, 0], false),\\n    ([0, 0, 1008, 1004, 0, 0, 0, 0, 888, 0], false),\\n    ([0, 1011, 1009, 1005, 0, 0, 0, 0, 889, 0], false),\\n    ([1020, 1018, 1014, 0, 0, 998, 0, 0, 890, 0], false),\\n    ([1017, 1015, 0, 0, 0, 999, 0, 0, 891, 0], false),\\n    ([1016, 0, 0, 0, 0, 1000, 0, 0, 892, 0], false),\\n    ([0, 0, 0, 0, 0, 1001, 0, 0, 893, 0], false),\\n    ([0, 1016, 0, 0, 0, 1002, 0, 0, 894, 0], false),\\n    ([1019, 0, 1015, 0, 0, 1003, 0, 0, 895, 0], false),\\n    ([0, 0, 1016, 0, 0, 1004, 0, 0, 896, 0], false),\\n    ([0, 1019, 1017, 0, 0, 1005, 0, 0, 897, 0], false),\\n    ([1024, 1022, 0, 1014, 0, 1006, 0, 0, 898, 0], false),\\n    ([1023, 0, 0, 1015, 0, 1007, 0, 0, 899, 0], false),\\n    ([0, 0, 0, 1016, 0, 1008, 0, 0, 900, 0], false),\\n    ([0, 1023, 0, 1017, 0, 1009, 0, 0, 901, 0], false),\\n    ([1026, 0, 1022, 1018, 0, 1010, 0, 0, 902, 0], false),\\n    ([0, 0, 1023, 1019, 0, 1011, 0, 0, 903, 0], false),\\n    ([0, 1026, 1024, 1020, 0, 1012, 0, 0, 904, 0], false),\\n    ([1035, 1033, 1029, 0, 0, 0, 998, 0, 906, 0], false),\\n    ([1032, 1030, 0, 0, 0, 0, 999, 0, 907, 0], false),\\n    ([1031, 0, 0, 0, 0, 0, 1000, 0, 908, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1001, 0, 909, 0], false),\\n    ([0, 1031, 0, 0, 0, 0, 1002, 0, 910, 0], false),\\n    ([1034, 0, 1030, 0, 0, 0, 1003, 0, 911, 0], false),\\n    ([0, 0, 1031, 0, 0, 0, 1004, 0, 912, 0], false),\\n    ([0, 1034, 1032, 0, 0, 0, 1005, 0, 913, 0], false),\\n    ([1043, 1041, 1037, 0, 0, 1028, 1013, 0, 921, 0], false),\\n    ([1040, 1038, 0, 0, 0, 1029, 1014, 0, 922, 0], false),\\n    ([1039, 0, 0, 0, 0, 1030, 1015, 0, 923, 0], false),\\n    ([0, 0, 0, 0, 0, 1031, 1016, 0, 924, 0], false),\\n    ([0, 1039, 0, 0, 0, 1032, 1017, 0, 925, 0], false),\\n    ([1042, 0, 1038, 0, 0, 1033, 1018, 0, 926, 0], false),\\n    ([0, 0, 1039, 0, 0, 1034, 1019, 0, 927, 0], false),\\n    ([0, 1042, 1040, 0, 0, 1035, 1020, 0, 928, 0], false),\\n    ([1059, 1057, 1053, 1045, 0, 0, 0, 997, 937, 0], false),\\n    ([1052, 1050, 1046, 0, 0, 0, 0, 998, 938, 0], false),\\n    ([1049, 1047, 0, 0, 0, 0, 0, 999, 939, 0], false),\\n    ([1048, 0, 0, 0, 0, 0, 0, 1000, 940, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1001, 941, 0], false),\\n    ([0, 1048, 0, 0, 0, 0, 0, 1002, 942, 0], false),\\n    ([1051, 0, 1047, 0, 0, 0, 0, 1003, 943, 0], false),\\n    ([0, 0, 1048, 0, 0, 0, 0, 1004, 944, 0], false),\\n    ([0, 1051, 1049, 0, 0, 0, 0, 1005, 945, 0], false),\\n    ([1056, 1054, 0, 1046, 0, 0, 0, 1006, 946, 0], false),\\n    ([1055, 0, 0, 1047, 0, 0, 0, 1007, 947, 0], false),\\n    ([0, 0, 0, 1048, 0, 0, 0, 1008, 948, 0], false),\\n    ([0, 1055, 0, 1049, 0, 0, 0, 1009, 949, 0], false),\\n    ([1058, 0, 1054, 1050, 0, 0, 0, 1010, 950, 0], false),\\n    ([0, 0, 1055, 1051, 0, 0, 0, 1011, 951, 0], false),\\n    ([0, 1058, 1056, 1052, 0, 0, 0, 1012, 952, 0], false),\\n    ([1067, 1065, 1061, 0, 0, 1045, 0, 1013, 953, 0], false),\\n    ([1064, 1062, 0, 0, 0, 1046, 0, 1014, 954, 0], false),\\n    ([1063, 0, 0, 0, 0, 1047, 0, 1015, 955, 0], false),\\n    ([0, 0, 0, 0, 0, 1048, 0, 1016, 956, 0], false),\\n    ([0, 1063, 0, 0, 0, 1049, 0, 1017, 957, 0], false),\\n    ([1066, 0, 1062, 0, 0, 1050, 0, 1018, 958, 0], false),\\n    ([0, 0, 1063, 0, 0, 1051, 0, 1019, 959, 0], false),\\n    ([0, 1066, 1064, 0, 0, 1052, 0, 1020, 960, 0], false),\\n    ([1071, 1069, 0, 1061, 0, 1053, 0, 1021, 961, 0], false),\\n    ([1070, 0, 0, 1062, 0, 1054, 0, 1022, 962, 0], false),\\n    ([0, 0, 0, 1063, 0, 1055, 0, 1023, 963, 0], false),\\n    ([0, 1070, 0, 1064, 0, 1056, 0, 1024, 964, 0], false),\\n    ([1073, 0, 1069, 1065, 0, 1057, 0, 1025, 965, 0], false),\\n    ([0, 0, 1070, 1066, 0, 1058, 0, 1026, 966, 0], false),\\n    ([1081, 1079, 1075, 0, 0, 0, 1045, 1028, 969, 0], false),\\n    ([1078, 1076, 0, 0, 0, 0, 1046, 1029, 970, 0], false),\\n    ([1077, 0, 0, 0, 0, 0, 1047, 1030, 971, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1048, 1031, 972, 0], false),\\n    ([0, 1077, 0, 0, 0, 0, 1049, 1032, 973, 0], false),\\n    ([1080, 0, 1076, 0, 0, 0, 1050, 1033, 974, 0], false),\\n    ([0, 0, 1077, 0, 0, 0, 1051, 1034, 975, 0], false),\\n    ([0, 1080, 1078, 0, 0, 0, 1052, 1035, 976, 0], false),\\n    ([1085, 1083, 0, 0, 0, 1075, 1061, 1037, 985, 0], false),\\n    ([1084, 0, 0, 0, 0, 1076, 1062, 1038, 986, 0], false),\\n    ([0, 0, 0, 0, 0, 1077, 1063, 1039, 987, 0], false),\\n    ([0, 1084, 0, 0, 0, 1078, 1064, 1040, 988, 0], false),\\n    ([1093, 1091, 1087, 0, 0, 0, 0, 0, 0, 875], false),\\n    ([1090, 1088, 0, 0, 0, 0, 0, 0, 0, 876], false),\\n    ([1089, 0, 0, 0, 0, 0, 0, 0, 0, 877], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 878], false),\\n    ([0, 1089, 0, 0, 0, 0, 0, 0, 0, 879], false),\\n    ([1092, 0, 1088, 0, 0, 0, 0, 0, 0, 880], false),\\n    ([0, 0, 1089, 0, 0, 0, 0, 0, 0, 881], false),\\n    ([0, 1092, 1090, 0, 0, 0, 0, 0, 0, 882], false),\\n    ([1097, 1095, 0, 1087, 0, 0, 0, 0, 0, 883], false),\\n    ([1096, 0, 0, 1088, 0, 0, 0, 0, 0, 884], false),\\n    ([0, 0, 0, 1089, 0, 0, 0, 0, 0, 885], false),\\n    ([0, 1096, 0, 1090, 0, 0, 0, 0, 0, 886], false),\\n    ([1099, 0, 0, 0, 0, 1088, 0, 0, 0, 892], false),\\n    ([0, 0, 0, 0, 0, 1089, 0, 0, 0, 893], false),\\n    ([0, 1099, 0, 0, 0, 1090, 0, 0, 0, 894], false),\\n    ([1102, 0, 1098, 0, 0, 1091, 0, 0, 0, 895], false),\\n    ([0, 0, 1099, 0, 0, 1092, 0, 0, 0, 896], false),\\n    ([0, 1102, 1100, 0, 0, 1093, 0, 0, 0, 897], false),\\n    ([1105, 0, 0, 1098, 0, 1095, 0, 0, 0, 899], false),\\n    ([0, 0, 0, 1099, 0, 1096, 0, 0, 0, 900], false),\\n    ([0, 1105, 0, 1100, 0, 1097, 0, 0, 0, 901], false),\\n    ([1114, 1112, 1108, 0, 0, 0, 1086, 0, 0, 906], false),\\n    ([1111, 1109, 0, 0, 0, 0, 1087, 0, 0, 907], false),\\n    ([1110, 0, 0, 0, 0, 0, 1088, 0, 0, 908], false),\\n    ([0, 0, 0, 0, 0, 0, 1089, 0, 0, 909], false),\\n    ([0, 1110, 0, 0, 0, 0, 1090, 0, 0, 910], false),\\n    ([1113, 0, 1109, 0, 0, 0, 1091, 0, 0, 911], false),\\n    ([0, 0, 1110, 0, 0, 0, 1092, 0, 0, 912], false),\\n    ([0, 1113, 1111, 0, 0, 0, 1093, 0, 0, 913], false),\\n    ([1118, 1116, 0, 1108, 0, 0, 1094, 0, 0, 914], false),\\n    ([1117, 0, 0, 1109, 0, 0, 1095, 0, 0, 915], false),\\n    ([0, 0, 0, 1110, 0, 0, 1096, 0, 0, 916], false),\\n    ([0, 1117, 0, 1111, 0, 0, 1097, 0, 0, 917], false),\\n    ([0, 0, 0, 0, 0, 1110, 1099, 0, 0, 924], false),\\n    ([0, 1119, 0, 0, 0, 1111, 1100, 0, 0, 925], false),\\n    ([0, 0, 1119, 0, 0, 1113, 1102, 0, 0, 927], false),\\n    ([0, 1121, 1120, 0, 0, 1114, 1103, 0, 0, 928], false),\\n    ([0, 0, 0, 1119, 0, 1117, 1105, 0, 0, 931], false),\\n    ([0, 1123, 0, 1120, 0, 1118, 1106, 0, 0, 932], false),\\n    ([1126, 0, 0, 0, 0, 0, 0, 1088, 0, 940], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1089, 0, 941], false),\\n    ([0, 1126, 0, 0, 0, 0, 0, 1090, 0, 942], false),\\n    ([1129, 0, 1125, 0, 0, 0, 0, 1091, 0, 943], false),\\n    ([0, 0, 1126, 0, 0, 0, 0, 1092, 0, 944], false),\\n    ([0, 1129, 1127, 0, 0, 0, 0, 1093, 0, 945], false),\\n    ([1132, 0, 0, 1125, 0, 0, 0, 1095, 0, 947], false),\\n    ([0, 0, 0, 1126, 0, 0, 0, 1096, 0, 948], false),\\n    ([0, 1132, 0, 1127, 0, 0, 0, 1097, 0, 949], false),\\n    ([1135, 0, 0, 0, 0, 1125, 0, 1098, 0, 955], false),\\n    ([0, 0, 0, 0, 0, 1126, 0, 1099, 0, 956], false),\\n    ([0, 1135, 0, 0, 0, 1127, 0, 1100, 0, 957], false),\\n    ([0, 0, 1135, 0, 0, 1129, 0, 1102, 0, 959], false),\\n    ([1139, 0, 0, 1134, 0, 1131, 0, 1104, 0, 962], false),\\n    ([0, 0, 0, 1135, 0, 1132, 0, 1105, 0, 963], false),\\n    ([0, 1139, 0, 1136, 0, 1133, 0, 1106, 0, 964], false),\\n    ([1142, 0, 0, 0, 0, 0, 1125, 1109, 0, 971], false),\\n    ([0, 0, 0, 0, 0, 0, 1126, 1110, 0, 972], false),\\n    ([0, 1142, 0, 0, 0, 0, 1127, 1111, 0, 973], false),\\n    ([1145, 0, 1141, 0, 0, 0, 1128, 1112, 0, 974], false),\\n    ([0, 0, 1142, 0, 0, 0, 1129, 1113, 0, 975], false),\\n    ([0, 1145, 1143, 0, 0, 0, 1130, 1114, 0, 976], false),\\n    ([1148, 0, 0, 1141, 0, 0, 1131, 1116, 0, 978], false),\\n    ([0, 0, 0, 1142, 0, 0, 1132, 1117, 0, 979], false),\\n    ([0, 1148, 0, 1143, 0, 0, 1133, 1118, 0, 980], false),\\n    ([0, 0, 0, 0, 0, 1142, 1135, 1119, 0, 987], false),\\n    ([0, 1150, 0, 0, 0, 1143, 1136, 1120, 0, 988], false),\\n    ([0, 0, 1150, 0, 0, 1145, 1137, 1121, 0, 990], false),\\n    ([0, 0, 0, 1150, 0, 1148, 1139, 1123, 0, 992], false),\\n    ([1161, 1159, 1155, 0, 0, 0, 0, 0, 1086, 998], false),\\n    ([1158, 1156, 0, 0, 0, 0, 0, 0, 1087, 999], false),\\n    ([1157, 0, 0, 0, 0, 0, 0, 0, 1088, 1000], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 1089, 1001], false),\\n    ([0, 1157, 0, 0, 0, 0, 0, 0, 1090, 1002], false),\\n    ([1160, 0, 1156, 0, 0, 0, 0, 0, 1091, 1003], false),\\n    ([0, 0, 1157, 0, 0, 0, 0, 0, 1092, 1004], false),\\n    ([0, 1160, 1158, 0, 0, 0, 0, 0, 1093, 1005], false),\\n    ([1165, 1163, 0, 1155, 0, 0, 0, 0, 1094, 1006], false),\\n    ([1164, 0, 0, 1156, 0, 0, 0, 0, 1095, 1007], false),\\n    ([0, 0, 0, 1157, 0, 0, 0, 0, 1096, 1008], false),\\n    ([0, 1164, 0, 1158, 0, 0, 0, 0, 1097, 1009], false),\\n    ([1167, 0, 0, 0, 0, 1156, 0, 0, 1098, 1015], false),\\n    ([0, 0, 0, 0, 0, 1157, 0, 0, 1099, 1016], false),\\n    ([0, 1167, 0, 0, 0, 1158, 0, 0, 1100, 1017], false),\\n    ([1170, 0, 1166, 0, 0, 1159, 0, 0, 1101, 1018], false),\\n    ([0, 0, 1167, 0, 0, 1160, 0, 0, 1102, 1019], false),\\n    ([0, 1170, 1168, 0, 0, 1161, 0, 0, 1103, 1020], false),\\n    ([0, 0, 0, 1167, 0, 1164, 0, 0, 1105, 1023], false),\\n    ([0, 1172, 0, 1168, 0, 1165, 0, 0, 1106, 1024], false),\\n    ([1181, 1179, 1175, 0, 0, 0, 1154, 0, 1107, 1028], false),\\n    ([1178, 1176, 0, 0, 0, 0, 1155, 0, 1108, 1029], false),\\n    ([1177, 0, 0, 0, 0, 0, 1156, 0, 1109, 1030], false),\\n    ([0, 0, 0, 0, 0, 0, 1157, 0, 1110, 1031], false),\\n    ([0, 1177, 0, 0, 0, 0, 1158, 0, 1111, 1032], false),\\n    ([1180, 0, 1176, 0, 0, 0, 1159, 0, 1112, 1033], false),\\n    ([0, 0, 1177, 0, 0, 0, 1160, 0, 1113, 1034], false),\\n    ([0, 1180, 1178, 0, 0, 0, 1161, 0, 1114, 1035], false),\\n    ([1183, 0, 0, 0, 0, 0, 0, 1156, 1125, 1047], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1157, 1126, 1048], false),\\n    ([0, 1183, 0, 0, 0, 0, 0, 1158, 1127, 1049], false),\\n    ([1186, 0, 1182, 0, 0, 0, 0, 1159, 1128, 1050], false),\\n    ([0, 0, 1183, 0, 0, 0, 0, 1160, 1129, 1051], false),\\n    ([0, 1186, 1184, 0, 0, 0, 0, 1161, 1130, 1052], false),\\n    ([1189, 0, 0, 1182, 0, 0, 0, 1163, 1131, 1054], false),\\n    ([0, 0, 0, 1183, 0, 0, 0, 1164, 1132, 1055], false),\\n    ([0, 1189, 0, 1184, 0, 0, 0, 1165, 1133, 1056], false),\\n    ([1192, 0, 0, 0, 0, 1182, 0, 1166, 1134, 1062], false),\\n    ([0, 0, 0, 0, 0, 1183, 0, 1167, 1135, 1063], false),\\n    ([0, 1192, 0, 0, 0, 1184, 0, 1168, 1136, 1064], false),\\n    ([0, 0, 1192, 0, 0, 1186, 0, 1170, 1137, 1066], false),\\n    ([0, 0, 0, 1192, 0, 1189, 0, 1172, 1139, 1070], false),\\n    ([0, 1195, 0, 1193, 0, 1190, 0, 1173, 1140, 1071], false),\\n    ([1198, 0, 0, 0, 0, 0, 1182, 1176, 1141, 1076], false),\\n    ([0, 0, 0, 0, 0, 0, 1183, 1177, 1142, 1077], false),\\n    ([0, 1198, 0, 0, 0, 0, 1184, 1178, 1143, 1078], false),\\n    ([1201, 0, 1197, 0, 0, 0, 1185, 1179, 1144, 1079], false),\\n    ([0, 0, 1198, 0, 0, 0, 1186, 1180, 1145, 1080], false),\\n    ([0, 1201, 1199, 0, 0, 0, 1187, 1181, 1146, 1081], false),\\n];\\n```\\n\\nIf you scrolled all the way here, you might as well enjoy reading the program that generates the graph:\\n\\n```\\nconst N_DIGITS: usize = 10;\\n\\nuse std::collections::HashMap;\\n\\nfn get_node_id(digits: &[usize], visited: &mut [bool], n_visited: usize) -> usize {\\n    if n_visited == 0 {\\n        usize::MAX\\n    } else {\\n        digits\\n            .iter()\\n            .zip(visited.iter())\\n            .fold(0, |id, (d, v)| if *v { id * 10 + *d } else { id })\\n    }\\n}\\n\\nfn backtrack(\\n    digits: &[usize],\\n    visited: &mut [bool],\\n    depth: usize,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let curr_id = get_node_id(digits, visited, depth);\\n    if depth == digits.len() {\\n        graph.get_mut(&curr_id).unwrap().2 = true;\\n    } else {\\n        graph.entry(curr_id).or_insert_with(|| {\\n            let nn = *node_number;\\n            *node_number += 1;\\n            (nn, [0; N_DIGITS], false)\\n        });\\n\\n        for i in 0..digits.len() {\\n            if !visited[i] {\\n                visited[i] = true;\\n                let next_id = get_node_id(digits, visited, depth + 1);\\n                let next_node_number = graph\\n                    .entry(next_id)\\n                    .or_insert_with(|| {\\n                        let nn = *node_number;\\n                        *node_number += 1;\\n                        (nn, [0; N_DIGITS], false)\\n                    })\\n                    .0;\\n                graph.get_mut(&curr_id).unwrap().1[digits[i]] = next_node_number;\\n                backtrack(digits, visited, depth + 1, graph, node_number);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n}\\n\\nfn get_digits(mut n: i32) -> Vec<usize> {\\n    if n == 0 {\\n        vec![0]\\n    } else {\\n        let mut rez = vec![];\\n        while n > 0 {\\n            rez.push((n % 10) as usize);\\n            n /= 10;\\n        }\\n        rez.sort_unstable_by(|d1, d2| d2.cmp(d1));\\n        rez\\n    }\\n}\\n\\nfn insert(\\n    n: i32,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let digits = get_digits(n);\\n    let mut visited = vec![false; digits.len()];\\n    backtrack(&digits, &mut visited, 0, graph, node_number);\\n}\\n\\nfn main() {\\n    let mut node_number = 0;\\n    let mut graph_map = HashMap::new();\\n    for shift in 0..30 {\\n        insert(1 << shift, &mut graph_map, &mut node_number);\\n    }\\n    let mut graph = graph_map.values().copied().collect::<Vec<_>>();\\n    graph.sort_unstable_by_key(|(node_number, _, _)| *node_number);\\n    let graph = graph\\n        .into_iter()\\n        .map(|(_, edges, leaf)| (edges, leaf))\\n        .collect::<Vec<_>>();\\n    println!(\"{:?}\", graph);\\n    println!(\"{:?}\", graph.len());\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst N_DIGITS: usize = 10;\\n\\nconst fn build_histogram(mut n: i32) -> [u8; N_DIGITS] {\\n    let mut rez = [0; N_DIGITS];\\n    while n > 0 {\\n        rez[(n % 10) as usize] += 1;\\n        n /= 10;\\n    }\\n    rez\\n}\\n\\nconst N_POWERS: usize = 30;\\n\\nconst fn compute_power_histograms() -> [[u8; N_DIGITS]; N_POWERS] {\\n    let mut i = 0;\\n    let mut rez = [[0; N_DIGITS]; N_POWERS];\\n    while i < N_POWERS {\\n        rez[i] = build_histogram(1 << i);\\n        i += 1;\\n    }\\n    rez\\n}\\n\\nconst POWER_HISTOGRAMS: [[u8; N_DIGITS]; N_POWERS] = compute_power_histograms();\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        POWER_HISTOGRAMS.contains(&build_histogram(n))\\n    }\\n}\\n```\n```\\nconst N_DIGITS: usize = 10;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(mut n: i32) -> bool {\\n        let mut node = 0;\\n        while n > 0 {\\n            let digit = (n % 10) as usize;\\n            match GRAPH[node].0[digit] {\\n                0 => return false,\\n                next_node => node = next_node,\\n            }\\n            n /= 10;\\n        }\\n        GRAPH[node].1\\n    }\\n}\\n\\nconst GRAPH: [([usize; N_DIGITS], bool); 1203] = [\\n    ([31, 1, 2, 7, 3, 17, 5, 87, 4, 38], false),\\n    ([30, 139, 13, 75, 25, 20, 6, 123, 12, 54], true),\\n    ([29, 13, 162, 8, 21, 18, 16, 94, 10, 52], true),\\n    ([27, 25, 21, 73, 154, 184, 9, 261, 32, 43], true),\\n    ([37, 12, 10, 66, 32, 176, 55, 76, 164, 48], true),\\n    ([47, 6, 16, 71, 9, 14, 96, 88, 55, 39], false),\\n    ([273, 460, 153, 72, 70, 269, 457, 250, 62, 1072], true),\\n    ([136, 75, 8, 512, 73, 107, 71, 92, 66, 363], false),\\n    ([132, 128, 733, 515, 511, 501, 95, 93, 86, 1082], true),\\n    ([46, 70, 147, 68, 141, 265, 581, 246, 56, 40], true),\\n    ([36, 11, 183, 86, 33, 180, 85, 83, 174, 49], false),\\n    ([1153, 672, 670, 667, 661, 1147, 1138, 649, 0, 50], true),\\n    ([237, 673, 11, 67, 65, 233, 62, 215, 557, 51], false),\\n    ([28, 137, 163, 128, 22, 19, 153, 118, 11, 53], false),\\n    ([271, 269, 15, 104, 265, 102, 97, 238, 218, 1044], false),\\n    ([1190, 1188, 0, 868, 867, 860, 842, 1162, 792, 1053], true),\\n    ([1196, 153, 151, 95, 147, 15, 454, 91, 85, 1068], false),\\n    ([278, 20, 18, 107, 184, 105, 14, 253, 176, 303], false),\\n    ([338, 19, 187, 501, 185, 482, 15, 322, 180, 304], false),\\n    ([337, 0, 334, 1197, 0, 0, 1188, 327, 1147, 309], true),\\n    ([277, 0, 19, 1200, 274, 0, 269, 258, 233, 312], false),\\n    ([24, 22, 160, 511, 155, 185, 147, 713, 33, 0], false),\\n    ([23, 731, 161, 727, 158, 0, 150, 717, 661, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 23, 0, 0, 0, 0, 0, 0, 34, 0], false),\\n    ([26, 732, 22, 74, 159, 274, 70, 262, 65, 361], false),\\n    ([0, 0, 23, 381, 379, 275, 272, 263, 236, 362], false),\\n    ([0, 26, 24, 382, 380, 276, 46, 264, 35, 44], false),\\n    ([0, 138, 339, 131, 23, 337, 1195, 121, 1153, 319], false),\\n    ([0, 28, 340, 132, 24, 338, 1196, 122, 36, 320], false),\\n    ([0, 140, 28, 135, 26, 277, 273, 126, 237, 321], false),\\n    ([0, 30, 29, 136, 27, 278, 47, 127, 37, 45], false),\\n    ([35, 65, 33, 63, 819, 177, 56, 211, 171, 0], false),\\n    ([34, 661, 182, 652, 822, 178, 798, 632, 172, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 236, 34, 0, 0, 232, 227, 214, 556, 0], false),\\n    ([0, 1153, 0, 1151, 34, 1149, 1140, 1124, 0, 993], false),\\n    ([0, 237, 36, 407, 35, 235, 229, 217, 405, 995], false),\\n    ([45, 54, 52, 363, 43, 303, 39, 279, 48, 0], false),\\n    ([42, 1072, 1068, 1060, 40, 1044, 0, 996, 936, 0], false),\\n    ([41, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 1073, 1071, 1067, 41, 1059, 0, 1027, 967, 0], false),\\n    ([44, 361, 0, 357, 341, 0, 40, 0, 0, 0], false),\\n    ([0, 362, 0, 360, 356, 0, 41, 0, 0, 0], false),\\n    ([0, 321, 320, 366, 44, 314, 42, 302, 995, 0], false),\\n    ([0, 272, 0, 0, 0, 268, 584, 249, 227, 41], false),\\n    ([0, 273, 1196, 408, 46, 271, 586, 252, 229, 42], false),\\n    ([995, 51, 49, 984, 0, 968, 936, 872, 0, 0], false),\\n    ([993, 50, 0, 985, 0, 977, 961, 929, 0, 0], false),\\n    ([992, 0, 0, 986, 0, 978, 962, 930, 0, 0], true),\\n    ([994, 0, 50, 989, 0, 981, 965, 933, 0, 0], false),\\n    ([320, 53, 315, 1082, 0, 304, 1068, 292, 49, 0], false),\\n    ([319, 0, 316, 1083, 0, 309, 1069, 297, 50, 0], false),\\n    ([321, 0, 53, 364, 361, 312, 1072, 300, 51, 0], false),\\n    ([229, 62, 85, 60, 56, 218, 567, 77, 399, 936], false),\\n    ([227, 59, 798, 57, 793, 219, 568, 196, 548, 0], false),\\n    ([0, 58, 797, 0, 794, 787, 765, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([226, 0, 0, 58, 0, 220, 569, 197, 549, 0], false),\\n    ([406, 61, 84, 0, 57, 790, 768, 78, 400, 953], false),\\n    ([1137, 0, 1134, 0, 58, 1128, 0, 1101, 0, 958], false),\\n    ([228, 0, 1138, 61, 59, 223, 572, 200, 552, 965], false),\\n    ([0, 64, 652, 0, 820, 815, 57, 623, 0, 0], false),\\n    ([0, 658, 656, 0, 0, 0, 58, 630, 0, 0], false),\\n    ([236, 663, 661, 64, 0, 230, 59, 212, 554, 0], false),\\n    ([407, 67, 86, 0, 63, 817, 60, 81, 403, 984], false),\\n    ([1152, 669, 667, 0, 64, 1144, 61, 644, 0, 989], false),\\n    ([0, 69, 871, 0, 869, 865, 847, 0, 57, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 58, 0], false),\\n    ([272, 0, 150, 69, 146, 266, 582, 247, 59, 0], false),\\n    ([408, 72, 95, 0, 68, 104, 101, 89, 60, 1060], false),\\n    ([1194, 0, 1191, 0, 69, 1185, 0, 1169, 61, 1065], false),\\n    ([382, 74, 511, 507, 375, 491, 68, 704, 63, 357], false),\\n    ([381, 729, 727, 0, 376, 0, 69, 711, 64, 358], false),\\n    ([135, 133, 128, 0, 74, 1200, 72, 113, 67, 364], false),\\n    ([217, 215, 83, 81, 211, 203, 77, 587, 516, 872], false),\\n    ([202, 200, 80, 78, 196, 188, 559, 0, 517, 873], false),\\n    ([1103, 1101, 79, 0, 0, 1086, 0, 0, 0, 890], false),\\n    ([1100, 1098, 0, 0, 0, 1087, 0, 0, 0, 891], true),\\n    ([1106, 1104, 0, 79, 0, 1094, 0, 0, 0, 898], false),\\n    ([1122, 644, 82, 0, 623, 1107, 78, 606, 0, 921], false),\\n    ([1120, 642, 639, 0, 624, 1108, 79, 607, 0, 922], false),\\n    ([1124, 649, 646, 82, 632, 1115, 80, 615, 0, 929], false),\\n    ([1136, 1134, 0, 0, 797, 791, 769, 79, 0, 954], false),\\n    ([1140, 1138, 0, 84, 798, 792, 770, 80, 0, 961], false),\\n    ([1151, 667, 664, 0, 652, 818, 84, 82, 0, 985], false),\\n    ([127, 123, 94, 92, 261, 253, 88, 409, 76, 279], false),\\n    ([252, 250, 91, 89, 246, 238, 445, 428, 77, 996], false),\\n    ([1171, 1169, 90, 0, 0, 1154, 0, 0, 78, 1013], false),\\n    ([1168, 1166, 0, 0, 0, 1155, 0, 0, 79, 1014], false),\\n    ([1173, 451, 0, 90, 0, 1162, 446, 435, 80, 1021], false),\\n    ([117, 113, 93, 0, 704, 1174, 89, 692, 81, 1036], false),\\n    ([112, 108, 720, 0, 705, 1175, 90, 693, 82, 1037], false),\\n    ([122, 118, 330, 93, 713, 322, 91, 440, 83, 292], false),\\n    ([1193, 1191, 0, 0, 871, 868, 850, 90, 84, 1061], false),\\n    ([586, 457, 454, 101, 581, 97, 0, 445, 567, 0], false),\\n    ([0, 0, 842, 100, 833, 98, 0, 0, 737, 0], false),\\n    ([0, 0, 832, 99, 823, 0, 0, 0, 738, 0], false),\\n    ([0, 0, 831, 0, 828, 0, 0, 0, 747, 0], true),\\n    ([0, 0, 841, 0, 838, 99, 0, 0, 758, 0], false),\\n    ([0, 0, 850, 0, 847, 100, 0, 0, 768, 0], false),\\n    ([0, 0, 860, 103, 851, 0, 98, 0, 771, 0], false),\\n    ([0, 0, 859, 0, 856, 0, 99, 0, 780, 0], false),\\n    ([1187, 1185, 868, 0, 865, 103, 100, 1154, 790, 1045], false),\\n    ([0, 0, 482, 106, 461, 0, 102, 0, 799, 0], false),\\n    ([0, 0, 481, 477, 470, 0, 103, 0, 808, 0], false),\\n    (\\n        [1202, 1200, 501, 497, 491, 106, 104, 1174, 817, 1074],\\n        false,\\n    ),\\n    ([111, 109, 721, 0, 709, 1176, 1166, 697, 642, 1038], false),\\n    ([110, 0, 722, 0, 710, 0, 0, 698, 643, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 110, 0, 0, 0, 1177, 1167, 0, 1119, 1039], false),\\n    ([0, 111, 0, 0, 0, 1178, 1168, 0, 1120, 1040], false),\\n    ([116, 114, 108, 0, 711, 1179, 1169, 699, 644, 1041], false),\\n    ([115, 0, 109, 0, 712, 0, 0, 700, 645, 0], false),\\n    ([0, 0, 110, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 115, 111, 0, 0, 1180, 1170, 0, 1121, 1042], false),\\n    ([0, 116, 112, 0, 0, 1181, 1171, 0, 1122, 1043], false),\\n    ([121, 119, 331, 108, 717, 327, 451, 441, 649, 297], false),\\n    ([120, 0, 723, 109, 718, 0, 452, 442, 650, 0], false),\\n    ([0, 0, 0, 110, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 120, 332, 111, 0, 328, 1172, 0, 1123, 298], false),\\n    ([0, 121, 333, 112, 0, 329, 1173, 0, 1124, 299], false),\\n    ([126, 124, 118, 113, 262, 258, 250, 443, 215, 300], false),\\n    ([125, 0, 119, 114, 719, 0, 453, 444, 651, 0], false),\\n    ([0, 0, 120, 115, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 125, 121, 116, 263, 259, 251, 0, 216, 301], false),\\n    ([0, 126, 122, 117, 264, 260, 252, 0, 217, 302], false),\\n    ([131, 129, 734, 0, 727, 1197, 1191, 108, 667, 1083], false),\\n    ([130, 0, 735, 0, 728, 0, 0, 109, 668, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 110, 0, 0], false),\\n    ([0, 130, 0, 0, 0, 1198, 1192, 111, 1150, 1084], false),\\n    ([0, 131, 0, 0, 0, 1199, 1193, 112, 1151, 1085], false),\\n    ([134, 0, 129, 0, 729, 0, 0, 114, 669, 0], false),\\n    ([0, 0, 130, 0, 0, 0, 0, 115, 0, 0], false),\\n    ([0, 134, 131, 0, 381, 1201, 1194, 116, 1152, 365], false),\\n    ([0, 135, 132, 0, 382, 1202, 408, 117, 407, 366], false),\\n    ([138, 0, 736, 129, 731, 0, 459, 119, 672, 0], false),\\n    ([0, 0, 0, 130, 0, 0, 0, 120, 0, 0], false),\\n    ([140, 0, 137, 133, 732, 0, 460, 124, 673, 0], false),\\n    ([0, 0, 138, 134, 0, 0, 0, 125, 0, 0], false),\\n    ([0, 146, 142, 869, 0, 861, 843, 0, 793, 0], false),\\n    ([0, 145, 143, 870, 0, 864, 846, 0, 796, 0], false),\\n    ([0, 144, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 144, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 145, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 150, 148, 871, 142, 867, 849, 0, 798, 0], false),\\n    ([0, 149, 0, 0, 143, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 144, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 149, 0, 145, 0, 0, 0, 0, 0], false),\\n    ([0, 152, 0, 0, 148, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 149, 0, 0, 0, 0, 0], false),\\n    (\\n        [1195, 459, 152, 1191, 150, 1188, 455, 451, 1138, 1069],\\n        false,\\n    ),\\n    ([380, 159, 155, 375, 367, 483, 141, 0, 819, 341], false),\\n    ([0, 158, 156, 506, 0, 490, 142, 0, 822, 0], false),\\n    ([0, 157, 0, 0, 0, 0, 143, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 144, 0, 0, 0], false),\\n    ([0, 0, 157, 0, 0, 0, 145, 0, 0, 0], false),\\n    ([379, 0, 158, 376, 372, 0, 146, 0, 0, 354], false),\\n    ([0, 161, 0, 724, 156, 186, 148, 714, 182, 0], false),\\n    ([0, 730, 0, 725, 157, 0, 149, 715, 659, 0], false),\\n    ([340, 163, 0, 733, 160, 187, 151, 330, 183, 315], false),\\n    ([339, 736, 0, 734, 161, 334, 152, 331, 670, 316], false),\\n    ([405, 557, 174, 403, 171, 165, 399, 516, 383, 0], false),\\n    ([0, 0, 169, 0, 166, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 167, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 168, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 170, 0, 167, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 168, 0, 0, 0, 0, 0], false),\\n    ([556, 554, 172, 0, 0, 166, 548, 533, 0, 0], false),\\n    ([0, 0, 173, 0, 0, 167, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 168, 0, 0, 0, 0], false),\\n    ([0, 0, 175, 0, 172, 169, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 173, 170, 0, 0, 0, 0], false),\\n    ([235, 233, 180, 817, 177, 799, 218, 203, 165, 968], false),\\n    ([232, 230, 178, 815, 811, 800, 219, 204, 166, 0], false),\\n    ([0, 0, 179, 816, 814, 807, 789, 0, 167, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 168, 0], false),\\n    ([1149, 1147, 181, 818, 178, 810, 792, 1115, 169, 977], false),\\n    ([0, 0, 0, 0, 179, 0, 0, 0, 170, 0], false),\\n    ([0, 659, 0, 653, 0, 179, 0, 633, 173, 0], false),\\n    ([0, 670, 0, 664, 182, 181, 0, 646, 175, 0], false),\\n    ([276, 274, 185, 491, 483, 461, 265, 254, 177, 0], false),\\n    ([0, 0, 186, 496, 490, 476, 867, 0, 178, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 179, 0], false),\\n    ([336, 334, 0, 0, 186, 0, 0, 323, 181, 305], false),\\n    ([195, 193, 1094, 1086, 189, 0, 0, 0, 0, 874], false),\\n    ([192, 190, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([191, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 191, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([194, 0, 1095, 1091, 190, 0, 0, 0, 0, 887], false),\\n    ([0, 0, 1096, 1092, 191, 0, 0, 0, 0, 888], false),\\n    ([0, 194, 1097, 1093, 192, 0, 0, 0, 0, 889], false),\\n    ([199, 197, 0, 0, 0, 189, 560, 0, 526, 0], false),\\n    ([198, 0, 0, 0, 0, 190, 561, 0, 527, 0], false),\\n    ([0, 0, 0, 0, 0, 191, 562, 0, 528, 0], false),\\n    ([0, 198, 0, 0, 0, 192, 563, 0, 529, 0], false),\\n    ([201, 0, 1104, 1101, 197, 193, 564, 0, 530, 902], false),\\n    ([0, 0, 1105, 1102, 198, 194, 565, 0, 531, 903], false),\\n    ([0, 201, 1106, 1103, 199, 195, 566, 0, 532, 904], false),\\n    ([210, 208, 1115, 1107, 204, 0, 188, 0, 0, 905], false),\\n    ([207, 205, 0, 0, 0, 0, 189, 0, 0, 0], false),\\n    ([206, 0, 0, 0, 0, 0, 190, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 191, 0, 0, 0], false),\\n    ([0, 206, 0, 0, 0, 0, 192, 0, 0, 0], false),\\n    ([209, 0, 1116, 1112, 205, 0, 193, 0, 0, 918], false),\\n    ([0, 0, 1117, 1113, 206, 0, 194, 0, 0, 919], false),\\n    ([0, 209, 1118, 1114, 207, 0, 195, 0, 0, 920], false),\\n    ([214, 212, 632, 623, 0, 204, 196, 588, 533, 0], false),\\n    ([213, 638, 636, 630, 0, 205, 197, 604, 534, 0], false),\\n    ([0, 0, 0, 0, 0, 206, 198, 0, 535, 0], false),\\n    ([0, 213, 0, 0, 0, 207, 199, 0, 536, 0], false),\\n    ([216, 651, 649, 644, 212, 208, 200, 621, 537, 933], false),\\n    ([0, 0, 1123, 1121, 213, 209, 201, 0, 538, 934], false),\\n    ([0, 216, 1124, 1122, 214, 210, 202, 0, 539, 935], false),\\n    ([225, 223, 792, 790, 219, 771, 737, 188, 0, 937], false),\\n    ([222, 220, 789, 787, 783, 772, 750, 189, 0, 0], false),\\n    ([221, 0, 0, 0, 0, 0, 0, 190, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 191, 0, 0], false),\\n    ([0, 221, 0, 0, 0, 0, 0, 192, 0, 0], false),\\n    ([224, 0, 1131, 1128, 220, 0, 0, 193, 0, 950], false),\\n    ([0, 0, 1132, 1129, 221, 0, 0, 194, 0, 951], false),\\n    ([0, 224, 1133, 1130, 222, 0, 0, 195, 0, 952], false),\\n    ([0, 0, 0, 0, 0, 221, 570, 198, 550, 0], false),\\n    ([0, 226, 0, 0, 0, 222, 571, 199, 551, 0], false),\\n    ([0, 0, 1139, 1137, 226, 224, 573, 201, 553, 966], false),\\n    ([0, 228, 1140, 406, 227, 225, 574, 202, 402, 967], false),\\n    ([231, 0, 0, 0, 0, 0, 220, 205, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 221, 206, 0, 0], false),\\n    ([0, 231, 0, 0, 0, 0, 222, 207, 0, 0], false),\\n    ([234, 0, 1147, 1144, 230, 0, 223, 208, 0, 981], false),\\n    ([0, 0, 1148, 1145, 231, 0, 224, 209, 0, 982], false),\\n    ([0, 234, 1149, 1146, 232, 0, 225, 210, 0, 983], false),\\n    ([0, 0, 0, 0, 0, 231, 226, 213, 555, 0], false),\\n    ([0, 0, 1153, 1152, 236, 234, 228, 216, 558, 994], false),\\n    ([245, 243, 1162, 1154, 239, 0, 0, 0, 188, 997], false),\\n    ([242, 240, 0, 0, 0, 0, 0, 0, 189, 0], false),\\n    ([241, 0, 0, 0, 0, 0, 0, 0, 190, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 191, 0], false),\\n    ([0, 241, 0, 0, 0, 0, 0, 0, 192, 0], false),\\n    ([244, 0, 1163, 1159, 240, 0, 0, 0, 193, 1010], false),\\n    ([0, 0, 1164, 1160, 241, 0, 0, 0, 194, 1011], false),\\n    ([0, 244, 1165, 1161, 242, 0, 0, 0, 195, 1012], false),\\n    ([249, 247, 0, 0, 0, 239, 575, 0, 196, 0], false),\\n    ([248, 0, 0, 0, 0, 240, 576, 0, 197, 0], false),\\n    ([0, 0, 0, 0, 0, 241, 577, 0, 198, 0], false),\\n    ([0, 248, 0, 0, 0, 242, 578, 0, 199, 0], false),\\n    ([251, 453, 451, 1169, 247, 243, 449, 438, 200, 1025], false),\\n    ([0, 0, 1172, 1170, 248, 244, 579, 0, 201, 1026], false),\\n    ([0, 251, 1173, 1171, 249, 245, 580, 0, 202, 1027], false),\\n    ([260, 258, 322, 1174, 254, 0, 238, 0, 203, 280], false),\\n    ([257, 255, 0, 0, 0, 0, 239, 0, 204, 0], false),\\n    ([256, 0, 0, 0, 0, 0, 240, 0, 205, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 241, 0, 206, 0], false),\\n    ([0, 256, 0, 0, 0, 0, 242, 0, 207, 0], false),\\n    ([259, 0, 327, 1179, 255, 0, 243, 0, 208, 289], false),\\n    ([0, 0, 328, 1180, 256, 0, 244, 0, 209, 290], false),\\n    ([0, 259, 329, 1181, 257, 0, 245, 0, 210, 291], false),\\n    ([264, 262, 713, 704, 0, 254, 246, 674, 211, 0], false),\\n    ([263, 719, 717, 711, 0, 255, 247, 690, 212, 0], false),\\n    ([0, 0, 0, 0, 0, 256, 248, 0, 213, 0], false),\\n    ([0, 263, 0, 0, 0, 257, 249, 0, 214, 0], false),\\n    ([268, 266, 867, 865, 861, 851, 833, 239, 219, 0], false),\\n    ([267, 0, 0, 0, 0, 0, 0, 240, 220, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 241, 221, 0], false),\\n    ([0, 267, 0, 0, 0, 0, 0, 242, 222, 0], false),\\n    ([270, 0, 1188, 1185, 266, 0, 0, 243, 223, 1057], false),\\n    ([0, 0, 1189, 1186, 267, 0, 0, 244, 224, 1058], false),\\n    ([0, 270, 1190, 1187, 268, 0, 0, 245, 225, 1059], false),\\n    ([0, 0, 0, 0, 0, 267, 583, 248, 226, 0], false),\\n    ([0, 0, 1195, 1194, 272, 270, 585, 251, 228, 1073], false),\\n    ([275, 0, 0, 0, 0, 0, 266, 255, 230, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 267, 256, 231, 0], false),\\n    ([0, 275, 0, 0, 0, 0, 268, 257, 232, 0], false),\\n    ([0, 0, 337, 1201, 275, 0, 270, 259, 234, 313], false),\\n    ([0, 277, 338, 1202, 276, 0, 271, 260, 235, 314], false),\\n    ([302, 300, 292, 1036, 0, 280, 996, 0, 872, 0], false),\\n    ([291, 289, 281, 1028, 0, 0, 997, 0, 905, 0], false),\\n    ([288, 286, 282, 1029, 0, 0, 1006, 0, 914, 0], false),\\n    ([285, 283, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([284, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 284, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([287, 0, 283, 1030, 0, 0, 1007, 0, 915, 0], false),\\n    ([0, 0, 284, 1031, 0, 0, 1008, 0, 916, 0], false),\\n    ([0, 287, 285, 1032, 0, 0, 1009, 0, 917, 0], false),\\n    ([290, 0, 286, 1033, 0, 0, 1010, 0, 918, 0], false),\\n    ([0, 0, 287, 1034, 0, 0, 1011, 0, 919, 0], false),\\n    ([0, 290, 288, 1035, 0, 0, 1012, 0, 920, 0], false),\\n    ([299, 297, 293, 1037, 0, 281, 1021, 0, 929, 0], false),\\n    ([296, 294, 0, 0, 0, 282, 0, 0, 0, 0], false),\\n    ([295, 0, 0, 0, 0, 283, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 284, 0, 0, 0, 0], false),\\n    ([0, 295, 0, 0, 0, 285, 0, 0, 0, 0], false),\\n    ([298, 0, 294, 1038, 0, 286, 1022, 0, 930, 0], false),\\n    ([0, 0, 295, 1039, 0, 287, 1023, 0, 931, 0], false),\\n    ([0, 298, 296, 1040, 0, 288, 1024, 0, 932, 0], false),\\n    ([301, 0, 297, 1041, 0, 289, 1025, 0, 933, 0], false),\\n    ([0, 0, 298, 1042, 0, 290, 1026, 0, 934, 0], false),\\n    ([0, 301, 299, 1043, 0, 291, 1027, 0, 935, 0], false),\\n    ([314, 312, 304, 1074, 0, 0, 1044, 280, 968, 0], false),\\n    ([311, 309, 305, 1075, 0, 0, 1053, 281, 977, 0], false),\\n    ([308, 306, 0, 0, 0, 0, 0, 282, 0, 0], false),\\n    ([307, 0, 0, 0, 0, 0, 0, 283, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 284, 0, 0], false),\\n    ([0, 307, 0, 0, 0, 0, 0, 285, 0, 0], false),\\n    ([310, 0, 306, 1076, 0, 0, 1054, 286, 978, 0], false),\\n    ([0, 0, 307, 1077, 0, 0, 1055, 287, 979, 0], false),\\n    ([0, 310, 308, 1078, 0, 0, 1056, 288, 980, 0], false),\\n    ([313, 0, 309, 1079, 0, 0, 1057, 289, 981, 0], false),\\n    ([0, 0, 310, 1080, 0, 0, 1058, 290, 982, 0], false),\\n    ([0, 313, 311, 1081, 0, 0, 1059, 291, 983, 0], false),\\n    ([318, 316, 0, 0, 0, 305, 0, 293, 0, 0], false),\\n    ([317, 0, 0, 0, 0, 306, 0, 294, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 307, 0, 295, 0, 0], false),\\n    ([0, 317, 0, 0, 0, 308, 0, 296, 0, 0], false),\\n    ([0, 0, 317, 1084, 0, 310, 1070, 298, 992, 0], false),\\n    ([0, 319, 318, 1085, 0, 311, 1071, 299, 993, 0], false),\\n    ([0, 0, 319, 365, 362, 313, 1073, 301, 994, 0], false),\\n    ([329, 327, 323, 1175, 0, 0, 1162, 0, 1115, 281], false),\\n    ([326, 324, 0, 0, 0, 0, 0, 0, 0, 282], false),\\n    ([325, 0, 0, 0, 0, 0, 0, 0, 0, 283], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 284], false),\\n    ([0, 325, 0, 0, 0, 0, 0, 0, 0, 285], false),\\n    ([328, 0, 324, 1176, 0, 0, 1163, 0, 1116, 286], false),\\n    ([0, 0, 325, 1177, 0, 0, 1164, 0, 1117, 287], false),\\n    ([0, 328, 326, 1178, 0, 0, 1165, 0, 1118, 288], false),\\n    ([333, 331, 0, 720, 714, 323, 0, 701, 646, 293], false),\\n    ([332, 723, 0, 721, 715, 324, 0, 702, 647, 294], false),\\n    ([0, 0, 0, 0, 0, 325, 0, 0, 0, 295], false),\\n    ([0, 332, 0, 0, 0, 326, 0, 0, 0, 296], false),\\n    ([335, 0, 0, 0, 0, 0, 0, 324, 0, 306], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 325, 0, 307], false),\\n    ([0, 335, 0, 0, 0, 0, 0, 326, 0, 308], false),\\n    ([0, 0, 335, 1198, 0, 0, 1189, 328, 1148, 310], false),\\n    ([0, 337, 336, 1199, 0, 0, 1190, 329, 1149, 311], false),\\n    ([0, 0, 0, 0, 0, 335, 0, 332, 0, 317], false),\\n    ([0, 339, 0, 0, 0, 336, 0, 333, 0, 318], false),\\n    ([356, 354, 0, 350, 342, 0, 0, 0, 0, 0], false),\\n    ([349, 347, 0, 343, 0, 0, 0, 0, 0, 0], false),\\n    ([346, 344, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([345, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 345, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([348, 0, 0, 344, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 345, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 348, 0, 346, 0, 0, 0, 0, 0, 0], false),\\n    ([353, 351, 0, 0, 343, 0, 0, 0, 0, 0], false),\\n    ([352, 0, 0, 0, 344, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 345, 0, 0, 0, 0, 0], false),\\n    ([0, 352, 0, 0, 346, 0, 0, 0, 0, 0], false),\\n    ([355, 0, 0, 351, 347, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 352, 348, 0, 0, 0, 0, 0], false),\\n    ([0, 355, 0, 353, 349, 0, 0, 0, 0, 0], false),\\n    ([360, 358, 0, 0, 350, 0, 0, 0, 0, 0], false),\\n    ([359, 0, 0, 0, 351, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 352, 0, 0, 0, 0, 0], false),\\n    ([0, 359, 0, 0, 353, 0, 0, 0, 0, 0], false),\\n    ([362, 0, 0, 358, 354, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 359, 355, 0, 0, 0, 0, 0], false),\\n    ([366, 364, 1082, 0, 357, 1074, 1060, 1036, 984, 0], false),\\n    ([365, 0, 1083, 0, 358, 1079, 1065, 1041, 989, 0], false),\\n    ([0, 0, 1084, 0, 359, 1080, 1066, 1042, 990, 0], false),\\n    ([0, 365, 1085, 0, 360, 1081, 1067, 1043, 991, 0], false),\\n    ([374, 372, 0, 368, 0, 0, 0, 0, 0, 342], false),\\n    ([371, 369, 0, 0, 0, 0, 0, 0, 0, 343], false),\\n    ([370, 0, 0, 0, 0, 0, 0, 0, 0, 344], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 345], false),\\n    ([0, 370, 0, 0, 0, 0, 0, 0, 0, 346], false),\\n    ([373, 0, 0, 369, 0, 0, 0, 0, 0, 347], false),\\n    ([0, 0, 0, 370, 0, 0, 0, 0, 0, 348], false),\\n    ([0, 373, 0, 371, 0, 0, 0, 0, 0, 349], false),\\n    ([378, 376, 506, 502, 368, 484, 869, 0, 820, 350], false),\\n    ([377, 0, 0, 0, 369, 0, 0, 0, 0, 351], false),\\n    ([0, 0, 0, 0, 370, 0, 0, 0, 0, 352], false),\\n    ([0, 377, 0, 0, 371, 0, 0, 0, 0, 353], false),\\n    ([0, 0, 0, 377, 373, 0, 0, 0, 0, 355], false),\\n    ([0, 379, 0, 378, 374, 0, 0, 0, 0, 356], false),\\n    ([0, 0, 0, 0, 377, 0, 0, 0, 0, 359], false),\\n    ([0, 381, 0, 0, 378, 0, 0, 0, 0, 360], false),\\n    ([398, 0, 0, 396, 0, 0, 392, 0, 384, 0], false),\\n    ([391, 0, 0, 389, 0, 0, 385, 0, 0, 0], false),\\n    ([388, 0, 0, 386, 0, 0, 0, 0, 0, 0], false),\\n    ([387, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 387, 0, 0, 0, 0, 0, 0], false),\\n    ([390, 0, 0, 0, 0, 0, 386, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 387, 0, 0, 0], false),\\n    ([0, 0, 0, 390, 0, 0, 388, 0, 0, 0], false),\\n    ([395, 0, 0, 393, 0, 0, 0, 0, 385, 0], false),\\n    ([394, 0, 0, 0, 0, 0, 0, 0, 386, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 387, 0], false),\\n    ([0, 0, 0, 394, 0, 0, 0, 0, 388, 0], false),\\n    ([397, 0, 0, 0, 0, 0, 393, 0, 389, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 394, 0, 390, 0], false),\\n    ([0, 0, 0, 397, 0, 0, 395, 0, 391, 0], false),\\n    ([402, 552, 0, 400, 548, 0, 540, 517, 392, 0], false),\\n    ([401, 0, 0, 0, 0, 0, 0, 0, 393, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 394, 0], false),\\n    ([0, 553, 0, 401, 551, 0, 547, 532, 395, 0], false),\\n    ([404, 0, 0, 0, 0, 0, 400, 0, 396, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 401, 0, 397, 0], false),\\n    ([0, 558, 0, 404, 556, 0, 402, 539, 398, 0], false),\\n    ([0, 1137, 1136, 0, 0, 1130, 0, 1103, 401, 960], false),\\n    ([0, 1152, 1151, 0, 0, 1146, 406, 1122, 404, 991], false),\\n    ([0, 1194, 1193, 0, 0, 1187, 0, 1171, 406, 1067], false),\\n    ([0, 443, 440, 692, 674, 0, 428, 410, 587, 0], false),\\n    ([0, 426, 423, 0, 0, 0, 411, 0, 0, 0], false),\\n    ([0, 421, 418, 0, 0, 0, 412, 0, 0, 0], false),\\n    ([0, 416, 413, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 414, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 415, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 417, 414, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 415, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 419, 0, 0, 0, 0, 413, 0, 0, 0], false),\\n    ([0, 420, 0, 0, 0, 0, 414, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 415, 0, 0, 0], false),\\n    ([0, 422, 419, 0, 0, 0, 416, 0, 0, 0], false),\\n    ([0, 0, 420, 0, 0, 0, 417, 0, 0, 0], false),\\n    ([0, 424, 0, 0, 0, 0, 418, 0, 0, 0], false),\\n    ([0, 425, 0, 0, 0, 0, 419, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 420, 0, 0, 0], false),\\n    ([0, 427, 424, 0, 0, 0, 421, 0, 0, 0], false),\\n    ([0, 0, 425, 0, 0, 0, 422, 0, 0, 0], false),\\n    ([0, 438, 435, 0, 0, 0, 429, 411, 0, 0], false),\\n    ([0, 433, 430, 0, 0, 0, 0, 412, 0, 0], false),\\n    ([0, 431, 0, 0, 0, 0, 0, 413, 0, 0], false),\\n    ([0, 432, 0, 0, 0, 0, 0, 414, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 415, 0, 0], false),\\n    ([0, 434, 431, 0, 0, 0, 0, 416, 0, 0], false),\\n    ([0, 0, 432, 0, 0, 0, 0, 417, 0, 0], false),\\n    ([0, 436, 0, 0, 0, 0, 430, 418, 0, 0], false),\\n    ([0, 437, 0, 0, 0, 0, 431, 419, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 432, 420, 0, 0], false),\\n    ([0, 439, 436, 0, 0, 0, 433, 421, 0, 0], false),\\n    ([0, 0, 437, 0, 0, 0, 434, 422, 0, 0], false),\\n    ([0, 441, 701, 693, 684, 0, 435, 423, 615, 0], false),\\n    ([0, 442, 702, 697, 688, 0, 436, 424, 619, 0], false),\\n    ([0, 0, 703, 698, 689, 0, 437, 425, 620, 0], false),\\n    ([0, 444, 441, 699, 690, 0, 438, 426, 621, 0], false),\\n    ([0, 0, 442, 700, 691, 0, 439, 427, 622, 0], false),\\n    ([580, 449, 446, 0, 575, 0, 0, 429, 559, 0], false),\\n    ([0, 447, 0, 0, 0, 0, 0, 430, 0, 0], false),\\n    ([0, 448, 0, 0, 0, 0, 0, 431, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 432, 0, 0], false),\\n    ([579, 450, 447, 0, 576, 0, 0, 433, 564, 0], false),\\n    ([0, 0, 448, 0, 0, 0, 0, 434, 0, 0], false),\\n    ([1172, 452, 0, 1166, 0, 1163, 447, 436, 1104, 1022], false),\\n    ([0, 0, 0, 0, 0, 0, 448, 437, 0, 0], false),\\n    ([0, 0, 452, 0, 0, 0, 450, 439, 0, 0], false),\\n    ([0, 455, 0, 850, 849, 842, 0, 446, 770, 0], false),\\n    ([0, 456, 0, 0, 0, 0, 0, 447, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 448, 0, 0], false),\\n    ([585, 458, 455, 0, 582, 0, 0, 449, 572, 0], false),\\n    ([0, 0, 456, 0, 0, 0, 0, 450, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 456, 452, 0, 0], false),\\n    ([0, 0, 459, 0, 0, 0, 458, 453, 0, 0], false),\\n    ([0, 0, 476, 470, 462, 0, 851, 0, 800, 0], false),\\n    ([0, 0, 469, 463, 0, 0, 852, 0, 801, 0], false),\\n    ([0, 0, 468, 464, 0, 0, 853, 0, 802, 0], false),\\n    ([0, 0, 467, 465, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 466, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 466, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 467, 0, 0, 854, 0, 803, 0], false),\\n    ([0, 0, 0, 468, 0, 0, 855, 0, 804, 0], false),\\n    ([0, 0, 475, 471, 463, 0, 856, 0, 805, 0], false),\\n    ([0, 0, 474, 472, 464, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 473, 0, 465, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 466, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 473, 467, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 474, 468, 0, 857, 0, 806, 0], false),\\n    ([0, 0, 0, 475, 469, 0, 858, 0, 807, 0], false),\\n    ([0, 0, 480, 478, 471, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 479, 0, 472, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 473, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 479, 474, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 480, 475, 0, 859, 0, 809, 0], false),\\n    ([0, 0, 0, 481, 476, 0, 860, 0, 810, 0], false),\\n    ([0, 0, 490, 484, 0, 462, 861, 0, 811, 0], false),\\n    ([0, 0, 489, 485, 0, 463, 862, 0, 812, 0], false),\\n    ([0, 0, 488, 486, 0, 464, 0, 0, 0, 0], false),\\n    ([0, 0, 487, 0, 0, 465, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 466, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 487, 0, 467, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 488, 0, 468, 863, 0, 813, 0], false),\\n    ([0, 0, 0, 489, 0, 469, 864, 0, 814, 0], false),\\n    ([0, 0, 496, 492, 484, 470, 865, 0, 815, 0], false),\\n    ([0, 0, 495, 493, 485, 471, 0, 0, 0, 0], false),\\n    ([0, 0, 494, 0, 486, 472, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 487, 473, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 494, 488, 474, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 495, 489, 475, 866, 0, 816, 0], false),\\n    ([0, 0, 500, 498, 492, 477, 0, 0, 0, 0], false),\\n    ([0, 0, 499, 0, 493, 478, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 494, 479, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 499, 495, 480, 0, 0, 0, 0], false),\\n    ([1199, 1197, 0, 500, 496, 481, 868, 1175, 818, 1075], false),\\n    ([0, 0, 505, 503, 0, 485, 0, 0, 0, 0], false),\\n    ([0, 0, 504, 0, 0, 486, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 487, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 504, 0, 488, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 505, 0, 489, 870, 0, 821, 0], false),\\n    ([0, 0, 510, 508, 502, 492, 0, 0, 0, 0], false),\\n    ([0, 0, 509, 0, 503, 493, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 504, 494, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 509, 505, 495, 0, 0, 0, 0], false),\\n    ([0, 727, 724, 510, 506, 496, 871, 705, 652, 0], false),\\n    ([0, 0, 515, 513, 507, 497, 0, 0, 0, 0], false),\\n    ([0, 0, 514, 0, 508, 498, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 509, 499, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 514, 510, 500, 0, 0, 0, 0], false),\\n    ([539, 537, 0, 0, 533, 0, 517, 0, 0, 0], false),\\n    ([532, 530, 0, 0, 526, 0, 518, 0, 0, 0], false),\\n    ([525, 523, 0, 0, 519, 0, 0, 0, 0, 0], false),\\n    ([522, 520, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([521, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 521, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([524, 0, 0, 0, 520, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 521, 0, 0, 0, 0, 0], false),\\n    ([0, 524, 0, 0, 522, 0, 0, 0, 0, 0], false),\\n    ([529, 527, 0, 0, 0, 0, 519, 0, 0, 0], false),\\n    ([528, 0, 0, 0, 0, 0, 520, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 521, 0, 0, 0], false),\\n    ([0, 528, 0, 0, 0, 0, 522, 0, 0, 0], false),\\n    ([531, 0, 0, 0, 527, 0, 523, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 528, 0, 524, 0, 0, 0], false),\\n    ([0, 531, 0, 0, 529, 0, 525, 0, 0, 0], false),\\n    ([536, 534, 0, 0, 0, 0, 526, 0, 0, 0], false),\\n    ([535, 0, 0, 0, 0, 0, 527, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 528, 0, 0, 0], false),\\n    ([0, 535, 0, 0, 0, 0, 529, 0, 0, 0], false),\\n    ([538, 0, 0, 0, 534, 0, 530, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 535, 0, 531, 0, 0, 0], false),\\n    ([0, 538, 0, 0, 536, 0, 532, 0, 0, 0], false),\\n    ([547, 545, 0, 0, 541, 0, 0, 518, 0, 0], false),\\n    ([544, 542, 0, 0, 0, 0, 0, 519, 0, 0], false),\\n    ([543, 0, 0, 0, 0, 0, 0, 520, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 521, 0, 0], false),\\n    ([0, 543, 0, 0, 0, 0, 0, 522, 0, 0], false),\\n    ([546, 0, 0, 0, 542, 0, 0, 523, 0, 0], false),\\n    ([0, 0, 0, 0, 543, 0, 0, 524, 0, 0], false),\\n    ([0, 546, 0, 0, 544, 0, 0, 525, 0, 0], false),\\n    ([551, 549, 0, 0, 0, 0, 541, 526, 0, 0], false),\\n    ([550, 0, 0, 0, 0, 0, 542, 527, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 543, 528, 0, 0], false),\\n    ([0, 550, 0, 0, 0, 0, 544, 529, 0, 0], false),\\n    ([553, 0, 0, 0, 549, 0, 545, 530, 0, 0], false),\\n    ([0, 0, 0, 0, 550, 0, 546, 531, 0, 0], false),\\n    ([555, 0, 0, 0, 0, 0, 549, 534, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 550, 535, 0, 0], false),\\n    ([0, 555, 0, 0, 0, 0, 551, 536, 0, 0], false),\\n    ([558, 0, 0, 0, 554, 0, 552, 537, 0, 0], false),\\n    ([0, 0, 0, 0, 555, 0, 553, 538, 0, 0], false),\\n    ([566, 564, 0, 0, 560, 0, 0, 0, 518, 0], false),\\n    ([563, 561, 0, 0, 0, 0, 0, 0, 519, 0], false),\\n    ([562, 0, 0, 0, 0, 0, 0, 0, 520, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 521, 0], false),\\n    ([0, 562, 0, 0, 0, 0, 0, 0, 522, 0], false),\\n    ([565, 0, 0, 0, 561, 0, 0, 0, 523, 0], false),\\n    ([0, 0, 0, 0, 562, 0, 0, 0, 524, 0], false),\\n    ([0, 565, 0, 0, 563, 0, 0, 0, 525, 0], false),\\n    ([574, 572, 770, 768, 568, 737, 0, 559, 540, 0], false),\\n    ([571, 569, 767, 765, 761, 750, 0, 560, 541, 0], false),\\n    ([570, 0, 0, 0, 0, 0, 0, 561, 542, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 562, 543, 0], false),\\n    ([0, 570, 0, 0, 0, 0, 0, 563, 544, 0], false),\\n    ([573, 0, 0, 0, 569, 0, 0, 564, 545, 0], false),\\n    ([0, 0, 0, 0, 570, 0, 0, 565, 546, 0], false),\\n    ([0, 573, 0, 0, 571, 0, 0, 566, 547, 0], false),\\n    ([578, 576, 0, 0, 0, 0, 0, 0, 560, 0], false),\\n    ([577, 0, 0, 0, 0, 0, 0, 0, 561, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 562, 0], false),\\n    ([0, 577, 0, 0, 0, 0, 0, 0, 563, 0], false),\\n    ([0, 0, 0, 0, 577, 0, 0, 0, 565, 0], false),\\n    ([0, 579, 0, 0, 578, 0, 0, 0, 566, 0], false),\\n    ([584, 582, 849, 847, 843, 833, 0, 575, 568, 0], false),\\n    ([583, 0, 0, 0, 0, 0, 0, 576, 569, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 577, 570, 0], false),\\n    ([0, 583, 0, 0, 0, 0, 0, 578, 571, 0], false),\\n    ([0, 0, 0, 0, 583, 0, 0, 579, 573, 0], false),\\n    ([0, 585, 0, 0, 584, 0, 0, 580, 574, 0], false),\\n    ([0, 621, 615, 606, 588, 0, 0, 0, 0, 0], false),\\n    ([0, 604, 598, 589, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 596, 590, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 594, 591, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 592, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 593, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 595, 592, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 593, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 597, 594, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 595, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 602, 599, 590, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 600, 0, 591, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 601, 0, 592, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 593, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 603, 600, 594, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 601, 595, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 605, 602, 596, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 603, 597, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 613, 607, 0, 589, 0, 0, 0, 0, 0], false),\\n    ([0, 611, 608, 0, 590, 0, 0, 0, 0, 0], false),\\n    ([0, 609, 0, 0, 591, 0, 0, 0, 0, 0], false),\\n    ([0, 610, 0, 0, 592, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 593, 0, 0, 0, 0, 0], false),\\n    ([0, 612, 609, 0, 594, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 610, 0, 595, 0, 0, 0, 0, 0], false),\\n    ([0, 614, 611, 0, 596, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 612, 0, 597, 0, 0, 0, 0, 0], false),\\n    ([0, 619, 616, 607, 598, 0, 0, 0, 0, 0], false),\\n    ([0, 617, 0, 608, 599, 0, 0, 0, 0, 0], false),\\n    ([0, 618, 0, 609, 600, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 610, 601, 0, 0, 0, 0, 0], false),\\n    ([0, 620, 617, 611, 602, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 618, 612, 603, 0, 0, 0, 0, 0], false),\\n    ([0, 622, 619, 613, 604, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 620, 614, 605, 0, 0, 0, 0, 0], false),\\n    ([0, 630, 624, 0, 0, 0, 0, 589, 0, 0], false),\\n    ([0, 628, 625, 0, 0, 0, 0, 590, 0, 0], false),\\n    ([0, 626, 0, 0, 0, 0, 0, 591, 0, 0], false),\\n    ([0, 627, 0, 0, 0, 0, 0, 592, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 593, 0, 0], false),\\n    ([0, 629, 626, 0, 0, 0, 0, 594, 0, 0], false),\\n    ([0, 0, 627, 0, 0, 0, 0, 595, 0, 0], false),\\n    ([0, 631, 628, 0, 0, 0, 0, 596, 0, 0], false),\\n    ([0, 0, 629, 0, 0, 0, 0, 597, 0, 0], false),\\n    ([0, 636, 633, 624, 0, 0, 0, 598, 0, 0], false),\\n    ([0, 634, 0, 625, 0, 0, 0, 599, 0, 0], false),\\n    ([0, 635, 0, 626, 0, 0, 0, 600, 0, 0], false),\\n    ([0, 0, 0, 627, 0, 0, 0, 601, 0, 0], false),\\n    ([0, 637, 634, 628, 0, 0, 0, 602, 0, 0], false),\\n    ([0, 0, 635, 629, 0, 0, 0, 603, 0, 0], false),\\n    ([0, 0, 637, 631, 0, 0, 0, 605, 0, 0], false),\\n    ([0, 640, 0, 0, 625, 0, 0, 608, 0, 0], false),\\n    ([0, 641, 0, 0, 626, 0, 0, 609, 0, 0], false),\\n    ([0, 0, 0, 0, 627, 0, 0, 610, 0, 0], false),\\n    ([1119, 643, 640, 0, 628, 1109, 1098, 611, 0, 923], false),\\n    ([0, 0, 641, 0, 629, 0, 0, 612, 0, 0], false),\\n    ([1121, 645, 642, 0, 630, 1112, 1101, 613, 0, 926], false),\\n    ([0, 0, 643, 0, 631, 0, 0, 614, 0, 0], false),\\n    ([0, 647, 0, 639, 633, 0, 0, 616, 0, 0], false),\\n    ([0, 648, 0, 640, 634, 0, 0, 617, 0, 0], false),\\n    ([0, 0, 0, 641, 635, 0, 0, 618, 0, 0], false),\\n    ([1123, 650, 647, 642, 636, 1116, 1104, 619, 0, 930], false),\\n    ([0, 0, 648, 643, 637, 0, 0, 620, 0, 0], false),\\n    ([0, 0, 650, 645, 638, 0, 0, 622, 0, 0], false),\\n    ([0, 656, 653, 0, 821, 816, 797, 624, 0, 0], false),\\n    ([0, 654, 0, 0, 0, 0, 0, 625, 0, 0], false),\\n    ([0, 655, 0, 0, 0, 0, 0, 626, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 627, 0, 0], false),\\n    ([0, 657, 654, 0, 0, 0, 0, 628, 0, 0], false),\\n    ([0, 0, 655, 0, 0, 0, 0, 629, 0, 0], false),\\n    ([0, 0, 657, 0, 0, 0, 0, 631, 0, 0], false),\\n    ([0, 660, 0, 654, 0, 0, 0, 634, 0, 0], false),\\n    ([0, 0, 0, 655, 0, 0, 0, 635, 0, 0], false),\\n    ([0, 662, 659, 656, 0, 0, 0, 636, 0, 0], false),\\n    ([0, 0, 660, 657, 0, 0, 0, 637, 0, 0], false),\\n    ([0, 0, 662, 658, 0, 0, 0, 638, 0, 0], false),\\n    ([0, 665, 0, 0, 653, 0, 0, 639, 0, 0], false),\\n    ([0, 666, 0, 0, 654, 0, 0, 640, 0, 0], false),\\n    ([0, 0, 0, 0, 655, 0, 0, 641, 0, 0], false),\\n    ([1150, 668, 665, 0, 656, 1141, 1134, 642, 0, 986], false),\\n    ([0, 0, 666, 0, 657, 0, 0, 643, 0, 0], false),\\n    ([0, 0, 668, 0, 658, 0, 0, 645, 0, 0], false),\\n    ([0, 671, 0, 665, 659, 0, 0, 647, 0, 0], false),\\n    ([0, 0, 0, 666, 660, 0, 0, 648, 0, 0], false),\\n    ([0, 0, 671, 668, 662, 0, 0, 650, 0, 0], false),\\n    ([0, 0, 672, 669, 663, 0, 0, 651, 0, 0], false),\\n    ([0, 690, 684, 675, 0, 0, 0, 0, 588, 0], false),\\n    ([0, 682, 676, 0, 0, 0, 0, 0, 589, 0], false),\\n    ([0, 680, 677, 0, 0, 0, 0, 0, 590, 0], false),\\n    ([0, 678, 0, 0, 0, 0, 0, 0, 591, 0], false),\\n    ([0, 679, 0, 0, 0, 0, 0, 0, 592, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 593, 0], false),\\n    ([0, 681, 678, 0, 0, 0, 0, 0, 594, 0], false),\\n    ([0, 0, 679, 0, 0, 0, 0, 0, 595, 0], false),\\n    ([0, 683, 680, 0, 0, 0, 0, 0, 596, 0], false),\\n    ([0, 0, 681, 0, 0, 0, 0, 0, 597, 0], false),\\n    ([0, 688, 685, 676, 0, 0, 0, 0, 598, 0], false),\\n    ([0, 686, 0, 677, 0, 0, 0, 0, 599, 0], false),\\n    ([0, 687, 0, 678, 0, 0, 0, 0, 600, 0], false),\\n    ([0, 0, 0, 679, 0, 0, 0, 0, 601, 0], false),\\n    ([0, 689, 686, 680, 0, 0, 0, 0, 602, 0], false),\\n    ([0, 0, 687, 681, 0, 0, 0, 0, 603, 0], false),\\n    ([0, 691, 688, 682, 0, 0, 0, 0, 604, 0], false),\\n    ([0, 0, 689, 683, 0, 0, 0, 0, 605, 0], false),\\n    ([0, 699, 693, 0, 675, 0, 0, 0, 606, 0], false),\\n    ([0, 697, 694, 0, 676, 0, 0, 0, 607, 0], false),\\n    ([0, 695, 0, 0, 677, 0, 0, 0, 608, 0], false),\\n    ([0, 696, 0, 0, 678, 0, 0, 0, 609, 0], false),\\n    ([0, 0, 0, 0, 679, 0, 0, 0, 610, 0], false),\\n    ([0, 698, 695, 0, 680, 0, 0, 0, 611, 0], false),\\n    ([0, 0, 696, 0, 681, 0, 0, 0, 612, 0], false),\\n    ([0, 700, 697, 0, 682, 0, 0, 0, 613, 0], false),\\n    ([0, 0, 698, 0, 683, 0, 0, 0, 614, 0], false),\\n    ([0, 702, 0, 694, 685, 0, 0, 0, 616, 0], false),\\n    ([0, 703, 0, 695, 686, 0, 0, 0, 617, 0], false),\\n    ([0, 0, 0, 696, 687, 0, 0, 0, 618, 0], false),\\n    ([0, 711, 705, 0, 0, 0, 0, 675, 623, 0], false),\\n    ([0, 709, 706, 0, 0, 0, 0, 676, 624, 0], false),\\n    ([0, 707, 0, 0, 0, 0, 0, 677, 625, 0], false),\\n    ([0, 708, 0, 0, 0, 0, 0, 678, 626, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 679, 627, 0], false),\\n    ([0, 710, 707, 0, 0, 0, 0, 680, 628, 0], false),\\n    ([0, 0, 708, 0, 0, 0, 0, 681, 629, 0], false),\\n    ([0, 712, 709, 0, 0, 0, 0, 682, 630, 0], false),\\n    ([0, 0, 710, 0, 0, 0, 0, 683, 631, 0], false),\\n    ([0, 717, 714, 705, 0, 0, 0, 684, 632, 0], false),\\n    ([0, 715, 0, 706, 0, 0, 0, 685, 633, 0], false),\\n    ([0, 716, 0, 707, 0, 0, 0, 686, 634, 0], false),\\n    ([0, 0, 0, 708, 0, 0, 0, 687, 635, 0], false),\\n    ([0, 718, 715, 709, 0, 0, 0, 688, 636, 0], false),\\n    ([0, 0, 716, 710, 0, 0, 0, 689, 637, 0], false),\\n    ([0, 0, 718, 712, 0, 0, 0, 691, 638, 0], false),\\n    ([0, 721, 0, 0, 706, 0, 0, 694, 639, 0], false),\\n    ([0, 722, 0, 0, 707, 0, 0, 695, 640, 0], false),\\n    ([0, 0, 0, 0, 708, 0, 0, 696, 641, 0], false),\\n    ([0, 0, 0, 722, 716, 0, 0, 703, 648, 0], false),\\n    ([0, 725, 0, 0, 0, 0, 0, 706, 653, 0], false),\\n    ([0, 726, 0, 0, 0, 0, 0, 707, 654, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 708, 655, 0], false),\\n    ([0, 728, 725, 0, 0, 0, 0, 709, 656, 0], false),\\n    ([0, 0, 726, 0, 0, 0, 0, 710, 657, 0], false),\\n    ([0, 0, 728, 0, 0, 0, 0, 712, 658, 0], false),\\n    ([0, 0, 0, 726, 0, 0, 0, 716, 660, 0], false),\\n    ([0, 0, 730, 728, 0, 0, 0, 718, 662, 0], false),\\n    ([0, 0, 731, 729, 0, 0, 0, 719, 663, 0], false),\\n    ([0, 734, 0, 0, 724, 0, 0, 720, 664, 0], false),\\n    ([0, 735, 0, 0, 725, 0, 0, 721, 665, 0], false),\\n    ([0, 0, 0, 0, 726, 0, 0, 722, 666, 0], false),\\n    ([0, 0, 0, 735, 730, 0, 0, 723, 671, 0], false),\\n    ([0, 0, 760, 758, 750, 738, 0, 0, 0, 0], false),\\n    ([0, 0, 749, 747, 739, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 746, 744, 740, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 743, 741, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 742, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 0, 0, 742, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 745, 0, 741, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 742, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 745, 743, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 748, 0, 744, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 745, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 748, 746, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 757, 755, 751, 739, 0, 0, 0, 0], false),\\n    ([0, 0, 754, 752, 0, 740, 0, 0, 0, 0], false),\\n    ([0, 0, 753, 0, 0, 741, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 742, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 753, 0, 743, 0, 0, 0, 0], false),\\n    ([0, 0, 756, 0, 752, 744, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 753, 745, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 756, 754, 746, 0, 0, 0, 0], false),\\n    ([0, 0, 759, 0, 755, 747, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 756, 748, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 759, 757, 749, 0, 0, 0, 0], false),\\n    ([0, 0, 764, 762, 0, 751, 0, 0, 0, 0], false),\\n    ([0, 0, 763, 0, 0, 752, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 753, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 763, 0, 754, 0, 0, 0, 0], false),\\n    ([0, 0, 766, 0, 762, 755, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 763, 756, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 766, 764, 757, 0, 0, 0, 0], false),\\n    ([0, 0, 769, 0, 765, 758, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 766, 759, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 769, 767, 760, 0, 0, 0, 0], false),\\n    ([0, 0, 782, 780, 772, 0, 738, 0, 0, 0], false),\\n    ([0, 0, 779, 777, 773, 0, 739, 0, 0, 0], false),\\n    ([0, 0, 776, 774, 0, 0, 740, 0, 0, 0], false),\\n    ([0, 0, 775, 0, 0, 0, 741, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 742, 0, 0, 0], false),\\n    ([0, 0, 0, 775, 0, 0, 743, 0, 0, 0], false),\\n    ([0, 0, 778, 0, 774, 0, 744, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 775, 0, 745, 0, 0, 0], false),\\n    ([0, 0, 0, 778, 776, 0, 746, 0, 0, 0], false),\\n    ([0, 0, 781, 0, 777, 0, 747, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 778, 0, 748, 0, 0, 0], false),\\n    ([0, 0, 0, 781, 779, 0, 749, 0, 0, 0], false),\\n    ([0, 0, 786, 784, 0, 773, 751, 0, 0, 0], false),\\n    ([0, 0, 785, 0, 0, 774, 752, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 775, 753, 0, 0, 0], false),\\n    ([0, 0, 0, 785, 0, 776, 754, 0, 0, 0], false),\\n    ([0, 0, 788, 0, 784, 777, 755, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 785, 778, 756, 0, 0, 0], false),\\n    ([0, 0, 0, 788, 786, 779, 757, 0, 0, 0], false),\\n    ([1130, 1128, 791, 0, 787, 780, 758, 1086, 0, 938], false),\\n    ([1127, 1125, 0, 0, 788, 781, 759, 1087, 0, 939], false),\\n    ([1133, 1131, 0, 791, 789, 782, 760, 1094, 0, 946], false),\\n    ([0, 0, 796, 794, 0, 783, 761, 0, 0, 0], false),\\n    ([0, 0, 795, 0, 0, 784, 762, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 785, 763, 0, 0, 0], false),\\n    ([0, 0, 0, 795, 0, 786, 764, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 795, 788, 766, 0, 0, 0], false),\\n    ([0, 0, 0, 797, 796, 789, 767, 0, 0, 0], false),\\n    ([0, 0, 810, 808, 800, 0, 771, 0, 0, 0], false),\\n    ([0, 0, 807, 805, 801, 0, 772, 0, 0, 0], false),\\n    ([0, 0, 804, 802, 0, 0, 773, 0, 0, 0], false),\\n    ([0, 0, 803, 0, 0, 0, 774, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 775, 0, 0, 0], false),\\n    ([0, 0, 0, 803, 0, 0, 776, 0, 0, 0], false),\\n    ([0, 0, 806, 0, 802, 0, 777, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 803, 0, 778, 0, 0, 0], false),\\n    ([0, 0, 0, 806, 804, 0, 779, 0, 0, 0], false),\\n    ([0, 0, 809, 0, 805, 0, 780, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 806, 0, 781, 0, 0, 0], false),\\n    ([0, 0, 0, 809, 807, 0, 782, 0, 0, 0], false),\\n    ([0, 0, 814, 812, 0, 801, 783, 0, 0, 0], false),\\n    ([0, 0, 813, 0, 0, 802, 784, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 803, 785, 0, 0, 0], false),\\n    ([0, 0, 0, 813, 0, 804, 786, 0, 0, 0], false),\\n    ([0, 0, 816, 0, 812, 805, 787, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 813, 806, 788, 0, 0, 0], false),\\n    ([1146, 1144, 818, 0, 815, 808, 790, 1107, 0, 969], false),\\n    ([1143, 1141, 0, 0, 816, 809, 791, 1108, 0, 970], false),\\n    ([0, 0, 822, 820, 0, 811, 793, 0, 0, 0], false),\\n    ([0, 0, 821, 0, 0, 812, 794, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 813, 795, 0, 0, 0], false),\\n    ([0, 0, 0, 821, 0, 814, 796, 0, 0, 0], false),\\n    ([0, 0, 830, 828, 824, 0, 0, 0, 739, 0], false),\\n    ([0, 0, 827, 825, 0, 0, 0, 0, 740, 0], false),\\n    ([0, 0, 826, 0, 0, 0, 0, 0, 741, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 742, 0], false),\\n    ([0, 0, 0, 826, 0, 0, 0, 0, 743, 0], false),\\n    ([0, 0, 829, 0, 825, 0, 0, 0, 744, 0], false),\\n    ([0, 0, 0, 0, 826, 0, 0, 0, 745, 0], false),\\n    ([0, 0, 0, 829, 827, 0, 0, 0, 746, 0], false),\\n    ([0, 0, 0, 0, 829, 0, 0, 0, 748, 0], false),\\n    ([0, 0, 0, 831, 830, 0, 0, 0, 749, 0], false),\\n    ([0, 0, 840, 838, 834, 823, 0, 0, 750, 0], false),\\n    ([0, 0, 837, 835, 0, 824, 0, 0, 751, 0], false),\\n    ([0, 0, 836, 0, 0, 825, 0, 0, 752, 0], false),\\n    ([0, 0, 0, 0, 0, 826, 0, 0, 753, 0], false),\\n    ([0, 0, 0, 836, 0, 827, 0, 0, 754, 0], false),\\n    ([0, 0, 839, 0, 835, 828, 0, 0, 755, 0], false),\\n    ([0, 0, 0, 0, 836, 829, 0, 0, 756, 0], false),\\n    ([0, 0, 0, 839, 837, 830, 0, 0, 757, 0], false),\\n    ([0, 0, 0, 0, 839, 831, 0, 0, 759, 0], false),\\n    ([0, 0, 0, 841, 840, 832, 0, 0, 760, 0], false),\\n    ([0, 0, 846, 844, 0, 834, 0, 0, 761, 0], false),\\n    ([0, 0, 845, 0, 0, 835, 0, 0, 762, 0], false),\\n    ([0, 0, 0, 0, 0, 836, 0, 0, 763, 0], false),\\n    ([0, 0, 0, 845, 0, 837, 0, 0, 764, 0], false),\\n    ([0, 0, 848, 0, 844, 838, 0, 0, 765, 0], false),\\n    ([0, 0, 0, 0, 845, 839, 0, 0, 766, 0], false),\\n    ([0, 0, 0, 848, 846, 840, 0, 0, 767, 0], false),\\n    ([0, 0, 0, 0, 848, 841, 0, 0, 769, 0], false),\\n    ([0, 0, 858, 856, 852, 0, 823, 0, 772, 0], false),\\n    ([0, 0, 855, 853, 0, 0, 824, 0, 773, 0], false),\\n    ([0, 0, 854, 0, 0, 0, 825, 0, 774, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 826, 0, 775, 0], false),\\n    ([0, 0, 0, 854, 0, 0, 827, 0, 776, 0], false),\\n    ([0, 0, 857, 0, 853, 0, 828, 0, 777, 0], false),\\n    ([0, 0, 0, 0, 854, 0, 829, 0, 778, 0], false),\\n    ([0, 0, 0, 857, 855, 0, 830, 0, 779, 0], false),\\n    ([0, 0, 0, 0, 857, 0, 831, 0, 781, 0], false),\\n    ([0, 0, 0, 859, 858, 0, 832, 0, 782, 0], false),\\n    ([0, 0, 864, 862, 0, 852, 834, 0, 783, 0], false),\\n    ([0, 0, 863, 0, 0, 853, 835, 0, 784, 0], false),\\n    ([0, 0, 0, 0, 0, 854, 836, 0, 785, 0], false),\\n    ([0, 0, 0, 863, 0, 855, 837, 0, 786, 0], false),\\n    ([0, 0, 866, 0, 862, 856, 838, 0, 787, 0], false),\\n    ([0, 0, 0, 0, 863, 857, 839, 0, 788, 0], false),\\n    ([0, 0, 0, 866, 864, 858, 840, 0, 789, 0], false),\\n    ([1184, 1182, 0, 0, 866, 859, 841, 1155, 791, 1046], false),\\n    ([0, 0, 870, 0, 0, 862, 844, 0, 794, 0], false),\\n    ([0, 0, 0, 0, 0, 863, 845, 0, 795, 0], false),\\n    ([0, 0, 0, 0, 870, 866, 848, 0, 797, 0], false),\\n    ([935, 933, 929, 921, 0, 905, 873, 0, 0, 0], false),\\n    ([904, 902, 898, 890, 0, 874, 0, 0, 0, 0], false),\\n    ([889, 887, 883, 875, 0, 0, 0, 0, 0, 0], false),\\n    ([882, 880, 876, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([879, 877, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([878, 0, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], true),\\n    ([0, 878, 0, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([881, 0, 877, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 878, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 881, 879, 0, 0, 0, 0, 0, 0, 0], false),\\n    ([886, 884, 0, 876, 0, 0, 0, 0, 0, 0], false),\\n    ([885, 0, 0, 877, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 878, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 885, 0, 879, 0, 0, 0, 0, 0, 0], false),\\n    ([888, 0, 884, 880, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 0, 885, 881, 0, 0, 0, 0, 0, 0], false),\\n    ([0, 888, 886, 882, 0, 0, 0, 0, 0, 0], false),\\n    ([897, 895, 891, 0, 0, 875, 0, 0, 0, 0], false),\\n    ([894, 892, 0, 0, 0, 876, 0, 0, 0, 0], false),\\n    ([893, 0, 0, 0, 0, 877, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 878, 0, 0, 0, 0], false),\\n    ([0, 893, 0, 0, 0, 879, 0, 0, 0, 0], false),\\n    ([896, 0, 892, 0, 0, 880, 0, 0, 0, 0], false),\\n    ([0, 0, 893, 0, 0, 881, 0, 0, 0, 0], false),\\n    ([0, 896, 894, 0, 0, 882, 0, 0, 0, 0], false),\\n    ([901, 899, 0, 891, 0, 883, 0, 0, 0, 0], false),\\n    ([900, 0, 0, 892, 0, 884, 0, 0, 0, 0], false),\\n    ([0, 0, 0, 893, 0, 885, 0, 0, 0, 0], false),\\n    ([0, 900, 0, 894, 0, 886, 0, 0, 0, 0], false),\\n    ([903, 0, 899, 895, 0, 887, 0, 0, 0, 0], false),\\n    ([0, 0, 900, 896, 0, 888, 0, 0, 0, 0], false),\\n    ([0, 903, 901, 897, 0, 889, 0, 0, 0, 0], false),\\n    ([920, 918, 914, 906, 0, 0, 874, 0, 0, 0], false),\\n    ([913, 911, 907, 0, 0, 0, 875, 0, 0, 0], false),\\n    ([910, 908, 0, 0, 0, 0, 876, 0, 0, 0], false),\\n    ([909, 0, 0, 0, 0, 0, 877, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 878, 0, 0, 0], false),\\n    ([0, 909, 0, 0, 0, 0, 879, 0, 0, 0], false),\\n    ([912, 0, 908, 0, 0, 0, 880, 0, 0, 0], false),\\n    ([0, 0, 909, 0, 0, 0, 881, 0, 0, 0], false),\\n    ([0, 912, 910, 0, 0, 0, 882, 0, 0, 0], false),\\n    ([917, 915, 0, 907, 0, 0, 883, 0, 0, 0], false),\\n    ([916, 0, 0, 908, 0, 0, 884, 0, 0, 0], false),\\n    ([0, 0, 0, 909, 0, 0, 885, 0, 0, 0], false),\\n    ([0, 916, 0, 910, 0, 0, 886, 0, 0, 0], false),\\n    ([919, 0, 915, 911, 0, 0, 887, 0, 0, 0], false),\\n    ([0, 0, 916, 912, 0, 0, 888, 0, 0, 0], false),\\n    ([0, 919, 917, 913, 0, 0, 889, 0, 0, 0], false),\\n    ([928, 926, 922, 0, 0, 906, 890, 0, 0, 0], false),\\n    ([925, 923, 0, 0, 0, 907, 891, 0, 0, 0], false),\\n    ([924, 0, 0, 0, 0, 908, 892, 0, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 909, 893, 0, 0, 0], false),\\n    ([0, 924, 0, 0, 0, 910, 894, 0, 0, 0], false),\\n    ([927, 0, 923, 0, 0, 911, 895, 0, 0, 0], false),\\n    ([0, 0, 924, 0, 0, 912, 896, 0, 0, 0], false),\\n    ([0, 927, 925, 0, 0, 913, 897, 0, 0, 0], false),\\n    ([932, 930, 0, 922, 0, 914, 898, 0, 0, 0], false),\\n    ([931, 0, 0, 923, 0, 915, 899, 0, 0, 0], false),\\n    ([0, 0, 0, 924, 0, 916, 900, 0, 0, 0], false),\\n    ([0, 931, 0, 925, 0, 917, 901, 0, 0, 0], false),\\n    ([934, 0, 930, 926, 0, 918, 902, 0, 0, 0], false),\\n    ([0, 0, 931, 927, 0, 919, 903, 0, 0, 0], false),\\n    ([0, 934, 932, 928, 0, 920, 904, 0, 0, 0], false),\\n    ([967, 965, 961, 953, 0, 937, 0, 873, 0, 0], false),\\n    ([952, 950, 946, 938, 0, 0, 0, 874, 0, 0], false),\\n    ([945, 943, 939, 0, 0, 0, 0, 875, 0, 0], false),\\n    ([942, 940, 0, 0, 0, 0, 0, 876, 0, 0], false),\\n    ([941, 0, 0, 0, 0, 0, 0, 877, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 878, 0, 0], false),\\n    ([0, 941, 0, 0, 0, 0, 0, 879, 0, 0], false),\\n    ([944, 0, 940, 0, 0, 0, 0, 880, 0, 0], false),\\n    ([0, 0, 941, 0, 0, 0, 0, 881, 0, 0], false),\\n    ([0, 944, 942, 0, 0, 0, 0, 882, 0, 0], false),\\n    ([949, 947, 0, 939, 0, 0, 0, 883, 0, 0], false),\\n    ([948, 0, 0, 940, 0, 0, 0, 884, 0, 0], false),\\n    ([0, 0, 0, 941, 0, 0, 0, 885, 0, 0], false),\\n    ([0, 948, 0, 942, 0, 0, 0, 886, 0, 0], false),\\n    ([951, 0, 947, 943, 0, 0, 0, 887, 0, 0], false),\\n    ([0, 0, 948, 944, 0, 0, 0, 888, 0, 0], false),\\n    ([0, 951, 949, 945, 0, 0, 0, 889, 0, 0], false),\\n    ([960, 958, 954, 0, 0, 938, 0, 890, 0, 0], false),\\n    ([957, 955, 0, 0, 0, 939, 0, 891, 0, 0], false),\\n    ([956, 0, 0, 0, 0, 940, 0, 892, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 941, 0, 893, 0, 0], false),\\n    ([0, 956, 0, 0, 0, 942, 0, 894, 0, 0], false),\\n    ([959, 0, 955, 0, 0, 943, 0, 895, 0, 0], false),\\n    ([0, 0, 956, 0, 0, 944, 0, 896, 0, 0], false),\\n    ([0, 959, 957, 0, 0, 945, 0, 897, 0, 0], false),\\n    ([964, 962, 0, 954, 0, 946, 0, 898, 0, 0], false),\\n    ([963, 0, 0, 955, 0, 947, 0, 899, 0, 0], false),\\n    ([0, 0, 0, 956, 0, 948, 0, 900, 0, 0], false),\\n    ([0, 963, 0, 957, 0, 949, 0, 901, 0, 0], false),\\n    ([966, 0, 962, 958, 0, 950, 0, 902, 0, 0], false),\\n    ([0, 0, 963, 959, 0, 951, 0, 903, 0, 0], false),\\n    ([0, 966, 964, 960, 0, 952, 0, 904, 0, 0], false),\\n    ([983, 981, 977, 969, 0, 0, 937, 905, 0, 0], false),\\n    ([976, 974, 970, 0, 0, 0, 938, 906, 0, 0], false),\\n    ([973, 971, 0, 0, 0, 0, 939, 907, 0, 0], false),\\n    ([972, 0, 0, 0, 0, 0, 940, 908, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 941, 909, 0, 0], false),\\n    ([0, 972, 0, 0, 0, 0, 942, 910, 0, 0], false),\\n    ([975, 0, 971, 0, 0, 0, 943, 911, 0, 0], false),\\n    ([0, 0, 972, 0, 0, 0, 944, 912, 0, 0], false),\\n    ([0, 975, 973, 0, 0, 0, 945, 913, 0, 0], false),\\n    ([980, 978, 0, 970, 0, 0, 946, 914, 0, 0], false),\\n    ([979, 0, 0, 971, 0, 0, 947, 915, 0, 0], false),\\n    ([0, 0, 0, 972, 0, 0, 948, 916, 0, 0], false),\\n    ([0, 979, 0, 973, 0, 0, 949, 917, 0, 0], false),\\n    ([982, 0, 978, 974, 0, 0, 950, 918, 0, 0], false),\\n    ([0, 0, 979, 975, 0, 0, 951, 919, 0, 0], false),\\n    ([0, 982, 980, 976, 0, 0, 952, 920, 0, 0], false),\\n    ([991, 989, 985, 0, 0, 969, 953, 921, 0, 0], false),\\n    ([988, 986, 0, 0, 0, 970, 954, 922, 0, 0], false),\\n    ([987, 0, 0, 0, 0, 971, 955, 923, 0, 0], false),\\n    ([0, 0, 0, 0, 0, 972, 956, 924, 0, 0], false),\\n    ([0, 987, 0, 0, 0, 973, 957, 925, 0, 0], false),\\n    ([990, 0, 986, 0, 0, 974, 958, 926, 0, 0], false),\\n    ([0, 0, 987, 0, 0, 975, 959, 927, 0, 0], false),\\n    ([0, 990, 988, 0, 0, 976, 960, 928, 0, 0], false),\\n    ([0, 0, 0, 987, 0, 979, 963, 931, 0, 0], false),\\n    ([0, 992, 0, 988, 0, 980, 964, 932, 0, 0], false),\\n    ([0, 0, 992, 990, 0, 982, 966, 934, 0, 0], false),\\n    ([0, 994, 993, 991, 0, 983, 967, 935, 0, 0], false),\\n    ([1027, 1025, 1021, 1013, 0, 997, 0, 0, 873, 0], false),\\n    ([1012, 1010, 1006, 998, 0, 0, 0, 0, 874, 0], false),\\n    ([1005, 1003, 999, 0, 0, 0, 0, 0, 875, 0], false),\\n    ([1002, 1000, 0, 0, 0, 0, 0, 0, 876, 0], false),\\n    ([1001, 0, 0, 0, 0, 0, 0, 0, 877, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 878, 0], false),\\n    ([0, 1001, 0, 0, 0, 0, 0, 0, 879, 0], false),\\n    ([1004, 0, 1000, 0, 0, 0, 0, 0, 880, 0], false),\\n    ([0, 0, 1001, 0, 0, 0, 0, 0, 881, 0], false),\\n    ([0, 1004, 1002, 0, 0, 0, 0, 0, 882, 0], false),\\n    ([1009, 1007, 0, 999, 0, 0, 0, 0, 883, 0], false),\\n    ([1008, 0, 0, 1000, 0, 0, 0, 0, 884, 0], false),\\n    ([0, 0, 0, 1001, 0, 0, 0, 0, 885, 0], false),\\n    ([0, 1008, 0, 1002, 0, 0, 0, 0, 886, 0], false),\\n    ([1011, 0, 1007, 1003, 0, 0, 0, 0, 887, 0], false),\\n    ([0, 0, 1008, 1004, 0, 0, 0, 0, 888, 0], false),\\n    ([0, 1011, 1009, 1005, 0, 0, 0, 0, 889, 0], false),\\n    ([1020, 1018, 1014, 0, 0, 998, 0, 0, 890, 0], false),\\n    ([1017, 1015, 0, 0, 0, 999, 0, 0, 891, 0], false),\\n    ([1016, 0, 0, 0, 0, 1000, 0, 0, 892, 0], false),\\n    ([0, 0, 0, 0, 0, 1001, 0, 0, 893, 0], false),\\n    ([0, 1016, 0, 0, 0, 1002, 0, 0, 894, 0], false),\\n    ([1019, 0, 1015, 0, 0, 1003, 0, 0, 895, 0], false),\\n    ([0, 0, 1016, 0, 0, 1004, 0, 0, 896, 0], false),\\n    ([0, 1019, 1017, 0, 0, 1005, 0, 0, 897, 0], false),\\n    ([1024, 1022, 0, 1014, 0, 1006, 0, 0, 898, 0], false),\\n    ([1023, 0, 0, 1015, 0, 1007, 0, 0, 899, 0], false),\\n    ([0, 0, 0, 1016, 0, 1008, 0, 0, 900, 0], false),\\n    ([0, 1023, 0, 1017, 0, 1009, 0, 0, 901, 0], false),\\n    ([1026, 0, 1022, 1018, 0, 1010, 0, 0, 902, 0], false),\\n    ([0, 0, 1023, 1019, 0, 1011, 0, 0, 903, 0], false),\\n    ([0, 1026, 1024, 1020, 0, 1012, 0, 0, 904, 0], false),\\n    ([1035, 1033, 1029, 0, 0, 0, 998, 0, 906, 0], false),\\n    ([1032, 1030, 0, 0, 0, 0, 999, 0, 907, 0], false),\\n    ([1031, 0, 0, 0, 0, 0, 1000, 0, 908, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1001, 0, 909, 0], false),\\n    ([0, 1031, 0, 0, 0, 0, 1002, 0, 910, 0], false),\\n    ([1034, 0, 1030, 0, 0, 0, 1003, 0, 911, 0], false),\\n    ([0, 0, 1031, 0, 0, 0, 1004, 0, 912, 0], false),\\n    ([0, 1034, 1032, 0, 0, 0, 1005, 0, 913, 0], false),\\n    ([1043, 1041, 1037, 0, 0, 1028, 1013, 0, 921, 0], false),\\n    ([1040, 1038, 0, 0, 0, 1029, 1014, 0, 922, 0], false),\\n    ([1039, 0, 0, 0, 0, 1030, 1015, 0, 923, 0], false),\\n    ([0, 0, 0, 0, 0, 1031, 1016, 0, 924, 0], false),\\n    ([0, 1039, 0, 0, 0, 1032, 1017, 0, 925, 0], false),\\n    ([1042, 0, 1038, 0, 0, 1033, 1018, 0, 926, 0], false),\\n    ([0, 0, 1039, 0, 0, 1034, 1019, 0, 927, 0], false),\\n    ([0, 1042, 1040, 0, 0, 1035, 1020, 0, 928, 0], false),\\n    ([1059, 1057, 1053, 1045, 0, 0, 0, 997, 937, 0], false),\\n    ([1052, 1050, 1046, 0, 0, 0, 0, 998, 938, 0], false),\\n    ([1049, 1047, 0, 0, 0, 0, 0, 999, 939, 0], false),\\n    ([1048, 0, 0, 0, 0, 0, 0, 1000, 940, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1001, 941, 0], false),\\n    ([0, 1048, 0, 0, 0, 0, 0, 1002, 942, 0], false),\\n    ([1051, 0, 1047, 0, 0, 0, 0, 1003, 943, 0], false),\\n    ([0, 0, 1048, 0, 0, 0, 0, 1004, 944, 0], false),\\n    ([0, 1051, 1049, 0, 0, 0, 0, 1005, 945, 0], false),\\n    ([1056, 1054, 0, 1046, 0, 0, 0, 1006, 946, 0], false),\\n    ([1055, 0, 0, 1047, 0, 0, 0, 1007, 947, 0], false),\\n    ([0, 0, 0, 1048, 0, 0, 0, 1008, 948, 0], false),\\n    ([0, 1055, 0, 1049, 0, 0, 0, 1009, 949, 0], false),\\n    ([1058, 0, 1054, 1050, 0, 0, 0, 1010, 950, 0], false),\\n    ([0, 0, 1055, 1051, 0, 0, 0, 1011, 951, 0], false),\\n    ([0, 1058, 1056, 1052, 0, 0, 0, 1012, 952, 0], false),\\n    ([1067, 1065, 1061, 0, 0, 1045, 0, 1013, 953, 0], false),\\n    ([1064, 1062, 0, 0, 0, 1046, 0, 1014, 954, 0], false),\\n    ([1063, 0, 0, 0, 0, 1047, 0, 1015, 955, 0], false),\\n    ([0, 0, 0, 0, 0, 1048, 0, 1016, 956, 0], false),\\n    ([0, 1063, 0, 0, 0, 1049, 0, 1017, 957, 0], false),\\n    ([1066, 0, 1062, 0, 0, 1050, 0, 1018, 958, 0], false),\\n    ([0, 0, 1063, 0, 0, 1051, 0, 1019, 959, 0], false),\\n    ([0, 1066, 1064, 0, 0, 1052, 0, 1020, 960, 0], false),\\n    ([1071, 1069, 0, 1061, 0, 1053, 0, 1021, 961, 0], false),\\n    ([1070, 0, 0, 1062, 0, 1054, 0, 1022, 962, 0], false),\\n    ([0, 0, 0, 1063, 0, 1055, 0, 1023, 963, 0], false),\\n    ([0, 1070, 0, 1064, 0, 1056, 0, 1024, 964, 0], false),\\n    ([1073, 0, 1069, 1065, 0, 1057, 0, 1025, 965, 0], false),\\n    ([0, 0, 1070, 1066, 0, 1058, 0, 1026, 966, 0], false),\\n    ([1081, 1079, 1075, 0, 0, 0, 1045, 1028, 969, 0], false),\\n    ([1078, 1076, 0, 0, 0, 0, 1046, 1029, 970, 0], false),\\n    ([1077, 0, 0, 0, 0, 0, 1047, 1030, 971, 0], false),\\n    ([0, 0, 0, 0, 0, 0, 1048, 1031, 972, 0], false),\\n    ([0, 1077, 0, 0, 0, 0, 1049, 1032, 973, 0], false),\\n    ([1080, 0, 1076, 0, 0, 0, 1050, 1033, 974, 0], false),\\n    ([0, 0, 1077, 0, 0, 0, 1051, 1034, 975, 0], false),\\n    ([0, 1080, 1078, 0, 0, 0, 1052, 1035, 976, 0], false),\\n    ([1085, 1083, 0, 0, 0, 1075, 1061, 1037, 985, 0], false),\\n    ([1084, 0, 0, 0, 0, 1076, 1062, 1038, 986, 0], false),\\n    ([0, 0, 0, 0, 0, 1077, 1063, 1039, 987, 0], false),\\n    ([0, 1084, 0, 0, 0, 1078, 1064, 1040, 988, 0], false),\\n    ([1093, 1091, 1087, 0, 0, 0, 0, 0, 0, 875], false),\\n    ([1090, 1088, 0, 0, 0, 0, 0, 0, 0, 876], false),\\n    ([1089, 0, 0, 0, 0, 0, 0, 0, 0, 877], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 0, 878], false),\\n    ([0, 1089, 0, 0, 0, 0, 0, 0, 0, 879], false),\\n    ([1092, 0, 1088, 0, 0, 0, 0, 0, 0, 880], false),\\n    ([0, 0, 1089, 0, 0, 0, 0, 0, 0, 881], false),\\n    ([0, 1092, 1090, 0, 0, 0, 0, 0, 0, 882], false),\\n    ([1097, 1095, 0, 1087, 0, 0, 0, 0, 0, 883], false),\\n    ([1096, 0, 0, 1088, 0, 0, 0, 0, 0, 884], false),\\n    ([0, 0, 0, 1089, 0, 0, 0, 0, 0, 885], false),\\n    ([0, 1096, 0, 1090, 0, 0, 0, 0, 0, 886], false),\\n    ([1099, 0, 0, 0, 0, 1088, 0, 0, 0, 892], false),\\n    ([0, 0, 0, 0, 0, 1089, 0, 0, 0, 893], false),\\n    ([0, 1099, 0, 0, 0, 1090, 0, 0, 0, 894], false),\\n    ([1102, 0, 1098, 0, 0, 1091, 0, 0, 0, 895], false),\\n    ([0, 0, 1099, 0, 0, 1092, 0, 0, 0, 896], false),\\n    ([0, 1102, 1100, 0, 0, 1093, 0, 0, 0, 897], false),\\n    ([1105, 0, 0, 1098, 0, 1095, 0, 0, 0, 899], false),\\n    ([0, 0, 0, 1099, 0, 1096, 0, 0, 0, 900], false),\\n    ([0, 1105, 0, 1100, 0, 1097, 0, 0, 0, 901], false),\\n    ([1114, 1112, 1108, 0, 0, 0, 1086, 0, 0, 906], false),\\n    ([1111, 1109, 0, 0, 0, 0, 1087, 0, 0, 907], false),\\n    ([1110, 0, 0, 0, 0, 0, 1088, 0, 0, 908], false),\\n    ([0, 0, 0, 0, 0, 0, 1089, 0, 0, 909], false),\\n    ([0, 1110, 0, 0, 0, 0, 1090, 0, 0, 910], false),\\n    ([1113, 0, 1109, 0, 0, 0, 1091, 0, 0, 911], false),\\n    ([0, 0, 1110, 0, 0, 0, 1092, 0, 0, 912], false),\\n    ([0, 1113, 1111, 0, 0, 0, 1093, 0, 0, 913], false),\\n    ([1118, 1116, 0, 1108, 0, 0, 1094, 0, 0, 914], false),\\n    ([1117, 0, 0, 1109, 0, 0, 1095, 0, 0, 915], false),\\n    ([0, 0, 0, 1110, 0, 0, 1096, 0, 0, 916], false),\\n    ([0, 1117, 0, 1111, 0, 0, 1097, 0, 0, 917], false),\\n    ([0, 0, 0, 0, 0, 1110, 1099, 0, 0, 924], false),\\n    ([0, 1119, 0, 0, 0, 1111, 1100, 0, 0, 925], false),\\n    ([0, 0, 1119, 0, 0, 1113, 1102, 0, 0, 927], false),\\n    ([0, 1121, 1120, 0, 0, 1114, 1103, 0, 0, 928], false),\\n    ([0, 0, 0, 1119, 0, 1117, 1105, 0, 0, 931], false),\\n    ([0, 1123, 0, 1120, 0, 1118, 1106, 0, 0, 932], false),\\n    ([1126, 0, 0, 0, 0, 0, 0, 1088, 0, 940], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1089, 0, 941], false),\\n    ([0, 1126, 0, 0, 0, 0, 0, 1090, 0, 942], false),\\n    ([1129, 0, 1125, 0, 0, 0, 0, 1091, 0, 943], false),\\n    ([0, 0, 1126, 0, 0, 0, 0, 1092, 0, 944], false),\\n    ([0, 1129, 1127, 0, 0, 0, 0, 1093, 0, 945], false),\\n    ([1132, 0, 0, 1125, 0, 0, 0, 1095, 0, 947], false),\\n    ([0, 0, 0, 1126, 0, 0, 0, 1096, 0, 948], false),\\n    ([0, 1132, 0, 1127, 0, 0, 0, 1097, 0, 949], false),\\n    ([1135, 0, 0, 0, 0, 1125, 0, 1098, 0, 955], false),\\n    ([0, 0, 0, 0, 0, 1126, 0, 1099, 0, 956], false),\\n    ([0, 1135, 0, 0, 0, 1127, 0, 1100, 0, 957], false),\\n    ([0, 0, 1135, 0, 0, 1129, 0, 1102, 0, 959], false),\\n    ([1139, 0, 0, 1134, 0, 1131, 0, 1104, 0, 962], false),\\n    ([0, 0, 0, 1135, 0, 1132, 0, 1105, 0, 963], false),\\n    ([0, 1139, 0, 1136, 0, 1133, 0, 1106, 0, 964], false),\\n    ([1142, 0, 0, 0, 0, 0, 1125, 1109, 0, 971], false),\\n    ([0, 0, 0, 0, 0, 0, 1126, 1110, 0, 972], false),\\n    ([0, 1142, 0, 0, 0, 0, 1127, 1111, 0, 973], false),\\n    ([1145, 0, 1141, 0, 0, 0, 1128, 1112, 0, 974], false),\\n    ([0, 0, 1142, 0, 0, 0, 1129, 1113, 0, 975], false),\\n    ([0, 1145, 1143, 0, 0, 0, 1130, 1114, 0, 976], false),\\n    ([1148, 0, 0, 1141, 0, 0, 1131, 1116, 0, 978], false),\\n    ([0, 0, 0, 1142, 0, 0, 1132, 1117, 0, 979], false),\\n    ([0, 1148, 0, 1143, 0, 0, 1133, 1118, 0, 980], false),\\n    ([0, 0, 0, 0, 0, 1142, 1135, 1119, 0, 987], false),\\n    ([0, 1150, 0, 0, 0, 1143, 1136, 1120, 0, 988], false),\\n    ([0, 0, 1150, 0, 0, 1145, 1137, 1121, 0, 990], false),\\n    ([0, 0, 0, 1150, 0, 1148, 1139, 1123, 0, 992], false),\\n    ([1161, 1159, 1155, 0, 0, 0, 0, 0, 1086, 998], false),\\n    ([1158, 1156, 0, 0, 0, 0, 0, 0, 1087, 999], false),\\n    ([1157, 0, 0, 0, 0, 0, 0, 0, 1088, 1000], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 0, 1089, 1001], false),\\n    ([0, 1157, 0, 0, 0, 0, 0, 0, 1090, 1002], false),\\n    ([1160, 0, 1156, 0, 0, 0, 0, 0, 1091, 1003], false),\\n    ([0, 0, 1157, 0, 0, 0, 0, 0, 1092, 1004], false),\\n    ([0, 1160, 1158, 0, 0, 0, 0, 0, 1093, 1005], false),\\n    ([1165, 1163, 0, 1155, 0, 0, 0, 0, 1094, 1006], false),\\n    ([1164, 0, 0, 1156, 0, 0, 0, 0, 1095, 1007], false),\\n    ([0, 0, 0, 1157, 0, 0, 0, 0, 1096, 1008], false),\\n    ([0, 1164, 0, 1158, 0, 0, 0, 0, 1097, 1009], false),\\n    ([1167, 0, 0, 0, 0, 1156, 0, 0, 1098, 1015], false),\\n    ([0, 0, 0, 0, 0, 1157, 0, 0, 1099, 1016], false),\\n    ([0, 1167, 0, 0, 0, 1158, 0, 0, 1100, 1017], false),\\n    ([1170, 0, 1166, 0, 0, 1159, 0, 0, 1101, 1018], false),\\n    ([0, 0, 1167, 0, 0, 1160, 0, 0, 1102, 1019], false),\\n    ([0, 1170, 1168, 0, 0, 1161, 0, 0, 1103, 1020], false),\\n    ([0, 0, 0, 1167, 0, 1164, 0, 0, 1105, 1023], false),\\n    ([0, 1172, 0, 1168, 0, 1165, 0, 0, 1106, 1024], false),\\n    ([1181, 1179, 1175, 0, 0, 0, 1154, 0, 1107, 1028], false),\\n    ([1178, 1176, 0, 0, 0, 0, 1155, 0, 1108, 1029], false),\\n    ([1177, 0, 0, 0, 0, 0, 1156, 0, 1109, 1030], false),\\n    ([0, 0, 0, 0, 0, 0, 1157, 0, 1110, 1031], false),\\n    ([0, 1177, 0, 0, 0, 0, 1158, 0, 1111, 1032], false),\\n    ([1180, 0, 1176, 0, 0, 0, 1159, 0, 1112, 1033], false),\\n    ([0, 0, 1177, 0, 0, 0, 1160, 0, 1113, 1034], false),\\n    ([0, 1180, 1178, 0, 0, 0, 1161, 0, 1114, 1035], false),\\n    ([1183, 0, 0, 0, 0, 0, 0, 1156, 1125, 1047], false),\\n    ([0, 0, 0, 0, 0, 0, 0, 1157, 1126, 1048], false),\\n    ([0, 1183, 0, 0, 0, 0, 0, 1158, 1127, 1049], false),\\n    ([1186, 0, 1182, 0, 0, 0, 0, 1159, 1128, 1050], false),\\n    ([0, 0, 1183, 0, 0, 0, 0, 1160, 1129, 1051], false),\\n    ([0, 1186, 1184, 0, 0, 0, 0, 1161, 1130, 1052], false),\\n    ([1189, 0, 0, 1182, 0, 0, 0, 1163, 1131, 1054], false),\\n    ([0, 0, 0, 1183, 0, 0, 0, 1164, 1132, 1055], false),\\n    ([0, 1189, 0, 1184, 0, 0, 0, 1165, 1133, 1056], false),\\n    ([1192, 0, 0, 0, 0, 1182, 0, 1166, 1134, 1062], false),\\n    ([0, 0, 0, 0, 0, 1183, 0, 1167, 1135, 1063], false),\\n    ([0, 1192, 0, 0, 0, 1184, 0, 1168, 1136, 1064], false),\\n    ([0, 0, 1192, 0, 0, 1186, 0, 1170, 1137, 1066], false),\\n    ([0, 0, 0, 1192, 0, 1189, 0, 1172, 1139, 1070], false),\\n    ([0, 1195, 0, 1193, 0, 1190, 0, 1173, 1140, 1071], false),\\n    ([1198, 0, 0, 0, 0, 0, 1182, 1176, 1141, 1076], false),\\n    ([0, 0, 0, 0, 0, 0, 1183, 1177, 1142, 1077], false),\\n    ([0, 1198, 0, 0, 0, 0, 1184, 1178, 1143, 1078], false),\\n    ([1201, 0, 1197, 0, 0, 0, 1185, 1179, 1144, 1079], false),\\n    ([0, 0, 1198, 0, 0, 0, 1186, 1180, 1145, 1080], false),\\n    ([0, 1201, 1199, 0, 0, 0, 1187, 1181, 1146, 1081], false),\\n];\\n```\n```\\nconst N_DIGITS: usize = 10;\\n\\nuse std::collections::HashMap;\\n\\nfn get_node_id(digits: &[usize], visited: &mut [bool], n_visited: usize) -> usize {\\n    if n_visited == 0 {\\n        usize::MAX\\n    } else {\\n        digits\\n            .iter()\\n            .zip(visited.iter())\\n            .fold(0, |id, (d, v)| if *v { id * 10 + *d } else { id })\\n    }\\n}\\n\\nfn backtrack(\\n    digits: &[usize],\\n    visited: &mut [bool],\\n    depth: usize,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let curr_id = get_node_id(digits, visited, depth);\\n    if depth == digits.len() {\\n        graph.get_mut(&curr_id).unwrap().2 = true;\\n    } else {\\n        graph.entry(curr_id).or_insert_with(|| {\\n            let nn = *node_number;\\n            *node_number += 1;\\n            (nn, [0; N_DIGITS], false)\\n        });\\n\\n        for i in 0..digits.len() {\\n            if !visited[i] {\\n                visited[i] = true;\\n                let next_id = get_node_id(digits, visited, depth + 1);\\n                let next_node_number = graph\\n                    .entry(next_id)\\n                    .or_insert_with(|| {\\n                        let nn = *node_number;\\n                        *node_number += 1;\\n                        (nn, [0; N_DIGITS], false)\\n                    })\\n                    .0;\\n                graph.get_mut(&curr_id).unwrap().1[digits[i]] = next_node_number;\\n                backtrack(digits, visited, depth + 1, graph, node_number);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n}\\n\\nfn get_digits(mut n: i32) -> Vec<usize> {\\n    if n == 0 {\\n        vec![0]\\n    } else {\\n        let mut rez = vec![];\\n        while n > 0 {\\n            rez.push((n % 10) as usize);\\n            n /= 10;\\n        }\\n        rez.sort_unstable_by(|d1, d2| d2.cmp(d1));\\n        rez\\n    }\\n}\\n\\nfn insert(\\n    n: i32,\\n    graph: &mut HashMap<usize, (usize, [usize; N_DIGITS], bool)>,\\n    node_number: &mut usize,\\n) {\\n    let digits = get_digits(n);\\n    let mut visited = vec![false; digits.len()];\\n    backtrack(&digits, &mut visited, 0, graph, node_number);\\n}\\n\\nfn main() {\\n    let mut node_number = 0;\\n    let mut graph_map = HashMap::new();\\n    for shift in 0..30 {\\n        insert(1 << shift, &mut graph_map, &mut node_number);\\n    }\\n    let mut graph = graph_map.values().copied().collect::<Vec<_>>();\\n    graph.sort_unstable_by_key(|(node_number, _, _)| *node_number);\\n    let graph = graph\\n        .into_iter()\\n        .map(|(_, edges, leaf)| (edges, leaf))\\n        .collect::<Vec<_>>();\\n    println!(\"{:?}\", graph);\\n    println!(\"{:?}\", graph.len());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482080,
                "title": "c-python-simple-fastest-solution-with-explanation",
                "content": "**Idea:**\\nThe easiest way to check if two things are shuffled versions of each other, which is what this problem is asking us to do, is to sort them both and the compare the result.\\n\\nIn that sense, the easiest solution here is to do exactly that: we can convert **N** to an array of its digits, sort it, then compare that result to the result of the same process on each power of **2**.\\n\\nSince the constraint upon **N** is **10e9**, we only need to check powers in the range **[0,29]**.\\n\\nTo make things easier to compare, we can always **join()** the resulting digit arrays into strings before comparison.\\n\\n**C++ Code:**\\nThe best result for the code below is 0ms / 5.9MB (beats 100% / 83.90%).\\n```\\nclass Solution {\\npublic:\\n    string convert(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = convert(n);\\n        for (int i = 0; i < 30; i++) {\\n            if (s == convert(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Python Code:**\\nThe best result for the code below is 33ms / 14MB (beats 98.93% / 26.74%).\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def getConvert(n):\\n            return \"\".join(sorted([x for x in str(n)]))\\n        s = getConvert(n)\\n        for i in range(30):\\n            if s == getConvert(1<<i): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = convert(n);\\n        for (int i = 0; i < 30; i++) {\\n            if (s == convert(1 << i)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def getConvert(n):\\n            return \"\".join(sorted([x for x in str(n)]))\\n        s = getConvert(n)\\n        for i in range(30):\\n            if s == getConvert(1<<i): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482051,
                "title": "q869-c-100-time-space-fast-easy",
                "content": "C++ Code:\\n```\\n    bool isEqual(int arr1[10], int arr2[10]) {\\n        for (int i = 0; i < 10; i++) if (arr1[i] != arr2[i]) return 0;\\n        return 1;\\n    }\\n\\n    int countDigits(int num, int digits[10]) {\\n        int cnt = 0;\\n        while (num > 0) digits[num % 10]++, num /= 10, cnt++;\\n        return cnt;\\n    }\\n\\n    bool reorderedPowerOf2(int num) {\\n        if (num > 0) {\\n            int numDigits[10] = { 0 }, numCnt = countDigits(num, numDigits);\\n            long po2 = 1; // po2: Power of 2\\n            while (1) {\\n                int po2Digits[10] = { 0 }, po2Cnt = countDigits(po2, po2Digits);\\n                po2 <<= 1; // same as (po2 = po2 * 2;)\\n                if (po2Cnt < numCnt) continue;\\n                if (po2Cnt > numCnt || po2 > INT_MAX) break;\\n                if (isEqual(numDigits, po2Digits)) return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n**The complexity of this solution:**\\n-\\tTime: O( n^2 ) // depend on the size of num and po2\\n-\\tSpace: O( 1 ) // constant array size\\n\\nResult: \\n![image](https://assets.leetcode.com/users/images/bceeb8be-3eb7-4c31-8d01-2517b3102621_1661493958.3626537.png)\\n**If you loved this solution please up vote, enjoy your coding \\uD83D\\uDE0A\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    bool isEqual(int arr1[10], int arr2[10]) {\\n        for (int i = 0; i < 10; i++) if (arr1[i] != arr2[i]) return 0;\\n        return 1;\\n    }\\n\\n    int countDigits(int num, int digits[10]) {\\n        int cnt = 0;\\n        while (num > 0) digits[num % 10]++, num /= 10, cnt++;\\n        return cnt;\\n    }\\n\\n    bool reorderedPowerOf2(int num) {\\n        if (num > 0) {\\n            int numDigits[10] = { 0 }, numCnt = countDigits(num, numDigits);\\n            long po2 = 1; // po2: Power of 2\\n            while (1) {\\n                int po2Digits[10] = { 0 }, po2Cnt = countDigits(po2, po2Digits);\\n                po2 <<= 1; // same as (po2 = po2 * 2;)\\n                if (po2Cnt < numCnt) continue;\\n                if (po2Cnt > numCnt || po2 > INT_MAX) break;\\n                if (isEqual(numDigits, po2Digits)) return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481945,
                "title": "90-tc-and-78-sc-python-magic",
                "content": "```\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n\\tnum = set(\"\".join(sorted(str(2**i))) for i in range(0, 32))\\n\\tn = \\'\\'.join(sorted(str(n)))\\n\\treturn n in num\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef reorderedPowerOf2(self, n: int) -> bool:\\n\\tnum = set(\"\".join(sorted(str(2**i))) for i in range(0, 32))\\n\\tn = \\'\\'.join(sorted(str(n)))\\n\\treturn n in num\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2481937,
                "title": "c-100-faster-0ms-solution-by-hash",
                "content": "# **Workaround**\\n\\nAccording to the question, we need to reorder the target number `n` to indicate whether the number is power of 2. That is, the count of each digit in `n` must be same as the certain number which is power of 2. Therefore, we can use a custom hash function to count the digits:\\n\\n``` cpp\\nint hashNumber(int n) {\\n  auto res = int(0);              /// our result hash value.\\n  while (n != 0) {                /// loop the number by taking its last digit until it becomes zero. \\n    res += int(pow(10, n % 10));  /// take digit and add res by 10 ^ n.\\n    n /= 10;                      /// iterate to next digit.\\n  }\\n  return res;\\n}\\n```\\n\\nNote for the argument `n` of function. We have constraints from the question `1 <= n <= 10^9` hence there is impossible to have a number with the count of certain digit more than `9`. We can add our result `res` by `pow(10, n%10*m)` if the count of certain digit can be increased to `m`-digits.\\n\\n---\\n# **Constant Variable**\\n\\nWhen it comes to the hash values of the power of 2, it always calculate the same hash value of `1`, `2`, `4`, `8` ... etc. Hence we can memorize the hash value of these number by  `hashNumber(m)` where `1 <= m <= 10^9` and `m` is power of 2, that is, we can construct a `unordered_set` :\\n\\n```cpp\\nauto mp     = unordered_set<int>(); /// our map which is used to store the hash value.\\nauto number = int(1);               /// our iteration of power of 2.\\nwhile (number <= 1e9) {             /// loop the number until it is bigger than 10^9.\\n  mp.emplace(hashNumber(number));   /// insert a hash value of number into our map.\\n  number <<= 1;                     /// iterate the number by multipling it by 2\\n}\\n```\\n\\nFinally, we have a constant `unordered_set`:\\n``` cpp\\nunordered_set<int> hashes{\\n  10,         100,        10000,     100000000,  1000010,    1100,\\n  1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n  1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n  1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n  32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n```\\n\\n---\\n\\n# **Source Code**\\n\\n``` cpp\\nclass Solution {\\nprivate:\\n  inline const static unordered_set<int> hashes{\\n    10,         100,        10000,     100000000,  1000010,    1100,\\n    1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n    1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n    1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n    32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n\\n  int hashNumber(int n) {\\n    auto res = int(0);\\n    while (n != 0) {\\n      res += int(pow(10, n % 10));\\n      n /= 10;\\n    }\\n    return res;\\n  }\\n\\npublic:\\n  bool reorderedPowerOf2(int n) {\\n    return hashes.find(hashNumber(n)) != hashes.end();\\n  }\\n};\\n```\\n# **Complexity**\\n\\n- **Time**: `O(number_of_digits(n))`\\n- **Space**: `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/24a1f710-c749-478e-9fc9-49c0285789f9_1661494383.20038.png)\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "``` cpp\\nint hashNumber(int n) {\\n  auto res = int(0);              /// our result hash value.\\n  while (n != 0) {                /// loop the number by taking its last digit until it becomes zero. \\n    res += int(pow(10, n % 10));  /// take digit and add res by 10 ^ n.\\n    n /= 10;                      /// iterate to next digit.\\n  }\\n  return res;\\n}\\n```\n```cpp\\nauto mp     = unordered_set<int>(); /// our map which is used to store the hash value.\\nauto number = int(1);               /// our iteration of power of 2.\\nwhile (number <= 1e9) {             /// loop the number until it is bigger than 10^9.\\n  mp.emplace(hashNumber(number));   /// insert a hash value of number into our map.\\n  number <<= 1;                     /// iterate the number by multipling it by 2\\n}\\n```\n``` cpp\\nunordered_set<int> hashes{\\n  10,         100,        10000,     100000000,  1000010,    1100,\\n  1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n  1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n  1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n  32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n```\n``` cpp\\nclass Solution {\\nprivate:\\n  inline const static unordered_set<int> hashes{\\n    10,         100,        10000,     100000000,  1000010,    1100,\\n    1010000,    100000110,  1100100,   100110,     10111,      100010101,\\n    1001010001, 1100000110, 101011010, 111001100,  2201000,    10001121,\\n    1020210,    200110200,  111110011, 1010100211, 1000031011, 401001001,\\n    32000120,   223100,     212010011, 120011220,  102221100,  1111101111};\\n\\n  int hashNumber(int n) {\\n    auto res = int(0);\\n    while (n != 0) {\\n      res += int(pow(10, n % 10));\\n      n /= 10;\\n    }\\n    return res;\\n  }\\n\\npublic:\\n  bool reorderedPowerOf2(int n) {\\n    return hashes.find(hashNumber(n)) != hashes.end();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481868,
                "title": "c-simple-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkdigits(int n,vector<int>&v)\\n    {\\n        vector<int>v1(10,-1);\\n        while(n)\\n        {\\n            v1[n%10]++;\\n            n=n/10;\\n        }\\n        if(v1==v)\\n            return true;\\n        return false;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v(10,-1);\\n        while(n)\\n        {\\n            v[n%10]++;\\n            n=n/10;\\n        }\\n        int num=1;\\n        for(int i=1;i<=30;i++)\\n        {\\n            if(checkdigits(num,v))\\n                return true;\\n            num=num*2;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkdigits(int n,vector<int>&v)\\n    {\\n        vector<int>v1(10,-1);\\n        while(n)\\n        {\\n            v1[n%10]++;\\n            n=n/10;\\n        }\\n        if(v1==v)\\n            return true;\\n        return false;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>v(10,-1);\\n        while(n)\\n        {\\n            v[n%10]++;\\n            n=n/10;\\n        }\\n        int num=1;\\n        for(int i=1;i<=30;i++)\\n        {\\n            if(checkdigits(num,v))\\n                return true;\\n            num=num*2;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481815,
                "title": "100-faster-c-solution-easy-understanding-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n        vector<int> gem(long int n) {\\n        vector<int>nums(10);\\n        \\n        while(n){\\n            nums[n%10]++;\\n            n=n/10;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>arr=gem(n);\\n        for(int i=0;i<31;i++){\\n            if(arr==gem(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n        vector<int> gem(long int n) {\\n        vector<int>nums(10);\\n        \\n        while(n){\\n            nums[n%10]++;\\n            n=n/10;\\n        }\\n        return nums;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        vector<int>arr=gem(n);\\n        for(int i=0;i<31;i++){\\n            if(arr==gem(1<<i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481805,
                "title": "approach-converting-into-string-max-tc-o-33-9-log-9-i-e-o-1-constant-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<33;i++){\\n            string x = to_string((long long)pow(2,i));\\n            sort(x.begin(),x.end());\\n            if(s==x){\\n                // cout<<s<<\" \"<<x<<endl;\\n                return true;\\n            }\\n                        \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<33;i++){\\n            string x = to_string((long long)pow(2,i));\\n            sort(x.begin(),x.end());\\n            if(s==x){\\n                // cout<<s<<\" \"<<x<<endl;\\n                return true;\\n            }\\n                        \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2481586,
                "title": "c",
                "content": "first we convert the given number to string and sort it. Then we compare the sorted string to every power of 2 till 30(as constraint is 10^9, so it can not exceed 2^30). If we find that n==2^x the we return true.\\n\\n bool reorderedPowerOf2(int n) {\\n       \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<31;i++)\\n        {\\n            int n= pow(2,i);\\n            string s2 = to_string(n);\\n            sort(s2.begin(),s2.end());\\n            if(s2==s) return true;\\n        }\\n        return false;\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "first we convert the given number to string and sort it. Then we compare the sorted string to every power of 2 till 30(as constraint is 10^9, so it can not exceed 2^30). If we find that n==2^x the we return true.\\n\\n bool reorderedPowerOf2(int n) {\\n       \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<31;i++)\\n        {\\n            int n= pow(2,i);\\n            string s2 = to_string(n);\\n            sort(s2.begin(),s2.end());\\n            if(s2==s) return true;\\n        }\\n        return false;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2481585,
                "title": "c-solution-using-sorting",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string x = to_string(n);\\n        sort(x.begin(),x.end());\\n        for(int i=0;i<32;i++){\\n            string temp = to_string(1<<i);\\n            sort(temp.begin(),temp.end());\\n            if(x==temp) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string x = to_string(n);\\n        sort(x.begin(),x.end());\\n        for(int i=0;i<32;i++){\\n            string temp = to_string(1<<i);\\n            sort(temp.begin(),temp.end());\\n            if(x==temp) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481490,
                "title": "c-easy-solution-100-fast",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        for (int i = 0; i <= 30; i++)\\n        {\\n            int p = pow(2, i);\\n            string t = to_string(p);\\n            sort(t.begin(), t.end());\\n            if (t == s)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string s = to_string(n);\\n        sort(s.begin(), s.end());\\n        for (int i = 0; i <= 30; i++)\\n        {\\n            int p = pow(2, i);\\n            string t = to_string(p);\\n            sort(t.begin(), t.end());\\n            if (t == s)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481455,
                "title": "string-based-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        int i = 1;\\n        int lenOfN = floor(log10(n)+1);\\n        int lenOfI = floor(log10(i)+1);\\n        string sn = to_string(n);\\n        sort(sn.begin(), sn.end());\\n        while(lenOfI<=lenOfN){\\n            \\n            string si = to_string(i);\\n            sort(si.begin(), si.end());\\n            \\n            if(lenOfN==lenOfI){\\n                    \\n                if(sn.compare(si)==0) return true;\\n            }\\n            \\n            i = i*2;\\n            lenOfI = floor(log10(i)+1);\\n      \\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        int i = 1;\\n        int lenOfN = floor(log10(n)+1);\\n        int lenOfI = floor(log10(i)+1);\\n        string sn = to_string(n);\\n        sort(sn.begin(), sn.end());\\n        while(lenOfI<=lenOfN){\\n            \\n            string si = to_string(i);\\n            sort(si.begin(), si.end());\\n            \\n            if(lenOfN==lenOfI){\\n                    \\n                if(sn.compare(si)==0) return true;\\n            }\\n            \\n            i = i*2;\\n            lenOfI = floor(log10(i)+1);\\n      \\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481415,
                "title": "c-good-code-quality-next-permutation-solution",
                "content": "We are generating each permutation from the string converting it back to integer and checking if it is a power of 2 or not. The runtime is not good it beats 10% but it is a different solution than the rest of discuss.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool LeadingDigitZero(string s){\\n        return s[0] == \\'0\\';\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        if(ceil(log2(n)) == floor(log2(n))){\\n            return true;\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        \\n        do{\\n            n = stoi(s);\\n            if(!LeadingDigitZero(s) && ceil(log2(n)) == floor(log2(n))){\\n                return true;\\n            }\\n        }while(next_permutation(s.begin(),s.end()));\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool LeadingDigitZero(string s){\\n        return s[0] == \\'0\\';\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        \\n        if(ceil(log2(n)) == floor(log2(n))){\\n            return true;\\n        }\\n        \\n        string s = to_string(n);\\n        sort(s.begin(),s.end());\\n        \\n        do{\\n            n = stoi(s);\\n            if(!LeadingDigitZero(s) && ceil(log2(n)) == floor(log2(n))){\\n                return true;\\n            }\\n        }while(next_permutation(s.begin(),s.end()));\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481395,
                "title": "java-solution-easy-counting-with-comments",
                "content": "### **Approach:**\\n##### *The Approach is to check whether the given number n is an anagram of another number m, where m is a power of two 1<=m<=Math.pow(2,30).*\\n```java \\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        String s=n+\"\";\\n        int[] a = new int[10];   // frequency of digits in number s, s=n\\n        for(int i=0;i<s.length();i++)\\n            a[s.charAt(i)-\\'0\\']++;\\n\\n        int i=1;\\n        String t = \"1\";   //Math.pow(2,0) =1\\n        while(s.length()>=t.length())\\n        {\\n            if(s.length()==t.length()){\\n            int[] b = new int[10];     // frequency of digits in number t, where t = Math.pow(2,i)\\n                \\n            for(int j=0;j<t.length();j++)\\n                b[t.charAt(j)-\\'0\\']++;\\n                \\n            if(Arrays.equals(a,b))   //Checking whether String s is Anagram of String t\\n                return true;\\n            }\\n            t = (int)Math.pow(2,i++)+\"\";\\n        }\\n        return false;\\n    }  \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        String s=n+\"\";\\n        int[] a = new int[10];   // frequency of digits in number s, s=n\\n        for(int i=0;i<s.length();i++)\\n            a[s.charAt(i)-\\'0\\']++;\\n\\n        int i=1;\\n        String t = \"1\";   //Math.pow(2,0) =1\\n        while(s.length()>=t.length())\\n        {\\n            if(s.length()==t.length()){\\n            int[] b = new int[10];     // frequency of digits in number t, where t = Math.pow(2,i)\\n                \\n            for(int j=0;j<t.length();j++)\\n                b[t.charAt(j)-\\'0\\']++;\\n                \\n            if(Arrays.equals(a,b))   //Checking whether String s is Anagram of String t\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2481394,
                "title": "c-stirng-solution",
                "content": "```\\n    bool reorderedPowerOf2(int n) {\\n        int i=0;\\n        string s1=to_string(n);\\n        sort(s1.begin(),s1.end());\\n        while(true)\\n        {\\n            int temp = pow(2,i);\\n            int digits= floor(log10(temp) + 1);\\n            int n_digits= floor(log10(n)+1);\\n            if(digits==n_digits)\\n            {\\n                string s=to_string(temp);\\n                sort(s.begin(),s.end());\\n                if(s.compare(s1)==0){\\n                    // cout<<s<<\" \"<<s1<<endl;\\n                    return true;\\n                }\\n            }\\n            if(digits>n_digits)\\n                return false;\\n            i++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\n    bool reorderedPowerOf2(int n) {\\n        int i=0;\\n        string s1=to_string(n);\\n        sort(s1.begin(),s1.end());\\n        while(true)\\n        {\\n            int temp = pow(2,i);\\n            int digits= floor(log10(temp) + 1);\\n            int n_digits= floor(log10(n)+1);\\n            if(digits==n_digits)\\n            {\\n                string s=to_string(temp);\\n                sort(s.begin(),s.end());\\n                if(s.compare(s1)==0){\\n                    // cout<<s<<\" \"<<s1<<endl;\\n                    return true;\\n                }\\n            }\\n            if(digits>n_digits)\\n                return false;\\n            i++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2481356,
                "title": "simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> func(int n){\\n        vector<int>ans(10);\\n        \\n        while(n){\\n            ans[n%10]++;\\n            n/=10;\\n        }\\n        \\n        return ans;\\n    }   \\n    \\n    bool reorderedPowerOf2(int n) {\\n                \\n        if((n&(n-1))==0)return true;\\n        \\n        vector<int>ans=func(n);\\n        \\n        for(int i=1;i<31;i++){\\n            vector<int>v=func(1<<i);\\n            if(v==ans)return true;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> func(int n){\\n        vector<int>ans(10);\\n        \\n        while(n){\\n            ans[n%10]++;\\n            n/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2481355,
                "title": "c-easy-string-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        long long x = 1;\\n        vector<string> arr;\\n        while(x <= 1000000000){\\n            arr.push_back(to_string(x)); // store all the power of 2s less than 1e9 in a vector\\n            x *= 2;\\n        }\\n        for(auto &i : arr){\\n            sort(i.begin(), i.end()); // sort each power of 2 \\n        }\\n        string s = to_string(n);\\n        sort(s.begin(), s.end()); // sort given number\\n        for(auto i : arr){\\n            if(i == s) // if our number matches with any of the number which is of power two, then we can re-arrange our number.\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        long long x = 1;\\n        vector<string> arr;\\n        while(x <= 1000000000){\\n            arr.push_back(to_string(x)); // store all the power of 2s less than 1e9 in a vector\\n            x *= 2;\\n        }\\n        for(auto &i : arr){\\n            sort(i.begin(), i.end()); // sort each power of 2 \\n        }\\n        string s = to_string(n);\\n        sort(s.begin(), s.end()); // sort given number\\n        for(auto i : arr){\\n            if(i == s) // if our number matches with any of the number which is of power two, then we can re-arrange our number.\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481253,
                "title": "javascript-easy-understanding-with-explanation",
                "content": "Instead of shuffling we can sort the the input value and do the comparison of sorted values of pow of i \\nPlease upvote the solution \\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar reorderedPowerOf2 = function(n) {\\n// If the value is 1 return true\\n    if(n===1) return true;\\n    let total = 1;\\n    let i = 1;\\n\\t// coverting the given number and sorted that with any order(ASC/DESC) \\n    let nTemp = n.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t// If the length of the string is more than the given one means we can break the loop and return false \\n    while(total.toString().length<=n.toString().length){\\n        total = Math.pow(2,i);\\n        let tTemp = total.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t\\t// Comparing the pow of 2 and the given number\\n        if(tTemp===nTemp) return true;\\n        i++;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar reorderedPowerOf2 = function(n) {\\n// If the value is 1 return true\\n    if(n===1) return true;\\n    let total = 1;\\n    let i = 1;\\n\\t// coverting the given number and sorted that with any order(ASC/DESC) \\n    let nTemp = n.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t// If the length of the string is more than the given one means we can break the loop and return false \\n    while(total.toString().length<=n.toString().length){\\n        total = Math.pow(2,i);\\n        let tTemp = total.toString().split(\\'\\').sort((a,b)=>a-b).join(\\'\\');\\n\\t\\t// Comparing the pow of 2 and the given number\\n        if(tTemp===nTemp) return true;\\n        i++;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481233,
                "title": "daily-leetcode-solution-time-complexity-log-n-space-complexity-log-n",
                "content": "![image](https://assets.leetcode.com/users/images/6b668789-1528-4080-9ea3-37b97cff6585_1661483519.3508134.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/6b668789-1528-4080-9ea3-37b97cff6585_1661483519.3508134.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2481227,
                "title": "very-easy-to-understand-implementation-with-80-runtime",
                "content": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        list_of_powers_of_2=[]\\n        for i in range(31):\\n            list_of_powers_of_2.append(\\'\\'.join(sorted(str(1<<i))))   ## storing powers of 2 as sorted string to help checking reorder of number given matches or not. \\n        return \\'\\'.join(sorted(str(n))) in list_of_powers_of_2 \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        list_of_powers_of_2=[]\\n        for i in range(31):\\n            list_of_powers_of_2.append(\\'\\'.join(sorted(str(1<<i))))   ## storing powers of 2 as sorted string to help checking reorder of number given matches or not. \\n        return \\'\\'.join(sorted(str(n))) in list_of_powers_of_2 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481143,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n == 1) return true;\\n        unordered_map<int, int> map;\\n        \\n        string temp = to_string(n);\\n        for(int i = 0; i < temp.size(); i++){\\n            map[int(temp[i])-48]++;\\n        }  \\n        \\n        int digits = temp.size();\\n        return helper(map, 1, n, digits);\\n    }\\n    \\n    bool helper(unordered_map<int, int> map, long k, int s, int digits){\\n        if(k > pow(10, digits) - 1) return false;\\n        if(k == s) return true;\\n        \\n        unordered_map<int, int> copy = map;\\n        \\n        string temp = to_string(k);\\n        for(int i = 0; i < temp.size(); i++){\\n            copy[int(temp[i])-48]--;\\n        }\\n        \\n        for(auto &it: copy){\\n            if(it.second != 0) return helper(map, k*2, s, digits);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n == 1) return true;\\n        unordered_map<int, int> map;\\n        \\n        string temp = to_string(n);\\n        for(int i = 0; i < temp.size(); i++){\\n            map[int(temp[i])-48]++;\\n        }  \\n        \\n        int digits = temp.size();\\n        return helper(map, 1, n, digits);\\n    }\\n    \\n    bool helper(unordered_map<int, int> map, long k, int s, int digits){\\n        if(k > pow(10, digits) - 1) return false;\\n        if(k == s) return true;\\n        \\n        unordered_map<int, int> copy = map;\\n        \\n        string temp = to_string(k);\\n        for(int i = 0; i < temp.size(); i++){\\n            copy[int(temp[i])-48]--;\\n        }\\n        \\n        for(auto &it: copy){\\n            if(it.second != 0) return helper(map, k*2, s, digits);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481027,
                "title": "swift-simple-solution",
                "content": "```\\nclass Solution {\\n\\tfunc reorderedPowerOf2(_ n: Int) -> Bool {\\n\\t\\tvar pool = Set<[Character]>()\\n\\t\\tvar i = 1\\n\\t\\twhile i <= 1000000000 {\\n\\t\\t\\tpool.insert(String(i).sorted())\\n\\t\\t\\ti *= 2\\n\\t\\t}\\n\\t\\treturn pool.contains(String(n).sorted())\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc reorderedPowerOf2(_ n: Int) -> Bool {\\n\\t\\tvar pool = Set<[Character]>()\\n\\t\\tvar i = 1\\n\\t\\twhile i <= 1000000000 {\\n\\t\\t\\tpool.insert(String(i).sorted())\\n\\t\\t\\ti *= 2\\n\\t\\t}\\n\\t\\treturn pool.contains(String(n).sorted())\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480924,
                "title": "c-clean-code-hashmap",
                "content": "**Code** : \\n```\\nclass Solution {\\npublic:\\n    vector<int> countdig(int N){\\n        vector<int>digitsInN(10);\\n        while(N)\\n            digitsInN[N % 10]++, N /= 10;\\n        return digitsInN;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digitsInN = countdig(N); \\n        for(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n            if(digitsInN == countdig(powOf2)) return true;  \\n        return false;\\n    }\\n};\\n```\\nTime Complexity : **O(logN)**\\nSpace Complexity : **O(1)**\\n\\nHope this helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countdig(int N){\\n        vector<int>digitsInN(10);\\n        while(N)\\n            digitsInN[N % 10]++, N /= 10;\\n        return digitsInN;\\n    }\\n    bool reorderedPowerOf2(int N) {\\n        vector<int> digitsInN = countdig(N); \\n        for(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n            if(digitsInN == countdig(powOf2)) return true;  \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480910,
                "title": "python-precompute-all-power2-and-add-to-set-30ms-beats-100",
                "content": "\\n\\nIdea: \\n- precalculate all power 2 numbers and add them as sorted strings into a set\\n- check if `sorted(str(n))` is in the set\\n\\n```python\\nclass Solution(object):\\n    def __init__(self):\\n        self.s = {\"1\"}\\n        K = 1\\n        while K <= 10** 9:\\n            K <<= 1\\n            self.s.add(\"\".join(sorted(str(K))))\\n            \\n    def reorderedPowerOf2(self, N):\\n        return \"\".join(sorted(str(N))) in self.s\\n```\\n\\nTime: `O(1)` or `O(KlogK)` where `max(K) = 9`\\nSpace: `O(1)` or 32 strings with max length of 9\\n\\n![image](https://assets.leetcode.com/users/images/0fed2e3c-313f-494e-aa12-4d5aa02d1ff6_1661473604.5191245.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution(object):\\n    def __init__(self):\\n        self.s = {\"1\"}\\n        K = 1\\n        while K <= 10** 9:\\n            K <<= 1\\n            self.s.add(\"\".join(sorted(str(K))))\\n            \\n    def reorderedPowerOf2(self, N):\\n        return \"\".join(sorted(str(N))) in self.s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178138,
                "title": "greate-solution",
                "content": "class Solution {\\npublic:\\n   bool reorderedPowerOf2(int n)\\n{\\n\\n    string num = to_string(n);\\n    int ans = 1;\\n    string ansnum = to_string(ans);\\n    while (ansnum.size() != num.size())\\n    {\\n        ans = ans * 2;\\n        ansnum = to_string(ans);\\n    }\\n\\n    unordered_map<char, int> mp;\\n    for (int i = 0; i < num.size(); i++)\\n    {\\n        mp[num[i]]++;\\n    }\\n\\n    while (ansnum.size() == num.size())\\n    {\\n        unordered_map<char, int> mp1;\\n        for (int i = 0; i < ansnum.size(); i++)\\n        {\\n            mp1[ansnum[i]]++;\\n        }\\n\\n        if (mp == mp1)\\n            return 1;\\n        ans = ans * 2;\\n        ansnum = to_string(ans);\\n\\n    }\\n    return 0;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   bool reorderedPowerOf2(int n)\\n{\\n\\n    string num = to_string(n);\\n    int ans = 1;\\n    string ansnum = to_string(ans);\\n    while (ansnum.size() != num.size())\\n    {\\n        ans = ans * 2;\\n        ansnum = to_string(ans);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1825803,
                "title": "javascript-869-reordered-power-of-2",
                "content": "---\\n\\n- Used known powers of 2, as question is a different test\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar reorderedPowerOf2 = function (n) {\\n    let p2 = [\\n        1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,\\n\\t\\t16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, /* , 2147483648, 4294967296, 8589934592, */\\n    ];\\n\\n    let ns = (\"\" + n).split(\"\").sort().join(\"\");\\n\\n    OUTER:\\n\\tfor (let p of p2) {\\n        let ps = (\"\" + p).split(\"\").sort().join(\"\");\\n        if (ps.length > ns.length) return false;\\n        if (ps === ns) return true;\\n    }\\n\\n    return false;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reorderedPowerOf2 = function (n) {\\n    let p2 = [\\n        1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,\\n\\t\\t16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, /* , 2147483648, 4294967296, 8589934592, */\\n    ];\\n\\n    let ns = (\"\" + n).split(\"\").sort().join(\"\");\\n\\n    OUTER:\\n\\tfor (let p of p2) {\\n        let ps = (\"\" + p).split(\"\").sort().join(\"\");\\n        if (ps.length > ns.length) return false;\\n        if (ps === ns) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1606443,
                "title": "c-0-ms-faster-than-100-solution-by-sorting-string",
                "content": "- Sort the digits of n and the numbers of form 2^i in the same order, then check if n is the same as the number of forms 2^i \\n- example: \\nn = 2401 -> 0124 \\n2^10 = 1024 -> 0124 \\n=> true\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int a=pow(2,i);\\n            power.push_back(to_string(a));\\n        }\\n        for(int i=0;i<=30;i++){\\n            sort(power[i].begin(),power[i].end());\\n        }\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n\\n        for(int i=0;i<=30;i++){\\n            if(s==power[i]){return true;}\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<string> power;\\n        for(int i=0;i<=30;i++){\\n            int a=pow(2,i);\\n            power.push_back(to_string(a));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1313945,
                "title": "c-solution",
                "content": "```\\n\\n```public:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        long long int i,x;\\n        sort(s.begin(),s.end());\\n        for(i=0;i<=30;i++)\\n        {\\n            x=pow(2,i);\\n            string s1=to_string(x);\\n            sort(s1.begin(),s1.end());\\n            if(s==s1)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121817,
                "title": "rust-fastest-solution-using-64-bit-number-as-counter-array",
                "content": "```rust\\nuse std::iter::successors;\\n\\nlazy_static! {\\n    static ref POWS: Vec<u64> = (0..30).map(|x| 1 << x).map(digit_map).collect();\\n}\\npub fn reordered_power_of2(n: i32) -> bool {\\n    POWS.contains(&digit_map(n))\\n}\\n\\nfn digit_map(n: i32) -> u64 {\\n    successors(Some(n), |&x| Some(x / 10))\\n        .take_while(|&x| x > 0)\\n        .map(|x| x % 10)\\n        .fold(0, |m, c| {\\n            let mask = 0b1111 << 4 * c;\\n            let count = ((m & mask) >> 4 * c) + 1;\\n            m & (!0 ^ mask) | (count << 4 * c)\\n        })\\n}\\n```\\n\\nthe only tricky part here is `digit_map` function, we use 64-bit number as array of 4-bit numbers. Bits from `4*i` to `4*i + 3` store count of  digit `i`\\n step-by step\\n```\\n    successors(Some(n), |&x| Some(x / 10))          // descending iterator of n / 10^i\\n        .take_while(|&x| x > 0)                     // stop when the number is zero\\n        .map(|x| x % 10)                            // take next digit\\n        .fold(0, |m, d| {                           // m - is current digit bitcounter, d is next digit\\n            let mask = 0b1111 << 4 * d;             // make a mask filtering bits from `4*i` to `4*i + 3`\\n            let count = ((m & mask) >> 4 * d) + 1;  // get and increment current value under the mask\\n            m & (!0 ^ mask) | (count << 4 * d)      // assign number under the mask for the next iteration\\n        });",
                "solutionTags": [],
                "code": "```rust\\nuse std::iter::successors;\\n\\nlazy_static! {\\n    static ref POWS: Vec<u64> = (0..30).map(|x| 1 << x).map(digit_map).collect();\\n}\\npub fn reordered_power_of2(n: i32) -> bool {\\n    POWS.contains(&digit_map(n))\\n}\\n\\nfn digit_map(n: i32) -> u64 {\\n    successors(Some(n), |&x| Some(x / 10))\\n        .take_while(|&x| x > 0)\\n        .map(|x| x % 10)\\n        .fold(0, |m, c| {\\n            let mask = 0b1111 << 4 * c;\\n            let count = ((m & mask) >> 4 * c) + 1;\\n            m & (!0 ^ mask) | (count << 4 * c)\\n        })\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120777,
                "title": "heavily-commented-javascript-solution-hash-maps-no-sort",
                "content": "My first thought was going towards generating all posibilities of orders of N\\'s numbers and check if it\\'s a pow by math.\\nThen I was thinking, we only have to check even numbers\\n\\nBut then I took a look at all the numbers that are  power of 2 under 10^9\\nThere are only 29 numbers there, as 2^30 is already over 10^9: 1,073,741,824\\n\\nSo if we generate those pows, or at least up to the N.length + 1\\nWe can then check the numbers that have the same length by a frequency map\\nIf the frequency map of N and one of the target powers is the same, we have a match.\\n\\nFor example: 1234\\nAll the powers of 2 of length 4 (it always has to be the same length as N of course) are:\\n[ 1024, 2048, 4096, 8192 ]\\n\\nThe frequency map of 1234 is:\\n{ \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\nVersus one of the powers of 2:\\n{ \\'1\\': 1, \\'0\\': 1, \\'2\\': 1, \\'4\\': 1 };\\n\\twill not match.\\n\\nBut if we had 1204 as N then we have a freq map of: { \\'1\\': 1, \\'2\\': 1, \\'0\\': 1, \\'4\\': 1 };\\nThough not in the same order as the freq map of 1024, a simple for loop will match them.\\n\\n-- Coding --\\n\\nThat works great with sample input, I think one optimization could be in the poweredNumbers \\ngenerator. I am generating all the pows of lower digit count too. Maybe with some math\\nand binary search I could make that better, but I don\\'t think it\\'s worth the effort.        \\n        \\n\\n\\n\\t/**\\n\\t * @param {number} N\\n\\t * @return {boolean}\\n\\t */\\n\\tvar reorderedPowerOf2 = function(N) {\\n\\n\\n\\t\\tvar maxPowerLength = 0, // I got this variable of a hair blower\\n\\t\\t\\tsN = String(N),\\n\\t\\t\\tnLength = sN.length, // how many numbers are in N total\\n\\t\\t\\tpoweredNumbers = [], // this will hold the numbers we should check N against\\n\\t\\t\\ti = 0,\\n\\t\\t\\tnFreq = {}; // we\\'ll use this in part 2, to check which numbers we need to find\\n\\n\\t\\t// Generate the powers\\n\\t\\twhile (maxPowerLength <= nLength) {\\n\\t\\t\\tlet pow = Math.pow(2, i);\\n\\n\\t\\t\\tmaxPowerLength = String(pow).length;\\n\\n\\t\\t\\t// We\\'re only interested in numbers of the same length, of course\\n\\t\\t\\tif (maxPowerLength === nLength) {\\n\\t\\t\\t\\tpoweredNumbers.push(pow);\\n\\t\\t\\t}\\n\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\t// at this point, for a N like 1234, we\\'ll have poweredNumbers [ 1024, 2048, 4096, 8192 ]\\n\\t\\t// console.log(\\'poweredNumbers\\', poweredNumbers);\\n\\n\\t\\t// now we need to see if all the numbers in N can be check off of one of those\\n\\t\\tnFreq = getFreqMap(sN);\\n\\n\\t\\t// at this point we have nFreq: { \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\t\\t// console.log(\\'nFreq\\', nFreq);\\n\\n\\t\\t// Create a map for the target numbers and see if there is a match\\n\\t\\tfor (var target of poweredNumbers) {\\n\\t\\t\\tlet fm2 = getFreqMap(String(target));\\n\\n\\t\\t\\tif (isFreqMapEqual(nFreq, fm2)) {\\n\\t\\t\\t\\t// we have a match!\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// by reaching this point we\\'ve proven there is no match possible\\n\\t\\treturn false;\\n\\t};\\n\\n\\t/**\\n\\t * Helper function: Create frequency map of a string\\n\\t * @param {string} s\\n\\t * @return {object}\\n\\t */\\n\\tvar getFreqMap = function (s) {\\n\\t\\tvar map = {},\\n\\t\\t\\tl = s.length;\\n\\n\\t\\tfor (i = 0; i < l; i++) {\\n\\t\\t\\tif (!map[s[i]]) {\\n\\t\\t\\t\\tmap[s[i]] = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap[s[i]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn map;\\n\\t}\\n\\n\\t/**\\n\\t * Helper function:  Check if 2 frequency maps hold the same values.\\n\\t *  Assumes the maps are of the same length total\\n\\t * @param {object} fm1 frequency map\\n\\t * @param {object} fm2 frequence map\\n\\t * @return {boolean}\\n\\t */\\n\\tvar isFreqMapEqual = function(fm1, fm2) {\\n\\n\\t\\tfor (var entry in fm1) {\\n\\t\\t\\tif (fm1[entry] !== fm2[entry]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "My first thought was going towards generating all posibilities of orders of N\\'s numbers and check if it\\'s a pow by math.\\nThen I was thinking, we only have to check even numbers\\n\\nBut then I took a look at all the numbers that are  power of 2 under 10^9\\nThere are only 29 numbers there, as 2^30 is already over 10^9: 1,073,741,824\\n\\nSo if we generate those pows, or at least up to the N.length + 1\\nWe can then check the numbers that have the same length by a frequency map\\nIf the frequency map of N and one of the target powers is the same, we have a match.\\n\\nFor example: 1234\\nAll the powers of 2 of length 4 (it always has to be the same length as N of course) are:\\n[ 1024, 2048, 4096, 8192 ]\\n\\nThe frequency map of 1234 is:\\n{ \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\nVersus one of the powers of 2:\\n{ \\'1\\': 1, \\'0\\': 1, \\'2\\': 1, \\'4\\': 1 };\\n\\twill not match.\\n\\nBut if we had 1204 as N then we have a freq map of: { \\'1\\': 1, \\'2\\': 1, \\'0\\': 1, \\'4\\': 1 };\\nThough not in the same order as the freq map of 1024, a simple for loop will match them.\\n\\n-- Coding --\\n\\nThat works great with sample input, I think one optimization could be in the poweredNumbers \\ngenerator. I am generating all the pows of lower digit count too. Maybe with some math\\nand binary search I could make that better, but I don\\'t think it\\'s worth the effort.        \\n        \\n\\n\\n\\t/**\\n\\t * @param {number} N\\n\\t * @return {boolean}\\n\\t */\\n\\tvar reorderedPowerOf2 = function(N) {\\n\\n\\n\\t\\tvar maxPowerLength = 0, // I got this variable of a hair blower\\n\\t\\t\\tsN = String(N),\\n\\t\\t\\tnLength = sN.length, // how many numbers are in N total\\n\\t\\t\\tpoweredNumbers = [], // this will hold the numbers we should check N against\\n\\t\\t\\ti = 0,\\n\\t\\t\\tnFreq = {}; // we\\'ll use this in part 2, to check which numbers we need to find\\n\\n\\t\\t// Generate the powers\\n\\t\\twhile (maxPowerLength <= nLength) {\\n\\t\\t\\tlet pow = Math.pow(2, i);\\n\\n\\t\\t\\tmaxPowerLength = String(pow).length;\\n\\n\\t\\t\\t// We\\'re only interested in numbers of the same length, of course\\n\\t\\t\\tif (maxPowerLength === nLength) {\\n\\t\\t\\t\\tpoweredNumbers.push(pow);\\n\\t\\t\\t}\\n\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\t// at this point, for a N like 1234, we\\'ll have poweredNumbers [ 1024, 2048, 4096, 8192 ]\\n\\t\\t// console.log(\\'poweredNumbers\\', poweredNumbers);\\n\\n\\t\\t// now we need to see if all the numbers in N can be check off of one of those\\n\\t\\tnFreq = getFreqMap(sN);\\n\\n\\t\\t// at this point we have nFreq: { \\'1\\': 1, \\'2\\': 1, \\'3\\': 1, \\'4\\': 1 };\\n\\t\\t// console.log(\\'nFreq\\', nFreq);\\n\\n\\t\\t// Create a map for the target numbers and see if there is a match\\n\\t\\tfor (var target of poweredNumbers) {\\n\\t\\t\\tlet fm2 = getFreqMap(String(target));\\n\\n\\t\\t\\tif (isFreqMapEqual(nFreq, fm2)) {\\n\\t\\t\\t\\t// we have a match!\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// by reaching this point we\\'ve proven there is no match possible\\n\\t\\treturn false;\\n\\t};\\n\\n\\t/**\\n\\t * Helper function: Create frequency map of a string\\n\\t * @param {string} s\\n\\t * @return {object}\\n\\t */\\n\\tvar getFreqMap = function (s) {\\n\\t\\tvar map = {},\\n\\t\\t\\tl = s.length;\\n\\n\\t\\tfor (i = 0; i < l; i++) {\\n\\t\\t\\tif (!map[s[i]]) {\\n\\t\\t\\t\\tmap[s[i]] = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap[s[i]]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn map;\\n\\t}\\n\\n\\t/**\\n\\t * Helper function:  Check if 2 frequency maps hold the same values.\\n\\t *  Assumes the maps are of the same length total\\n\\t * @param {object} fm1 frequency map\\n\\t * @param {object} fm2 frequence map\\n\\t * @return {boolean}\\n\\t */\\n\\tvar isFreqMapEqual = function(fm1, fm2) {\\n\\n\\t\\tfor (var entry in fm1) {\\n\\t\\t\\tif (fm1[entry] !== fm2[entry]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1120141,
                "title": "c-cool-super-short-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) \\n    {\\n        static const set<string> pows {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\", \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\", \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\", \"0112344778\"};\\n        \\n        string str = to_string(N);\\n        sort(str.begin(), str.end());\\n        \\n        return pows.find(str) != pows.end();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) \\n    {\\n        static const set<string> pows {\"1\", \"2\", \"4\", \"8\", \"16\", \"23\", \"46\", \"128\", \"256\", \"125\", \"0124\", \"0248\", \"0469\", \"1289\", \"13468\", \"23678\", \"35566\", \"011237\", \"122446\", \"224588\", \"0145678\", \"0122579\", \"0134449\", \"0368888\", \"11266777\", \"23334455\", \"01466788\", \"112234778\", \"234455668\", \"012356789\", \"0112344778\"};\\n        \\n        string str = to_string(N);\\n        sort(str.begin(), str.end());\\n        \\n        return pows.find(str) != pows.end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120090,
                "title": "java-count-occurance-of-digits",
                "content": "From the problem description it is clear that we need to check whether N is a permutation of a power of 2. The approach is the following:\\n\\nIn the first step, we count the occurance of each digit (0-9) in N\\n\\nIn the second step, we go through each power of 2 (say, x). For each x, we do the following:\\n1. Count the occurance of each digit in x\\n2. We compare the occurance of digits in x with that of N. If we find a match, we return true.\\n3. If we don\\'t find a match for any x, we return false.\\n\\nFor example, for N = 83461, the counts will match for x = 16384 and thus we will return true. For, N = 10000, the counts will not match for any x, so we will return false.\\n\\n```\\n\\tpublic boolean reorderedPowerOf2(int N) {\\n        int[] dcountN = getDigitCount(N);\\n        \\n        for(int i = 0; i < 31; i++){\\n            int x = 1 << i, j;\\n            int[] dcountX = getDigitCount(x);\\n            \\n            for(j = 0; j < 10 && dcountN[j] == dcountX[j]; j++);\\n\\t\\t\\t/*if j becomes 10 after above loop, it means the counts\\n\\t\\t\\t  of the digits are the same in x and N*/\\n            if(j == 10) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int[] getDigitCount(int x){\\n        int[] result = new int[10];\\n        while(x > 0){\\n            result[x % 10]++;\\n            x /= 10;\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "From the problem description it is clear that we need to check whether N is a permutation of a power of 2. The approach is the following:\\n\\nIn the first step, we count the occurance of each digit (0-9) in N\\n\\nIn the second step, we go through each power of 2 (say, x). For each x, we do the following:\\n1. Count the occurance of each digit in x\\n2. We compare the occurance of digits in x with that of N. If we find a match, we return true.\\n3. If we don\\'t find a match for any x, we return false.\\n\\nFor example, for N = 83461, the counts will match for x = 16384 and thus we will return true. For, N = 10000, the counts will not match for any x, so we will return false.\\n\\n```\\n\\tpublic boolean reorderedPowerOf2(int N) {\\n        int[] dcountN = getDigitCount(N);\\n        \\n        for(int i = 0; i < 31; i++){\\n            int x = 1 << i, j;\\n            int[] dcountX = getDigitCount(x);\\n            \\n            for(j = 0; j < 10 && dcountN[j] == dcountX[j]; j++);\\n\\t\\t\\t/*if j becomes 10 after above loop, it means the counts\\n\\t\\t\\t  of the digits are the same in x and N*/\\n            if(j == 10) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int[] getDigitCount(int x){\\n        int[] result = new int[10];\\n        while(x > 0){\\n            result[x % 10]++;\\n            x /= 10;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1120038,
                "title": "python-o64-o1-hashmap-solution",
                "content": "```\\nclass Solution:\\n    def helper(self,num):\\n        char_arr = str(num)\\n        table = dict()\\n        for char in char_arr:\\n            if char not in table:\\n                table[char] = 1\\n            else:\\n                table[char] += 1\\n        return table\\n            \\n            \\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        num_tab = self.helper(N)\\n        i = 0\\n        while i < 64:\\n            if num_tab == self.helper(pow(2,i)):\\n                return True\\n            else:\\n                i += 1\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self,num):\\n        char_arr = str(num)\\n        table = dict()\\n        for char in char_arr:\\n            if char not in table:\\n                table[char] = 1\\n            else:\\n                table[char] += 1\\n        return table\\n            \\n            \\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        num_tab = self.helper(N)\\n        i = 0\\n        while i < 64:\\n            if num_tab == self.helper(pow(2,i)):\\n                return True\\n            else:\\n                i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104832,
                "title": "c-beats-100-simple-approach",
                "content": "Powers of 2 will increase really rapidly, hence we can utilize that. \\n\\n// 1\\n// 2\\n// 4\\n// 8\\n// 16\\n// 32\\n// 64\\n// 128\\n// 256\\n// 512\\n// 1024\\n// 2048\\n// 4096\\n// 8192\\n// 16384\\n// 32768\\n// 65536\\n// 131072\\n// 262144\\n// 524288\\n\\nJust collect the numbers having same number of digits and a match accordingly. \\n\\n```\\nclass Solution {\\npublic:\\n\\t#define d(x) cout<<#x<<\" \"<<x<<endl; \\n    bool check(int a,int b)\\n    {\\n\\t\\t// Can use a map too.\\n        vector<int> ar(10,0);\\n        while(a)\\n        {\\n            ar[a%10]++;\\n            a/=10;\\n        }\\n        while(b)\\n        {\\n            ar[b%10]--;\\n            b/=10;\\n        }\\n        for(int i:ar)\\n        {\\n            if(i!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n  \\n    bool reorderedPowerOf2(int N) {\\n        vector<int> ar;\\n        int sum = 1;\\n\\t\\t\\n\\t\\t//Number of Digits of N\\n        int digitN = floor(log10(N)) + 1;\\n\\t\\t\\n\\t\\t// Important Consideration we need to go to the last value in that range and not till N, \\n\\t\\t// Eg: for 125 we should go till 512 so let\\'s better go till 999.\\n        int X = pow(10,digitN)-1;\\n\\t\\t\\n        while(sum<X)\\n        {\\n            int digit = floor(log10(sum)) + 1;\\n            if(digit == digitN)\\n                ar.push_back(sum);\\n            sum=sum*2;\\n            // d(digit);\\n            // d(sum);\\n        }\\n        for(int i:ar)\\n        {\\n            // cout<<i;\\n            if(check(i,N))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t#define d(x) cout<<#x<<\" \"<<x<<endl; \\n    bool check(int a,int b)\\n    {\\n\\t\\t// Can use a map too.\\n        vector<int> ar(10,0);\\n        while(a)\\n        {\\n            ar[a%10]++;\\n            a/=10;\\n        }\\n        while(b)\\n        {\\n            ar[b%10]--;\\n            b/=10;\\n        }\\n        for(int i:ar)\\n        {\\n            if(i!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n  \\n    bool reorderedPowerOf2(int N) {\\n        vector<int> ar;\\n        int sum = 1;\\n\\t\\t\\n\\t\\t//Number of Digits of N\\n        int digitN = floor(log10(N)) + 1;\\n\\t\\t\\n\\t\\t// Important Consideration we need to go to the last value in that range and not till N, \\n\\t\\t// Eg: for 125 we should go till 512 so let\\'s better go till 999.\\n        int X = pow(10,digitN)-1;\\n\\t\\t\\n        while(sum<X)\\n        {\\n            int digit = floor(log10(sum)) + 1;\\n            if(digit == digitN)\\n                ar.push_back(sum);\\n            sum=sum*2;\\n            // d(digit);\\n            // d(sum);\\n        }\\n        for(int i:ar)\\n        {\\n            // cout<<i;\\n            if(check(i,N))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 970128,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        [\\n            [1, 1, 1, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 0, 1, 1, 0, 0, 1, 1, 1, 0],\\n            [0, 0, 0, 1, 0, 2, 2, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 0, 1, 0, 1, 0, 0, 0, 1, 0],\\n            [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],\\n            [0, 1, 2, 0, 2, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 1, 1, 0, 0, 0],\\n            [1, 1, 0, 0, 1, 0, 2, 1, 2, 0],\\n            [1, 1, 0, 0, 1, 1, 1, 1, 1, 0],\\n            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],\\n            [1, 0, 0, 1, 0, 0, 1, 0, 4, 0],\\n            [0, 2, 1, 0, 0, 0, 2, 3, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 3, 2, 2, 0, 0, 0, 0],\\n            [1, 1, 1, 1, 0, 1, 1, 1, 1, 1],\\n            [1, 2, 1, 1, 0, 0, 0, 1, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 1],\\n            [0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\\n            [1, 1, 2, 0, 0, 1, 0, 1, 0, 1],\\n            [0, 2, 2, 1, 1, 0, 0, 2, 1, 0],\\n            [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],\\n            [0, 0, 2, 0, 1, 1, 0, 0, 2, 0],\\n            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 1, 0, 1, 3, 0, 0, 0, 0, 1],\\n            [0, 0, 1, 1, 2, 2, 2, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 1, 0, 0, 0, 0],\\n            [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 0],\\n        ]\\n        .iter()\\n        .cloned()\\n        .collect::<HashSet<[i32; 10]>>()\\n        .contains(\\n            &n.to_string().chars().map(|c| c.to_digit(10).unwrap()).fold(\\n                [0; 10],\\n                |mut acc, cur| {\\n                    acc[cur as usize] += 1;\\n                    acc\\n                },\\n            ),\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn reordered_power_of2(n: i32) -> bool {\\n        [\\n            [1, 1, 1, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 0, 1, 1, 0, 0, 1, 1, 1, 0],\\n            [0, 0, 0, 1, 0, 2, 2, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 0, 1, 0, 1, 0, 0, 0, 1, 0],\\n            [1, 0, 0, 0, 1, 0, 1, 0, 0, 1],\\n            [0, 1, 2, 0, 2, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 0, 0, 1, 1, 0, 0, 0],\\n            [1, 1, 0, 0, 1, 0, 2, 1, 2, 0],\\n            [1, 1, 0, 0, 1, 1, 1, 1, 1, 0],\\n            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],\\n            [1, 0, 0, 1, 0, 0, 1, 0, 4, 0],\\n            [0, 2, 1, 0, 0, 0, 2, 3, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\\n            [0, 0, 1, 3, 2, 2, 0, 0, 0, 0],\\n            [1, 1, 1, 1, 0, 1, 1, 1, 1, 1],\\n            [1, 2, 1, 1, 0, 0, 0, 1, 0, 0],\\n            [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 1],\\n            [0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\\n            [1, 1, 2, 0, 0, 1, 0, 1, 0, 1],\\n            [0, 2, 2, 1, 1, 0, 0, 2, 1, 0],\\n            [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],\\n            [0, 0, 2, 0, 1, 1, 0, 0, 2, 0],\\n            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\\n            [1, 1, 0, 1, 3, 0, 0, 0, 0, 1],\\n            [0, 0, 1, 1, 2, 2, 2, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 1, 0, 0, 0, 0],\\n            [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\\n            [0, 1, 1, 0, 0, 0, 0, 0, 1, 0],\\n        ]\\n        .iter()\\n        .cloned()\\n        .collect::<HashSet<[i32; 10]>>()\\n        .contains(\\n            &n.to_string().chars().map(|c| c.to_digit(10).unwrap()).fold(\\n                [0; 10],\\n                |mut acc, cur| {\\n                    acc[cur as usize] += 1;\\n                    acc\\n                },\\n            ),\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480331,
                "title": "count-digits-up-to-2-31-1-c-solution",
                "content": "```\\n    bool reorderedPowerOf2(int N) {\\n         for(int i =0;i < 31;i++){\\n            if(cmpr(N,1<<i))\\n                return true;\\n         }\\n        return false;\\n    }\\n    bool cmpr(int i , int j){\\n        vector <int> cnti (10,0);\\n        vector <int> cntj (10,0);\\n        while(i> 0){\\n            cnti[i%10]++;\\n            i -= i%10;\\n            i /= 10;\\n        }\\n        while(j> 0){\\n            cntj[j%10]++;\\n            j -= j%10;\\n            j /= 10;\\n        }\\n        for(int it =0; it < 10; it++){\\n            if(cnti[it] != cntj[it]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool reorderedPowerOf2(int N) {\\n         for(int i =0;i < 31;i++){\\n            if(cmpr(N,1<<i))\\n                return true;\\n         }\\n        return false;\\n    }\\n    bool cmpr(int i , int j){\\n        vector <int> cnti (10,0);\\n        vector <int> cntj (10,0);\\n        while(i> 0){\\n            cnti[i%10]++;\\n            i -= i%10;\\n            i /= 10;\\n        }\\n        while(j> 0){\\n            cntj[j%10]++;\\n            j -= j%10;\\n            j /= 10;\\n        }\\n        for(int it =0; it < 10; it++){\\n            if(cnti[it] != cntj[it]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475150,
                "title": "c",
                "content": "```\\npublic bool ReorderedPowerOf2(int N) {\\n\\tvar pows = new HashSet<string>();\\n\\tfor (var i = 1; 0 < i && i < int.MaxValue; i *= 2)\\n\\t\\tpows.Add(Ordered(i));\\n\\n\\treturn pows.Contains(Ordered(N));\\n\\n\\tstring Ordered(int n) =>\\n\\t\\tnew string(n.ToString().ToCharArray().OrderBy(c => c).ToArray());\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool ReorderedPowerOf2(int N) {\\n\\tvar pows = new HashSet<string>();\\n\\tfor (var i = 1; 0 < i && i < int.MaxValue; i *= 2)\\n\\t\\tpows.Add(Ordered(i));\\n\\n\\treturn pows.Contains(Ordered(N));\\n\\n\\tstring Ordered(int n) =>\\n\\t\\tnew string(n.ToString().ToCharArray().OrderBy(c => c).ToArray());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470212,
                "title": "c-simple-straight-forward-using-sorting-beat-100-100",
                "content": "Just a simple idea using std::string and sorting.\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string sN = to_string(N);\\n        sort(sN.begin(), sN.end());\\n        \\n        for (int i=1; ; i*=2) {\\n            string si = to_string(i);\\n            if (si.length() < sN.length()) continue;\\n            if (si.length() > sN.length()) break;\\n            sort(si.begin(), si.end());\\n            if (si == sN) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string sN = to_string(N);\\n        sort(sN.begin(), sN.end());\\n        \\n        for (int i=1; ; i*=2) {\\n            string si = to_string(i);\\n            if (si.length() < sN.length()) continue;\\n            if (si.length() > sN.length()) break;\\n            sort(si.begin(), si.end());\\n            if (si == sN) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433700,
                "title": "c-o-1-time-o-1-space-with-explanation",
                "content": "If a number `q` can be converted to a target number `N` by re-ordering digits, the histograms of the digits of `q` and `N` must match. For example the histogram of the numbers `1024` => `((0,1),(1,1),(2,1),(3,0),(4,1),(5,0),(6,0),(7,0),(8,0),(9,0))` is the same as the histogram for `2014` => `((0,1),(1,1),(2,1),(3,0),(4,1),(5,0),(6,0),(7,0),(8,0),(9,0))`. The number of integers which are a power of 2 less than `10e9` are `floor(log2(10e9))`. Hence, the solution just checks if the given target `N` has the same histogram as any power of two in the given range.\\n\\n```\\nclass Solution {\\nprivate:\\n    /*\\n        make_hist(): function to make histogram of input number\\n        \\n        params: pp (long int): number to construct histogram\\n        returns: ret (pair<int,vector<int>>): ret.first: number of digits in pp\\n                                              ret.second: histogram of digits in pp\\n    */\\n    pair<int,vector<int>> make_hist(long int pp)\\n    {\\n        int num_digs = 0;\\n        vector<int> dig_count(10, 0);\\n        while(pp)\\n        {\\n            ++num_digs;\\n            ++dig_count[pp%10];\\n            pp /= 10;\\n        }\\n        return make_pair(num_digs, dig_count);\\n    }\\npublic:    \\n    bool reorderedPowerOf2(int N) \\n    {\\n        // make histogram of target N\\n        auto tg_hist = make_hist(N);\\n        \\n        // start querying from lowest power of 2\\n        long int q = 1;\\n        while(q <= 10e9) // upper limit given in the question\\n        {\\n            // make histogram of power of 2\\n            auto q_hist = make_hist(q);\\n            q <<= 1; // increment q to next power\\n            \\n            // if number of digits in query > number of digits in target\\n            // break -- since answer cannot have different number of digits\\n            if(q_hist.first > tg_hist.first) break;\\n            \\n            // if number of digits in query < than number of digits in target\\n            // move on to next query\\n            if(q_hist.first < tg_hist.first) continue;\\n            \\n            // now it is ensured query and target have same number of digits\\n            \\n            // compare histograms of target and query\\n            int i = 0;\\n            for(; i < 10; ++i)\\n            {\\n                if(tg_hist.second[i] != q_hist.second[i]) break;\\n            }\\n            \\n            // if match found\\n            if(i == 10) return true;\\n        }\\n        // no match found\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    /*\\n        make_hist(): function to make histogram of input number\\n        \\n        params: pp (long int): number to construct histogram\\n        returns: ret (pair<int,vector<int>>): ret.first: number of digits in pp\\n                                              ret.second: histogram of digits in pp\\n    */\\n    pair<int,vector<int>> make_hist(long int pp)\\n    {\\n        int num_digs = 0;\\n        vector<int> dig_count(10, 0);\\n        while(pp)\\n        {\\n            ++num_digs;\\n            ++dig_count[pp%10];\\n            pp /= 10;\\n        }\\n        return make_pair(num_digs, dig_count);\\n    }\\npublic:    \\n    bool reorderedPowerOf2(int N) \\n    {\\n        // make histogram of target N\\n        auto tg_hist = make_hist(N);\\n        \\n        // start querying from lowest power of 2\\n        long int q = 1;\\n        while(q <= 10e9) // upper limit given in the question\\n        {\\n            // make histogram of power of 2\\n            auto q_hist = make_hist(q);\\n            q <<= 1; // increment q to next power\\n            \\n            // if number of digits in query > number of digits in target\\n            // break -- since answer cannot have different number of digits\\n            if(q_hist.first > tg_hist.first) break;\\n            \\n            // if number of digits in query < than number of digits in target\\n            // move on to next query\\n            if(q_hist.first < tg_hist.first) continue;\\n            \\n            // now it is ensured query and target have same number of digits\\n            \\n            // compare histograms of target and query\\n            int i = 0;\\n            for(; i < 10; ++i)\\n            {\\n                if(tg_hist.second[i] != q_hist.second[i]) break;\\n            }\\n            \\n            // if match found\\n            if(i == 10) return true;\\n        }\\n        // no match found\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165554,
                "title": "cpp-by-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string> s;\\n    Solution(){\\n        int n = 1;\\n        for(int i = 0; i < 32; i++){\\n            string str = to_string(n);\\n            sort(str.begin(), str.end());\\n            s.insert(str);\\n            n <<= 1;\\n        }\\n    }  \\n    bool reorderedPowerOf2(int N) {\\n        string n = to_string(N);\\n        sort(n.begin(), n.end());\\n        if(s.find(n) == s.end()) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> s;\\n    Solution(){\\n        int n = 1;\\n        for(int i = 0; i < 32; i++){\\n            string str = to_string(n);\\n            sort(str.begin(), str.end());\\n            s.insert(str);\\n            n <<= 1;\\n        }\\n    }  \\n    bool reorderedPowerOf2(int N) {\\n        string n = to_string(N);\\n        sort(n.begin(), n.end());\\n        if(s.find(n) == s.end()) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150509,
                "title": "another-0ms-c-solution-no-special-data-structure",
                "content": "```\\n    int myPow(int a) {              //  returns 10^a;\\n        if(!a) return 1;\\n\\n        int res=1;\\n        while(a--)\\n\\t\\t\\t\\tres *= 10;\\n\\n        return res;\\n    }\\n\\n    int counter(int N, int& c1 ) {\\n        int res = 0;\\n\\n        for (; N; N /= 10) {res += myPow(N%10); c1++;}\\n\\n        return res;\\n    }\\n\\n\\n    bool reorderedPowerOf2(int N) {\\n        if(N<10) {\\n            if(N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n        \\n        int c, cc=0;\\n        c = counter(N, cc);\\n\\n        for (int i = 2*cc, k; i < 3*cc+3; i++)\\n            if (counter(1 << i, k) == c) return true;\\n\\n        return false;\\n    } \\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    int myPow(int a) {              //  returns 10^a;\\n        if(!a) return 1;\\n\\n        int res=1;\\n        while(a--)\\n\\t\\t\\t\\tres *= 10;\\n\\n        return res;\\n    }\\n\\n    int counter(int N, int& c1 ) {\\n        int res = 0;\\n\\n        for (; N; N /= 10) {res += myPow(N%10); c1++;}\\n\\n        return res;\\n    }\\n\\n\\n    bool reorderedPowerOf2(int N) {\\n        if(N<10) {\\n            if(N==1 || N==2 || N==4 || N==8) return true;\\n            return false;\\n        }\\n        \\n        int c, cc=0;\\n        c = counter(N, cc);\\n\\n        for (int i = 2*cc, k; i < 3*cc+3; i++)\\n            if (counter(1 << i, k) == c) return true;\\n\\n        return false;\\n    } \\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702162,
                "title": "explained-easy-cpp-solution",
                "content": "# Approach\\nPut Digits of n in a vector(Suppose G) and then find a power of 2 that has digits as vector G if we find that both have same digits return true else false.\\n\\n# Complexity\\n- Time complexity: 0ms,better than 100% online CPP Solutions\\n\\n- Space complexity: 6.36mb better than 40.61% online CPP Solutions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> g;\\n        while(n)\\n        {\\n            g.push_back(n%10);\\n            n/=10;\\n        }\\n        sort(g.begin(),g.end());\\n        for(int i=0;;i++)\\n        {\\n            vector<int> v;\\n            long long int t=pow(2,i);\\n            while(t)\\n            {\\n               v.push_back(t%10);\\n               t/=10;\\n            }\\n            sort(v.begin(),v.end());\\n            if(v==g)\\n            return true;\\n\\n            if(v.size()>g.size())\\n            break;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting",
                    "Counting",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        vector<int> g;\\n        while(n)\\n        {\\n            g.push_back(n%10);\\n            n/=10;\\n        }\\n        sort(g.begin(),g.end());\\n        for(int i=0;;i++)\\n        {\\n            vector<int> v;\\n            long long int t=pow(2,i);\\n            while(t)\\n            {\\n               v.push_back(t%10);\\n               t/=10;\\n            }\\n            sort(v.begin(),v.end());\\n            if(v==g)\\n            return true;\\n\\n            if(v.size()>g.size())\\n            break;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499369,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  bool reorderedPowerOf2(int N) {\\n    int count = counter(N);\\n\\n    for (int i = 0; i < 30; ++i)\\n      if (counter(1 << i) == count)\\n        return true;\\n\\n    return false;\\n  }\\n private:\\n  int counter(int n) {\\n    int count = 0;\\n\\n    for (; n > 0; n /= 10)\\n      count += pow(10, n % 10);\\n\\n    return count;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n\\n        t = sorted(str(n))\\n        i = 0\\n        while len(str(2**i))<=len(str(n)):\\n            if t==sorted(str(2**i)):\\n                return True\\n            i+=1\\n        return False\\n```\\n\\n```Java []\\nclass Solution {\\n    static byte[][] ocurr;\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  bool reorderedPowerOf2(int N) {\\n    int count = counter(N);\\n\\n    for (int i = 0; i < 30; ++i)\\n      if (counter(1 << i) == count)\\n        return true;\\n\\n    return false;\\n  }\\n private:\\n  int counter(int n) {\\n    int count = 0;\\n\\n    for (; n > 0; n /= 10)\\n      count += pow(10, n % 10);\\n\\n    return count;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n\\n        t = sorted(str(n))\\n        i = 0\\n        while len(str(2**i))<=len(str(n)):\\n            if t==sorted(str(2**i)):\\n                return True\\n            i+=1\\n        return False\\n```\n```Java []\\nclass Solution {\\n    static byte[][] ocurr;\\n    public boolean reorderedPowerOf2(int n) {\\n        if (n == 1) return true;\\n        if (ocurr == null) {\\n            ocurr = fillOccurencesForEachPowerOf2();\\n        }\\n        byte[] freq = countFreqs(n);\\n        for (byte[] oc : ocurr) {\\n            if (areSame(oc, freq)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private byte[][] fillOccurencesForEachPowerOf2() {\\n        byte[][] res = new byte[30][10];\\n        for (int i = 0; i < res.length; i++) {\\n            int pow = (int) Math.pow(2, i);\\n            res[i] = countFreqs(pow);\\n        }\\n        return res;\\n    }\\n    private byte[] countFreqs(int pow) {\\n        byte[] freq = new byte[10];\\n        while (pow > 0) {\\n            int digit = pow % 10;\\n            freq[digit]++;\\n            pow /= 10;\\n        }\\n        return freq;\\n    }\\n    private boolean areSame(byte[] oc, byte[] freq) {\\n        for (int i = 0; i < oc.length; i++) {\\n            if (oc[i] != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343801,
                "title": "c-short-and-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string nn = to_string(n);\\n        \\n        sort(nn.begin(), nn.end());\\n        \\n        for (int i = 0; i < 32; i++)\\n        {\\n            string pp = to_string(1 << i);\\n            \\n            sort(pp.begin(), pp.end());\\n            \\n            if (pp == nn)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        string nn = to_string(n);\\n        \\n        sort(nn.begin(), nn.end());\\n        \\n        for (int i = 0; i < 32; i++)\\n        {\\n            string pp = to_string(1 << i);\\n            \\n            sort(pp.begin(), pp.end());\\n            \\n            if (pp == nn)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224186,
                "title": "java-easy-solution-no-bit-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- There are 31 powers of 2 that are within the question constraints of `1 <= n <= 10^9`\\n- Sort the number `n` and each sorted power of 2 from 0 -> 30\\n- Leading 0 case is handled because the ordered power will never have a 0. For example, 0256 and 256 are not.\\n# Complexity\\n- Time complexity: $$O(nlogn*n)$$ Sort * string creation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] numArray = String.valueOf(n).toCharArray();\\n        Arrays.sort(numArray);\\n        String orderedNum = new String(numArray);\\n\\n        for (int i = 0; i < 31; i++) {\\n            int powerNum = (int) Math.pow(2, i);\\n            char[] powerNumArray = String.valueOf(powerNum).toCharArray();\\n            Arrays.sort(powerNumArray);\\n            String orderedPower = new String(powerNumArray);\\n\\n            if (orderedNum.equals(orderedPower)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        char[] numArray = String.valueOf(n).toCharArray();\\n        Arrays.sort(numArray);\\n        String orderedNum = new String(numArray);\\n\\n        for (int i = 0; i < 31; i++) {\\n            int powerNum = (int) Math.pow(2, i);\\n            char[] powerNumArray = String.valueOf(powerNum).toCharArray();\\n            Arrays.sort(powerNumArray);\\n            String orderedPower = new String(powerNumArray);\\n\\n            if (orderedNum.equals(orderedPower)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976338,
                "title": "python-few-lines-of-easy-brute-force",
                "content": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        target = sorted(str(n))\\n\\n        for i in range(31):  # 10^9\\n            if sorted(str(2**i)) == target:\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        target = sorted(str(n))\\n\\n        for i in range(31):  # 10^9\\n            if sorted(str(2**i)) == target:\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755253,
                "title": "c-100-fast-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) \\n{\\n   string str = to_string(n);\\n   sort(str.begin(),str.end());\\n   long long int num;\\n   int counter=0;\\n   \\n   while(true)\\n   {\\n      num = pow(2,counter++);\\n      \\n      string temp = to_string(num);\\n      \\n       \\n      if(temp.length()>str.length())\\n      {\\n          //cout<<\"temp=\"<<temp<<endl;\\n          break;\\n      }\\n       \\n      sort(temp.begin(),temp.end());\\n         \\n      if(str == temp)\\n      return true;\\n     \\n   }     \\n   return false;   \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) \\n{\\n   string str = to_string(n);\\n   sort(str.begin(),str.end());\\n   long long int num;\\n   int counter=0;\\n   \\n   while(true)\\n   {\\n      num = pow(2,counter++);\\n      \\n      string temp = to_string(num);\\n      \\n       \\n      if(temp.length()>str.length())\\n      {\\n          //cout<<\"temp=\"<<temp<<endl;\\n          break;\\n      }\\n       \\n      sort(temp.begin(),temp.end());\\n         \\n      if(str == temp)\\n      return true;\\n     \\n   }     \\n   return false;   \\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2512264,
                "title": "clever-solution-convert-to-string-c",
                "content": "```\\nbool reorderedPowerOf2(int n) {\\n    unordered_set<string> powers = {\\n        \"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\", \"128\",\"256\",\"512\",\"1024\",\"2048\",\"4096\",\"8192\",\"16384\",\"32768\",\"65536\", \"131072\", \"262144\",\"524288\", \"1048576\", \"2097152\", \"4194304\", \"8388608\", \"16777216\", \"33554432\", \"67108864\", \"134217728\", \"268435456\", \"536870912\", \"1073741824\", \"2147483648\"\\n    };\\n\\n    string num = to_string(n);\\n    sort(num.begin(), num.end());\\n\\n    for(string s : powers) {\\n        sort(s.begin(), s.end());\\n\\n        if(num == s)\\n            return true;\\n    } \\n    return false;\\n}\\n```\\n**upVote** \\uD83C\\uDF1D",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nbool reorderedPowerOf2(int n) {\\n    unordered_set<string> powers = {\\n        \"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\", \"128\",\"256\",\"512\",\"1024\",\"2048\",\"4096\",\"8192\",\"16384\",\"32768\",\"65536\", \"131072\", \"262144\",\"524288\", \"1048576\", \"2097152\", \"4194304\", \"8388608\", \"16777216\", \"33554432\", \"67108864\", \"134217728\", \"268435456\", \"536870912\", \"1073741824\", \"2147483648\"\\n    };\\n\\n    string num = to_string(n);\\n    sort(num.begin(), num.end());\\n\\n    for(string s : powers) {\\n        sort(s.begin(), s.end());\\n\\n        if(num == s)\\n            return true;\\n    } \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496603,
                "title": "reordered-power-of-2-o-1-time-complexity-cpp-solution",
                "content": "*simply take all 2 powered no.s from 2^0 to 2^30 which falls under 10^9 and convert given number \\'n\\' into string and then simply compare with all other 2^x powers by converting it into string and sorting and checking if they both match then return true else after end of loop return false.*\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n==0) return false;\\n        string cnum = to_string(n);\\n        vector<string> res;\\n        sort(cnum.begin(),cnum.end());\\n        int len = cnum.size();\\n        for(int i=0;i<30;i++){\\n            int temp = pow(2,i);\\n            string num = to_string(temp);\\n            if(len==num.size()){\\n                sort(num.begin(),num.end());\\n                if(num==cnum) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        if(n==0) return false;\\n        string cnum = to_string(n);\\n        vector<string> res;\\n        sort(cnum.begin(),cnum.end());\\n        int len = cnum.size();\\n        for(int i=0;i<30;i++){\\n            int temp = pow(2,i);\\n            string num = to_string(temp);\\n            if(len==num.size()){\\n                sort(num.begin(),num.end());\\n                if(num==cnum) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485629,
                "title": "c",
                "content": "```\\npublic class Solution \\n{\\n    public bool ReorderedPowerOf2(int n) \\n    {\\n\\t\\tstring s0 = string.Concat(n.ToString().OrderBy(ch => ch));\\n        \\n        int len = Convert.ToString( (int)Math.Pow(10, n.ToString().Length) , 2).Length;\\n        for (int i = 0; i <= len; i++)\\n        {\\n            int temp = (int)Math.Pow(2, i);\\n            string s1 = string.Concat(temp.ToString().OrderBy(ch => ch));\\n\\n            if (s1 == s0)\\n            {\\n                return true;\\n            }            \\n        }\\n\\n        return false;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool ReorderedPowerOf2(int n) \\n    {\\n\\t\\tstring s0 = string.Concat(n.ToString().OrderBy(ch => ch));\\n        \\n        int len = Convert.ToString( (int)Math.Pow(10, n.ToString().Length) , 2).Length;\\n        for (int i = 0; i <= len; i++)\\n        {\\n            int temp = (int)Math.Pow(2, i);\\n            string s1 = string.Concat(temp.ToString().OrderBy(ch => ch));\\n\\n            if (s1 == s0)\\n            {\\n                return true;\\n            }            \\n        }\\n\\n        return false;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485464,
                "title": "golang-c-python-100-solutions",
                "content": "same logic: \\n1) we prepare a int[10] list to store count of each digits in <kbd>n</kbd>,\\n2) check every <kbd>2 ** i</kbd> result for an identical list, until result reaches <kbd>1e9</kbd> (dictated in the subject)\\n\\n# Go\\n```go\\nfunc reorderedPowerOf2(n int) bool {\\n    check := count_n(n)\\n    // fmt.Println(check)\\n    num := 0\\n    i := 0\\n    for num < 1e9 + 1 {\\n        num = int(math.Pow(2, float64(i)))\\n        temp := count_n(num)\\n        if check == temp {\\n            return true\\n        }\\n        i++\\n    }\\n    return false\\n}\\n\\nfunc count_n(n int) [10] int {\\n    r := [10] int {} // auto 0-filled\\n    for n > 0 {\\n        r[n % 10]++\\n        n /= 10\\n    }\\n    return r\\n}\\n```\\n# C++\\n```r\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        vector<int> check, temp;\\n        int         i, res;\\n\\n        check = count_n(n);\\n        i = 0;\\n        res = 0;\\n        while (res < (int) 1e9 + 1)\\n        {\\n            res = pow(2, i);\\n            temp = count_n(res);\\n            if (check == temp)\\n                return true;\\n            i++;\\n        }\\n        return false;\\n    }\\n\\n    vector<int> count_n(int n)\\n    {\\n        vector<int> r(10, 0);\\n\\n        while (n)\\n        {\\n            r[n % 10]++;\\n            n /= 10;\\n        }\\n        return r;\\n    }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def count_n(num: int) -> List[int]:\\n            r = [0] * 10\\n            while num > 0:\\n                r[num % 10] += 1\\n                num //= 10\\n            return r\\n        check = count_n(n)\\n        res, i = 0, 0\\n        while res < 10 ** 9 + 1:\\n            res = 2 ** i\\n            temp = count_n(res)\\n            if check == temp:\\n                return True\\n            i += 1\\n        return False\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "```go\\nfunc reorderedPowerOf2(n int) bool {\\n    check := count_n(n)\\n    // fmt.Println(check)\\n    num := 0\\n    i := 0\\n    for num < 1e9 + 1 {\\n        num = int(math.Pow(2, float64(i)))\\n        temp := count_n(num)\\n        if check == temp {\\n            return true\\n        }\\n        i++\\n    }\\n    return false\\n}\\n\\nfunc count_n(n int) [10] int {\\n    r := [10] int {} // auto 0-filled\\n    for n > 0 {\\n        r[n % 10]++\\n        n /= 10\\n    }\\n    return r\\n}\\n```\n```r\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n)\\n    {\\n        vector<int> check, temp;\\n        int         i, res;\\n\\n        check = count_n(n);\\n        i = 0;\\n        res = 0;\\n        while (res < (int) 1e9 + 1)\\n        {\\n            res = pow(2, i);\\n            temp = count_n(res);\\n            if (check == temp)\\n                return true;\\n            i++;\\n        }\\n        return false;\\n    }\\n\\n    vector<int> count_n(int n)\\n    {\\n        vector<int> r(10, 0);\\n\\n        while (n)\\n        {\\n            r[n % 10]++;\\n            n /= 10;\\n        }\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        def count_n(num: int) -> List[int]:\\n            r = [0] * 10\\n            while num > 0:\\n                r[num % 10] += 1\\n                num //= 10\\n            return r\\n        check = count_n(n)\\n        res, i = 0, 0\\n        while res < 10 ** 9 + 1:\\n            res = 2 ** i\\n            temp = count_n(res)\\n            if check == temp:\\n                return True\\n            i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485338,
                "title": "c-100-0ms-readable-optimised",
                "content": "```\\n\\tint nDig(int n) {\\n        int x=0;\\n        while(n || !x) {\\n            x++;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    string encodeDig(int n) {\\n        string x=\"0000000000\";\\n        while(n) {\\n            int i=n%10;\\n            x[i]+=1;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        string nstr=encodeDig(n);\\n        int ndig = nDig(n);\\n        int p2=1;\\n        while(nDig(p2)!=ndig) p2*=2;\\n        while(nDig(p2)==ndig) if(nstr==encodeDig(p2)) return true; else p2*=2;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tint nDig(int n) {\\n        int x=0;\\n        while(n || !x) {\\n            x++;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    string encodeDig(int n) {\\n        string x=\"0000000000\";\\n        while(n) {\\n            int i=n%10;\\n            x[i]+=1;\\n            n/=10;\\n        }\\n        return x;\\n    }\\n    bool reorderedPowerOf2(int n) {\\n        string nstr=encodeDig(n);\\n        int ndig = nDig(n);\\n        int p2=1;\\n        while(nDig(p2)!=ndig) p2*=2;\\n        while(nDig(p2)==ndig) if(nstr==encodeDig(p2)) return true; else p2*=2;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485329,
                "title": "crazy-unusual-method-fta-python",
                "content": "![image](https://assets.leetcode.com/users/images/f581bc8b-cdae-458c-81ce-e507a5604a39_1661544945.0515218.png)\\nThe idea of this method is behind the desire of pre-calculating all the possible answers in a special way so that when we get a number we can quickly say is it an answer or not.\\n\\nLet\\'s not stray far from the idea of counting the number of all digits, because it\\'s pretty reasonable. We need to somehow hash all precalculations for powers of two less than 10**9.\\n\\nThat is, in other words, we must be able to quickly understand whether, say, the number of eights in the number given to us coincides with the number of eights in any of the powers of two. Or, to put it another way, is there a power of two with the same number of eights as in the given number.\\n\\nThat is, for each digit we need to understand the \"degree\" of its occurrence in the number and be able to quickly answer whether there is a power of two with the same number of the same digits.\\n\\nAt this point, I remembered the Fundamental Theorem of Arithmetic, and I came up with the idea of \\u200B\\u200Bthe following way to encode numbers. To each digit we associate a certain prime number (for simplicity, let\\'s say that we associate the \"i\" digit with the \"i+1\"-th prime number). Then the number will be encoded by multiplying all prime numbers encoded by its digits, raised to the power of occurrence of these digits.\\n\\nThus, we can create a set with all encoded powers of two less than 10**9, and then just encode each number given to us in the same way and check whether this number is in our set or not.\\n\\nThe main idea has been explained. Only the technical part of the implementation remains.\\n\\nFirst, let\\'s create a list of the first 10 primes (it\\'s faster to do it by hand). Here it is: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n\\nNow we need all powers of two less than 10**9. They can be generated like this:\\n```\\npowers_of_two = []\\ni = 0\\nwhile 2 ** i <= 10**9:\\n\\tpowers_of_two.append(2**i)\\n\\ti += 1\\n```\\nNow each power of two has to be encoded. For example, it can be done like this:\\n```\\nans = set()\\nfor num in powers_of_two:\\n\\tcnt = Counter(str(num))\\n\\ttmp = 1\\n\\tfor digit in cnt:\\n\\t\\ttmp *= primes[int(digit)] ** cnt[digit]\\n\\tans.add(tmp)\\n```\\nNow we have all the necessary pre-calculations in hand, and we can write the code itself:\\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        ans = {3, 143849475, 5, 191712774, 11, 89201295, 1074450, 10005, 23, 35, 154275, 4757357605, 1621158, 66602158, 260015, 51, 187, 11970, 195, 6374082, 330, 588153930, 1105, 90321, 35070035, 345, 10846, 2530, 1891175, 341887}\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        cnt = Counter(str(n))\\n        t = 1\\n        for digit in cnt:\\n            t *= primes[int(digit)] ** cnt[digit]\\n        return t in ans\\n```\\n**Upvote if you find interesting this approach!**",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\npowers_of_two = []\\ni = 0\\nwhile 2 ** i <= 10**9:\\n\\tpowers_of_two.append(2**i)\\n\\ti += 1\\n```\n```\\nans = set()\\nfor num in powers_of_two:\\n\\tcnt = Counter(str(num))\\n\\ttmp = 1\\n\\tfor digit in cnt:\\n\\t\\ttmp *= primes[int(digit)] ** cnt[digit]\\n\\tans.add(tmp)\\n```\n```\\nclass Solution:\\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        ans = {3, 143849475, 5, 191712774, 11, 89201295, 1074450, 10005, 23, 35, 154275, 4757357605, 1621158, 66602158, 260015, 51, 187, 11970, 195, 6374082, 330, 588153930, 1105, 90321, 35070035, 345, 10846, 2530, 1891175, 341887}\\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\\n        cnt = Counter(str(n))\\n        t = 1\\n        for digit in cnt:\\n            t *= primes[int(digit)] ** cnt[digit]\\n        return t in ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485204,
                "title": "java-with-bit-shift-100-faster-memory-usage-99-33",
                "content": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        int digitCount[] = getDigitCount(n);\\n        int totalDigits = 0;\\n        \\n        for (int count : digitCount) {\\n            totalDigits += count;\\n        }\\n        \\n\\t\\t// set upper and lower limit\\n        int max = (int) Math.pow(10, totalDigits);\\n        int min = (int) Math.pow(10, totalDigits - 1);\\n        int powTwo = 1;\\n        \\n\\t\\t// shift until within upper and lower limit range\\n        while (powTwo < min) {\\n            powTwo <<= 1;\\n        }\\n        \\n        boolean same = true;\\n        while (powTwo < max) {\\n            int[] powTwoDigitCount = getDigitCount(powTwo);\\n            same = true;\\n\\t\\t\\t\\n\\t\\t\\t// check if digits occurrences are equal\\n            for (int i = 0; i < digitCount.length; i++) {\\n                if (digitCount[i] != powTwoDigitCount[i]) {\\n                    same = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (same) break;\\n            powTwo <<= 1;\\n        }\\n        \\n        return same;\\n    }\\n    \\n    private int[] getDigitCount(int n) {\\n        int digitCount[] = new int[10];\\n        while (n != 0) {\\n            digitCount[n % 10]++;\\n            n /= 10;\\n        }\\n        \\n        return digitCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n        int digitCount[] = getDigitCount(n);\\n        int totalDigits = 0;\\n        \\n        for (int count : digitCount) {\\n            totalDigits += count;\\n        }\\n        \\n\\t\\t// set upper and lower limit\\n        int max = (int) Math.pow(10, totalDigits);\\n        int min = (int) Math.pow(10, totalDigits - 1);\\n        int powTwo = 1;\\n        \\n\\t\\t// shift until within upper and lower limit range\\n        while (powTwo < min) {\\n            powTwo <<= 1;\\n        }\\n        \\n        boolean same = true;\\n        while (powTwo < max) {\\n            int[] powTwoDigitCount = getDigitCount(powTwo);\\n            same = true;\\n\\t\\t\\t\\n\\t\\t\\t// check if digits occurrences are equal\\n            for (int i = 0; i < digitCount.length; i++) {\\n                if (digitCount[i] != powTwoDigitCount[i]) {\\n                    same = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (same) break;\\n            powTwo <<= 1;\\n        }\\n        \\n        return same;\\n    }\\n    \\n    private int[] getDigitCount(int n) {\\n        int digitCount[] = new int[10];\\n        while (n != 0) {\\n            digitCount[n % 10]++;\\n            n /= 10;\\n        }\\n        \\n        return digitCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485111,
                "title": "i-am-a-noob-got-1ms-solution",
                "content": "```\\nimport java.util.*;\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        boolean flag = true;\\n        int length = String.valueOf(n).length();\\n        int k =1;\\n        int[] arr = func(n);\\n        while(flag = true)\\n        {\\n            k = k*2;\\n            int[] temp = func(k);\\n            if(Arrays. equals(temp,arr ))\\n            {\\n                return true;\\n            }    \\n            int p =String.valueOf(k).length();\\n            if(p>length)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    public static int[] func(int n)\\n    {\\n        int[] arr = new int[10];\\n        while(n>0)\\n        {\\n            int digit = n%10;\\n            arr[digit]++;\\n            n = n/10;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution \\n{\\n    public boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        boolean flag = true;\\n        int length = String.valueOf(n).length();\\n        int k =1;\\n        int[] arr = func(n);\\n        while(flag = true)\\n        {\\n            k = k*2;\\n            int[] temp = func(k);\\n            if(Arrays. equals(temp,arr ))\\n            {\\n                return true;\\n            }    \\n            int p =String.valueOf(k).length();\\n            if(p>length)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    public static int[] func(int n)\\n    {\\n        int[] arr = new int[10];\\n        while(n>0)\\n        {\\n            int digit = n%10;\\n            arr[digit]++;\\n            n = n/10;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484999,
                "title": "i-am-a-noob-but-1ms-solution",
                "content": "import java.util.;\\nclass Solution \\n{\\n\\tpublic boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n        boolean flag = true;\\n        int length = String.valueOf(n).length();\\n        int k =1;\\n        int[] arr = func(n);\\n        while(flag = true)\\n        {\\n            k = k2;\\n            int[] temp = func(k);\\n            if(Arrays. equals(temp,arr ))\\n            {\\n                return true;\\n            }    \\n            int p =String.valueOf(k).length();\\n            if(p>length)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    public static int[] func(int n)\\n    {\\n        int[] arr = new int[10];\\n        while(n>0)\\n        {\\n            int digit = n%10;\\n            arr[digit]++;\\n            n = n/10;\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution \\n{\\n\\tpublic boolean reorderedPowerOf2(int n) \\n    {\\n        if(n==1)\\n        {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2484959,
                "title": "c-reordered-power-of-2",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<=30;i++){\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            if(temp==s)\\n                return true;\\n            \\n        }\\n        return false;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string s=to_string(n);\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<=30;i++){\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            if(temp==s)\\n                return true;\\n            \\n        }\\n        return false;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2484863,
                "title": "0ms-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int i,s=1;\\n        string a=to_string(n);\\n        sort(a.begin(),a.end());\\n        vector<string> v;\\n        string b;\\n        for(i=0;i<=29;i++)\\n        {\\n            b=to_string(s);\\n            v.push_back(b);\\n            s=s*2;\\n            sort(b.begin(),b.end());\\n            if(b==a)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        int i,s=1;\\n        string a=to_string(n);\\n        sort(a.begin(),a.end());\\n        vector<string> v;\\n        string b;\\n        for(i=0;i<=29;i++)\\n        {\\n            b=to_string(s);\\n            v.push_back(b);\\n            s=s*2;\\n            sort(b.begin(),b.end());\\n            if(b==a)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484734,
                "title": "c-easy-solution-clean-code-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string num=to_string(n);\\n        sort(num.begin(),num.end());\\n        //cout<<num<<endl;\\n        //vector<string> hash;\\n        for(int i=0;i<=30;i++){\\n            //cout<<pow(2,i)<<endl;\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            //cout<<temp<<endl;\\n            if(temp==num) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        string num=to_string(n);\\n        sort(num.begin(),num.end());\\n        //cout<<num<<endl;\\n        //vector<string> hash;\\n        for(int i=0;i<=30;i++){\\n            //cout<<pow(2,i)<<endl;\\n            string temp=\"\";\\n            int t=pow(2,i);\\n            temp=to_string(t);\\n            sort(temp.begin(),temp.end());\\n            //cout<<temp<<endl;\\n            if(temp==num) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2484719,
                "title": "80-faster-c-code-daily-leetcode-challenge-august-day-26",
                "content": "```\\nvector<map<int,int>> findarray(int nodigits){\\n    long long start=1;\\n    for(int i=1;i<nodigits;i++){\\n        start*=10;\\n    }\\n    long long end=start*10;\\n    long long start2=1;\\n    while(start2<start){\\n        start2*=2;\\n    }\\n   vector<map<int,int>> ans(100);\\n    int i=0;\\n    while(start2<=end){\\n        long long topush=start2;\\n        while(topush>0){\\n            int digito=topush%10;\\n            ans[i][digito]++;\\n            topush/=10;\\n        }\\n        i++;\\n        start2*=2;\\n    }\\n    return ans;\\n}    \\n```\\n```\\n    bool reorderedPowerOf2(int n) {\\n        int digits=0;\\n        long long num=n;\\n        map<int,int> original;\\n        while(num>0){\\n            int digito=num%10;\\n            original[digito]++;\\n            num/=10;\\n            digits++;\\n        }\\n        vector<map<int,int>> find=findarray(digits);\\n        for(int i=0;i<find.size();i++){\\n            if(find[i]==original){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<map<int,int>> findarray(int nodigits){\\n    long long start=1;\\n    for(int i=1;i<nodigits;i++){\\n        start*=10;\\n    }\\n    long long end=start*10;\\n    long long start2=1;\\n    while(start2<start){\\n        start2*=2;\\n    }\\n   vector<map<int,int>> ans(100);\\n    int i=0;\\n    while(start2<=end){\\n        long long topush=start2;\\n        while(topush>0){\\n            int digito=topush%10;\\n            ans[i][digito]++;\\n            topush/=10;\\n        }\\n        i++;\\n        start2*=2;\\n    }\\n    return ans;\\n}    \\n```\n```\\n    bool reorderedPowerOf2(int n) {\\n        int digits=0;\\n        long long num=n;\\n        map<int,int> original;\\n        while(num>0){\\n            int digito=num%10;\\n            original[digito]++;\\n            num/=10;\\n            digits++;\\n        }\\n        vector<map<int,int>> find=findarray(digits);\\n        for(int i=0;i<find.size();i++){\\n            if(find[i]==original){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484686,
                "title": "c-detailed-explanation-tc-o-nlogn",
                "content": "**Two Approaches**\\n* Approach-1 -> Generating all the permutations for the digits of number n, and checking individually for the power of 2.\\n*  TC =Total Permutations of the digits i.e. (n)!\\n ```\\nclass Solution {\\n    bool twoPower(string digits){\\n        int num=stoi(digits);\\n        return (num & (num-1))==0;\\n    }\\n    bool check(string digits,int pos){\\n        if(pos==digits.size()){\\n            if(digits[0]!=\\'0\\'&&twoPower(digits)) {\\n                return true;\\n            }\\n            else return false;\\n        }\\n        for(int i=pos;i<digits.size();i++){\\n            swap(digits[pos],digits[i]);\\n            if(digits[0]!=\\'0\\'&&check(digits,pos+1)) return true;\\n            swap(digits[i],digits[pos]);\\n        }\\n        return false;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        return check(to_string(n),0);\\n    }\\n};\\n```\\n* Approach-2 -> Getting all the power of twos arranging their digits in increasing order and put them in map, convert n to string, sort it, check whether it belongs to that map or not.\\n* Let count of digits of given number=k, TC = O(32 * k * log(k)).\\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        unordered_map<string,bool> mp;\\n        for(int i=0;i<32;i++){\\n            int num= 1<<i;\\n            string s=to_string(num);\\n            sort(s.begin(),s.end());\\n            mp[s]=true;\\n        }\\n        string tc=to_string(n);\\n        sort(tc.begin(),tc.end());\\n        return mp.find(tc)!=mp.end();\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool twoPower(string digits){\\n        int num=stoi(digits);\\n        return (num & (num-1))==0;\\n    }\\n    bool check(string digits,int pos){\\n        if(pos==digits.size()){\\n            if(digits[0]!=\\'0\\'&&twoPower(digits)) {\\n                return true;\\n            }\\n            else return false;\\n        }\\n        for(int i=pos;i<digits.size();i++){\\n            swap(digits[pos],digits[i]);\\n            if(digits[0]!=\\'0\\'&&check(digits,pos+1)) return true;\\n            swap(digits[i],digits[pos]);\\n        }\\n        return false;\\n    }\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        return check(to_string(n),0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        unordered_map<string,bool> mp;\\n        for(int i=0;i<32;i++){\\n            int num= 1<<i;\\n            string s=to_string(num);\\n            sort(s.begin(),s.end());\\n            mp[s]=true;\\n        }\\n        string tc=to_string(n);\\n        sort(tc.begin(),tc.end());\\n        return mp.find(tc)!=mp.end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484665,
                "title": "java-simple-100-sweet-and-simple",
                "content": "**IF you LIKE it UPVOTE**\\n```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n    int Count[] = Count(n);\\n       \\n        for (int i = 0; i < 31; i++) {\\n            int power = (int)Math.pow(2,i);\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { \\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean reorderedPowerOf2(int n) {\\n    int Count[] = Count(n);\\n       \\n        for (int i = 0; i < 31; i++) {\\n            int power = (int)Math.pow(2,i);\\n            int[] PowerCount = Count(power);\\n            if (Equal(Count, PowerCount)) {\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n    private int[] Count(int n) { \\n        int Count[] = new int[10];\\n        while (n != 0) {\\n            Count[n % 10]++;\\n            n /= 10;\\n        }\\n        return Count;\\n    }\\n\\n    private boolean Equal(int ar1[], int ar2[]) {\\n        for (int i = 0; i < ar2.length; i++) {\\n            if (ar1[i] != ar2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484537,
                "title": "easy-c-solution-using-vector-100-faster-than-others",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(int n){\\n        //Storing occurence of n :-\\n        vector<int>v(10);\\n        while(n){\\n            v[n%10]++;\\n            n/=10;\\n        }\\n        return v;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        if(n==1)return true;\\n        \\n        vector<int>v = solve(n);\\n        \\n        for(int i = 0;i<30;i++){\\n            // if(v == solve(pow(2,i)))return true;\\n            if(v == solve(1<<i))return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve(int n){\\n        //Storing occurence of n :-\\n        vector<int>v(10);\\n        while(n){\\n            v[n%10]++;\\n            n/=10;\\n        }\\n        return v;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        if(n==1)return true;\\n        \\n        vector<int>v = solve(n);\\n        \\n        for(int i = 0;i<30;i++){\\n            // if(v == solve(pow(2,i)))return true;\\n            if(v == solve(1<<i))return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484532,
                "title": "c-code-with-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        //Convert the integer to string\\n        string s=to_string(n);\\n        \\n        //Sort the string\\n        sort(s.begin(),s.end());\\n        \\n        //Now check for all power till 32 and covert all power into string and sort them\\n        //If we get any power of 2 string equal to s then return true\\n        for(int i=0;i<32;i++){\\n            int power_2=(1<<i);\\n            string compare=to_string(power_2);\\n            sort(compare.begin(),compare.end());\\n            if(compare==s)return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int n) {\\n        \\n        //Convert the integer to string\\n        string s=to_string(n);\\n        \\n        //Sort the string\\n        sort(s.begin(),s.end());\\n        \\n        //Now check for all power till 32 and covert all power into string and sort them\\n        //If we get any power of 2 string equal to s then return true\\n        for(int i=0;i<32;i++){\\n            int power_2=(1<<i);\\n            string compare=to_string(power_2);\\n            sort(compare.begin(),compare.end());\\n            if(compare==s)return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484340,
                "title": "c-easy-solution",
                "content": "**c++ easy understanding code using a string sort_string function**\\n\\n\\n\\n    \\n   string sort_string(int n)\\n    {\\n       string str=to_string(n);//convert to array\\n       sort(str.begin(),str.end());//sort it    \\n\\t   return str;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s=sort_string(n);// sort  the \\n        \\n        for(int i=0;i<30;i++)\\n        {\\n            string t=sort_string(1<<i);//sort the decimal form of the power of 2\\n            if(s==t)return true;//check if they are same or not\\n            \\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**c++ easy understanding code using a string sort_string function**\\n\\n\\n\\n    \\n   string sort_string(int n)\\n    {\\n       string str=to_string(n);//convert to array\\n       sort(str.begin(),str.end());//sort it    \\n\\t   return str;\\n    }\\n    \\n    bool reorderedPowerOf2(int n) {\\n        string s=sort_string(n);// sort  the \\n        \\n        for(int i=0;i<30;i++)\\n        {\\n            string t=sort_string(1<<i);//sort the decimal form of the power of 2\\n            if(s==t)return true;//check if they are same or not\\n            \\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2484279,
                "title": "100-faster-100-less-memory-than-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/75551367-0224-4491-a7be-5fd53e52c224_1661530948.5126617.png)\\n\\n\\n```\\n    public bool ReorderedPowerOf2(int n) {\\n        int[] numbers = GetFrequencyArray(n);\\n        for(int i=0; i<31; i++)\\n        {\\n            int pow = (int)Math.Pow(2, i);\\n            int[] powerFrequencies = GetFrequencyArray(pow);\\n            if(Compare(numbers, powerFrequencies)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private int[] GetFrequencyArray(int n)\\n    {\\n        int[] frequencies = new int[10];\\n        while(n>0)\\n        {\\n            frequencies[n%10]++;\\n            n /= 10;\\n        }\\n        return frequencies;\\n    }\\n    \\n    private bool Compare(int[] arrOne, int[] arrTwo)\\n    {\\n        for(int i=0; i<10; i++)\\n        {\\n            if(arrOne[i] != arrTwo[i]) return false;\\n        }\\n        return true;\\n    }  \\n```",
                "solutionTags": [],
                "code": "```\\n    public bool ReorderedPowerOf2(int n) {\\n        int[] numbers = GetFrequencyArray(n);\\n        for(int i=0; i<31; i++)\\n        {\\n            int pow = (int)Math.Pow(2, i);\\n            int[] powerFrequencies = GetFrequencyArray(pow);\\n            if(Compare(numbers, powerFrequencies)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private int[] GetFrequencyArray(int n)\\n    {\\n        int[] frequencies = new int[10];\\n        while(n>0)\\n        {\\n            frequencies[n%10]++;\\n            n /= 10;\\n        }\\n        return frequencies;\\n    }\\n    \\n    private bool Compare(int[] arrOne, int[] arrTwo)\\n    {\\n        for(int i=0; i<10; i++)\\n        {\\n            if(arrOne[i] != arrTwo[i]) return false;\\n        }\\n        return true;\\n    }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484264,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]\\n```\\n bool reorderedPowerOf2(int n) {\\n        vector<string>ans;\\n        string ndigit=to_string(n);\\n        \\n    \\n        sort(ndigit.begin(),ndigit.end());\\n        \\n        \\n        for(int i=0;i<31;i++){\\n            int p=pow(2,i);\\n            ans.push_back(to_string(p));\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            sort(ans[i].begin(),ans[i].end());\\n        }\\n        for(int i=0;i<=30;i++){\\n            if(ans[i]==ndigit) return true;\\n        }\\n        return false;\\n    }\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n bool reorderedPowerOf2(int n) {\\n        vector<string>ans;\\n        string ndigit=to_string(n);\\n        \\n    \\n        sort(ndigit.begin(),ndigit.end());\\n        \\n        \\n        for(int i=0;i<31;i++){\\n            int p=pow(2,i);\\n            ans.push_back(to_string(p));\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            sort(ans[i].begin(),ans[i].end());\\n        }\\n        for(int i=0;i<=30;i++){\\n            if(ans[i]==ndigit) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484235,
                "title": "javascript-soln",
                "content": "```\\nvar reorderedPowerOf2 = function(n) {\\n    const max = 10**9\\n    let power = 0;\\n    let pvalue = 0 \\n    const input = `${n}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n    while(pvalue <= max ) {\\n        pvalue = 2**power\\n        power++\\n        const p = `${pvalue}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n        if(p === input) { return true }  \\n        if(p.length > input.length) { return false }\\n    }\\n    return false\\n};",
                "solutionTags": [],
                "code": "```\\nvar reorderedPowerOf2 = function(n) {\\n    const max = 10**9\\n    let power = 0;\\n    let pvalue = 0 \\n    const input = `${n}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n    while(pvalue <= max ) {\\n        pvalue = 2**power\\n        power++\\n        const p = `${pvalue}`.split(\\'\\').sort((a, b) =>a -b).join(\\'\\')\\n        if(p === input) { return true }  \\n        if(p.length > input.length) { return false }\\n    }\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2484183,
                "title": "python-25ms-beat-90",
                "content": "1. create a list of all possible power of 2 under 10^9 by utilizing binary representation of integers.\\n2. an integer is power of 2 iff its representation in binary starts with \\'1\\' and trailed with all \\'0\\'s.\\n3. utilizing the counter function to compare the frequency of characters with that of each element in the list we built in step 1. \\n```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        n=str(n)\\n        counter=collections.Counter(n)\\n        ## create the lst of all possible power of 2 under 10**9\\n        lst=[]\\n        for i in range(0,99):\\n            s=\\'1\\'+\\'0\\'*i\\n            m=int(s,2)\\n            if m>10**9:\\n                break\\n            lst.append(str(m))\\n        ##\\n        for i in lst:\\n            if len(i)!=len(n):\\n                continue\\n            counter2=collections.Counter(i)\\n            if counter == counter2:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def reorderedPowerOf2(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        n=str(n)\\n        counter=collections.Counter(n)\\n        ## create the lst of all possible power of 2 under 10**9\\n        lst=[]\\n        for i in range(0,99):\\n            s=\\'1\\'+\\'0\\'*i\\n            m=int(s,2)\\n            if m>10**9:\\n                break\\n            lst.append(str(m))\\n        ##\\n        for i in lst:\\n            if len(i)!=len(n):\\n                continue\\n            counter2=collections.Counter(i)\\n            if counter == counter2:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484172,
                "title": "python",
                "content": "```\\nimport itertools\\n\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        while n%2 == 0:\\n            n /= 2\\n        return 1 == n\\n    \\n    def getAllPermutations(self, n):\\n        permutations = []\\n        for num in itertools.permutations(list(n)):\\n            permutations.append(int(\"\".join(num)))\\n        return permutations\\n    \\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n = str(n)\\n        for num in self.getAllPermutations(n):\\n            if(self.isPowerOfTwo(num) and len(n) == len(str(num))): return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nimport itertools\\n\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        while n%2 == 0:\\n            n /= 2\\n        return 1 == n\\n    \\n    def getAllPermutations(self, n):\\n        permutations = []\\n        for num in itertools.permutations(list(n)):\\n            permutations.append(int(\"\".join(num)))\\n        return permutations\\n    \\n    def reorderedPowerOf2(self, n: int) -> bool:\\n        n = str(n)\\n        for num in self.getAllPermutations(n):\\n            if(self.isPowerOfTwo(num) and len(n) == len(str(num))): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484030,
                "title": "1-ms-faster-than-100-00-of-java",
                "content": "```\\npublic boolean reorderedPowerOf2(int n) {\\n\\t\\tif (n == 1) return true;\\n\\t\\tboolean isCorrect = false;\\n\\t\\t\\n\\t\\tint[] valCountArr = new int[10];\\n\\t\\tlong count = 0;\\n\\t\\tfor(char c : String.valueOf(n).toCharArray()) {\\n\\t\\t\\tvalCountArr[c-\\'0\\']++;\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint target = 2;\\n\\t\\t\\n\\t\\twhile (String.valueOf(target).length() <= count) {\\n\\t\\t\\t\\n\\t\\t\\tif(String.valueOf(target).length() < count) {\\n\\t\\t\\t\\ttarget *= 2;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint[] targetArr = new int[10];\\n\\t\\t\\t\\n\\t\\t\\tfor(char c : String.valueOf(target).toCharArray())\\n\\t\\t\\t\\ttargetArr[c-\\'0\\']++;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 0; i < 10; i++) {\\n\\t\\t\\t\\tif (targetArr[i] == valCountArr[i]) {\\n\\t\\t\\t\\t\\tif (i == 9)\\n\\t\\t\\t\\t\\t\\tisCorrect = true;\\n\\t\\t\\t\\t}else break;\\n\\t\\t\\t}\\n\\t\\t\\tif(isCorrect) break;\\n\\t\\t\\ttarget *= 2;\\n\\t\\t}\\n\\t\\treturn isCorrect;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean reorderedPowerOf2(int n) {\\n\\t\\tif (n == 1) return true;\\n\\t\\tboolean isCorrect = false;\\n\\t\\t\\n\\t\\tint[] valCountArr = new int[10];\\n\\t\\tlong count = 0;\\n\\t\\tfor(char c : String.valueOf(n).toCharArray()) {\\n\\t\\t\\tvalCountArr[c-\\'0\\']++;\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint target = 2;\\n\\t\\t\\n\\t\\twhile (String.valueOf(target).length() <= count) {\\n\\t\\t\\t\\n\\t\\t\\tif(String.valueOf(target).length() < count) {\\n\\t\\t\\t\\ttarget *= 2;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint[] targetArr = new int[10];\\n\\t\\t\\t\\n\\t\\t\\tfor(char c : String.valueOf(target).toCharArray())\\n\\t\\t\\t\\ttargetArr[c-\\'0\\']++;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 0; i < 10; i++) {\\n\\t\\t\\t\\tif (targetArr[i] == valCountArr[i]) {\\n\\t\\t\\t\\t\\tif (i == 9)\\n\\t\\t\\t\\t\\t\\tisCorrect = true;\\n\\t\\t\\t\\t}else break;\\n\\t\\t\\t}\\n\\t\\t\\tif(isCorrect) break;\\n\\t\\t\\ttarget *= 2;\\n\\t\\t}\\n\\t\\treturn isCorrect;\\n\\t}",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1754009,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "when I run the test case \"46\", the solution should be \"false\", but the expected is \"true\".\\nI don\\'t understand why it should be true, since the binary representation of \"46\" is 101110, and its clear that we can\\'t reorder this number to be a power of 2.... what I\\'m missing here?\\n\\n(I\\'m solving in C)"
                    },
                    {
                        "username": "user9132S",
                        "content": "[@lowchhector](/lowchhector) Thank you!"
                    },
                    {
                        "username": "lowchhector",
                        "content": "im thinking 46 can be reordered to 64 which is a power of 2"
                    },
                    {
                        "username": "shakti_2003",
                        "content": "we can not represent 46 as a power of 2 but it shows true for 46 .. how ????"
                    },
                    {
                        "username": "EgoriiSt",
                        "content": "if you reorder 46 you get 64 which is 2^6"
                    }
                ]
            },
            {
                "id": 1956852,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "when I run the test case \"46\", the solution should be \"false\", but the expected is \"true\".\\nI don\\'t understand why it should be true, since the binary representation of \"46\" is 101110, and its clear that we can\\'t reorder this number to be a power of 2.... what I\\'m missing here?\\n\\n(I\\'m solving in C)"
                    },
                    {
                        "username": "user9132S",
                        "content": "[@lowchhector](/lowchhector) Thank you!"
                    },
                    {
                        "username": "lowchhector",
                        "content": "im thinking 46 can be reordered to 64 which is a power of 2"
                    },
                    {
                        "username": "shakti_2003",
                        "content": "we can not represent 46 as a power of 2 but it shows true for 46 .. how ????"
                    },
                    {
                        "username": "EgoriiSt",
                        "content": "if you reorder 46 you get 64 which is 2^6"
                    }
                ]
            }
        ]
    },
    {
        "title": "Advantage Shuffle",
        "question_content": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> both of the same length. The <strong>advantage</strong> of <code>nums1</code> with respect to <code>nums2</code> is the number of indices <code>i</code> for which <code>nums1[i] &gt; nums2[i]</code>.</p>\n\n<p>Return <em>any permutation of </em><code>nums1</code><em> that maximizes its <strong>advantage</strong> with respect to </em><code>nums2</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n<strong>Output:</strong> [2,11,7,15]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n<strong>Output:</strong> [24,32,8,12]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums2.length == nums1.length</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 149822,
                "title": "java-greedy-6-lines-with-explanation",
                "content": "Contest version below:\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n=A.length;\\n        int[] res= new int[n];\\n        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->b[0]-a[0]);\\n        for (int i=0; i<n; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=n-1;\\n        while(!pq.isEmpty()){\\n            int[] cur= pq.poll();\\n            int idx=cur[1], val=cur[0];\\n            if (A[hi]>val) res[idx]=A[hi--];\\n            else res[idx]=A[lo++];\\n        }\\n        return res;\\n    }  \\n}\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/caraxin/image_1531625378.png)\\nShorter version just for fun (promise me never use it during an interview):\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->b[0]-a[0]);\\n        for (int i=0; i<B.length; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=A.length-1, res[] = new int[A.length];\\n        while(!pq.isEmpty()) res[pq.peek()[1]]=pq.poll()[0]<A[hi]?A[hi--]:A[lo++];\\n        return res;\\n    }\\n}\\n```\\nIf you are chasing speed, it\\'s time to forget lambda, beats 90%:\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n=A.length;\\n        int[] res= new int[n];\\n        PriorityQueue<int[]> pq= new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                return b[0]-a[0];\\n            }\\n        });\\n        for (int i=0; i<n; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=n-1;\\n        while(!pq.isEmpty()){\\n            int[] cur= pq.poll();\\n            int idx=cur[1], val=cur[0];\\n            if (A[hi]>val) res[idx]=A[hi--];\\n            else res[idx]=A[lo++];\\n        }\\n        return res;\\n    }  \\n}\\n```\\nHappy coding.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n=A.length;\\n        int[] res= new int[n];\\n        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->b[0]-a[0]);\\n        for (int i=0; i<n; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=n-1;\\n        while(!pq.isEmpty()){\\n            int[] cur= pq.poll();\\n            int idx=cur[1], val=cur[0];\\n            if (A[hi]>val) res[idx]=A[hi--];\\n            else res[idx]=A[lo++];\\n        }\\n        return res;\\n    }  \\n}\\n```\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->b[0]-a[0]);\\n        for (int i=0; i<B.length; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=A.length-1, res[] = new int[A.length];\\n        while(!pq.isEmpty()) res[pq.peek()[1]]=pq.poll()[0]<A[hi]?A[hi--]:A[lo++];\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n=A.length;\\n        int[] res= new int[n];\\n        PriorityQueue<int[]> pq= new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                return b[0]-a[0];\\n            }\\n        });\\n        for (int i=0; i<n; i++) pq.add(new int[]{B[i], i});\\n        int lo=0, hi=n-1;\\n        while(!pq.isEmpty()){\\n            int[] cur= pq.poll();\\n            int idx=cur[1], val=cur[0];\\n            if (A[hi]>val) res[idx]=A[hi--];\\n            else res[idx]=A[lo++];\\n        }\\n        return res;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149831,
                "title": "c-6-lines-greedy-o-n-log-n",
                "content": "For each B[i], we select the smallest number in A that is greater than B[i]. If there are no such number, we select the smalest number in A.\\n\\nI am usign multiset to sort and keep track of numbers in A. After a number is selected, we need to remove it from the multiset (erase by iterator takes a constant time).\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149842,
                "title": "python-greedy-solution-using-sort",
                "content": "# Explanation\\nSort `A`\\nFor every element `b` in B from big to small,\\nif `A[-1] > b`,\\nthen this `b` will take the biggest element in A by `A.pop()`.\\notherwise take the smallest in A by  `A.popleft()`\\n<br>\\n\\n\\n# Complexity\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Python3**\\n```py\\n    def advantageCount(self, A, B):\\n        A = deque(sorted(A))\\n        for b, i in sorted([-b, i] for i, b in enumerate(B)):\\n            B[i] = A.pop() if -b < A[-1] else A.popleft()\\n        return B\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def advantageCount(self, A, B):\\n        A = deque(sorted(A))\\n        for b, i in sorted([-b, i] for i, b in enumerate(B)):\\n            B[i] = A.pop() if -b < A[-1] else A.popleft()\\n        return B\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149840,
                "title": "c-java-greedy-solution-using-map",
                "content": "# Explanation\\nCount elements in `A` to a map `m`.\\nFor each element in `B`, find the least bigger element in map `m`.\\nOtherwise, we\\'ll take the smallest element.\\nThen we update the `m`.\\n<br>\\n\\n# Complexity\\nTime `O(NlogN)`\\nSpace `O(N)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s(begin(A), end(A));\\n        for (int i = 0; i < B.size(); ++i) {\\n            auto it = *s.rbegin() > B[i] ? s.upper_bound(B[i]) : s.begin();\\n            A[i] = *it;\\n            s.erase(it);\\n        }\\n        return A;\\n    }\\n```\\n**Java:**\\n```java\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for (int i : A) m.put(i, m.getOrDefault(i, 0) + 1);\\n        int[] res = new int[A.length];\\n        for (int i = 0; i < A.length; ++i) {\\n            Integer x = m.higherKey(B[i]);\\n            if (x == null) x = m.firstKey();\\n            m.put(x, m.get(x) - 1);\\n            if (m.get(x) == 0) m.remove(x);\\n            res[i] = x;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s(begin(A), end(A));\\n        for (int i = 0; i < B.size(); ++i) {\\n            auto it = *s.rbegin() > B[i] ? s.upper_bound(B[i]) : s.begin();\\n            A[i] = *it;\\n            s.erase(it);\\n        }\\n        return A;\\n    }\\n```\n```java\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for (int i : A) m.put(i, m.getOrDefault(i, 0) + 1);\\n        int[] res = new int[A.length];\\n        for (int i = 0; i < A.length; ++i) {\\n            Integer x = m.higherKey(B[i]);\\n            if (x == null) x = m.firstKey();\\n            m.put(x, m.get(x) - 1);\\n            if (m.get(x) == 0) m.remove(x);\\n            res[i] = x;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190310,
                "title": "explain-the-algorithm-and-concise-java-implementation",
                "content": "This is a generalization of the classic Chinese story of General Tian's Horse Race.\nhttps://en.wikipedia.org/wiki/Tian_Ji\n\nIn the original story there are only 3 numbers in each array and A[0] < B[0], A[1] < B[1], A[2] < B[2], how can A make a possible win?\n\nThe key mindset, is, instead of try to maximize the gain, try to minimize the loss.\n\nI will prove this strategy inline.\n\n```\npublic int[] advantageCount(int[] A, int[] B) {\n    // TJSM is the Chinese acronym for the original story\n    int[] TJSM = new int[A.length];\n\n    // Sort my hand to have an ordered horse quality\n    Arrays.sort(A);\n\t\t\n    // Use a max heap for my opponents to deal with his faster horse first\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[1] - a[1]);\n    for (int i = 0; i < B.length; i++) {\n        maxHeap.offer(new int[] {i, B[i]});\n    }\n\n    int slow = 0, fast = A.length - 1;\n    while (!maxHeap.isEmpty()) {\n        int[] b = maxHeap.poll();\n        // If my fastest horse remained is slower than my opponents' fastest horse,\n        // there is no way for me to win, use my slower horse.\n        // Otherwise use my fastest horse to win this round.\n        // Why using my second fastest horse won't improve my global scores?\n        // If my second fastest horse is faster than my opponents' fastest one,\n        // it sure is faster than the rest of his horse. Thus proved this strategy is\n        // optimal.\n        TJSM[b[0]] = b[1] >= A[fast] ? A[slow++] : A[fast--];\n    }\n\n    return TJSM;\n}\n```",
                "solutionTags": [],
                "code": "```\npublic int[] advantageCount(int[] A, int[] B) {\n    // TJSM is the Chinese acronym for the original story\n    int[] TJSM = new int[A.length];\n\n    // Sort my hand to have an ordered horse quality\n    Arrays.sort(A);\n\t\t\n    // Use a max heap for my opponents to deal with his faster horse first\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[1] - a[1]);\n    for (int i = 0; i < B.length; i++) {\n        maxHeap.offer(new int[] {i, B[i]});\n    }\n\n    int slow = 0, fast = A.length - 1;\n    while (!maxHeap.isEmpty()) {\n        int[] b = maxHeap.poll();\n        // If my fastest horse remained is slower than my opponents' fastest horse,\n        // there is no way for me to win, use my slower horse.\n        // Otherwise use my fastest horse to win this round.\n        // Why using my second fastest horse won't improve my global scores?\n        // If my second fastest horse is faster than my opponents' fastest one,\n        // it sure is faster than the rest of his horse. Thus proved this strategy is\n        // optimal.\n        TJSM[b[0]] = b[1] >= A[fast] ? A[slow++] : A[fast--];\n    }\n\n    return TJSM;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125119,
                "title": "python-greedy-solution-two-pointers-explained",
                "content": "The idea here is to sort `A` and `B` lists first and start with the biggest number from `B` and check if we can beat it with biggest number from `A`. If we can, do it and increase `beg` pointer. If no, than we need to choose the smallest number we have and we move `end` pointer. One difficulty here is that we need to keep order of data somehow, so we add indexes to `B` list. Then we create `ans` list and change corresponding element of it.\\n\\nTime complexity is `O(n log n)` to perform sorts and space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        n = len(A)\\n        B = sorted([(num, i) for i, num in enumerate(B)])[::-1]\\n        A = sorted(A)[::-1]\\n        ans = [-1]*n\\n        \\n        beg, end = 0, n - 1\\n        \\n        for num, ind in B:\\n            if A[beg] > num:\\n                ans[ind] = A[beg]\\n                beg += 1\\n            else:\\n                ans[ind] = A[end]\\n                end -= 1\\n                \\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        n = len(A)\\n        B = sorted([(num, i) for i, num in enumerate(B)])[::-1]\\n        A = sorted(A)[::-1]\\n        ans = [-1]*n\\n        \\n        beg, end = 0, n - 1\\n        \\n        for num, ind in B:\\n            if A[beg] > num:\\n                ans[ind] = A[beg]\\n                beg += 1\\n            else:\\n                ans[ind] = A[end]\\n                end -= 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125188,
                "title": "c-greedy-using-multiset-explained",
                "content": "Store all elements of array A in multiset.\\nFor each element *b* of array B, we find the first greater element than b in array A and push it in vector *v* and  if no such element is present then we push the smallest element of array A to vector *v* and remove it from A.\\n\\n\\n\\n**Time Complexity: O(nlogn)**\\n*code:*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b){\\n        multiset<int> s;\\n        vector<int> v;\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n        }\\n        for(int i=0;i<b.size();i++){\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end()){\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else{\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b){\\n        multiset<int> s;\\n        vector<int> v;\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n        }\\n        for(int i=0;i<b.size();i++){\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end()){\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else{\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125217,
                "title": "js-python-java-c-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe general principle here is easy to understand: for each value in **B**, we ideally want to pick a number from **A** that is *just* higher to match up against it. The naive way to do this would require sorting **A**, then iterating through it until we find the ideal number, then removing that number from **A** and moving it to the answer array (**ans**) at a **time complexity** of **O(n^2)**.\\n\\nWe could employ a **binary search** instead of a straight iteration, which would drop the overall time complexity to **O(n * log n)**, matching the sort time complexity. The issue that remains, however, is that getting rid of elements of **A** can be time-consuming. (*Note: This method actually works well in Python; see the code below.*)\\n\\nInstead, if we had a sorted **B** as well, we could just match up the values very easily in descending order. If the largest remaining value of **A** is larger than the largest remaining value of **B**, then use it, otherwise, use the smallest remaining value of **A**, which is the least useful.\\n\\nSince we need to return our answer matched up agains the original order of **B**, however, we can\\'t just sort **B**. We can, however, create an **index order lookup array** and sort it in reference to the values in **B**, then use it as a bridge between the sorted **A** and unsorted **B**.\\n\\nOnce we\\'ve finished iterating, we can **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript as usual should take advantage of the faster typed arrays here.\\n\\nPython can convert **A** to a **deque** when it sorts to speed up the removal of elements from both ends. (Thanks [**@gizmo707**](https://leetcode.com/gizmo707)!)\\n\\nAs noted above, Python also has a very short, competitively performant version using **bisect** and without needing to sort **B**.\\n\\nJava will have to use a basic sort on **A**, as it\\'s a primitive array, but we can make **ord** an Integer array so that we can use a **lambda** sort. That means we\\'ll have to swap **i** and **j**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **160ms / 47.8MB** (beats 100% / 70%).\\n```javascript\\nvar advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **308ms / 16.7MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```\\n\\n---\\n\\n#### ***Python Code w/ Binary Search:***\\n\\nThe best result for the code below is **344ms / 16.6MB** (beats 88% / 100%).\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, A = [], sorted(A)\\n        for num in B:\\n            val = bisect_right(A, num)\\n            ans.append(A.pop(0) if val == len(A) else A.pop(val))\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **25ms / 41.3MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **60ms / 33.4MB** (beats 99% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> ord = vector<int>(B.size()), ans = vector<int>(A.size());\\n        for (int i = 0; i < B.size(); i++) ord[i] = i;\\n        sort(ord.begin(), ord.end(), [&](int a, int b) {return B[a] > B[b];});\\n        sort(A.begin(), A.end(), greater<>());\\n        int i = 0, j = B.size() - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[i] > B[ix] ? A[i++] : A[j--];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, A = [], sorted(A)\\n        for num in B:\\n            val = bisect_right(A, num)\\n            ans.append(A.pop(0) if val == len(A) else A.pop(val))\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> ord = vector<int>(B.size()), ans = vector<int>(A.size());\\n        for (int i = 0; i < B.size(); i++) ord[i] = i;\\n        sort(ord.begin(), ord.end(), [&](int a, int b) {return B[a] > B[b];});\\n        sort(A.begin(), A.end(), greater<>());\\n        int i = 0, j = B.size() - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[i] > B[ix] ? A[i++] : A[j--];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149932,
                "title": "python-greedy-sol-with-detailed-comment-chinese-story-tian-ji-s-horse-race",
                "content": "```\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [None]*len(A)\\n        A = collections.deque(sorted(A))\\n        B = collections.deque(sorted([(B[i], i) for i in range(len(B))]))\\n        \\n        last = len(res)-1\\n        head = 0\\n        while A and B:\\n            a = A.popleft()\\n            b, idx = B.popleft()\\n            \\n            # if we can win by arrange our current weakeset fighter vs. enemy\\'s current weakest fighter:\\n            if a > b:   \\n                res[idx] = a  # arrange them to fight, we win, and get one advantage score\\n\\n            # if we will lose by arrange our current weakeset fighter vs. enemy\\'s current weakest fighter:\\n            else:\\n            \\t# put enemy\\'s current fighter back to their queue, we will try our next stronger fighter for him in next round\\n                B.appendleft((b, idx))   \\n                # arrange our current fighter to fight with enemy\\'s current strongest fighter, \\n                # although we will lose this round, but enemy also lose their most powerful fighter so far\\n                last = B.pop()[1]   \\n                res[last] = a\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [None]*len(A)\\n        A = collections.deque(sorted(A))\\n        B = collections.deque(sorted([(B[i], i) for i in range(len(B))]))\\n        \\n        last = len(res)-1\\n        head = 0\\n        while A and B:\\n            a = A.popleft()\\n            b, idx = B.popleft()\\n            \\n            # if we can win by arrange our current weakeset fighter vs. enemy\\'s current weakest fighter:\\n            if a > b:   \\n                res[idx] = a  # arrange them to fight, we win, and get one advantage score\\n\\n            # if we will lose by arrange our current weakeset fighter vs. enemy\\'s current weakest fighter:\\n            else:\\n            \\t# put enemy\\'s current fighter back to their queue, we will try our next stronger fighter for him in next round\\n                B.appendleft((b, idx))   \\n                # arrange our current fighter to fight with enemy\\'s current strongest fighter, \\n                # although we will lose this round, but enemy also lose their most powerful fighter so far\\n                last = B.pop()[1]   \\n                res[last] = a\\n\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1125220,
                "title": "advantage-shuffle-js-python-java-c-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe general principle here is easy to understand: for each value in **B**, we ideally want to pick a number from **A** that is *just* higher to match up against it. The naive way to do this would require sorting **A**, then iterating through it until we find the ideal number, then removing that number from **A** and moving it to the answer array (**ans**) at a **time complexity** of **O(n^2)**.\\n\\nWe could employ a **binary search** instead of a straight iteration, which would drop the overall time complexity to **O(n * log n)**, matching the sort time complexity. The issue that remains, however, is that getting rid of elements of **A** can be time-consuming. (*Note: This method actually works well in Python; see the code below.*)\\n\\nInstead, if we had a sorted **B** as well, we could just match up the values very easily in descending order. If the largest remaining value of **A** is larger than the largest remaining value of **B**, then use it, otherwise, use the smallest remaining value of **A**, which is the least useful.\\n\\nSince we need to return our answer matched up agains the original order of **B**, however, we can\\'t just sort **B**. We can, however, create an **index order lookup array** and sort it in reference to the values in **B**, then use it as a bridge between the sorted **A** and unsorted **B**.\\n\\nOnce we\\'ve finished iterating, we can **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript as usual should take advantage of the faster typed arrays here.\\n\\nPython can convert **A** to a **deque** when it sorts to speed up the removal of elements from both ends. (Thanks [**@gizmo707**](https://leetcode.com/gizmo707)!)\\n\\nAs noted above, Python also has a very short, competitively performant version using **bisect** and without needing to sort **B**.\\n\\nJava will have to use a basic sort on **A**, as it\\'s a primitive array, but we can make **ord** an Integer array so that we can use a **lambda** sort. That means we\\'ll have to swap **i** and **j**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **160ms / 47.8MB** (beats 100% / 70%).\\n```javascript\\nvar advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **308ms / 16.7MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```\\n\\n---\\n\\n#### ***Python Code w/ Binary Search:***\\n\\nThe best result for the code below is **344ms / 16.6MB** (beats 88% / 100%).\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, A = [], sorted(A)\\n        for num in B:\\n            val = bisect_right(A, num)\\n            ans.append(A.pop(0) if val == len(A) else A.pop(val))\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **25ms / 41.3MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **60ms / 33.4MB** (beats 99% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> ord = vector<int>(B.size()), ans = vector<int>(A.size());\\n        for (int i = 0; i < B.size(); i++) ord[i] = i;\\n        sort(ord.begin(), ord.end(), [&](int a, int b) {return B[a] > B[b];});\\n        sort(A.begin(), A.end(), greater<>());\\n        int i = 0, j = B.size() - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[i] > B[ix] ? A[i++] : A[j--];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, A = [], sorted(A)\\n        for num in B:\\n            val = bisect_right(A, num)\\n            ans.append(A.pop(0) if val == len(A) else A.pop(val))\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> ord = vector<int>(B.size()), ans = vector<int>(A.size());\\n        for (int i = 0; i < B.size(); i++) ord[i] = i;\\n        sort(ord.begin(), ord.end(), [&](int a, int b) {return B[a] > B[b];});\\n        sort(A.begin(), A.end(), greater<>());\\n        int i = 0, j = B.size() - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[i] > B[ix] ? A[i++] : A[j--];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406893,
                "title": "c-solution-o-nlogn-simple",
                "content": "```\\n       int n = A.size();\\n        if(n < 2 ) return A;\\n    \\n        sort(A.begin(), A.end());\\n        vector<pair<int,int>> C;\\n        for(int i=0; i<n; ++i)\\n            C.push_back( make_pair(B[i], i));    \\n        sort(C.begin(), C.end());\\n       \\n        int l = 0, r = n-1;\\n        vector<int> D(n); \\n        for(int i = n-1; i >=0; i--){\\n           if(A[r]<=C[i].first)\\n                D[C[i].second] = A[l++];\\n            else\\n                D[C[i].second] = A[r--];       \\n        }   \\n        return D;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n       int n = A.size();\\n        if(n < 2 ) return A;\\n    \\n        sort(A.begin(), A.end());\\n        vector<pair<int,int>> C;\\n        for(int i=0; i<n; ++i)\\n            C.push_back( make_pair(B[i], i));    \\n        sort(C.begin(), C.end());\\n       \\n        int l = 0, r = n-1;\\n        vector<int> D(n); \\n        for(int i = n-1; i >=0; i--){\\n           if(A[r]<=C[i].first)\\n                D[C[i].second] = A[l++];\\n            else\\n                D[C[i].second] = A[r--];       \\n        }   \\n        return D;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125212,
                "title": "short-easy-w-explanation-simple-greedy-o-nlogn",
                "content": "***Solution - I***\\n\\nThe problem asks us to maximize `A[i] > B[i]`. We can do this by choosing an element from `A` for every element of `B` such that element chosen from A is the smallest element greater than corresponding element from B.\\n\\nTo do this efficiently, we must sort the arrays `A` and `B`. After that, we must choose the elements for each index of B as stated above. The index of B for which `A[i] > B[i]` isn\\'t possible in solution are assigned at last (order doesn\\'t matter).\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(begin(A), end(A));\\n\\tvector<int> tmp = B;\\n\\tsort(begin(tmp), end(tmp));\\n\\tint idx1 = 0, idx2 = 0, n = size(A);\\n\\tunordered_map<int, vector<int> > mp;\\n\\twhile(idx1 < n)\\n\\t\\tif(A[idx1] > tmp[idx2]) mp[tmp[idx2++]].push_back(A[idx1]), A[idx1++] = -1;\\n\\t\\telse idx1++;\\n\\tfor(auto& num : A) if(num != -1) mp[tmp[idx2++]].push_back(num);\\n\\tidx2 = 0;\\n\\tfor(auto& num : B) tmp[idx2++] = mp[num].back(), mp[num].pop_back();\\n\\treturn tmp;\\n}\\n```\\n\\n**Time Complexity :** **`O(NlogN)`**, where `N` is the length of vectors `A/B`\\n**Space Complexity :** **`O(N)`**\\n\\n----------\\n----------\\n\\n***Solution - II***\\n\\nA better, more concise solution is to use multiset to solve the problem. We can keep track of the sorted elements of `A` and if any element of B is such that `A[i] > B[i]` is not possible, just assign it the smallest element available in the multiset. Every time an element is assigned and deleted.\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {        \\n\\tmultiset<int> s(begin(A), end(A));        \\n\\tfor(int i = 0; i < size(B); i++){\\n\\t\\tauto it = s.upper_bound(B[i]);\\n\\t\\tif(it == end(s)) it = begin(s);\\n\\t\\tB[i] = *it;\\n\\t\\ts.erase(it);\\n\\t}\\n\\treturn B;\\n}\\n```\\n\\n**Time Complexity :** **`O(NlogN)`**, where `N` is the length of vectors `A/B`.\\n**Space Complexity :** **`O(N)`**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(begin(A), end(A));\\n\\tvector<int> tmp = B;\\n\\tsort(begin(tmp), end(tmp));\\n\\tint idx1 = 0, idx2 = 0, n = size(A);\\n\\tunordered_map<int, vector<int> > mp;\\n\\twhile(idx1 < n)\\n\\t\\tif(A[idx1] > tmp[idx2]) mp[tmp[idx2++]].push_back(A[idx1]), A[idx1++] = -1;\\n\\t\\telse idx1++;\\n\\tfor(auto& num : A) if(num != -1) mp[tmp[idx2++]].push_back(num);\\n\\tidx2 = 0;\\n\\tfor(auto& num : B) tmp[idx2++] = mp[num].back(), mp[num].pop_back();\\n\\treturn tmp;\\n}\\n```\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {        \\n\\tmultiset<int> s(begin(A), end(A));        \\n\\tfor(int i = 0; i < size(B); i++){\\n\\t\\tauto it = s.upper_bound(B[i]);\\n\\t\\tif(it == end(s)) it = begin(s);\\n\\t\\tB[i] = *it;\\n\\t\\ts.erase(it);\\n\\t}\\n\\treturn B;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150122,
                "title": "java-greedy-solution-using-map-easy-to-read-and-understand",
                "content": "Idea is that we need a sorted structure that makes it easy to find a smallest number higher than B[i]. If no such number exists, you use your smallest number from A at that position to maximize our chances to find better positions later.\\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\t\\t\\t\\t\\n\\t    //Add each number to the map along with count\\n        for (int a : A) map.put(a, map.getOrDefault(a, 0)+1);\\n        \\n        int[] ret = new int[A.length];\\n        for (int i = 0; i < B.length; i++) {\\n            //Find the best number to beat B[i]\\n            ret[i] = findBestMatch(B[i], map);\\n        }\\n        return ret;\\n    }\\n    \\n    private int findBestMatch(int target, TreeMap<Integer, Integer> map) {\\n\\t\\t// See if there exists a number higher than the target\\n        Integer res = map.higherKey(target);\\n\\t\\t\\t\\t\\n\\t\\t// If a number higher than target does not exist, use the smalles available number\\n        if (res == null) res = map.firstKey();\\n\\t\\t\\t\\t\\n\\t\\t//Update the TreeMap, remove the key if the number has 0 remaining occurences\\n        map.put(res, map.get(res) - 1);\\n        if (map.get(res) == 0) map.remove(res);\\n\\t\\t\\t\\t\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\t\\t\\t\\t\\n\\t    //Add each number to the map along with count\\n        for (int a : A) map.put(a, map.getOrDefault(a, 0)+1);\\n        \\n        int[] ret = new int[A.length];\\n        for (int i = 0; i < B.length; i++) {\\n            //Find the best number to beat B[i]\\n            ret[i] = findBestMatch(B[i], map);\\n        }\\n        return ret;\\n    }\\n    \\n    private int findBestMatch(int target, TreeMap<Integer, Integer> map) {\\n\\t\\t// See if there exists a number higher than the target\\n        Integer res = map.higherKey(target);\\n\\t\\t\\t\\t\\n\\t\\t// If a number higher than target does not exist, use the smalles available number\\n        if (res == null) res = map.firstKey();\\n\\t\\t\\t\\t\\n\\t\\t//Update the TreeMap, remove the key if the number has 0 remaining occurences\\n        map.put(res, map.get(res) - 1);\\n        if (map.get(res) == 0) map.remove(res);\\n\\t\\t\\t\\t\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125451,
                "title": "2-solution-custom-sort-with-two-pointer-treemap",
                "content": "**Custom Sorting**\\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        int[][] C = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            C[i][0] = B[i];\\n            C[i][1] = i;\\n        }\\n        \\n        Arrays.sort(C, (a, b) -> b[0] - a[0]);\\n        \\n        int[] result = new int[n];\\n        int lo = 0, hi = n - 1;\\n        for(int i = 0; i < n; i++) {\\n            if(A[hi] > C[i][0])\\n                result[C[i][1]] = A[hi--];\\n            else\\n                result[C[i][1]] = A[lo++];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n************\\n**TreeMap**\\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        for (int a : A)\\n            treeMap.put(a, treeMap.getOrDefault(a, 0) + 1);\\n        int[] result = new int[A.length];\\n        for (int i = 0; i < B.length; i++) {\\n            Integer higher = treeMap.higherKey(B[i]);\\n            if (higher == null)\\n                higher = treeMap.firstKey();\\n            treeMap.put(higher, treeMap.get(higher) - 1);\\n            if (treeMap.get(higher) == 0)\\n                treeMap.remove(higher);\\n            result[i] = higher;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        int[][] C = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            C[i][0] = B[i];\\n            C[i][1] = i;\\n        }\\n        \\n        Arrays.sort(C, (a, b) -> b[0] - a[0]);\\n        \\n        int[] result = new int[n];\\n        int lo = 0, hi = n - 1;\\n        for(int i = 0; i < n; i++) {\\n            if(A[hi] > C[i][0])\\n                result[C[i][1]] = A[hi--];\\n            else\\n                result[C[i][1]] = A[lo++];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        for (int a : A)\\n            treeMap.put(a, treeMap.getOrDefault(a, 0) + 1);\\n        int[] result = new int[A.length];\\n        for (int i = 0; i < B.length; i++) {\\n            Integer higher = treeMap.higherKey(B[i]);\\n            if (higher == null)\\n                higher = treeMap.firstKey();\\n            treeMap.put(higher, treeMap.get(higher) - 1);\\n            if (treeMap.get(higher) == 0)\\n                treeMap.remove(higher);\\n            result[i] = higher;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125173,
                "title": "c-super-simple-and-easy-7-line-solution",
                "content": "First, we sort A.\\nThen, for each element in B, we insert in the result the least bigger element from A.\\nIf B[i] is bigger than the biggest value in A, there\\'s no way we can get a bigger element, so we\\'ll insert the smallest element from A.\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> res;\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < B.size(); i++) {\\n            auto it = A.back() > B[i] ? upper_bound(A.begin(), A.end(), B[i]) : A.begin();\\n            res.push_back(*it);\\n            A.erase(it);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> res;\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < B.size(); i++) {\\n            auto it = A.back() > B[i] ? upper_bound(A.begin(), A.end(), B[i]) : A.begin();\\n            res.push_back(*it);\\n            A.erase(it);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125210,
                "title": "advantage-shuffle-short-easy-w-explanation",
                "content": "***Solution - I***\\n\\nThe problem asks us to maximize `A[i] > B[i]`. We can do this by choosing an element from `A` for every element of `B` such that element chosen from A is the smallest element greater than corresponding element from B.\\n\\nTo do this efficiently, we must sort the arrays `A` and `B`. After that, we must choose the elements for each index of B as stated above. The index of B for which `A[i] > B[i]` isn\\'t possible in solution are assigned at last (order doesn\\'t matter).\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(begin(A), end(A));\\n\\tvector<int> tmp = B;\\n\\tsort(begin(tmp), end(tmp));\\n\\tint idx1 = 0, idx2 = 0, n = size(A);\\n\\tunordered_map<int, vector<int> > mp;\\n\\twhile(idx1 < n)\\n\\t\\tif(A[idx1] > tmp[idx2]) mp[tmp[idx2++]].push_back(A[idx1]), A[idx1++] = -1;\\n\\t\\telse idx1++;\\n\\tfor(auto& num : A) if(num != -1) mp[tmp[idx2++]].push_back(num);\\n\\tidx2 = 0;\\n\\tfor(auto& num : B) tmp[idx2++] = mp[num].back(), mp[num].pop_back();\\n\\treturn tmp;\\n}\\n```\\n\\n**Time Complexity :** **`O(NlogN)`**, where `N` is the length of vectors `A/B`\\n**Space Complexity :** **`O(N)`**\\n\\n----------\\n----------\\n\\n***Solution - II***\\n\\nA better, more concise solution is to use multiset to solve the problem. We can keep track of the sorted elements of `A` and if any element of B is such that `A[i] > B[i]` is not possible, just assign it the smallest element available in the multiset. Every time an element is assigned and deleted.\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {        \\n\\tmultiset<int> s(begin(A), end(A));        \\n\\tfor(int i = 0; i < size(B); i++){\\n\\t\\tauto it = s.upper_bound(B[i]);\\n\\t\\tif(it == end(s)) it = begin(s);\\n\\t\\tB[i] = *it;\\n\\t\\ts.erase(it);\\n\\t}\\n\\treturn B;\\n}\\n```\\n\\n**Time Complexity :** **`O(NlogN)`**, where `N` is the length of vectors `A/B`.\\n**Space Complexity :** **`O(N)`**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(begin(A), end(A));\\n\\tvector<int> tmp = B;\\n\\tsort(begin(tmp), end(tmp));\\n\\tint idx1 = 0, idx2 = 0, n = size(A);\\n\\tunordered_map<int, vector<int> > mp;\\n\\twhile(idx1 < n)\\n\\t\\tif(A[idx1] > tmp[idx2]) mp[tmp[idx2++]].push_back(A[idx1]), A[idx1++] = -1;\\n\\t\\telse idx1++;\\n\\tfor(auto& num : A) if(num != -1) mp[tmp[idx2++]].push_back(num);\\n\\tidx2 = 0;\\n\\tfor(auto& num : B) tmp[idx2++] = mp[num].back(), mp[num].pop_back();\\n\\treturn tmp;\\n}\\n```\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {        \\n\\tmultiset<int> s(begin(A), end(A));        \\n\\tfor(int i = 0; i < size(B); i++){\\n\\t\\tauto it = s.upper_bound(B[i]);\\n\\t\\tif(it == end(s)) it = begin(s);\\n\\t\\tB[i] = *it;\\n\\t\\ts.erase(it);\\n\\t}\\n\\treturn B;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126314,
                "title": "java-simple-and-easy-to-understand-solution-27-ms-faster-than-94-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        \\n        //store the element of B, and their corresponding index\\n        List<Item> itemBList = new ArrayList();\\n        for(int i = 0; i < A.length; i++){\\n            itemBList.add(new Item(i, B[i]));\\n        }\\n        \\n        //sort Array A increasing order\\n        Arrays.sort(A); \\n        \\n        //sort Array B increasing order, without loosing their index\\n        Collections.sort(itemBList, (a, b) -> (a.val - b.val));\\n        \\n        //make new array, and fill -1\\n        int[] result = new int[A.length];\\n        Arrays.fill(result, -1);\\n        \\n        List<Integer> remainingVal = new ArrayList();\\n        int i = 0;\\n        int j = 0;\\n        \\n        /*\\n            Gready Appraoch\\n            sort A, and B (wihout losing its index) increasing oreder of their value\\n            case \\n                if element at A[i], is greater than  itemBList.get(j), \\n                - just place A[i] in the right index itemBList.get(j).index\\n                otherwise \\n                -  just store in the remaining  array\\n        */\\n        \\n        \\n        while(i < A.length && j < A.length){\\n            if(A[i] > itemBList.get(j).val){\\n                //place the elemet of A, in the right place\\n                result[itemBList.get(j).index] = A[i];\\n                \\n                //move to next element for both A, and B\\n                i++;\\n                j++;\\n            }else{\\n                remainingVal.add(A[i]);\\n                \\n                //move to the next A item\\n                i++;\\n            }\\n        }\\n        \\n        //store the remaining elemet\\n        j = 0;\\n        for(i = 0; i < A.length && j < remainingVal.size(); i++){\\n            if(result[i] == -1){\\n                result[i] = remainingVal.get(j++);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n}\\n\\nclass Item {\\n    int index;\\n    int val;\\n    public Item(int index, int val){\\n        this.index = index;\\n        this.val = val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        \\n        //store the element of B, and their corresponding index\\n        List<Item> itemBList = new ArrayList();\\n        for(int i = 0; i < A.length; i++){\\n            itemBList.add(new Item(i, B[i]));\\n        }\\n        \\n        //sort Array A increasing order\\n        Arrays.sort(A); \\n        \\n        //sort Array B increasing order, without loosing their index\\n        Collections.sort(itemBList, (a, b) -> (a.val - b.val));\\n        \\n        //make new array, and fill -1\\n        int[] result = new int[A.length];\\n        Arrays.fill(result, -1);\\n        \\n        List<Integer> remainingVal = new ArrayList();\\n        int i = 0;\\n        int j = 0;\\n        \\n        /*\\n            Gready Appraoch\\n            sort A, and B (wihout losing its index) increasing oreder of their value\\n            case \\n                if element at A[i], is greater than  itemBList.get(j), \\n                - just place A[i] in the right index itemBList.get(j).index\\n                otherwise \\n                -  just store in the remaining  array\\n        */\\n        \\n        \\n        while(i < A.length && j < A.length){\\n            if(A[i] > itemBList.get(j).val){\\n                //place the elemet of A, in the right place\\n                result[itemBList.get(j).index] = A[i];\\n                \\n                //move to next element for both A, and B\\n                i++;\\n                j++;\\n            }else{\\n                remainingVal.add(A[i]);\\n                \\n                //move to the next A item\\n                i++;\\n            }\\n        }\\n        \\n        //store the remaining elemet\\n        j = 0;\\n        for(i = 0; i < A.length && j < remainingVal.size(); i++){\\n            if(result[i] == -1){\\n                result[i] = remainingVal.get(j++);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n}\\n\\nclass Item {\\n    int index;\\n    int val;\\n    public Item(int index, int val){\\n        this.index = index;\\n        this.val = val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164319,
                "title": "java-two-pointer-solution-without-using-treemap",
                "content": "What if both A and B are sorted? Then it could be solved by two-pointer like below:\\n\\n```\\nint[] res = new int[A.length];\\nint l = 0, r = res.length - 1;\\nfor (int idxA = 0, idxB = 0; idxA < A.length; idxA++) {\\n    if (A[idxA] > B[idxB]) {\\n        res[l] = A[idxA];\\n        idxB++;\\n        l++;\\n    } else {\\n        res[r] = A[idxA];\\n        r--;\\n    }\\n}\\nreturn res;\\n```\\n\\nBut for this problem, we cannot sort B. So let\\'s create an array for the indices of B, and sort it by the corresponding values in B. Then we could apply the two-pointer solution:\\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        \\n        Integer[] bIdxArr = new Integer[B.length];\\n        for (int i = 0; i < bIdxArr.length; i++) {\\n            bIdxArr[i] = i;\\n        }\\n        Arrays.sort(bIdxArr, (a, b) -> (B[a] - B[b]));\\n        \\n        int[] res = new int[A.length];\\n        int l = 0, r = res.length - 1;\\n        for (int idxA = 0, idxB = 0; idxA < A.length; idxA++) {\\n            if (A[idxA] > B[bIdxArr[idxB]]) {\\n                res[bIdxArr[l]] = A[idxA];\\n                idxB++;\\n                l++;\\n            } else {\\n                res[bIdxArr[r]] = A[idxA];\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint[] res = new int[A.length];\\nint l = 0, r = res.length - 1;\\nfor (int idxA = 0, idxB = 0; idxA < A.length; idxA++) {\\n    if (A[idxA] > B[idxB]) {\\n        res[l] = A[idxA];\\n        idxB++;\\n        l++;\\n    } else {\\n        res[r] = A[idxA];\\n        r--;\\n    }\\n}\\nreturn res;\\n```\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        \\n        Integer[] bIdxArr = new Integer[B.length];\\n        for (int i = 0; i < bIdxArr.length; i++) {\\n            bIdxArr[i] = i;\\n        }\\n        Arrays.sort(bIdxArr, (a, b) -> (B[a] - B[b]));\\n        \\n        int[] res = new int[A.length];\\n        int l = 0, r = res.length - 1;\\n        for (int idxA = 0, idxB = 0; idxA < A.length; idxA++) {\\n            if (A[idxA] > B[bIdxArr[idxB]]) {\\n                res[bIdxArr[l]] = A[idxA];\\n                idxB++;\\n                l++;\\n            } else {\\n                res[bIdxArr[r]] = A[idxA];\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783387,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126749,
                "title": "c-greedy-multiset-approach-o-nlogn",
                "content": "Since we want to maximize number of indices i such that A[i] > B[i] we can greedily choose values while iterating vector B.\\n\\nApproach: \\n* Insert all the elements of vector A inside a multiset\\n* for each element in B try to find a suitable element in A using upper_bound which takes time complexity of O(logn) since multiset is stores elements in sorted order.\\n* If for an index we cannot find a proper value in mutliset we will skip the index and fill it up later with remainig values.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        multiset<int> a (A.begin(), A.end());\\n        \\n        vector<int> answer(A.size(),-1);\\n        \\n        for(int i = 0 ; i < A.size() ; i++) {\\n            auto it = a.upper_bound(B[i]);\\n            if(it != a.end()) {\\n                answer[i] = *it;\\n                a.erase(it);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < A.size() ; i++) {\\n            if(answer[i] == -1) {\\n                answer[i] = *(a.begin());\\n                a.erase(a.begin());\\n            }\\n        }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        multiset<int> a (A.begin(), A.end());\\n        \\n        vector<int> answer(A.size(),-1);\\n        \\n        for(int i = 0 ; i < A.size() ; i++) {\\n            auto it = a.upper_bound(B[i]);\\n            if(it != a.end()) {\\n                answer[i] = *it;\\n                a.erase(it);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < A.size() ; i++) {\\n            if(answer[i] == -1) {\\n                answer[i] = *(a.begin());\\n                a.erase(a.begin());\\n            }\\n        }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126365,
                "title": "c-upper-bound-solution-with-comments",
                "content": "**Explaination**\\n\\nA = [2,7,11,15]\\nB = [1,10,4,11]\\n\\nIt is mentioned in the question we requrie a permutation of A. So, we should start iterating in B. To get advantage we have to find greater element than current element of B from A. This defination is equivalent to Upper Bound. Upper Bound will return index of element which is greater than given element. If index is out of bound it means we are unable to find the element. So, we should remove first i.e. smallest element of A (as we required to sort A for upper bound),\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());  // Sorting A so that we can apply upper bound\\n        int n=B.size();  // Storing initial size of A and size of B\\n        vector<int> ans; // Defining ans vector which we are going to return\\n        for(int i=0;i<n;i++){\\n            int arr_size=A.size(); // Calculating size of A \\n            int ind=upper_bound(A.begin(),A.end(),B[i])-A.begin(); //Applying upper bound on vector A\\n            if(ind<arr_size){  // If index is within range of valid index of A it means we can get advantage\\n                ans.push_back(A[ind]); // Pushing element into ans vector\\n                A.erase(A.begin()+ind); // Removing element from vector A as we have used that element\\n            }\\n            else{\\n                ans.push_back(A[0]); // If we don\\'t have greater element in A we should take smallest element from A so that we can use other greter element for other elements\\' advantage as we require as many greater element as possible \\n                A.erase(A.begin()); // Removing smallest element from Vector A\\n            }\\n        }\\n        return ans; // Returning answer vector\\n    }\\n};\\n```\\n\\nIf like please upvote :)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());  // Sorting A so that we can apply upper bound\\n        int n=B.size();  // Storing initial size of A and size of B\\n        vector<int> ans; // Defining ans vector which we are going to return\\n        for(int i=0;i<n;i++){\\n            int arr_size=A.size(); // Calculating size of A \\n            int ind=upper_bound(A.begin(),A.end(),B[i])-A.begin(); //Applying upper bound on vector A\\n            if(ind<arr_size){  // If index is within range of valid index of A it means we can get advantage\\n                ans.push_back(A[ind]); // Pushing element into ans vector\\n                A.erase(A.begin()+ind); // Removing element from vector A as we have used that element\\n            }\\n            else{\\n                ans.push_back(A[0]); // If we don\\'t have greater element in A we should take smallest element from A so that we can use other greter element for other elements\\' advantage as we require as many greater element as possible \\n                A.erase(A.begin()); // Removing smallest element from Vector A\\n            }\\n        }\\n        return ans; // Returning answer vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125203,
                "title": "c-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());\\n        vector<int> C;\\n        C=B;\\n        sort(B.begin(),B.end());\\n        vector<int> ans;\\n        map<int,vector<int>> w;\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        int k=B.size()-1;\\n        while(j<B.size() && i<A.size()){\\n            if(A[i]>B[j]){\\n                count+=1;\\n                w[B[j]].push_back(A[i]);\\n                i+=1;\\n                j+=1;\\n            }\\n            else{\\n                w[B[k]].push_back(A[i]);\\n                i+=1;\\n                k-=1;\\n                \\n            }\\n            \\n        }\\n        for(auto i:C){\\n            ans.push_back(w[i][w[i].size()-1]);\\n            w[i].pop_back();\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());\\n        vector<int> C;\\n        C=B;\\n        sort(B.begin(),B.end());\\n        vector<int> ans;\\n        map<int,vector<int>> w;\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        int k=B.size()-1;\\n        while(j<B.size() && i<A.size()){\\n            if(A[i]>B[j]){\\n                count+=1;\\n                w[B[j]].push_back(A[i]);\\n                i+=1;\\n                j+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1125073,
                "title": "advantage-shuffle-c-solution-easy-to-understand-with-explanation",
                "content": "The idea is to find the smallest greater number in `A` for every number in `B`. If there is no element greater in `A`, we take smallest number from `A`. \\n**using multiset**:\\nSo, here we use the multiset, we traverse `B` and find the `upperbound` for every number in `B`.removing element from multiset takes `O(1) time` since we are removing using iterator.\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s;\\n        for(int n:A) s.insert(n);\\n        for(int i = 0; i < B.size();i++) {\\n            auto p =  s.upper_bound(B[i]);\\n            if(p == s.end()) p =s.begin();\\n            A[i] = *p;\\n            s.erase(p);\\n        }\\n      return A;\\n    }\\n```\\n\\n**using vector**:\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<pair<int, int>> v;\\n\\t    for(int i=0; i<B.size(); i++)\\n            v.push_back({B[i], i});\\n\\t    sort(A.begin(), A.end());\\n\\t    sort(v.begin(), v.end());\\n        int k = A.size()-1;\\n\\t    for (int i=0,j=0;i<A.size();i++) {\\n\\t\\t    if(A[i] > v[j].first){\\n                B[v[j].second] = A[i];\\n                j++;\\n            }else{\\n                B[v[k].second] = A[i];\\n                k--;\\n            } \\n\\t    }\\n        return B;\\n    }\\n```\\n**Do Upvote** if you find it helpful!!!",
                "solutionTags": [],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s;\\n        for(int n:A) s.insert(n);\\n        for(int i = 0; i < B.size();i++) {\\n            auto p =  s.upper_bound(B[i]);\\n            if(p == s.end()) p =s.begin();\\n            A[i] = *p;\\n            s.erase(p);\\n        }\\n      return A;\\n    }\\n```\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<pair<int, int>> v;\\n\\t    for(int i=0; i<B.size(); i++)\\n            v.push_back({B[i], i});\\n\\t    sort(A.begin(), A.end());\\n\\t    sort(v.begin(), v.end());\\n        int k = A.size()-1;\\n\\t    for (int i=0,j=0;i<A.size();i++) {\\n\\t\\t    if(A[i] > v[j].first){\\n                B[v[j].second] = A[i];\\n                j++;\\n            }else{\\n                B[v[k].second] = A[i];\\n                k--;\\n            } \\n\\t    }\\n        return B;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591514,
                "title": "simple-c-code-greedy",
                "content": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\n\\tvector<pair<int, int>> C;\\n\\tfor (int i = 0; i < B.size(); ++i) C.push_back({B[i], i});\\n\\tsort(A.begin(), A.end());\\n\\tsort(C.begin(), C.end());\\n\\n\\tfor (int i = 0, j = 0, k = A.size() - 1; i < A.size(); ++i) {\\n\\t\\tif (A[i] > C[j].first) B[C[j].second] = A[i], ++j;\\n\\t\\telse B[C[k].second] = A[i], --k;\\n\\t}\\n\\n\\treturn B;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\n\\tvector<pair<int, int>> C;\\n\\tfor (int i = 0; i < B.size(); ++i) C.push_back({B[i], i});\\n\\tsort(A.begin(), A.end());\\n\\tsort(C.begin(), C.end());\\n\\n\\tfor (int i = 0, j = 0, k = A.size() - 1; i < A.size(); ++i) {\\n\\t\\tif (A[i] > C[j].first) B[C[j].second] = A[i], ++j;\\n\\t\\telse B[C[k].second] = A[i], --k;\\n\\t}\\n\\n\\treturn B;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236924,
                "title": "greedy-solution-without-using-map",
                "content": "The idea is to sort the indices of array B based on the elements.\\nThen compare the sorted array A with sorted array B. Because \\nwe keep the original indices of array B, we know where the value should be put\\nin output array.\\n\\n```java\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        Integer[] C = new Integer[B.length];\\n        for(int i = 0; i < C.length; i++) {\\n            C[i] = i;\\n        }\\n        Arrays.sort(C, new Comparator<Integer>() {\\n            @Override\\n            public int compare(Integer o1, Integer o2) {\\n                return B[o1] - B[o2];\\n            }\\n        });\\n        Arrays.sort(A);\\n        int i = 0, j = A.length - 1, k = C.length - 1;\\n        while(i <= j) {\\n           if (A[j] > B[C[k]]) {\\n               result[C[k]] = A[j--];\\n           } else {\\n               result[C[k]] = A[i++];\\n           }\\n            k--;  \\n        }\\n        return result;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        Integer[] C = new Integer[B.length];\\n        for(int i = 0; i < C.length; i++) {\\n            C[i] = i;\\n        }\\n        Arrays.sort(C, new Comparator<Integer>() {\\n            @Override\\n            public int compare(Integer o1, Integer o2) {\\n                return B[o1] - B[o2];\\n            }\\n        });\\n        Arrays.sort(A);\\n        int i = 0, j = A.length - 1, k = C.length - 1;\\n        while(i <= j) {\\n           if (A[j] > B[C[k]]) {\\n               result[C[k]] = A[j--];\\n           } else {\\n               result[C[k]] = A[i++];\\n           }\\n            k--;  \\n        }\\n        return result;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2837204,
                "title": "advantage-shuffling-by-using-multiset-approach",
                "content": "Step 1 : change array into multiset -->it become sorted have rich function also\\nStep 2 : search the greater element in multiset  for given b[i] by multiset :: upper_bound(iterator)\\nStep 3 : if found --> store in new array and erase that element by multiset :: erase(iterator) ,otherwise store beginnning element of multiset in new array   and erase then ;\\nStep 4 :  return the new array\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b)\\n    {\\n        multiset<int> s;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<b.size();i++)\\n        {\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end())\\n            {\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else\\n            {\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b)\\n    {\\n        multiset<int> s;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<b.size();i++)\\n        {\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end())\\n            {\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else\\n            {\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282817,
                "title": "swap-greedily-detailed-explanation-c",
                "content": "I have not yet checked the discussion section but my approach is basically this :\\n\\n0. Map the elements of nums2 with its indices as it would be useful for step 3.\\n\\n1. Sort both the arrays.\\n\\n2. Now, start selecting elements from nums2. \\n**The goal is to select the smallest element in nums1 beating nums2[i] - if I find one, I will swap nums1[i] with that element, else I won\\'t swap and end the loop.**\\n\\n3. Now just map the elements of the resultant nums1 array according to the oiginal nums2 array.\\n\\n***Now, the question is, why does this algorithm work?***\\n\\nSuppose we are checking element at position i - that means that all the elements before index i have been optimally paired, and need not be modified.\\n\\nSo, we need to find an element between index i and len - 1 in nums1, which is larger than nums2[i], we must also ensure that the element we are choosing is the least among the greater elements, else we might lose advantage later. For instance, we have arrays :\\nnums1 = [2,7,11,15]\\nnums2 = [1,10,4,11]\\n\\nWhile considering index 0, I will select element 2 here. Why? Suppose, we choose 15 to pair with 1, then we would won\\'t have any element to pair and gain advantage over 11.\\nSimilar issue with choosing 7 or 11.\\n\\n***What if I don\\'t find any greater element in nums1? Why should I break out of the loop?***\\n\\nAs already stated, all elements in nums1 before index i are already at their optimal positions, modifying them is unnecessary. If we don\\'t find an element greater than nums2[i] in nums1[i] to nums1[-1], we won\\'t be finding any element greater than nums2[i], even in the later iterations as nums2 is already sorted in the ascending order.\\nSo, we won\\'t be having any \"advantage\" later in the loop, so break out of the loop.\\n\\nTime complexity - O(n log n) same as the sorting time.\\n\\nHere is the code :\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n    \\n        map<int , set<int>> mp;\\n        for(int i = 0 ; i < nums1.size(); i++){\\n            mp[nums2[i]].insert(i);\\n        }\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int n = nums1.size();\\n        \\n        vector<int> res(n , 0);\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n\\t\\t\\tauto a = upper_bound(nums1.begin() + i, nums1.end(), nums2[i]);                                       int x = a - nums1.begin();\\n            \\n            if(x < n){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[x];\\n                nums1[x] = temp;               \\n            }\\n            \\n            else \\n                break;\\n\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            int pos = *(mp[nums2[i]].begin());\\n            \\n            mp[nums2[i]].erase(pos);\\n            \\n            res[pos] = nums1[i];\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n  \\n};\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n    \\n        map<int , set<int>> mp;\\n        for(int i = 0 ; i < nums1.size(); i++){\\n            mp[nums2[i]].insert(i);\\n        }\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int n = nums1.size();\\n        \\n        vector<int> res(n , 0);\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n\\t\\t\\tauto a = upper_bound(nums1.begin() + i, nums1.end(), nums2[i]);                                       int x = a - nums1.begin();\\n            \\n            if(x < n){\\n                int temp = nums1[i];\\n                nums1[i] = nums1[x];\\n                nums1[x] = temp;               \\n            }\\n            \\n            else \\n                break;\\n\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            int pos = *(mp[nums2[i]].begin());\\n            \\n            mp[nums2[i]].erase(pos);\\n            \\n            res[pos] = nums1[i];\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126094,
                "title": "c-greedy-sorting-two-pointers-beats-100-easy-to-understand",
                "content": "```\\npublic class Solution {\\n\\tpublic int[] AdvantageCount(int[] A, int[] B) {\\n        var N = A.Length;\\n        var idxs = new int[N]; // indices from 0..N-1\\n        for(int i=N-1; i>= 0; --i)\\n            idxs[i] = i;\\n        \\n        Array.Sort(B, idxs); // sort B in ascending order, keeping the original order into idxs\\n        Array.Sort(A); // sort A in ascending order\\n        \\n\\t\\tvar L = 0; // pointer to \"minimum\" value in A\\n        var R = N-1; // pointer to \"maximum\" value in A\\n        var result = new int[N];\\n        for(int i=N-1; i>= 0; --i)\\n        {\\n            if(B[i] >= A[R])\\n            {\\n\\t\\t\\t\\t// greedy approach: assign minimum value from A (and move \"minimum\" pointer to the right)\\n\\t\\t\\t\\t// and map current \"i\" position into original B position\\n                result[idxs[i]] = A[L++];\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// greedy approach: assign maximum value from A (and move \"maximum\" pointer to the left)\\n\\t\\t\\t\\t// and map current \"i\" position into original B position\\n                result[idxs[i]] = A[R--];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n\\tpublic int[] AdvantageCount(int[] A, int[] B) {\\n        var N = A.Length;\\n        var idxs = new int[N]; // indices from 0..N-1\\n        for(int i=N-1; i>= 0; --i)\\n            idxs[i] = i;\\n        \\n        Array.Sort(B, idxs); // sort B in ascending order, keeping the original order into idxs\\n        Array.Sort(A); // sort A in ascending order\\n        \\n\\t\\tvar L = 0; // pointer to \"minimum\" value in A\\n        var R = N-1; // pointer to \"maximum\" value in A\\n        var result = new int[N];\\n        for(int i=N-1; i>= 0; --i)\\n        {\\n            if(B[i] >= A[R])\\n            {\\n\\t\\t\\t\\t// greedy approach: assign minimum value from A (and move \"minimum\" pointer to the right)\\n\\t\\t\\t\\t// and map current \"i\" position into original B position\\n                result[idxs[i]] = A[L++];\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// greedy approach: assign maximum value from A (and move \"maximum\" pointer to the left)\\n\\t\\t\\t\\t// and map current \"i\" position into original B position\\n                result[idxs[i]] = A[R--];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125740,
                "title": "javascript-simple-two-pointer-greedy-approach",
                "content": "Time: `O(N log N)`\\nSpace: `O(N)`\\n```javascript\\nvar advantageCount = function(A, B) {\\n    const mapB = B.map((n, i) => [n, i]);\\n    const len = A.length;\\n    const output = [];\\n    const useless = []\\n    \\n    A.sort((a, b) => a - b);\\n    mapB.sort((a, b) => a[0] - b[0]);\\n    \\n    let currB = 0;\\n    \\n    for(let i = 0; i < len; i++) {\\n        const [numB, idxB] = mapB[currB];\\n        \\n        if(numB >= A[i]) useless.push(A[i]);\\n        else {\\n            output[idxB] = A[i];\\n            currB++;\\n        }\\n    }\\n    \\n    for(let i = 0; i < len; i++) {\\n        if(output[i] === undefined) {\\n            output[i] = useless.pop();\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```javascript\\nvar advantageCount = function(A, B) {\\n    const mapB = B.map((n, i) => [n, i]);\\n    const len = A.length;\\n    const output = [];\\n    const useless = []\\n    \\n    A.sort((a, b) => a - b);\\n    mapB.sort((a, b) => a[0] - b[0]);\\n    \\n    let currB = 0;\\n    \\n    for(let i = 0; i < len; i++) {\\n        const [numB, idxB] = mapB[currB];\\n        \\n        if(numB >= A[i]) useless.push(A[i]);\\n        else {\\n            output[idxB] = A[i];\\n            currB++;\\n        }\\n    }\\n    \\n    for(let i = 0; i < len; i++) {\\n        if(output[i] === undefined) {\\n            output[i] = useless.pop();\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125177,
                "title": "simple-and-intuitive-solution-using-multiset-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\t\\t// why multiset not set ? Duplicates ?\\n        multiset<int> set(begin(A),end(A));\\n\\t\\t// answer array !\\n        vector<int> ans(n,0);\\n\\t\\t// ans[i] => 0 means answer for this index is not yet discovered \\n\\t\\t// find upper bound of every element of B in multiset of A .... why ? coz A[i] > B[i]\\n        for(int i=0;i<n;i++){\\n            auto find = set.upper_bound(B[i]);\\n\\t\\t\\t// if got an upper bound then use it and erase it !\\n            if(find!=set.end()){\\n                ans[i]=*find;\\n\\t\\t\\t\\t// deletes only that particular element not all it\\'s occurrence.\\n                set.erase(find);\\n            }\\n        }\\n\\t\\t// if there are still some elements left ... put all of them in remaining space !\\n        if(set.size()){\\n            auto it = set.begin();\\n            for(int i=0;i<n;i++){\\n                if(!ans[i]){\\n                    ans[i] = *it;\\n                    it++;\\n                }\\n            }\\n        }\\n\\t\\t// hurray, we made it !\\n        return ans;\\n    }\\n};\\n```\\n```\\nLet\\'s talk About Time and Space complexity : \\nTC : O(NlogN) \\nSC : O(N) \\n```\\nDo Upvote if you liked it !",
                "solutionTags": [
                    "Binary Search",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\t\\t// why multiset not set ? Duplicates ?\\n        multiset<int> set(begin(A),end(A));\\n\\t\\t// answer array !\\n        vector<int> ans(n,0);\\n\\t\\t// ans[i] => 0 means answer for this index is not yet discovered \\n\\t\\t// find upper bound of every element of B in multiset of A .... why ? coz A[i] > B[i]\\n        for(int i=0;i<n;i++){\\n            auto find = set.upper_bound(B[i]);\\n\\t\\t\\t// if got an upper bound then use it and erase it !\\n            if(find!=set.end()){\\n                ans[i]=*find;\\n\\t\\t\\t\\t// deletes only that particular element not all it\\'s occurrence.\\n                set.erase(find);\\n            }\\n        }\\n\\t\\t// if there are still some elements left ... put all of them in remaining space !\\n        if(set.size()){\\n            auto it = set.begin();\\n            for(int i=0;i<n;i++){\\n                if(!ans[i]){\\n                    ans[i] = *it;\\n                    it++;\\n                }\\n            }\\n        }\\n\\t\\t// hurray, we made it !\\n        return ans;\\n    }\\n};\\n```\n```\\nLet\\'s talk About Time and Space complexity : \\nTC : O(NlogN) \\nSC : O(N) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 920672,
                "title": "java-treemap",
                "content": "```\\nclass Solution {\\n\\n    public int[] advantageCount(int[] A, int[] B) {\\n\\t\\n\\t    //Use TreeMap to sort\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        for (int a : A) {\\n            tm.put(a, tm.getOrDefault(a, 0) + 1);\\n        }\\n        \\n        for(int i=0; i<B.length; i++) {\\n            int val = B[i];\\n\\t\\t\\t\\n\\t\\t\\t//find the higher value\\n            Integer tmp = tm.ceilingKey(val+1);\\n\\t\\t\\t//if no higher value, use the least key\\n            if(tmp == null) {\\n                tmp = tm.firstKey();\\n            }\\n\\t\\t\\t//store to results\\n            A[i] = tmp;\\n\\t\\t\\t\\n\\t\\t\\t//reduce key count or remove when 0\\n            int cnt = tm.get(tmp);\\n            if(cnt > 1) {\\n                tm.put(tmp, cnt-1);\\n            } else {\\n                tm.remove(tmp);\\n            }\\n            \\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int[] advantageCount(int[] A, int[] B) {\\n\\t\\n\\t    //Use TreeMap to sort\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n        for (int a : A) {\\n            tm.put(a, tm.getOrDefault(a, 0) + 1);\\n        }\\n        \\n        for(int i=0; i<B.length; i++) {\\n            int val = B[i];\\n\\t\\t\\t\\n\\t\\t\\t//find the higher value\\n            Integer tmp = tm.ceilingKey(val+1);\\n\\t\\t\\t//if no higher value, use the least key\\n            if(tmp == null) {\\n                tmp = tm.firstKey();\\n            }\\n\\t\\t\\t//store to results\\n            A[i] = tmp;\\n\\t\\t\\t\\n\\t\\t\\t//reduce key count or remove when 0\\n            int cnt = tm.get(tmp);\\n            if(cnt > 1) {\\n                tm.put(tmp, cnt-1);\\n            } else {\\n                tm.remove(tmp);\\n            }\\n            \\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843628,
                "title": "python-3-greedy-two-pointers-explanations",
                "content": "### Explanation\\n- Intuitively, we can see that, for A, to make the most advantage over B is to use large number cover large number, small number to cover small number, if possible. e.g.\\n\\t- `A = [5, 9]`, `B = [4, 8]`, we can easily tell, 5 covers 4, 9 covers 8\\n\\t- but if we switch the order, we noticed that 9 covers 4, but 5 can\\'t cover 8\\n- Given the thought above, we simply sort `A` & `B` (reversely, from large to small)\\n- Iterate over `B`, \\n\\t- if current `A[j]` covers current `B[i]`\\n\\t\\t- we take it, meaning assign `A[j]` at the original index (`ori_idx`) of `B[i]` \\n\\t\\t- then increment `j`, meaning use next largest number in `A`\\n\\t- otherwise, meaning `B[i]` is too large for the current maximum available `A[j]`, so check whether next number (`B[i+1]`) can be covered by `A[j]`\\n- After we iterate over `B`, there might have some original index wasn\\'t assigned (because it\\'s possible that not all values is B was covered)\\n\\t- Simply iterate over `ans`, if we meet a `-1` (meaning wasn\\'t assigned), then assign the rest value in A to them\\n### Implementation\\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        sorted_a = sorted(A, reverse=True)                                         # descending order\\n        sorted_b = sorted(enumerate(B), key=lambda x: (x[1], x[0]), reverse=True)  # descending order with original index\\n        n, j = len(B), 0\\n        ans = [-1] * n\\n        for i, (ori_idx, val) in enumerate(sorted_b):                 # A greedily tries to cover value in B as large as possible\\n            if sorted_a[j] > val: ans[ori_idx], j = sorted_a[j], j+1\\n        for i in range(n):                                            # assign rest value in A to ans\\n            if ans[i] == -1: ans[i], j = sorted_a[j], j+1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        sorted_a = sorted(A, reverse=True)                                         # descending order\\n        sorted_b = sorted(enumerate(B), key=lambda x: (x[1], x[0]), reverse=True)  # descending order with original index\\n        n, j = len(B), 0\\n        ans = [-1] * n\\n        for i, (ori_idx, val) in enumerate(sorted_b):                 # A greedily tries to cover value in B as large as possible\\n            if sorted_a[j] > val: ans[ori_idx], j = sorted_a[j], j+1\\n        for i in range(n):                                            # assign rest value in A to ans\\n            if ans[i] == -1: ans[i], j = sorted_a[j], j+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694392,
                "title": "javascript-o-nlog-n-time-o-n-space-beats-90",
                "content": "```\\nvar advantageCount = function(A, B) {\\n    //first, map indices within B to their values\\n    const bMap = {};\\n    for (let i = 0; i < B.length; i++) {\\n        const num = B[i];\\n        if (!bMap[num]) bMap[num] = [];\\n        bMap[num].push(i);\\n    }\\n    \\n    //initialize output array\\n    let output = new Array(A.length).fill(null);\\n    \\n    //sort both arrays largest to smallest\\n    A.sort((a, b) => b - a);\\n    B.sort((a, b) => b - a);\\n    \\n    //tracking indices avoids time penalties of shifting array.\\n    let aStart = 0;\\n    let aEnd = A.length - 1;\\n    let bStart = 0;\\n    \\n    //If largest remaining A can beat largest remaining B, let it.\\n    //Otherwise, pair largest remaining B with smallest remaining A.\\n    while (aStart <= aEnd) {\\n        const aMax = A[aStart];\\n        const aMin = A[aEnd];\\n        const bMax = B[bStart];\\n        const bCoord = bMap[bMax].pop();\\n        if (aMax > bMax) {\\n            output[bCoord] = aMax;\\n            aStart ++;\\n        } else {\\n            output[bCoord] = aMin;\\n            aEnd --;\\n        }\\n        bStart ++;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar advantageCount = function(A, B) {\\n    //first, map indices within B to their values\\n    const bMap = {};\\n    for (let i = 0; i < B.length; i++) {\\n        const num = B[i];\\n        if (!bMap[num]) bMap[num] = [];\\n        bMap[num].push(i);\\n    }\\n    \\n    //initialize output array\\n    let output = new Array(A.length).fill(null);\\n    \\n    //sort both arrays largest to smallest\\n    A.sort((a, b) => b - a);\\n    B.sort((a, b) => b - a);\\n    \\n    //tracking indices avoids time penalties of shifting array.\\n    let aStart = 0;\\n    let aEnd = A.length - 1;\\n    let bStart = 0;\\n    \\n    //If largest remaining A can beat largest remaining B, let it.\\n    //Otherwise, pair largest remaining B with smallest remaining A.\\n    while (aStart <= aEnd) {\\n        const aMax = A[aStart];\\n        const aMin = A[aEnd];\\n        const bMax = B[bStart];\\n        const bCoord = bMap[bMax].pop();\\n        if (aMax > bMax) {\\n            output[bCoord] = aMax;\\n            aStart ++;\\n        } else {\\n            output[bCoord] = aMin;\\n            aEnd --;\\n        }\\n        bStart ++;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151736,
                "title": "python-solution-nlog-n-time-complexity-with-a-b-space",
                "content": "```\\nfrom collections import defaultdict\\n    \\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = sorted(A)\\n        b = sorted(B)\\n        j = 0 \\n        hm = defaultdict(list)\\n        no_matches = []\\n        for i in range(len(a)):\\n            if a[i] > b[j]:\\n                hm[b[j]].append(a[i])\\n                j += 1\\n            else:\\n                no_matches.append(a[i])\\n        return [ hm[n].pop() if n in hm and len(hm[n]) > 0 else no_matches.pop() for n in B ]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n    \\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = sorted(A)\\n        b = sorted(B)\\n        j = 0 \\n        hm = defaultdict(list)\\n        no_matches = []\\n        for i in range(len(a)):\\n            if a[i] > b[j]:\\n                hm[b[j]].append(a[i])\\n                j += 1\\n            else:\\n                no_matches.append(a[i])\\n        return [ hm[n].pop() if n in hm and len(hm[n]) > 0 else no_matches.pop() for n in B ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149865,
                "title": "python-using-sort",
                "content": "```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        B0=[[i,B[i],0] for i in range(len(B))]\\n        A.sort()\\n        B0.sort(key=lambda x:x[1])\\n        p2=0\\n        wasted=1\\n        for p1 in A:\\n            if p1>B0[p2][1]:\\n                B0[p2][2]=p1\\n                p2+=1\\n            else:\\n                B0[-wasted][2]=p1\\n                wasted+=1\\n        B0.sort(key=lambda x:x[0])\\n\\t\\t\\t\\t\\n        return [i[2] for i in B0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        B0=[[i,B[i],0] for i in range(len(B))]\\n        A.sort()\\n        B0.sort(key=lambda x:x[1])\\n        p2=0\\n        wasted=1\\n        for p1 in A:\\n            if p1>B0[p2][1]:\\n                B0[p2][2]=p1\\n                p2+=1\\n            else:\\n                B0[-wasted][2]=p1\\n                wasted+=1\\n        B0.sort(key=lambda x:x[0])\\n\\t\\t\\t\\t\\n        return [i[2] for i in B0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499371,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        vector<int>res(n,-1);\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[j].first<nums1[i])\\n            {\\n                res[v[j].second]=nums1[i];\\n                nums1[i]=-1;\\n                j++;\\n            }\\n        }\\n        j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i]!=-1)\\n            {\\n                while(res[j]!=-1)\\n                {\\n                    j++;\\n                }\\n                res[j]=nums1[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        from collections import deque\\n        q = deque(sorted(nums1))\\n        n = len(nums1)\\n        order = sorted(range(n), key=lambda x: nums2[x], reverse=True)\\n        res = [0] * n\\n        for idx in order:\\n            if q[-1] > nums2[idx]:\\n                res[idx] = q.pop()\\n            else:\\n                res[idx] = q.popleft()\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        int[] ans = new int[n];\\n        boolean[] vis = new boolean[n];\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int ub = upperBound(nums1, nums2[i]);\\n            if(ub!=n && vis[ub]==false){\\n                 ans[i] = nums1[ub];\\n                 vis[ub] = true;\\n            }\\n            else if(ub<n-1 && vis[ub]==true){\\n                while(ub<n && vis[ub]==true){\\n                    ub++;\\n                }\\n                if(ub==n){\\n                    arr.add(i);\\n                }\\n                else{\\n                     ans[i] = nums1[ub];\\n                     vis[ub]=true;\\n                }\\n            }\\n            else{\\n              arr.add(i);\\n            }\\n        }\\n        int j=0;\\n        for(int x: arr){\\n            while(j<n && vis[j]==true){\\n                j++;\\n            }\\n            ans[x]=nums1[j];\\n            vis[j]=true;\\n        }\\n        return ans;\\n    }\\n    public int upperBound(int[] nums, int target){\\n        int low = 0;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]<=target){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        vector<int>res(n,-1);\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[j].first<nums1[i])\\n            {\\n                res[v[j].second]=nums1[i];\\n                nums1[i]=-1;\\n                j++;\\n            }\\n        }\\n        j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i]!=-1)\\n            {\\n                while(res[j]!=-1)\\n                {\\n                    j++;\\n                }\\n                res[j]=nums1[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        from collections import deque\\n        q = deque(sorted(nums1))\\n        n = len(nums1)\\n        order = sorted(range(n), key=lambda x: nums2[x], reverse=True)\\n        res = [0] * n\\n        for idx in order:\\n            if q[-1] > nums2[idx]:\\n                res[idx] = q.pop()\\n            else:\\n                res[idx] = q.popleft()\\n        return res\\n```\n```Java []\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        int[] ans = new int[n];\\n        boolean[] vis = new boolean[n];\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int ub = upperBound(nums1, nums2[i]);\\n            if(ub!=n && vis[ub]==false){\\n                 ans[i] = nums1[ub];\\n                 vis[ub] = true;\\n            }\\n            else if(ub<n-1 && vis[ub]==true){\\n                while(ub<n && vis[ub]==true){\\n                    ub++;\\n                }\\n                if(ub==n){\\n                    arr.add(i);\\n                }\\n                else{\\n                     ans[i] = nums1[ub];\\n                     vis[ub]=true;\\n                }\\n            }\\n            else{\\n              arr.add(i);\\n            }\\n        }\\n        int j=0;\\n        for(int x: arr){\\n            while(j<n && vis[j]==true){\\n                j++;\\n            }\\n            ans[x]=nums1[j];\\n            vis[j]=true;\\n        }\\n        return ans;\\n    }\\n    public int upperBound(int[] nums, int target){\\n        int low = 0;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]<=target){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574032,
                "title": "only-simple-sorting-without-heap-or-multiset-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>&a, pair<int,int>&b){\\n        return a.second < b.second;\\n    }\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        sort(nums1.begin(), nums1.end());\\n        vector<pair<int,int>>v;\\n        for(int i = 0; i < n ; i++){\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int>vis(n,0);\\n        int i = 0;\\n        int j = 0;\\n        while( j < n && i < n){\\n            if(nums1[i] > v[j].first){\\n                v[j].first = nums1[i];\\n                vis[i] = 1;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        i = 0;\\n        while( j < n){\\n            if(vis[i] == 0){\\n                v[j].first = nums1[i];\\n                j++;\\n            }\\n            i++;\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        vector<int> ans;\\n        for(auto &x:v)\\n            ans.push_back(x.first);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>&a, pair<int,int>&b){\\n        return a.second < b.second;\\n    }\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        sort(nums1.begin(), nums1.end());\\n        vector<pair<int,int>>v;\\n        for(int i = 0; i < n ; i++){\\n            v.push_back({nums2[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int>vis(n,0);\\n        int i = 0;\\n        int j = 0;\\n        while( j < n && i < n){\\n            if(nums1[i] > v[j].first){\\n                v[j].first = nums1[i];\\n                vis[i] = 1;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        i = 0;\\n        while( j < n){\\n            if(vis[i] == 0){\\n                v[j].first = nums1[i];\\n                j++;\\n            }\\n            i++;\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        vector<int> ans;\\n        for(auto &x:v)\\n            ans.push_back(x.first);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491265,
                "title": "sort",
                "content": "**greedy**\\n**time: `O(NlogN)`; space: `O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/baeb977b-a7f1-4f70-ba82-0e7dcba741f9_1661636280.332966.png)\\n\\n![image](https://assets.leetcode.com/users/images/8628aaf7-2640-4351-8763-5d9377ce1afe_1661637931.9426262.png)\\n\\n![image](https://assets.leetcode.com/users/images/3f0cacf8-5e77-4b77-85ec-b879173e0b28_1661637080.2531178.png)\\n\\n```\\nvector<int> advantageCount(vector<int>& n, vector<int>& m) \\n{\\n\\tvector<int> i(size(n)), out(size(n));\\n\\tiota(begin(i), end(i), 0); \\n\\tsort(begin(n), end(n));\\n\\tsort(begin(i), end(i), [&](auto & x, auto & y){ return m[x]<m[y]; });\\n\\n\\tfor(int b{}, e(size(n)); const auto & x : n)\\n\\t\\tout[i[m[i[b]]<x ? b++ : --e]] = x; \\n\\treturn out;\\n}\\n```\\n**Notation:**\\n\\n`i` - **i**ndices;\\n`b` - **b**egin;\\n`e` - **e**nd.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& n, vector<int>& m) \\n{\\n\\tvector<int> i(size(n)), out(size(n));\\n\\tiota(begin(i), end(i), 0); \\n\\tsort(begin(n), end(n));\\n\\tsort(begin(i), end(i), [&](auto & x, auto & y){ return m[x]<m[y]; });\\n\\n\\tfor(int b{}, e(size(n)); const auto & x : n)\\n\\t\\tout[i[m[i[b]]<x ? b++ : --e]] = x; \\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2362809,
                "title": "simple-and-short-c-solution",
                "content": "1)The idea here is to push the elements of nums1 to map \\n2)Use upper bound to find the immediate greater element\\n3)If no greater element found  for that given index,the answer for the given index would be the smallest existing element of nums1\\n4)Remove that element from map,once pushed to ans vector to avoid it being taken more than once\\n\\n\\n\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++)m[nums1[i]]++;\\n         \\n        for(int i=0;i<nums2.size();i++){\\n            \\n            auto it=m.upper_bound(nums2[i]);\\n          \\n            if(it==m.end()){// in case no larger element is found,we put the smallest element as our ans for that given index\\n                int t=m.begin()->first;\\n                ans.push_back(t);\\n               m[t]--;\\n                if(m[t]==0)m.erase(t);\\n            }\\n            else{\\n                int t=it->first;\\n               ans.push_back(t);\\n                m[t]--;\\n                if(m[t]==0)m.erase(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\'\\'\\'\\n\\nDo upvote if you like the solution:)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "1)The idea here is to push the elements of nums1 to map \\n2)Use upper bound to find the immediate greater element\\n3)If no greater element found  for that given index,the answer for the given index would be the smallest existing element of nums1\\n4)Remove that element from map,once pushed to ans vector to avoid it being taken more than once\\n\\n\\n\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++)m[nums1[i]]++;\\n         \\n        for(int i=0;i<nums2.size();i++){\\n            \\n            auto it=m.upper_bound(nums2[i]);\\n          \\n            if(it==m.end()){// in case no larger element is found,we put the smallest element as our ans for that given index\\n                int t=m.begin()->first;\\n                ans.push_back(t);\\n               m[t]--;\\n                if(m[t]==0)m.erase(t);\\n            }\\n            else{\\n                int t=it->first;\\n               ans.push_back(t);\\n                m[t]--;\\n                if(m[t]==0)m.erase(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\'\\'\\'\\n\\nDo upvote if you like the solution:)",
                "codeTag": "Unknown"
            },
            {
                "id": 2246818,
                "title": "c",
                "content": "vector<int> advantageCount(vector<int>& arr, vector<int>& arr2) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size(),i;\\n        vector<int>ans(n,-1);\\n        unordered_map<int,vector<int>>mp;\\n        for ( i = 0; i < n; i++)\\n        {\\n            mp[arr2[i]].push_back(i);\\n        }\\n        sort(arr2.begin(),arr2.end());\\n\\n         i=0;\\n         int j=0;\\n         vector<int>temp;\\n         while (i<n)\\n         {\\n            if (arr[i]>arr2[j])\\n            {\\n                int x=mp[arr2[j]].back();\\n                mp[arr2[j]].pop_back();\\n                ans[x]=arr[i];\\n                i++,j++;\\n               \\n            }\\n            else\\n            {\\n                temp.push_back(arr[i]);\\n                i++;\\n            }\\n            \\n            \\n         }\\n         j=0;\\n         for ( i = 0; i < n; i++)\\n         {\\n            if (ans[i]==-1)\\n            {\\n                ans[i]=temp[j];\\n                j++;\\n            }\\n            \\n         }\\n         \\n         \\n        return ans;\\n\\n        \\n    }",
                "solutionTags": [],
                "code": "vector<int> advantageCount(vector<int>& arr, vector<int>& arr2) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size(),i;\\n        vector<int>ans(n,-1);\\n        unordered_map<int,vector<int>>mp;\\n        for ( i = 0; i < n; i++)\\n        {\\n            mp[arr2[i]].push_back(i);\\n        }\\n        sort(arr2.begin(),arr2.end());\\n\\n         i=0;\\n         int j=0;\\n         vector<int>temp;\\n         while (i<n)\\n         {\\n            if (arr[i]>arr2[j])\\n            {\\n                int x=mp[arr2[j]].back();\\n                mp[arr2[j]].pop_back();\\n                ans[x]=arr[i];\\n                i++,j++;\\n               \\n            }\\n            else\\n            {\\n                temp.push_back(arr[i]);\\n                i++;\\n            }\\n            \\n            \\n         }\\n         j=0;\\n         for ( i = 0; i < n; i++)\\n         {\\n            if (ans[i]==-1)\\n            {\\n                ans[i]=temp[j];\\n                j++;\\n            }\\n            \\n         }\\n         \\n         \\n        return ans;\\n\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1860873,
                "title": "c-easy-to-understand-simple-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n\\n**Using vector (Gives TLE)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> t;\\n        for(auto num:nums1)\\n        {\\n            t.push_back(num);\\n        }\\n        sort(t.begin(),t.end());\\n        vector<int> ans;\\n        int k=0;\\n        for(auto num:nums2)\\n        {\\n            auto upper=upper_bound(t.begin()+k,t.end(),num);\\n            if(upper!=t.end())\\n            {\\n                ans.push_back(*upper);\\n                t.erase(upper);\\n            }\\n            else\\n            {\\n                ans.push_back(*(t.begin()+k));\\n                t.erase(t.begin()+k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Using Multi-set**\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        multiset<int> t;\\n        for(auto num:nums1)\\n        {\\n            t.insert(num);\\n        }\\n        vector<int> ans;\\n        for(auto num:nums2)\\n        {\\n            auto upper=t.upper_bound(num);\\n            if(upper!=t.end())\\n            {\\n                ans.push_back(*upper);\\n                t.erase(upper);\\n            }\\n            else\\n            {\\n                ans.push_back(*t.begin());\\n                t.erase(t.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> t;\\n        for(auto num:nums1)\\n        {\\n            t.push_back(num);\\n        }\\n        sort(t.begin(),t.end());\\n        vector<int> ans;\\n        int k=0;\\n        for(auto num:nums2)\\n        {\\n            auto upper=upper_bound(t.begin()+k,t.end(),num);\\n            if(upper!=t.end())\\n            {\\n                ans.push_back(*upper);\\n                t.erase(upper);\\n            }\\n            else\\n            {\\n                ans.push_back(*(t.begin()+k));\\n                t.erase(t.begin()+k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        multiset<int> t;\\n        for(auto num:nums1)\\n        {\\n            t.insert(num);\\n        }\\n        vector<int> ans;\\n        for(auto num:nums2)\\n        {\\n            auto upper=t.upper_bound(num);\\n            if(upper!=t.end())\\n            {\\n                ans.push_back(*upper);\\n                t.erase(upper);\\n            }\\n            else\\n            {\\n                ans.push_back(*t.begin());\\n                t.erase(t.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496555,
                "title": "c-super-simple-using-two-pointer-just-compare-and-update",
                "content": "```\\n/* \\nwe will think of greater element first i.e. :-\\nif(max(A)>max(B)) then we\\'ll update maximum[B]=maximum[A], else  maximum[B]=minimum[A] \\n*/\\n\\nclass Solution {\\npublic:\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n         int n = A.size();\\n        if(n < 2 ) return A;\\n    \\n        sort(A.begin(), A.end());\\n        vector<pair<int,int>> C;\\n        for(int i=0; i<n; ++i)\\n            C.push_back( make_pair(B[i], i));    \\n        sort(C.begin(), C.end());\\n       \\n        int l = 0, r = n-1;\\n        vector<int> D(n); \\n        for(int i = n-1; i >=0; i--){\\n           if(A[r]<=C[i].first)\\n                D[C[i].second] = A[l++];  \\n            else\\n                D[C[i].second] = A[r--];       \\n        }   \\n        return D;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n/* \\nwe will think of greater element first i.e. :-\\nif(max(A)>max(B)) then we\\'ll update maximum[B]=maximum[A], else  maximum[B]=minimum[A] \\n*/\\n\\nclass Solution {\\npublic:\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n         int n = A.size();\\n        if(n < 2 ) return A;\\n    \\n        sort(A.begin(), A.end());\\n        vector<pair<int,int>> C;\\n        for(int i=0; i<n; ++i)\\n            C.push_back( make_pair(B[i], i));    \\n        sort(C.begin(), C.end());\\n       \\n        int l = 0, r = n-1;\\n        vector<int> D(n); \\n        for(int i = n-1; i >=0; i--){\\n           if(A[r]<=C[i].first)\\n                D[C[i].second] = A[l++];  \\n            else\\n                D[C[i].second] = A[r--];       \\n        }   \\n        return D;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280974,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        //we need to maintain the nums1 in sorted order\\n        //for every ele in nums2 get the next greater ele in nums1;\\n        \\n        multiset<int> s(nums1.begin(),nums1.end());\\n        \\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            //if the last element in set is greater than current element\\n            //then we can be sure to get a upper bound\\n            //if not we place the first element (smallest element) \\n             auto it= *s.rbegin()>nums2[i] ? s.upper_bound(nums2[i]) : s.begin();\\n            nums1[i]= *it;\\n            s.erase(it);\\n        }\\n        return nums1;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        //we need to maintain the nums1 in sorted order\\n        //for every ele in nums2 get the next greater ele in nums1;\\n        \\n        multiset<int> s(nums1.begin(),nums1.end());\\n        \\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            //if the last element in set is greater than current element\\n            //then we can be sure to get a upper bound\\n            //if not we place the first element (smallest element) \\n             auto it= *s.rbegin()>nums2[i] ? s.upper_bound(nums2[i]) : s.begin();\\n            nums1[i]= *it;\\n            s.erase(it);\\n        }\\n        return nums1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147578,
                "title": "c-using-multiset-and-upper-bound-probably-the-most-intuitive",
                "content": "O(nlogn): The idea is simple, take a multiset and store all the values of A. Then perform binary search to find element just greater than B[i]. If one such element is found, remove this from the multiset, and continue. \\nAfter that, there will be some positions in B for which we were unable to find any greater element, so add the remaining values of the multiset into the result. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset <int> aset; \\n        for(auto x:A) aset.insert(x); \\n        int n = B.size(); \\n        vector<int> out(n, -1);\\n        for(int i=0; i <n ; i++){\\n            auto it = aset.upper_bound(B[i]); \\n            if(it!= aset.end()) out[i] = (*it), aset.erase(it); \\n        }\\n        for(int i=0; i <n ; i++){\\n            if(out[i] == -1) out[i] = *(aset.cbegin()), aset.erase(aset.cbegin()); \\n        }\\n        return out ; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset <int> aset; \\n        for(auto x:A) aset.insert(x); \\n        int n = B.size(); \\n        vector<int> out(n, -1);\\n        for(int i=0; i <n ; i++){\\n            auto it = aset.upper_bound(B[i]); \\n            if(it!= aset.end()) out[i] = (*it), aset.erase(it); \\n        }\\n        for(int i=0; i <n ; i++){\\n            if(out[i] == -1) out[i] = *(aset.cbegin()), aset.erase(aset.cbegin()); \\n        }\\n        return out ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130646,
                "title": "java-treemap-bst-o-n-log-n",
                "content": "**idea**\\n\\n* For each B[i], it is advantageous to pick the smallest number from A that is higher than B[i].\\n* If such number does not exist, we just pick the lowest number from A.\\n\\nWe can use `TreeSet` to make those queries efficient.\\n\\n**code**\\n\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n = A.length;\\n        int m = B.length;\\n        if (n != m) {\\n            throw new IllegalArgumentException(\"the inputs have different lengths.\");\\n        }\\n        \\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\\n        for (int num : A) {\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            Integer cur = counts.higherKey(B[i]);\\n            if (cur == null) {\\n                cur = counts.firstKey();\\n            }\\n            \\n            ans[i] = cur;\\n            \\n            if (counts.get(cur) == 1) {\\n                counts.remove(cur);\\n            } else {\\n                counts.put(cur, counts.get(cur) - 1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**analysis**\\n\\nLet N = |A|\\n\\n* Time complexity: ~O(NlogN)\\n* Space complexity: ~O(N)",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Ordered Set"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n = A.length;\\n        int m = B.length;\\n        if (n != m) {\\n            throw new IllegalArgumentException(\"the inputs have different lengths.\");\\n        }\\n        \\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\\n        for (int num : A) {\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            Integer cur = counts.higherKey(B[i]);\\n            if (cur == null) {\\n                cur = counts.firstKey();\\n            }\\n            \\n            ans[i] = cur;\\n            \\n            if (counts.get(cur) == 1) {\\n                counts.remove(cur);\\n            } else {\\n                counts.put(cur, counts.get(cur) - 1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126215,
                "title": "c-heap-based-in-place-solution-explained-99-time-65-space",
                "content": "This was a fun one to solve; I went to use 2 `priotity_queues`; maybe thee is an even better way, but it performed rather well for me.\\n\\nFirst of all I declared an external constant variable `lmt` to store the upperbound of our input, which will also double as our increment later on.\\n\\nInside the main function, we are going to declare a few support variables:\\n* `len` will store the length of our input vectors (guaranteed to be always the same);\\n* `curr` is where we will store the current top of the heap;\\n* `qa` is going to be a `priority_queue` of values from `a`, in increasing order;\\n* `qa` is going to be a `priority_queue` of pairs of values from `b` and their matching index, in increasing order.\\n\\nWe will first of all go to populate `qa` and `qb` and mentioned above.\\n\\nWe will then have a man loop where we will:\\n* assign the smallest element in `qa` to `curr`;\\n* if `curr` is bigger than the `qb.top().first` (ie: we have an advantage) or `curr >= lmt` (ie: it is an element we already saw and sent to the bottom), we will:\\n\\t* if we come from an already seen value, then we will subtract `lmt` from it again;\\n\\t* we will update `a` to be `curr` at the index stored in `qb.top().second`;\\n\\t* finally, we will pop from both `qa` and `qb`;\\n* otherwise we will:\\n\\t* increase `curr` by `lmt` (to mark it as already seen);\\n\\t* pop its previous value from `qa`,\\n\\t* add it back into `qa` (where it will go at the bottom).\\n\\nOnce done, we can return `a`.\\n\\nThe code:\\n\\n```cpp\\nusing qpair = pair<int, int>;\\n\\nstatic constexpr int lmt = 1e9;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        // support variables\\n        int len = a.size(), curr;\\n        priority_queue<int, vector<int>, greater<int>> qa;\\n        priority_queue<qpair, vector<qpair>, greater<qpair>> qb;\\n        // populating qa and qb\\n        for (int i = 0; i < len; i ++) {\\n            qa.push(a[i]);\\n            qb.push({b[i], i});\\n        }\\n        while (qa.size()) {\\n            curr = qa.top();\\n            // qa is a good fit\\n            if (curr > qb.top().first || curr >= lmt) {\\n                // restoring curr if it was sent to the end of the heap\\n                if (curr >= lmt) curr -= lmt;\\n                // updating a\\n                a[qb.top().second] = curr;\\n                // moving on with qa and qb\\n                qa.pop(), qb.pop();\\n            }\\n            // sending unfit elements to the back;\\n            else {\\n                curr += lmt;\\n                qa.pop();\\n                qa.push(curr);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\\n\\nAlternative version without the incrementing/decrementing trick, just storing the non fitting values in another `priority_queue`, apparently with little to no gain in performance:\\n\\n```cpp\\nusing qpair = pair<int, int>;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        // support variables\\n        int len = a.size(), curr;\\n        priority_queue<int, vector<int>, greater<int>> qa, leftovers;\\n        priority_queue<qpair, vector<qpair>, greater<qpair>> qb;\\n        // populating qa and qb\\n        for (int i = 0; i < len; i ++) {\\n            qa.push(a[i]);\\n            qb.push({b[i], i});\\n        }\\n        while (qa.size()) {\\n            curr = qa.top();\\n            // curr is a good fit\\n            if (curr > qb.top().first) {\\n                // updating a\\n                a[qb.top().second] = curr;\\n                // moving on with qa and qb\\n                qa.pop(), qb.pop();\\n            }\\n            // sending unfit elements to leftovers;\\n            else {\\n                leftovers.push(curr);\\n                qa.pop();\\n            }\\n        }\\n        // assigning the leftovers\\n        while (leftovers.size()) {\\n            curr = leftovers.top();\\n            // updating a\\n            a[qb.top().second] = curr;\\n            // moving on with leftovers and qb\\n            leftovers.pop(), qb.pop();\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nusing qpair = pair<int, int>;\\n\\nstatic constexpr int lmt = 1e9;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        // support variables\\n        int len = a.size(), curr;\\n        priority_queue<int, vector<int>, greater<int>> qa;\\n        priority_queue<qpair, vector<qpair>, greater<qpair>> qb;\\n        // populating qa and qb\\n        for (int i = 0; i < len; i ++) {\\n            qa.push(a[i]);\\n            qb.push({b[i], i});\\n        }\\n        while (qa.size()) {\\n            curr = qa.top();\\n            // qa is a good fit\\n            if (curr > qb.top().first || curr >= lmt) {\\n                // restoring curr if it was sent to the end of the heap\\n                if (curr >= lmt) curr -= lmt;\\n                // updating a\\n                a[qb.top().second] = curr;\\n                // moving on with qa and qb\\n                qa.pop(), qb.pop();\\n            }\\n            // sending unfit elements to the back;\\n            else {\\n                curr += lmt;\\n                qa.pop();\\n                qa.push(curr);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\n```cpp\\nusing qpair = pair<int, int>;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        // support variables\\n        int len = a.size(), curr;\\n        priority_queue<int, vector<int>, greater<int>> qa, leftovers;\\n        priority_queue<qpair, vector<qpair>, greater<qpair>> qb;\\n        // populating qa and qb\\n        for (int i = 0; i < len; i ++) {\\n            qa.push(a[i]);\\n            qb.push({b[i], i});\\n        }\\n        while (qa.size()) {\\n            curr = qa.top();\\n            // curr is a good fit\\n            if (curr > qb.top().first) {\\n                // updating a\\n                a[qb.top().second] = curr;\\n                // moving on with qa and qb\\n                qa.pop(), qb.pop();\\n            }\\n            // sending unfit elements to leftovers;\\n            else {\\n                leftovers.push(curr);\\n                qa.pop();\\n            }\\n        }\\n        // assigning the leftovers\\n        while (leftovers.size()) {\\n            curr = leftovers.top();\\n            // updating a\\n            a[qb.top().second] = curr;\\n            // moving on with leftovers and qb\\n            leftovers.pop(), qb.pop();\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125788,
                "title": "java-simple-concise-solution-using-sorting-faster-than-99",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n=A.length;\\n        \\n        Integer t[]=new Integer[n];\\n        \\n        for(int i=0;i<n;i++)\\n            t[i]=i;\\n        int ans[]= new int[n];\\n        \\n        Arrays.sort(t,(i,j) -> B[i]-B[j]);\\n        Arrays.sort(A);\\n        int min=0;\\n        int max=n-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int ind=t[i];\\n            if(B[ind]<A[max])\\n                ans[ind]=A[max--];\\n            else\\n                 ans[ind]=A[min++];\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n=A.length;\\n        \\n        Integer t[]=new Integer[n];\\n        \\n        for(int i=0;i<n;i++)\\n            t[i]=i;\\n        int ans[]= new int[n];\\n        \\n        Arrays.sort(t,(i,j) -> B[i]-B[j]);\\n        Arrays.sort(A);\\n        int min=0;\\n        int max=n-1;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int ind=t[i];\\n            if(B[ind]<A[max])\\n                ans[ind]=A[max--];\\n            else\\n                 ans[ind]=A[min++];\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125545,
                "title": "c-pure-stl-readable-and-easy-comments",
                "content": "Simple use of STL\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(A.begin(),A.end());  // Upper bound works on sorted arrays\\n\\tvector<int> ans;\\n\\tfor(auto i: B)\\n\\t{\\n\\t\\tauto ele = upper_bound(A.begin(),A.end(),i);  // Get the first element strictly greater than i\\n\\t\\tif(ele==A.end())   // If no element is greater than i, then use the least useful element in A, i.e, the smallest one \\n\\t\\t\\tele = min_element(A.begin(),A.end());\\n\\t\\tans.push_back(*ele);\\n\\t\\tA.erase(ele); // Remove it from A\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(A.begin(),A.end());  // Upper bound works on sorted arrays\\n\\tvector<int> ans;\\n\\tfor(auto i: B)\\n\\t{\\n\\t\\tauto ele = upper_bound(A.begin(),A.end(),i);  // Get the first element strictly greater than i\\n\\t\\tif(ele==A.end())   // If no element is greater than i, then use the least useful element in A, i.e, the smallest one \\n\\t\\t\\tele = min_element(A.begin(),A.end());\\n\\t\\tans.push_back(*ele);\\n\\t\\tA.erase(ele); // Remove it from A\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125511,
                "title": "greedy-two-pointers-sorting-java",
                "content": "**GOAL + Approch:**\\n* we have to maximize Advantage . i.e rearrange array A such that number of idx following this property A[i]>B[i] is maximum.\\n* we will approch greedly try the maximum value of A on maximum value of B. if maximum of A is greater than maximum of B. will put that maximum at that index. \\n* if maximum value of A is less than maximum value of B .If we put the maximum of A here it is a loos. because its not contributing to advantage so better to put minimum value of A here and use the maximum next time maybe its greater than that and contribute to advantage.\\n\\n\\n**Code:**\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result=new int[A.length];\\n      \\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        for(int i=0;i<B.length;i++){\\n            int val=B[i];\\n            Pair np=new Pair(val,i);\\n            pq.add(np);\\n        }\\n        \\n        Arrays.sort(A);\\n        \\n        int end=A.length-1;\\n        int start=0;\\n        while(start<=end){\\n           Pair top=pq.remove();\\n            \\n           int idx=top.idx;\\n           int val=top.val;\\n            \\n           int max=A[end];\\n           int min=A[start];\\n            \\n           if(max>val){\\n               result[idx]=max;\\n               end--;\\n           }else{\\n               result[idx]=min;\\n               start++;\\n           }\\n        }\\n        return result;\\n    }\\n    \\n    public class Pair implements Comparable<Pair>{\\n        int idx;\\n        int val;\\n        \\n        Pair(int val,int idx){\\n            this.val=val;\\n            this.idx=idx;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair other){\\n            return other.val-this.val;\\n        }\\n    }\\n}\\n```\\n\\n**Complexity : O(nlogn) and Space:O(n)**\\nPlease **UPVOTE** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result=new int[A.length];\\n      \\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        for(int i=0;i<B.length;i++){\\n            int val=B[i];\\n            Pair np=new Pair(val,i);\\n            pq.add(np);\\n        }\\n        \\n        Arrays.sort(A);\\n        \\n        int end=A.length-1;\\n        int start=0;\\n        while(start<=end){\\n           Pair top=pq.remove();\\n            \\n           int idx=top.idx;\\n           int val=top.val;\\n            \\n           int max=A[end];\\n           int min=A[start];\\n            \\n           if(max>val){\\n               result[idx]=max;\\n               end--;\\n           }else{\\n               result[idx]=min;\\n               start++;\\n           }\\n        }\\n        return result;\\n    }\\n    \\n    public class Pair implements Comparable<Pair>{\\n        int idx;\\n        int val;\\n        \\n        Pair(int val,int idx){\\n            this.val=val;\\n            this.idx=idx;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair other){\\n            return other.val-this.val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125301,
                "title": "python-o-n-lg-n-by-horse-racing-strategy-w-hint",
                "content": "**Hint**:\\n\\nLike the mutli-round horse racing strategy between A and B\\n\\nWhat we want is the **best match sequence** for A to win B as much as possible\\n\\nKeep A in sorted order, and make a heap for B.\\n\\nFor each round:\\n\\nIf current largest element of A is larger than current largest element of B, \\nthen pick current largest element of A as best shuffle against B\\n[ use **best of A** to **win best of B** ]\\n\\nOtherwise, pick current smallest of A as best shuffle against B.\\n[ use **worst of A** to **comsume best of B** ]\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/7fbd9bef-84e3-41ff-963d-e467c87066c4_1616584312.1154692.png)\\n[Source: Alge Timing](https://alge-timing.com/AlgeTiming_V2/en/horse-racing.html)\\n---\\n\\n**Implementation**\\n\\n```\\n\\n\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n\\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        \\n        # array size\\n        size = len(A)\\n        \\n        # best advantage shuffle of A\\n        best_shuffle = [ 0 for _ in range(size) ]\\n        \\n        \\n        # two pointers for A and best shuffle\\n        left, right = 0, size-1\\n        \\n        \\n        # B_tuple\\n        # first item: negative value of b\\n        # second item: index of b\\n        B_tuple = [ (-b, idx) for idx, b in enumerate(B) ]\\n        \\n        \\n        # build a min heap from B_tuple\\n        # larger elements will be on the top naturally (because what we record in tuple is -b, negative value )\\n        heapq.heapify(B_tuple)\\n        \\n        \\n        # find best shuffle of A against B from largest value\\n        \\n        while B_tuple:\\n            \\n            \\n            largest_b_value, largest_b_idx = heapq.heappop(B_tuple)\\n        \\n            if A[right] > abs(largest_b_value):\\n                \\n                # largest of A is bigger than largest of B\\n                # pick A\\'s largest value as best shuffle\\n                \\n                best_shuffle[largest_b_idx] = A[right]\\n                right -= 1\\n                \\n            else:\\n                \\n                # largest of A is smaller than or equal to B\\n                # no chance to win, pick A\\'s smallest value as best shuffle\\n                \\n                best_shuffle[largest_b_idx] = A[left]\\n                left += 1\\n                \\n                \\n        return best_shuffle\\n```\\n\\n---\\n\\nReferecne:\\n\\n[1] [Python offficial docs about heap](https://docs.python.org/3/library/heapq.html)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Two Pointers",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n\\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        \\n        # array size\\n        size = len(A)\\n        \\n        # best advantage shuffle of A\\n        best_shuffle = [ 0 for _ in range(size) ]\\n        \\n        \\n        # two pointers for A and best shuffle\\n        left, right = 0, size-1\\n        \\n        \\n        # B_tuple\\n        # first item: negative value of b\\n        # second item: index of b\\n        B_tuple = [ (-b, idx) for idx, b in enumerate(B) ]\\n        \\n        \\n        # build a min heap from B_tuple\\n        # larger elements will be on the top naturally (because what we record in tuple is -b, negative value )\\n        heapq.heapify(B_tuple)\\n        \\n        \\n        # find best shuffle of A against B from largest value\\n        \\n        while B_tuple:\\n            \\n            \\n            largest_b_value, largest_b_idx = heapq.heappop(B_tuple)\\n        \\n            if A[right] > abs(largest_b_value):\\n                \\n                # largest of A is bigger than largest of B\\n                # pick A\\'s largest value as best shuffle\\n                \\n                best_shuffle[largest_b_idx] = A[right]\\n                right -= 1\\n                \\n            else:\\n                \\n                # largest of A is smaller than or equal to B\\n                # no chance to win, pick A\\'s smallest value as best shuffle\\n                \\n                best_shuffle[largest_b_idx] = A[left]\\n                left += 1\\n                \\n                \\n        return best_shuffle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125290,
                "title": "java-maxheap",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<int[]> maxHeap = new  PriorityQueue<int[]>((a,b)-> (b[1]  -a[1]));\\n        int shuffledArray[] = new int[A.length];\\n        for(int i=0; i<B.length; i++){\\n            maxHeap.offer(new int[]{i, B[i]});\\n        }\\n        \\n        int low= 0 ;\\n        int high = A.length-1;\\n        while(!maxHeap.isEmpty()){\\n            int top[] = maxHeap.poll();\\n            int maximum =  top[1];\\n            int index =  top[0];\\n            if(A[high] > maximum){\\n                shuffledArray[index] = A[high];\\n                high-=1;\\n            }else {\\n                shuffledArray[index] = A[low];\\n                low++;\\n            }\\n        }\\n        \\n        return shuffledArray;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<int[]> maxHeap = new  PriorityQueue<int[]>((a,b)-> (b[1]  -a[1]));\\n        int shuffledArray[] = new int[A.length];\\n        for(int i=0; i<B.length; i++){\\n            maxHeap.offer(new int[]{i, B[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1125260,
                "title": "runtime-beats-94-37-of-cpp-submissions-2-pointer-approach-greedy-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        //this will store value and index of the arry B\\n        int sz=A.size();\\n        vector<pair<int,int>> vi(sz);\\n        for(int i=0;i<B.size();i++)\\n        {\\n            vi[i]=make_pair(B[i],i);\\n        }\\n        sort(vi.begin(),vi.end(),greater<pair<int,int>>());\\n        sort(A.begin(),A.end(),greater<int>());\\n        int li=0,ri=sz-1;\\n        for(int i=0;i<sz;i++)\\n        {\\n            if(vi[i].first<A[li])\\n            {\\n                B[vi[i].second]=A[li];\\n                li++;\\n            }\\n            else\\n            {\\n                B[vi[i].second]=A[ri];\\n                ri--;\\n            }\\n        }\\n        return B;\\n    }\\n};\\n```\\n**If You Like It! Please Upvote**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        //this will store value and index of the arry B\\n        int sz=A.size();\\n        vector<pair<int,int>> vi(sz);\\n        for(int i=0;i<B.size();i++)\\n        {\\n            vi[i]=make_pair(B[i],i);\\n        }\\n        sort(vi.begin(),vi.end(),greater<pair<int,int>>());\\n        sort(A.begin(),A.end(),greater<int>());\\n        int li=0,ri=sz-1;\\n        for(int i=0;i<sz;i++)\\n        {\\n            if(vi[i].first<A[li])\\n            {\\n                B[vi[i].second]=A[li];\\n                li++;\\n            }\\n            else\\n            {\\n                B[vi[i].second]=A[ri];\\n                ri--;\\n            }\\n        }\\n        return B;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125171,
                "title": "c-greedy",
                "content": "```\\npublic class Solution {\\n    public int[] AdvantageCount(int[] A, int[] B) {\\n        Array.Sort(A);\\n        // deep copy of B\\n        var bCopy = (int[])B.Clone();\\n        Array.Sort(B);\\n        int idx = 0;    \\n        int ALength = A.Length; \\n        int[] sortedResult = new int[ALength];        \\n        \\n        // Greedy approach to get the hand that beats a sorted B. First find the numbers in sorted A that beat numbers in sorted B.\\n        // In the second for we fill the remaining positions with the number in A that won\\'t beat numbers in B\\n        for (int i = 0; i < ALength; i++)\\n        {\\n            if (A[i] > B[idx])\\n            {\\n                sortedResult[idx] = A[i];\\n                A[i] = -1;\\n                idx++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < ALength; i++)\\n        {\\n            if (A[i] != -1)\\n            {\\n                sortedResult[idx] = A[i];\\n                idx++;\\n            }\\n        }\\n        \\n        // Go through B and find the original positions of numbers (using the deep copy) so that we can re-arrage A\\n        for (int i = 0; i < ALength; i++)\\n        {\\n            // find the original index of B[i] in bCopy\\n            int index = Array.IndexOf(bCopy, B[i]);\\n            // make sure next time we look in B we don\\'t pick the same position\\n            bCopy[index] = -1;\\n            // put the number in A\\n            A[index] = sortedResult[i];\\n        }\\n        \\n        return A;\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int[] AdvantageCount(int[] A, int[] B) {\\n        Array.Sort(A);\\n        // deep copy of B\\n        var bCopy = (int[])B.Clone();\\n        Array.Sort(B);\\n        int idx = 0;    \\n        int ALength = A.Length; \\n        int[] sortedResult = new int[ALength];        \\n        \\n        // Greedy approach to get the hand that beats a sorted B. First find the numbers in sorted A that beat numbers in sorted B.\\n        // In the second for we fill the remaining positions with the number in A that won\\'t beat numbers in B\\n        for (int i = 0; i < ALength; i++)\\n        {\\n            if (A[i] > B[idx])\\n            {\\n                sortedResult[idx] = A[i];\\n                A[i] = -1;\\n                idx++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 683730,
                "title": "python-dictionary-sort-time-93-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        result = []\\n        counter = defaultdict(list)\\n        for idx in sorted(B, reverse=True):\\n            if A[-1] > idx: \\n                counter[idx].append(A.pop())\\n        for idx in B:\\n            if counter[idx]:\\n                result.append(counter[idx].pop())\\n            else:\\n                result.append(A.pop())\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        result = []\\n        counter = defaultdict(list)\\n        for idx in sorted(B, reverse=True):\\n            if A[-1] > idx: \\n                counter[idx].append(A.pop())\\n        for idx in B:\\n            if counter[idx]:\\n                result.append(counter[idx].pop())\\n            else:\\n                result.append(A.pop())\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642921,
                "title": "easy-understanding-python-solution",
                "content": "Concept: what is the point to pair a (a from A) to b (b from B) if a<b? So lets sort both from top to bottom and if a<b , pair the smallest avilable a to b.\\n\\n```\\nout=[0]*len(A)\\n\\nB=[[B[i],i] for i in range(len(B))]\\nB=sorted(B,reverse=True)\\nA=sorted(A,reverse=True)\\nfor i in range(len(B)):\\n\\tif A[0]>B[i][0]:\\n\\t\\tout[B[i][1]]=A.pop(0)\\n\\n\\telse:\\n\\t\\tout[B[i][1]]=A.pop()\\nreturn out\\n\\n```",
                "solutionTags": [],
                "code": "```\\nout=[0]*len(A)\\n\\nB=[[B[i],i] for i in range(len(B))]\\nB=sorted(B,reverse=True)\\nA=sorted(A,reverse=True)\\nfor i in range(len(B)):\\n\\tif A[0]>B[i][0]:\\n\\t\\tout[B[i][1]]=A.pop(0)\\n\\n\\telse:\\n\\t\\tout[B[i][1]]=A.pop()\\nreturn out\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548111,
                "title": "python-binary-search",
                "content": "```Python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A.sort()\\n        res = []\\n        for i in B:\\n            index = bisect.bisect(A, i)\\n            if index == len(A):\\n                res.append(A.pop(0))\\n            else:\\n                res.append(A.pop(index))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A.sort()\\n        res = []\\n        for i in B:\\n            index = bisect.bisect(A, i)\\n            if index == len(A):\\n                res.append(A.pop(0))\\n            else:\\n                res.append(A.pop(index))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452567,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int[] AdvantageCount(int[] A, int[] B) \\n    {\\n        List<int> result = new List<int>(), list = new List<int>(A);\\n        list.Sort();\\n        for(int i = 0; i < B.Length; i++)\\n        {\\n            var index = list.BinarySearch(B[i] + 1);\\n            if(index < 0) index = ~index;\\n            if(index == list.Count) index = 0;\\n            result.Add(list[index]);\\n            list.RemoveAt(index);\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[] AdvantageCount(int[] A, int[] B) \\n    {\\n        List<int> result = new List<int>(), list = new List<int>(A);\\n        list.Sort();\\n        for(int i = 0; i < B.Length; i++)\\n        {\\n            var index = list.BinarySearch(B[i] + 1);\\n            if(index < 0) index = ~index;\\n            if(index == list.Count) index = 0;\\n            result.Add(list[index]);\\n            list.RemoveAt(index);\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287666,
                "title": "java-greedy-with-treemap-o-nlogn-slower-but-easier",
                "content": "First of all , build up a treemap from numbers in A  , and record the qty\\n\\nSecondly , loop the number in B one by one to build up the result array from getting the ceilingKey in the treemap\\n\\ntwo cases here:\\n1.if we can find such ceiling key , then use it and deduct  qty or remove it from the treemap when qty becomes 0\\n\\n2.if we can\\'t find such a key, then use the smallest key of the treemap , also deduct the qty or remove it when it\\'s qty becomes 0\\n\\nThe time complexity of building a treemap is o(logn)\\nThe time complexity of looking up ceiling key is also o(logn) while we lookup the ceiling key in a loop which complexity is o(n) , so the final time complexity is o(nlogn)\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n        for(int num: A){\\n            map.put(num,map.getOrDefault(num,0)+1);\\n        }\\n        \\n        int[] result = new int[B.length];\\n        \\n        for(int i = 0;i<result.length;i++){\\n            \\n            Integer nextKey =map.ceilingKey(B[i]+1);\\n            \\n            if(null!=nextKey){\\n              result[i]=nextKey;   \\n            }else{\\n              result[i]=map.firstKey();\\n            }\\n            \\n            if(map.get(result[i])==1){\\n                map.remove(result[i]);\\n               }else{\\n                map.put(result[i],map.get(result[i])-1);    \\n              }  \\n                        \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n        for(int num: A){\\n            map.put(num,map.getOrDefault(num,0)+1);\\n        }\\n        \\n        int[] result = new int[B.length];\\n        \\n        for(int i = 0;i<result.length;i++){\\n            \\n            Integer nextKey =map.ceilingKey(B[i]+1);\\n            \\n            if(null!=nextKey){\\n              result[i]=nextKey;   \\n            }else{\\n              result[i]=map.firstKey();\\n            }\\n            \\n            if(map.get(result[i])==1){\\n                map.remove(result[i]);\\n               }else{\\n                map.put(result[i],map.get(result[i])-1);    \\n              }  \\n                        \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153787,
                "title": "c-greedy-beats-96-easy-to-remember-and-impl-in-7mins",
                "content": "```\\n#include <vector>\\n#include <algorithm>\\n#include <utility>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\n        vector<pair<int, int>> pairs(n);\\n        for (int i = 0; i < n; ++i) {\\n            pairs[i] = make_pair(B[i], i);\\n        }\\n\\n        sort(A.begin(), A.end());\\n        sort(pairs.begin(), pairs.end());\\n\\n        vector<int> remain;\\n        vector<bool> used(n, false);\\n        vector<int> res(n);\\n\\n        int j = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] <= pairs[j].first) {\\n                remain.push_back(A[i]);\\n            } else {\\n                res[pairs[j].second] = A[i];\\n                used[pairs[j].second] = true;\\n                ++j;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (!used[i]) {\\n                res[i] = remain.back();\\n                remain.pop_back();\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n#include <utility>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\n        vector<pair<int, int>> pairs(n);\\n        for (int i = 0; i < n; ++i) {\\n            pairs[i] = make_pair(B[i], i);\\n        }\\n\\n        sort(A.begin(), A.end());\\n        sort(pairs.begin(), pairs.end());\\n\\n        vector<int> remain;\\n        vector<bool> used(n, false);\\n        vector<int> res(n);\\n\\n        int j = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] <= pairs[j].first) {\\n                remain.push_back(A[i]);\\n            } else {\\n                res[pairs[j].second] = A[i];\\n                used[pairs[j].second] = true;\\n                ++j;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (!used[i]) {\\n                res[i] = remain.back();\\n                remain.pop_back();\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 152705,
                "title": "c-greedy-multiset-7-line",
                "content": "```\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s(A.begin(), A.end());\\n        for(int i=0;i<A.size();i++){\\n            auto it = *s.rbegin() > B[i] ? s.upper_bound(B[i]) : s.begin();\\n            A[i] = *it;\\n            s.erase(it);\\n        }\\n        return A;\\n    } ```",
                "solutionTags": [],
                "code": "```\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> s(A.begin(), A.end());\\n        for(int i=0;i<A.size();i++){\\n            auto it = *s.rbegin() > B[i] ? s.upper_bound(B[i]) : s.begin();\\n            A[i] = *it;\\n            s.erase(it);\\n        }\\n        return A;\\n    } ```",
                "codeTag": "Unknown"
            },
            {
                "id": 151908,
                "title": "nlogn-time-on-space-c",
                "content": " public int[] AdvantageCount(int[] A, int[] B) {\\n        if(A.Length <=1)\\n            return A;\\n        \\n        int[] sortedB = new int[B.Length];\\n        Array.Copy(B,sortedB,B.Length);\\n        Array.Sort(sortedB);\\n        Array.Sort(A);\\n        \\n        Dictionary<int,List<int>> dics = new Dictionary<int,List<int>>();\\n        int i = 0, j= 0, endA = A.Length -1, endB = B.Length -1;\\n     \\n        while(i<= endA && j <= endB)\\n        {\\n            if(A[i] > sortedB[j])\\n            {\\n                if (dics.ContainsKey(sortedB[j]))\\n                    dics[sortedB[j]].Add(A[i]);\\n                else\\n                    dics[sortedB[j]] = new List<int>{A[i]};\\n                \\n                i++;\\n                j++;\\n            }\\n            else \\n            {\\n                 if (dics.ContainsKey(sortedB[endB]))\\n                    dics[sortedB[endB]].Add(A[i]);\\n                else\\n                    dics[sortedB[endB]] =  new List<int>{A[i]};\\n                \\n                endB--;\\n                i++;\\n                \\n            }\\n        }\\n        \\n       for(int k = 0; k < B.Length; k++)\\n       {\\n           A[k] = dics[B[k]].First();\\n           dics[B[k]].Remove(A[k]);\\n       }\\n        \\n        \\n        return A;\\n        \\n    }",
                "solutionTags": [],
                "code": " public int[] AdvantageCount(int[] A, int[] B) {\\n        if(A.Length <=1)\\n            return A;\\n        \\n        int[] sortedB = new int[B.Length];\\n        Array.Copy(B,sortedB,B.Length);\\n        Array.Sort(sortedB);\\n        Array.Sort(A);\\n        \\n        Dictionary<int,List<int>> dics = new Dictionary<int,List<int>>();\\n        int i = 0, j= 0, endA = A.Length -1, endB = B.Length -1;\\n     \\n        while(i<= endA && j <= endB)\\n        {\\n            if(A[i] > sortedB[j])\\n            {\\n                if (dics.ContainsKey(sortedB[j]))\\n                    dics[sortedB[j]].Add(A[i]);\\n                else\\n                    dics[sortedB[j]] = new List<int>{A[i]};\\n                \\n                i++;\\n                j++;\\n            }\\n            else \\n            {\\n                 if (dics.ContainsKey(sortedB[endB]))\\n                    dics[sortedB[endB]].Add(A[i]);\\n                else\\n                    dics[sortedB[endB]] =  new List<int>{A[i]};\\n                \\n                endB--;\\n                i++;\\n                \\n            }\\n        }\\n        \\n       for(int k = 0; k < B.Length; k++)\\n       {\\n           A[k] = dics[B[k]].First();\\n           dics[B[k]].Remove(A[k]);\\n       }\\n        \\n        \\n        return A;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 151081,
                "title": "java-greedy-treeset-hashmap",
                "content": "TreeSet to be used to get higer or lowest.\\nHashMap is used as counter. Once run out, remove value from TreeSet.\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeSet<Integer> values=new TreeSet<>();\\n        Map<Integer,Integer> counts=new HashMap<>();\\n        for (int value:A) {\\n            int count=counts.getOrDefault(value,0);\\n            if (count==0) {\\n                values.add(value);                \\n            }\\n            counts.put(value,count+1);\\n        }\\n        int len=A.length;\\n        int[] dest=new int[len];\\n        for (int i=0;i<len;i++) {\\n            int value=B[i];\\n            Integer k=values.higher(value);\\n            if (k==null) {\\n                k=values.first();\\n            }\\n            dest[i]=k;\\n            int count=counts.get(k)-1;\\n            counts.put(k,count);\\n            if (count==0) {\\n                values.remove(k);                \\n            }\\n        }\\n        return dest;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeSet<Integer> values=new TreeSet<>();\\n        Map<Integer,Integer> counts=new HashMap<>();\\n        for (int value:A) {\\n            int count=counts.getOrDefault(value,0);\\n            if (count==0) {\\n                values.add(value);                \\n            }\\n            counts.put(value,count+1);\\n        }\\n        int len=A.length;\\n        int[] dest=new int[len];\\n        for (int i=0;i<len;i++) {\\n            int value=B[i];\\n            Integer k=values.higher(value);\\n            if (k==null) {\\n                k=values.first();\\n            }\\n            dest[i]=k;\\n            int count=counts.get(k)-1;\\n            counts.put(k,count);\\n            if (count==0) {\\n                values.remove(k);                \\n            }\\n        }\\n        return dest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150380,
                "title": "python-greedy-solution-using-sort-and-min-heap-with-o-n-log-n-time",
                "content": "We don\\'t need to sort `A`. A min-heap from `A` will suffice.\\n\\n```\\n# Time complexity: O(N * log N)\\n# Space complexity: O(N)\\n# N = len(A) = len(B)\\n\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # Sort the tuples of (number, index) of \"B\" in an\\n        # non-decreasing order.\\n        B_with_index = [(b, i) for i, b in enumerate(B)]\\n        B_with_index.sort()\\n        \\n        # Create a min-heap from \"A\".\\n        lenA = len(A)\\n        res = [0] * lenA\\n        heapify(A)\\n        \\n        # For each number in the sorted \"B\", the optimal\\n        # advantage number of \"A\" is the minimum number in\\n        # \"A\" which is greater than the number of \"B\".\\n        unusedA = []\\n        for b, i in B_with_index:\\n            # If the min-heap is non-empty, keep popping\\n            # numbers of it until we see a number which is\\n            # bigger than the number in the sorted \"B\".\\n            while A:\\n                a = heappop(A)\\n                if a > b:\\n                    res[i] = a\\n                    break\\n                else:\\n                    # For those \"small\" numbers in \"A\", simply\\n                    # put them in the remaining positions after\\n                    # we put all the advantage numbers.\\n                    unusedA.append(a)\\n            if not A:\\n                break\\n        \\n        # Put the \"small\" numbers in the remaining positions.\\n        len_unusedA = len(unusedA)\\n        for j in range(lenA - len_unusedA, lenA):\\n            res[B_with_index[j][1]] = unusedA[j - (lenA - len_unusedA)]\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# Time complexity: O(N * log N)\\n# Space complexity: O(N)\\n# N = len(A) = len(B)\\n\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # Sort the tuples of (number, index) of \"B\" in an\\n        # non-decreasing order.\\n        B_with_index = [(b, i) for i, b in enumerate(B)]\\n        B_with_index.sort()\\n        \\n        # Create a min-heap from \"A\".\\n        lenA = len(A)\\n        res = [0] * lenA\\n        heapify(A)\\n        \\n        # For each number in the sorted \"B\", the optimal\\n        # advantage number of \"A\" is the minimum number in\\n        # \"A\" which is greater than the number of \"B\".\\n        unusedA = []\\n        for b, i in B_with_index:\\n            # If the min-heap is non-empty, keep popping\\n            # numbers of it until we see a number which is\\n            # bigger than the number in the sorted \"B\".\\n            while A:\\n                a = heappop(A)\\n                if a > b:\\n                    res[i] = a\\n                    break\\n                else:\\n                    # For those \"small\" numbers in \"A\", simply\\n                    # put them in the remaining positions after\\n                    # we put all the advantage numbers.\\n                    unusedA.append(a)\\n            if not A:\\n                break\\n        \\n        # Put the \"small\" numbers in the remaining positions.\\n        len_unusedA = len(unusedA)\\n        for j in range(lenA - len_unusedA, lenA):\\n            res[B_with_index[j][1]] = unusedA[j - (lenA - len_unusedA)]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150176,
                "title": "easy-peasy-java-squeezy",
                "content": "```class Solution {\\n\\t\\tpublic int[] advantageCount(int[] A, int[] B) {\\n\\t\\t\\t\\tTreeMap<Integer,Integer> nums = new TreeMap<>();\\n\\n\\t\\t\\t\\tfor(int i : A) nums.put(i, nums.getOrDefault(i,0)+1);\\n\\n\\n\\t\\t\\t\\tfor (int i = 0; i < B.length; i++){\\n\\t\\t\\t\\t\\t\\tInteger advantage = nums.higherKey(B[i]);\\n\\t\\t\\t\\t\\t\\tif(advantage == null)\\n\\t\\t\\t\\t\\t\\t\\t\\tadvantage = nums.firstKey();\\n\\n\\t\\t\\t\\t\\t\\tA[i] = advantage;\\n\\n\\t\\t\\t\\t\\t\\tnums.put(advantage, nums.get(advantage)-1);\\n\\t\\t\\t\\t\\t\\tif(nums.get(advantage) == 0)\\n\\t\\t\\t\\t\\t\\t\\t\\tnums.remove(advantage);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn A;\\n\\t\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n\\t\\tpublic int[] advantageCount(int[] A, int[] B) {\\n\\t\\t\\t\\tTreeMap<Integer,Integer> nums = new TreeMap<>();\\n\\n\\t\\t\\t\\tfor(int i : A) nums.put(i, nums.getOrDefault(i,0)+1);\\n\\n\\n\\t\\t\\t\\tfor (int i = 0; i < B.length; i++){\\n\\t\\t\\t\\t\\t\\tInteger advantage = nums.higherKey(B[i]);\\n\\t\\t\\t\\t\\t\\tif(advantage == null)\\n\\t\\t\\t\\t\\t\\t\\t\\tadvantage = nums.firstKey();\\n\\n\\t\\t\\t\\t\\t\\tA[i] = advantage;\\n\\n\\t\\t\\t\\t\\t\\tnums.put(advantage, nums.get(advantage)-1);\\n\\t\\t\\t\\t\\t\\tif(nums.get(advantage) == 0)\\n\\t\\t\\t\\t\\t\\t\\t\\tnums.remove(advantage);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn A;\\n\\t\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149830,
                "title": "c-greedy-and-binary-search-o-nlogn-s-1",
                "content": "```\\n// greedy, O(nlogn), S(1)\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        std::sort(begin(A), end(A));\\n        \\n        for(auto i = 0 ; i < B.size() ; i++){\\n            \\n            const auto it = std::upper_bound(begin(A), end(A), B[i]);\\n            \\n            if(it != end(A)){\\n                \\n                B[i] = *it;\\n                A.erase(it);\\n                \\n            }else{\\n                \\n                B[i] = *A.begin();\\n                A.erase(A.begin());\\n            }\\n        }\\n        \\n        return B;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// greedy, O(nlogn), S(1)\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        std::sort(begin(A), end(A));\\n        \\n        for(auto i = 0 ; i < B.size() ; i++){\\n            \\n            const auto it = std::upper_bound(begin(A), end(A), B[i]);\\n            \\n            if(it != end(A)){\\n                \\n                B[i] = *it;\\n                A.erase(it);\\n                \\n            }else{\\n                \\n                B[i] = *A.begin();\\n                A.erase(A.begin());\\n            }\\n        }\\n        \\n        return B;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611297,
                "title": "two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTwo Pointers and sorting\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)->sorting\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums2.size();\\n        vector<int> res(n);\\n        sort(nums1.begin(),nums1.end());\\n        vector<pair<int,int>> p;\\n        for(int i=0;i<n;i++){\\n            p.push_back({nums2[i],i});\\n        }\\n        sort(p.begin(),p.end());\\n\\n        int fp=0,lp=n-1;\\n        \\n        for(auto i:nums1){\\n            if(p[fp].first < i){\\n                res[p[fp++].second]=i;\\n            }\\n            else{\\n                res[p[lp--].second]=i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums2.size();\\n        vector<int> res(n);\\n        sort(nums1.begin(),nums1.end());\\n        vector<pair<int,int>> p;\\n        for(int i=0;i<n;i++){\\n            p.push_back({nums2[i],i});\\n        }\\n        sort(p.begin(),p.end());\\n\\n        int fp=0,lp=n-1;\\n        \\n        for(auto i:nums1){\\n            if(p[fp].first < i){\\n                res[p[fp++].second]=i;\\n            }\\n            else{\\n                res[p[lp--].second]=i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405273,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) \\n    {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) \\n  {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) \\n    {\\n  multiset<int> s(begin(A), end(A));\\n  for (auto i = 0; i < B.size(); ++i) \\n  {\\n    auto p = *s.rbegin() <= B[i] ? s.begin() : s.upper_bound(B[i]);\\n    A[i] = *p;\\n    s.erase(p);\\n  }\\n  return A;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350655,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b)\\n    {\\n        multiset<int> s;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<b.size();i++)\\n        {\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end())\\n            {\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else\\n            {\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b)\\n    {\\n        multiset<int> s;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s.insert(a[i]);\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<b.size();i++)\\n        {\\n            auto it = s.upper_bound(b[i]);\\n            if(it!=s.end())\\n            {\\n                v.push_back(*(it));\\n                s.erase(it);\\n            }\\n            else\\n            {\\n                v.push_back(*(s.begin()));\\n                s.erase(s.begin());\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037169,
                "title": "100-kotlin",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun advantageCount(nums1: IntArray, nums2: IntArray): IntArray {\\n        nums1.sort()\\n        \\n        val pairs2 = nums2.mapIndexed {i, n -> Pair(n, i)}.sortedByDescending {it.first}\\n        var left = 0\\n        var right = nums1.lastIndex \\n\\n        val res = IntArray(nums1.size)\\n\\n        for (p in pairs2) {\\n            if (nums1[right] > p.first) {\\n                res[p.second] = nums1[right--]\\n            } else {\\n                res[p.second] = nums1[left++]\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun advantageCount(nums1: IntArray, nums2: IntArray): IntArray {\\n        nums1.sort()\\n        \\n        val pairs2 = nums2.mapIndexed {i, n -> Pair(n, i)}.sortedByDescending {it.first}\\n        var left = 0\\n        var right = nums1.lastIndex \\n\\n        val res = IntArray(nums1.size)\\n\\n        for (p in pairs2) {\\n            if (nums1[right] > p.first) {\\n                res[p.second] = nums1[right--]\\n            } else {\\n                res[p.second] = nums1[left++]\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036588,
                "title": "sorting-two-pointers-approach-java-simple-solution-clean-code",
                "content": "# Intuition\\nLargest number of `nums1` should be assigned to largest number of `nums2` as long as it satisfies the condition.\\n\\n# Approach\\n- Sort both the arrays maintaining the indices of `nums2`\\n- Greedily assign the largest number of `nums1[i]` to largest number of `nums2[j]` such that `nums1[i] > nums2[j]` using two pointers approach.\\n- Assign the rest element randomly.\\n\\n# Complexity\\nLet $$n = nums1.length = nums2.length$$\\n- Time complexity: $$O(n * logn)$$\\n\\n- Space complexity: $$O(1)$$ (ignoring space used for answer)\\n\\n# Code\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int ans[] = new int[n];\\n        Arrays.fill(ans,-1);\\n        Arrays.sort(nums1);\\n        int mat[][] = new int[n][2];\\n        for(int i = 0;i < n;i++){\\n            mat[i][0] = i;\\n            mat[i][1] = nums2[i];\\n        }\\n        Arrays.sort(mat,(a,b) -> a[1] - b[1]);\\n        int i1 = n - 1;\\n        for(int i2 = n - 1;i1 >= 0 && i2 >= 0;){\\n            for(;i2 >= 0 && mat[i2][1] >= nums1[i1];) --i2;\\n            if(i2 >= 0){\\n                ans[mat[i2][0]] = nums1[i1];\\n                --i2;\\n                --i1;\\n            }\\n        }\\n        for(int i = 0;i < n && i1 >= 0;i++,i1--){\\n            for(;i < n && ans[i] != -1;) i++;\\n            ans[i] = nums1[i1];\\n        }\\n        if(i1 >= 0) ans[n - 1] = nums1[i1];\\n        return ans;\\n\\n    }\\n}\\n```\\n\\n# Upvote if you like \\uD83D\\uDC4D\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int ans[] = new int[n];\\n        Arrays.fill(ans,-1);\\n        Arrays.sort(nums1);\\n        int mat[][] = new int[n][2];\\n        for(int i = 0;i < n;i++){\\n            mat[i][0] = i;\\n            mat[i][1] = nums2[i];\\n        }\\n        Arrays.sort(mat,(a,b) -> a[1] - b[1]);\\n        int i1 = n - 1;\\n        for(int i2 = n - 1;i1 >= 0 && i2 >= 0;){\\n            for(;i2 >= 0 && mat[i2][1] >= nums1[i1];) --i2;\\n            if(i2 >= 0){\\n                ans[mat[i2][0]] = nums1[i1];\\n                --i2;\\n                --i1;\\n            }\\n        }\\n        for(int i = 0;i < n && i1 >= 0;i++,i1--){\\n            for(;i < n && ans[i] != -1;) i++;\\n            ans[i] = nums1[i1];\\n        }\\n        if(i1 >= 0) ans[n - 1] = nums1[i1];\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891124,
                "title": "brute-force-solution-in-python-tle",
                "content": "```py\\nclass Solution:\\n    from itertools import permutations\\n    def advantageCount(self, nums1, nums2):\\n        def calc_advantage(nums1, nums2):\\n            adv = 0\\n            for i in range(len(nums1)):\\n                if nums1[i] > nums2[i]:\\n                    adv += 1\\n            return adv\\n\\n        max_advantage = -1 \\n        \\n        for perm in permutations(nums1):\\n            adv = calc_advantage(perm, nums2)\\n            if adv > max_advantage:\\n                max_advantage = adv\\n                res = perm\\n        return res\\n```\\n\\nThe idea behind the brute force algorithm is as follows: Given the two integer arrays nums1 and nums2, we can enumerate all the permutations of nums1 and calculate the advantage of each permutation. Finally, we can choose the permutation with the maximum advantage as the answer.\\n\\nTime complexity: Since we need to enumerate all the permutations of nums1, the time complexity is O(n! * n), where n is the length of nums1 and nums2.\\n\\nSpace complexity: Since we need to store all the permutations of nums1, the space complexity is O(n!).\\n\\nThe drawback of this brute force algorithm is that when n becomes large, its running time becomes very long, so it is not an efficient solution. We need a more efficient algorithm to solve this problem.\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    from itertools import permutations\\n    def advantageCount(self, nums1, nums2):\\n        def calc_advantage(nums1, nums2):\\n            adv = 0\\n            for i in range(len(nums1)):\\n                if nums1[i] > nums2[i]:\\n                    adv += 1\\n            return adv\\n\\n        max_advantage = -1 \\n        \\n        for perm in permutations(nums1):\\n            adv = calc_advantage(perm, nums2)\\n            if adv > max_advantage:\\n                max_advantage = adv\\n                res = perm\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674815,
                "title": "advantage-shuffle",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Integer[] idx1 = new Integer[n];\\n        Integer[] idx2 = new Integer[n];\\n        for (int i = 0; i < n; ++i) {\\n            idx1[i] = i;\\n            idx2[i] = i;\\n        }\\n        Arrays.sort(idx1, (i, j) -> nums1[i] - nums1[j]);\\n        Arrays.sort(idx2, (i, j) -> nums2[i] - nums2[j]);\\n\\n        int[] res = new int[n];\\n        int left = 0, right = n - 1;\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[idx1[i]] > nums2[idx2[left]]) {\\n                res[idx2[left]] = nums1[idx1[i]];\\n                ++left;\\n            } else {\\n                res[idx2[right]] = nums1[idx1[i]];\\n                --right;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Integer[] idx1 = new Integer[n];\\n        Integer[] idx2 = new Integer[n];\\n        for (int i = 0; i < n; ++i) {\\n            idx1[i] = i;\\n            idx2[i] = i;\\n        }\\n        Arrays.sort(idx1, (i, j) -> nums1[i] - nums1[j]);\\n        Arrays.sort(idx2, (i, j) -> nums2[i] - nums2[j]);\\n\\n        int[] res = new int[n];\\n        int left = 0, right = n - 1;\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[idx1[i]] > nums2[idx2[left]]) {\\n                res[idx2[left]] = nums1[idx1[i]];\\n                ++left;\\n            } else {\\n                res[idx2[right]] = nums1[idx1[i]];\\n                --right;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618151,
                "title": "98-faster-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<nums2.size(); i++) v.push_back({nums2[i], i});\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(v.begin(), v.end(), greater<pair<int, int>>());\\n        \\n        int s = 0, e = nums1.size() - 1;\\n        vector<int> ans(nums1.size());\\n        \\n        for(auto i : v) {\\n            ans[i.second] = nums1[e] <= i.first ? nums1[s++] : nums1[e--];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<nums2.size(); i++) v.push_back({nums2[i], i});\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(v.begin(), v.end(), greater<pair<int, int>>());\\n        \\n        int s = 0, e = nums1.size() - 1;\\n        vector<int> ans(nums1.size());\\n        \\n        for(auto i : v) {\\n            ans[i.second] = nums1[e] <= i.first ? nums1[s++] : nums1[e--];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489018,
                "title": "c-easy-binary-search-solved-it-in-salesforce-interview",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        multiset<int> ms(nums1.begin(),nums1.end());\\n        for(int x : nums2) {\\n            auto it = ms.upper_bound(x);\\n            if(it==ms.end()) {\\n                ans.push_back(*ms.begin());\\n                ms.erase(ms.begin());\\n            }\\n            else {\\n                ans.push_back(*it);\\n                ms.erase(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        multiset<int> ms(nums1.begin(),nums1.end());\\n        for(int x : nums2) {\\n            auto it = ms.upper_bound(x);\\n            if(it==ms.end()) {\\n                ans.push_back(*ms.begin());\\n                ms.erase(ms.begin());\\n            }\\n            else {\\n                ans.push_back(*it);\\n                ms.erase(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342025,
                "title": "python-o-nlogn-tc-o-n-sc-greedy-sorting",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        \\n\\t\\tnums1.sort()\\n\\t\\t\\n        nums3 = []\\n        for i in range(len(nums2)):\\n            nums3.append((nums2[i], i))\\n\\t\\t\\t\\n        nums3.sort(key=lambda x : x[0])\\n        \\n        # greedily pick just larger nums2[i] and if that is not the case then pick smallest and assign to it\\n        for i in range(len(nums1)-1, -1, -1):\\n            if nums1[-1] > nums3[i][0]:\\n                nums2[nums3[i][1]] = nums1.pop()\\n            else:\\n                nums2[nums3[i][1]] = nums1.pop(0)\\n        \\n        return nums2\\n\\'\\'\\'\\nIf you get this then try Space Optimizing it ; )",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        \\n\\t\\tnums1.sort()\\n\\t\\t\\n        nums3 = []\\n        for i in range(len(nums2)):\\n            nums3.append((nums2[i], i))\\n\\t\\t\\t\\n        nums3.sort(key=lambda x : x[0])\\n        \\n        # greedily pick just larger nums2[i] and if that is not the case then pick smallest and assign to it\\n        for i in range(len(nums1)-1, -1, -1):\\n            if nums1[-1] > nums3[i][0]:\\n                nums2[nums3[i][1]] = nums1.pop()\\n            else:\\n                nums2[nums3[i][1]] = nums1.pop(0)\\n        \\n        return nums2\\n\\'\\'\\'\\nIf you get this then try Space Optimizing it ; )",
                "codeTag": "Java"
            },
            {
                "id": 2310057,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        n1 = collections.deque(sorted(nums1, reverse = True))\\n        n2 = sorted([(num, idx) for idx, num in enumerate(nums2)], reverse = True)\\n        res = [0] * len(n1)\\n        for num, idx in n2:\\n            if num < n1[0]:\\n                res[idx] = n1.popleft()\\n            else:\\n                res[idx] = n1.pop()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        n1 = collections.deque(sorted(nums1, reverse = True))\\n        n2 = sorted([(num, idx) for idx, num in enumerate(nums2)], reverse = True)\\n        res = [0] * len(n1)\\n        for num, idx in n2:\\n            if num < n1[0]:\\n                res[idx] = n1.popleft()\\n            else:\\n                res[idx] = n1.pop()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118480,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Multiset***\\n\\n* ***Time Complexity : O(NlogN)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        multiset<int> s(nums1.begin(), nums1.end());\\n        \\n        for(int i = 0; i < n2; i++)\\n        {\\n            int val = nums2[i];\\n            \\n            auto it = s.upper_bound(val);\\n            \\n            if(it != s.end())\\n            {\\n                nums1[i] = *it;\\n                \\n                s.erase(it);\\n            }\\n            else\\n            {\\n                nums1[i] = -1;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n1; i++)\\n        {\\n            if(nums1[i] == -1)\\n            {\\n                nums1[i] = *s.begin();\\n                \\n                s.erase(s.begin());\\n            }\\n        }\\n        \\n        return nums1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        multiset<int> s(nums1.begin(), nums1.end());\\n        \\n        for(int i = 0; i < n2; i++)\\n        {\\n            int val = nums2[i];\\n            \\n            auto it = s.upper_bound(val);\\n            \\n            if(it != s.end())\\n            {\\n                nums1[i] = *it;\\n                \\n                s.erase(it);\\n            }\\n            else\\n            {\\n                nums1[i] = -1;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n1; i++)\\n        {\\n            if(nums1[i] == -1)\\n            {\\n                nums1[i] = *s.begin();\\n                \\n                s.erase(s.begin());\\n            }\\n        }\\n        \\n        return nums1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830993,
                "title": "python-very-easy-greedy-sorting-explained",
                "content": "**\\nFor every position we try to get a point or advantage\\nTo get a point lets say for 2 we have choices [3,10] the we should use 3 not 10 as we can get advantage from both of them but using less valuable item can be good in the long run .\\nTo do so we sort num1 and find the index with value just greater than item in nums2 : if no such index exists add the smallest we have\\n**\\n```\\nclass Solution:\\n    def binarySearch(self , arr , x):\\n        low = 0 \\n        high = len(arr)-1\\n        while low <= high:\\n            mid = (low+high)//2\\n            if arr[mid] <= x:low = mid + 1\\n            else: high = mid - 1\\n        return low\\n    \\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        nums1.sort()\\n        n = len(nums1)\\n        ans = []\\n        for i in nums2:\\n            idx = self.binarySearch(nums1 , i)\\n            if idx == n: idx = 0\\n            ans.append(nums1[idx])\\n            nums1.pop(idx)\\n            n-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def binarySearch(self , arr , x):\\n        low = 0 \\n        high = len(arr)-1\\n        while low <= high:\\n            mid = (low+high)//2\\n            if arr[mid] <= x:low = mid + 1\\n            else: high = mid - 1\\n        return low\\n    \\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        nums1.sort()\\n        n = len(nums1)\\n        ans = []\\n        for i in nums2:\\n            idx = self.binarySearch(nums1 , i)\\n            if idx == n: idx = 0\\n            ans.append(nums1[idx])\\n            nums1.pop(idx)\\n            n-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716092,
                "title": "tim-n-o-log-n-space-4-o-n-noob-solution",
                "content": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n\\tint n = nums1.size();\\n\\t\\n\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\tpriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq2;\\t\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tpq.push(nums1[i]);\\n\\t\\tpq2.push({nums2[i], i});\\n\\t}\\n\\n\\tvector<int> result(n, -1);\\n\\tstack<int> res;\\n\\twhile(!pq2.empty() && !pq.empty()){\\n\\t\\tint ele = pq2.top().first;\\n\\t\\tint idx = pq2.top().second;\\n\\t\\tpq2.pop();\\n\\n\\t\\twhile(!pq.empty() && pq.top() <= ele){\\n\\t\\t\\tres.push(pq.top());\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\n\\t\\tif(!pq.empty() && pq.top() > ele){\\n\\t\\t\\tresult[idx] = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\t\\telse\\tbreak;\\n\\t}\\n\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tif(result[i] == -1){\\n\\t\\t\\tresult[i] = res.top();\\n\\t\\t\\tres.pop();\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n\\tint n = nums1.size();\\n\\t\\n\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\tpriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq2;\\t\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tpq.push(nums1[i]);\\n\\t\\tpq2.push({nums2[i], i});\\n\\t}\\n\\n\\tvector<int> result(n, -1);\\n\\tstack<int> res;\\n\\twhile(!pq2.empty() && !pq.empty()){\\n\\t\\tint ele = pq2.top().first;\\n\\t\\tint idx = pq2.top().second;\\n\\t\\tpq2.pop();\\n\\n\\t\\twhile(!pq.empty() && pq.top() <= ele){\\n\\t\\t\\tres.push(pq.top());\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\n\\t\\tif(!pq.empty() && pq.top() > ele){\\n\\t\\t\\tresult[idx] = pq.top();\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\t\\telse\\tbreak;\\n\\t}\\n\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tif(result[i] == -1){\\n\\t\\t\\tresult[i] = res.top();\\n\\t\\t\\tres.pop();\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1672786,
                "title": "java-easy-solution-greedy-sorting-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n       int temp1[]=nums1.clone();\\n       int temp2[]=nums2.clone();\\n       Arrays.sort(temp1);\\n       Arrays.sort(temp2);\\n       HashMap<Integer,Queue<Integer>> map=new HashMap<>();\\n       int j=0,k=nums2.length-1;\\n       for(int i=0;i<nums1.length;i++){\\n           \\n            \\n           \\n           if(temp1[i]>temp2[j])\\n           {\\n               \\n              if(!map.containsKey(temp2[j]))\\n                   map.put(temp2[j],new LinkedList<>());\\n               \\n               \\n               map.get(temp2[j++]).add(temp1[i]);\\n           }\\n           else\\n           {\\n               if(!map.containsKey(temp2[k]))\\n                   map.put(temp2[k],new LinkedList<>());\\n               \\n               \\n               map.get(temp2[k--]).add(temp1[i]);\\n           }\\n              \\n       }\\n      for(int i=0;i<nums2.length;i++)\\n          nums1[i]=map.get(nums2[i]).poll();\\n        \\n       return nums1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n       int temp1[]=nums1.clone();\\n       int temp2[]=nums2.clone();\\n       Arrays.sort(temp1);\\n       Arrays.sort(temp2);\\n       HashMap<Integer,Queue<Integer>> map=new HashMap<>();\\n       int j=0,k=nums2.length-1;\\n       for(int i=0;i<nums1.length;i++){\\n           \\n            \\n           \\n           if(temp1[i]>temp2[j])\\n           {\\n               \\n              if(!map.containsKey(temp2[j]))\\n                   map.put(temp2[j],new LinkedList<>());\\n               \\n               \\n               map.get(temp2[j++]).add(temp1[i]);\\n           }\\n           else\\n           {\\n               if(!map.containsKey(temp2[k]))\\n                   map.put(temp2[k],new LinkedList<>());\\n               \\n               \\n               map.get(temp2[k--]).add(temp1[i]);\\n           }\\n              \\n       }\\n      for(int i=0;i<nums2.length;i++)\\n          nums1[i]=map.get(nums2[i]).poll();\\n        \\n       return nums1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574167,
                "title": "c-short-code-using-multiset",
                "content": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        multiset<int> buffer;\\n        for(auto x : nums1){\\n            buffer.insert(x);\\n        }\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            auto it = buffer.upper_bound(nums2[i]);\\n            if(it==buffer.end()){\\n                it = buffer.begin();\\n            }\\n            ans[i] = *it;\\n            buffer.erase(it);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        multiset<int> buffer;\\n        for(auto x : nums1){\\n            buffer.insert(x);\\n        }\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            auto it = buffer.upper_bound(nums2[i]);\\n            if(it==buffer.end()){\\n                it = buffer.begin();\\n            }\\n            ans[i] = *it;\\n            buffer.erase(it);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1530696,
                "title": "o-n-log-n-sorting-monotonic-queue",
                "content": "Our goal, for each index `i` in `nums2`, is to (greedily) find the smallest value in `nums1` which exceeds `nums2[i]` (and thus yields us an advantage at position `i`). That is, we want to find the \\'next greater element\\' in `nums1` for each value in `nums2`.\\n\\nIf we cannot find such a value for index `i`, then we are free to assign to `nums1[i]` anything that remains unused after we finish iterating through the elements of `nums2`.\\n\\n**SORTED CASE: MONOTONIC QUEUE**\\nLet\\'s simplify our lives a bit by assuming that `nums1` and `nums2` are each sorted in ascending order. \\n\\nFor current value `nums2[i]`, we can iterate through the elements of `nums1` from the front (since they are in ascending order as well) until we arrive at the first element in `nums1` that exceeds `nums2[i]`; we assign this value to index `i` of the new shuffled array (as this greedily confers an advantage to us at index `i`). \\n\\nHowever, since the numbers of `nums2` are in ascending order, everything in `nums1` that didn\\'t exceed `nums2[i]` will not exceed anything later on in `nums2`, so we can safely \\'discard\\'/dequeue these values (more on this in a moment), i.e. we treat `nums1` as a monotonic queue.\\n\\nWhat happens if we cannot find anything in `nums1` that exceeds value `nums2[i]`? This occurs if and only if our queue `nums1` becomes empty during the above process of finding a next greater element in `nums1`. What do we assign to index `i` of our shuffled array in this case? Well, anything that has not been used already from `nums1` will work (since none of these values will confer any advantage ever). For this reason, anything we dequeue from our monotonic queue `nums1`, we shouldn\\'t _truly_ discard, but rather save off as a set of unsed elements, for filling any slots `i` where we cannot find an element in (sorted) `nums1` that exceeds `nums2[i]`.\\n\\n**UNSORTED CASE**\\nNow to handle the general case of when the arrays are unsorted, we note that the only thing we really care about above from the original ordering of `nums1` and `nums2` are the original indexes of elements from `nums2` (since we use these to determine where to assign a front element from our monotonic queue `nums1` in the new shuffled array).\\n\\nOf course, sorting elements, we lose this information about `nums2`; so before we do any sorting, we should save this information in a multi-valued hash map (for the situation that we have repeated numbers in `nums2`), and reference back to this when determining which index in our new shuffled array should be assigned the front value in the monotonic queue `nums1` (or an unused element).\\n\\n**CODE**\\n```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        n = len(nums1)\\n        \\n        # STEP 1: For each value in nums2, store the list of indexes in the array the value appears at\\n        nums2_val_to_index = {v: [] for v in nums2}\\n        for i,v in enumerate(nums2):\\n            nums2_val_to_index[v].append(i)\\n\\n        # STEP 2: Sort nums1 and nums2\\n        nums1.sort()\\n        nums2.sort()\\n        \\n        # STEP 3: Treat nums1 as monotonic queue, in order to greedily find next greatest element in (sorted)\\n        # nums1 for each element in (sorted) nums2 \\n        unused = []\\n        new_arr = [0] * n\\n        for i, v in enumerate(nums2):\\n            while len(nums1) > 0 and nums1[0] <= v:\\n                unused.append(nums1.pop(0))\\n            # everything in nums1 is too small compared to nums2[i]; we are free to fill original index of nums2[i] in the \\n            # new shuffled array with whatever has been \\'discarded\\' from the queue\\n            if len(nums1) == 0:\\n                new_arr[nums2_val_to_index[v].pop(0)] = unused.pop(0)\\n            else:\\n                new_arr[nums2_val_to_index[v].pop(0)] = nums1.pop(0)\\n\\n        return new_arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        n = len(nums1)\\n        \\n        # STEP 1: For each value in nums2, store the list of indexes in the array the value appears at\\n        nums2_val_to_index = {v: [] for v in nums2}\\n        for i,v in enumerate(nums2):\\n            nums2_val_to_index[v].append(i)\\n\\n        # STEP 2: Sort nums1 and nums2\\n        nums1.sort()\\n        nums2.sort()\\n        \\n        # STEP 3: Treat nums1 as monotonic queue, in order to greedily find next greatest element in (sorted)\\n        # nums1 for each element in (sorted) nums2 \\n        unused = []\\n        new_arr = [0] * n\\n        for i, v in enumerate(nums2):\\n            while len(nums1) > 0 and nums1[0] <= v:\\n                unused.append(nums1.pop(0))\\n            # everything in nums1 is too small compared to nums2[i]; we are free to fill original index of nums2[i] in the \\n            # new shuffled array with whatever has been \\'discarded\\' from the queue\\n            if len(nums1) == 0:\\n                new_arr[nums2_val_to_index[v].pop(0)] = unused.pop(0)\\n            else:\\n                new_arr[nums2_val_to_index[v].pop(0)] = nums1.pop(0)\\n\\n        return new_arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522671,
                "title": "easy-c-solution-map-binary-search-sorting-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static cmp(pair<int,int>&a,pair<int,int>&b) {\\n         return  a.first<b.first;\\n    }\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        map<int,int> mp;\\n        vector<pair<int,int>> px;\\n        for(int i=0; i<a.size(); i++) {\\n             px.push_back({b[i],i});\\n             mp[a[i]]++;\\n        }\\n        sort(px.begin(),px.end(),cmp);\\n        for(int i=0; i<px.size(); i++) {\\n             auto it=mp.upper_bound(px[i].first);\\n             if(it==mp.end()) {\\n                  for(pair<int,int> p : mp) {\\n                     for(int j=0; j<p.second; j++) a[px[i++].second]=p.first;\\n                  }\\n                  break;\\n             }\\n             a[px[i].second]=it->first;\\n             it->second--;\\n             if(it->second==0) mp.erase(it);\\n        }\\n        return a;\\n    }\\n};\\n/*\\n1 4 10 11\\n2 7 11 15\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(pair<int,int>&a,pair<int,int>&b) {\\n         return  a.first<b.first;\\n    }\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        map<int,int> mp;\\n        vector<pair<int,int>> px;\\n        for(int i=0; i<a.size(); i++) {\\n             px.push_back({b[i],i});\\n             mp[a[i]]++;\\n        }\\n        sort(px.begin(),px.end(),cmp);\\n        for(int i=0; i<px.size(); i++) {\\n             auto it=mp.upper_bound(px[i].first);\\n             if(it==mp.end()) {\\n                  for(pair<int,int> p : mp) {\\n                     for(int j=0; j<p.second; j++) a[px[i++].second]=p.first;\\n                  }\\n                  break;\\n             }\\n             a[px[i].second]=it->first;\\n             it->second--;\\n             if(it->second==0) mp.erase(it);\\n        }\\n        return a;\\n    }\\n};\\n/*\\n1 4 10 11\\n2 7 11 15\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448054,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        B = sorted([(ix, val) for ix, val in enumerate(B)], key=lambda x:x[1], reverse=True)\\n        answer = [0]*len(A)\\n        for (i, b) in B:\\n            if b < A[-1]:\\n                answer[i] = A.pop()\\n            else:\\n                answer[i] = A[0]\\n                A = A[1:]\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        B = sorted([(ix, val) for ix, val in enumerate(B)], key=lambda x:x[1], reverse=True)\\n        answer = [0]*len(A)\\n        for (i, b) in B:\\n            if b < A[-1]:\\n                answer[i] = A.pop()\\n            else:\\n                answer[i] = A[0]\\n                A = A[1:]\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417014,
                "title": "c-multiset-greedy-algorithm",
                "content": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n  multiset<int> store{begin(nums1), end(nums1)};\\n  for (int i = 0; i < nums2.size(); ++ i) {\\n\\tauto iter = store.upper_bound(nums2[i]);\\n\\tif (iter == store.end()) {\\n\\t  iter = store.begin();\\n\\t}\\n\\tnums1[i] = *iter;\\n\\tstore.erase(iter);\\n  }\\n  return nums1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n  multiset<int> store{begin(nums1), end(nums1)};\\n  for (int i = 0; i < nums2.size(); ++ i) {\\n\\tauto iter = store.upper_bound(nums2[i]);\\n\\tif (iter == store.end()) {\\n\\t  iter = store.begin();\\n\\t}\\n\\tnums1[i] = *iter;\\n\\tstore.erase(iter);\\n  }\\n  return nums1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1367347,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        int n=nums1.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            pq.push({nums2[i],i});\\n        }\\n        vector<int>ans(n,-1);\\n        int i=0;\\n        vector<int>missing;\\n        while(i<nums1.size() && !pq.empty())\\n        {\\n            if(nums1[i]>pq.top().first)\\n            {\\n                ans[pq.top().second]=nums1[i];\\n                pq.pop();\\n                i++;\\n            }\\n            else\\n            {\\n                missing.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        int k=0;\\n        for(int a=0;a<ans.size();a++)\\n        {\\n            if(ans[a]==-1)\\n            {\\n                ans[a]=missing[k];\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        int n=nums1.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            pq.push({nums2[i],i});\\n        }\\n        vector<int>ans(n,-1);\\n        int i=0;\\n        vector<int>missing;\\n        while(i<nums1.size() && !pq.empty())\\n        {\\n            if(nums1[i]>pq.top().first)\\n            {\\n                ans[pq.top().second]=nums1[i];\\n                pq.pop();\\n                i++;\\n            }\\n            else\\n            {\\n                missing.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        int k=0;\\n        for(int a=0;a<ans.size();a++)\\n        {\\n            if(ans[a]==-1)\\n            {\\n                ans[a]=missing[k];\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350234,
                "title": "java-solution-using-priorityqueue-hashmap-and-stacks",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int temp2[]=new int[nums1.length]; // clone of nums2\\n        for(int i=0;i<nums2.length;i++)\\n            temp2[i]=nums2[i];\\n        Arrays.sort(temp2); // sorting the clone of nums2\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(); // priority queue to store the elements of nums1\\n        for(int i : nums1)\\n            pq.add(i);\\n        HashMap<Integer,Stack<Integer>> hm=new HashMap<>(); // hashmap to store the corresponding answer values\\n        Stack<Integer> helper=new Stack<>(); // stack to store the unmatched elements of nums1\\n        for(int i=0;i<temp2.length;i++)\\n        {\\n            if(pq.isEmpty())\\n                break;\\n            int p=pq.remove();\\n            if(p<=temp2[i])\\n            {\\n                i--;\\n               helper.push(p);\\n            }\\n            else\\n            {\\n                if(!hm.containsKey(temp2[i]))\\n                    hm.put(temp2[i],new Stack<Integer>());\\n                hm.get(temp2[i]).push(p);\\n            }\\n        }\\n        int ans[]=new int[nums2.length];\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(hm.containsKey(nums2[i]) && hm.get(nums2[i]).size()>0) // checking if there is mapping for current element\\n                ans[i]=hm.get(nums2[i]).pop();\\n            else\\n                ans[i]=helper.pop(); // the unmapped element is mapped with the unmapped nums1 elements\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int temp2[]=new int[nums1.length]; // clone of nums2\\n        for(int i=0;i<nums2.length;i++)\\n            temp2[i]=nums2[i];\\n        Arrays.sort(temp2); // sorting the clone of nums2\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(); // priority queue to store the elements of nums1\\n        for(int i : nums1)\\n            pq.add(i);\\n        HashMap<Integer,Stack<Integer>> hm=new HashMap<>(); // hashmap to store the corresponding answer values\\n        Stack<Integer> helper=new Stack<>(); // stack to store the unmatched elements of nums1\\n        for(int i=0;i<temp2.length;i++)\\n        {\\n            if(pq.isEmpty())\\n                break;\\n            int p=pq.remove();\\n            if(p<=temp2[i])\\n            {\\n                i--;\\n               helper.push(p);\\n            }\\n            else\\n            {\\n                if(!hm.containsKey(temp2[i]))\\n                    hm.put(temp2[i],new Stack<Integer>());\\n                hm.get(temp2[i]).push(p);\\n            }\\n        }\\n        int ans[]=new int[nums2.length];\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(hm.containsKey(nums2[i]) && hm.get(nums2[i]).size()>0) // checking if there is mapping for current element\\n                ans[i]=hm.get(nums2[i]).pop();\\n            else\\n                ans[i]=helper.pop(); // the unmapped element is mapped with the unmapped nums1 elements\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173832,
                "title": "c-greedy-two-pointers-easy-code",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        vector<pair<int, int>> vec;\\n        for(int i = 0; i<n; i++){\\n            vec.push_back(make_pair(b[i], i));\\n        }\\n        sort(vec.begin(), vec.end(), greater<pair<int, int>>());\\n        \\n        sort(a.begin(), a.end(), greater<int>());\\n        \\n        int low = 0, high = n-1;\\n        for(int i = 0; i<n; i++){\\n            if(a[low] > vec[i].first){\\n                b[vec[i].second] = a[low];\\n                low++;\\n            }else{\\n                b[vec[i].second] = a[high];\\n                high--;\\n            }\\n        }\\n        return b;\\n    } \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        vector<pair<int, int>> vec;\\n        for(int i = 0; i<n; i++){\\n            vec.push_back(make_pair(b[i], i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1129822,
                "title": "c-sorting-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<pair<int,int>> arrB;\\n        vector<int> unused, res(n, -1);\\n        for(int i = 0; i < n; i++) arrB.push_back(make_pair(B[i], i));\\n        sort(A.begin(), A.end());\\n        sort(arrB.begin(), arrB.end());\\n        int i = 0, j = 0;\\n        while(i < n && j < n) {\\n            if(A[i] > arrB[j].first) {res[arrB[j].second] = A[i];j++;}\\n            else unused.push_back(A[i]);\\n            i++;\\n        }\\n        j = 0;\\n        for(int i = 0; i < n; i++) if(res[i] == -1) res[i] = unused[j++];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<pair<int,int>> arrB;\\n        vector<int> unused, res(n, -1);\\n        for(int i = 0; i < n; i++) arrB.push_back(make_pair(B[i], i));\\n        sort(A.begin(), A.end());\\n        sort(arrB.begin(), arrB.end());\\n        int i = 0, j = 0;\\n        while(i < n && j < n) {\\n            if(A[i] > arrB[j].first) {res[arrB[j].second] = A[i];j++;}\\n            else unused.push_back(A[i]);\\n            i++;\\n        }\\n        j = 0;\\n        for(int i = 0; i < n; i++) if(res[i] == -1) res[i] = unused[j++];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126454,
                "title": "javascript-easy-to-understand-greedy",
                "content": "The key point for this problem is that we could return any permutation meets the requirement.\\nSo it\\'s easy to find out that we could traversal the sorted `B` and find the answer via greedy algorithm.\\n\\n## SOLUTION 1\\n\\n1. We sort the `A` and `B` first.\\n2. Traversal `B` to find out the closest and bigger number in `A` for each number in `B`. If there\\'s no such number, then we use the smallest number in `A` which is mostly useless in our rule.\\n3. Try to match the index and value to original `B` to get the final answer.\\n\\n```js\\nconst SWAP = (a, b) => b - a;\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const ret = new Uint32Array(LEN);\\n  const b = [...B];\\n  const map = {};\\n  b.sort(SWAP);\\n  a.sort(SWAP);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > b[i] ? a[left++] : a[right--];\\n    map[b[i]] ? map[b[i]].push(value) : (map[b[i]] = [value]);\\n  }\\n  for (let i = 0; i < B.length; ++i) {\\n    ret[i] = map[B[i]].pop();\\n  }\\n  return ret;\\n};\\n```\\n\\n## SOLUTION 2\\n\\nWe use a hashmap and linear list to save the value mappings in solution 1. But we could do it better actually.\\nThe most important is to find a way to save the index mappings between the original `B` and sorted `B`.\\n\\nSo, I give 2 solutions here, the main greedy algorithm is the same as solution 1. I think it\\'s easy to read, so if there\\'s any question, please give me a comment.\\n\\n```js\\n// save the index as extra data\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const b = B.map((val, idx) => [val, idx]);\\n  const ret = new Uint32Array(LEN);\\n  a.sort((a, b) => b - a);\\n  b.sort((a, b) => b[0] - a[0]);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > b[i][0] ? a[left++] : a[right--];\\n    ret[b[i][1]] = value;\\n  }\\n  return ret;\\n};\\n```\\n\\n```js\\n// save the index for B which is sorted by value\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const b = B.map((val, idx) => idx);\\n  const ret = new Uint32Array(LEN);\\n  a.sort((a, b) => b - a);\\n  b.sort((i, j) => B[j] - B[i]);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > B[b[i]] ? a[left++] : a[right--];\\n    ret[b[i]] = value;\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst SWAP = (a, b) => b - a;\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const ret = new Uint32Array(LEN);\\n  const b = [...B];\\n  const map = {};\\n  b.sort(SWAP);\\n  a.sort(SWAP);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > b[i] ? a[left++] : a[right--];\\n    map[b[i]] ? map[b[i]].push(value) : (map[b[i]] = [value]);\\n  }\\n  for (let i = 0; i < B.length; ++i) {\\n    ret[i] = map[B[i]].pop();\\n  }\\n  return ret;\\n};\\n```\n```js\\n// save the index as extra data\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const b = B.map((val, idx) => [val, idx]);\\n  const ret = new Uint32Array(LEN);\\n  a.sort((a, b) => b - a);\\n  b.sort((a, b) => b[0] - a[0]);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > b[i][0] ? a[left++] : a[right--];\\n    ret[b[i][1]] = value;\\n  }\\n  return ret;\\n};\\n```\n```js\\n// save the index for B which is sorted by value\\nconst advantageCount = (a, B) => {\\n  const LEN = a.length;\\n  const b = B.map((val, idx) => idx);\\n  const ret = new Uint32Array(LEN);\\n  a.sort((a, b) => b - a);\\n  b.sort((i, j) => B[j] - B[i]);\\n  for (let i = 0, left = 0, right = LEN - 1; i < LEN; ++i) {\\n    const value = a[left] > B[b[i]] ? a[left++] : a[right--];\\n    ret[b[i]] = value;\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126272,
                "title": "c-without-map-sets-using-single-sort-and-upper-bound-to-a",
                "content": "Intuition - Advantage will be when we select an element in A such that it is greater than B at some index. And we will have more greater elements left in A if we select the smallest greater element than B instead of randomly selecting element in A that is greater than B.\\n\\nUpper_bound on sorted array gives the iterator to next greater element than the element searched for. E.g. - upper_bound(sortedA.begin(), sortedA.end(), 8) will give you iterator to 9 for sortedA = [5,6,7,8,9,10]\\n\\nSo, knowing this I sorted array A and created a boolean indices array of same size as A that will store which indices from A have been occupied.\\n\\nNow traversing B we will look for element in A that is just greater than B. If found we will update indices A to true and res as well to store the resultant permutation.\\n\\nIn the end we will also fill the rest of res for elements which did not had any greater element in A.\\n\\n```\\n// to get the next index that is not occupied\\nint nextAvailable(vector<bool>& indices, int j, const int& n){\\n\\twhile(j < n && indices[j]) j++;\\n\\treturn j;\\n}\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tint n = A.size(), idx;\\n\\tvector<bool> indices(n);\\n\\tvector<int> res(n, -1);\\n\\tsort(A.begin(), A.end());\\n\\tfor(int i=0;i<n;i++){\\n\\t\\t// get the index of the next greater element\\n\\t\\tidx = upper_bound(A.begin(), A.end(), B[i]) - A.begin();\\n\\t\\twhile(idx < n && indices[idx]) idx++;\\n\\t\\tif(idx != n){\\n\\t\\t\\tindices[idx] = true;\\n\\t\\t\\tres[i] = A[idx];\\n\\t\\t}\\n\\t}\\n\\t// updating res with rest of the elements\\n\\tint j = 0;\\n\\tj = nextAvailable(indices, j, n);\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tif(res[i] == -1){\\n\\t\\t\\tres[i] = A[j];\\n\\t\\t\\tj = nextAvailable(indices, j+1, n);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// to get the next index that is not occupied\\nint nextAvailable(vector<bool>& indices, int j, const int& n){\\n\\twhile(j < n && indices[j]) j++;\\n\\treturn j;\\n}\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tint n = A.size(), idx;\\n\\tvector<bool> indices(n);\\n\\tvector<int> res(n, -1);\\n\\tsort(A.begin(), A.end());\\n\\tfor(int i=0;i<n;i++){\\n\\t\\t// get the index of the next greater element\\n\\t\\tidx = upper_bound(A.begin(), A.end(), B[i]) - A.begin();\\n\\t\\twhile(idx < n && indices[idx]) idx++;\\n\\t\\tif(idx != n){\\n\\t\\t\\tindices[idx] = true;\\n\\t\\t\\tres[i] = A[idx];\\n\\t\\t}\\n\\t}\\n\\t// updating res with rest of the elements\\n\\tint j = 0;\\n\\tj = nextAvailable(indices, j, n);\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tif(res[i] == -1){\\n\\t\\t\\tres[i] = A[j];\\n\\t\\t\\tj = nextAvailable(indices, j+1, n);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126041,
                "title": "python-3-binary-search-two-pointers-deque-2-lines",
                "content": "# Naive, Binary search\\n- Naive iterative approach is to find minimum `A` value greater than current `B` value. If  there is no such minimum value then use just lowest value (no advantage).\\n- To avoid double usage the found values should be removed from the `A` list.\\n- To quickly search `A` list it should be sorted.\\n- Time complexity is `O(n**2)`. Space complexity is `O(n)`.\\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A = sorted(A)\\n        \\n        return [A.pop(bisect_right(A, b) % len(A)) for b in B]\\n```\\n# Two pointers, A loop\\n- `pop(i)` method from the previous approach takes `O(n)`. To improve it we can sort both `A` and `B` lists and use it in pair. Sorted `B` list should contain original index to be able restore original order.\\n- Every sorted `A` value we compare with sorted `B` value. If `A` value is greater `B` value then `A` value has the advantage (move `A` value to the begin of result list). Else `A` value and all next values have no advantage (move `A` value to the end of result list).\\n- Use `B` index to sort result in original order.\\n- Time complexity is `O(n * log n)`. Space complexity is `O(n)`.\\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        B = sorted(zip(B, count()))\\n        i, j = 0, -1; ret = [None]*len(B)\\n        for a in sorted(A):\\n            if a > B[i][0]:\\n                ret[B[i][1]] = a; i += 1\\n            else:\\n                ret[B[j][1]] = a; j -= 1\\n        \\n        return ret\\n```\\n# Deque, B loop\\n- We can use double ended queue instead of two pointers.\\n- We can traverse sorted `B` list instead of sorted `A`. Note the lists are reversed.\\n- Time complexity is `O(n * log n)`. Space complexity is `O(n)`.\\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A = deque(sorted(A, reverse=True))\\n\\t\\tret = [...]*len(B)\\n        for b, i in sorted(zip(B, count()), reverse=True):\\n            ret[i] = A.popleft() if A[0] > b else A.pop()\\n        \\n        return ret\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A = sorted(A)\\n        \\n        return [A.pop(bisect_right(A, b) % len(A)) for b in B]\\n```\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        B = sorted(zip(B, count()))\\n        i, j = 0, -1; ret = [None]*len(B)\\n        for a in sorted(A):\\n            if a > B[i][0]:\\n                ret[B[i][1]] = a; i += 1\\n            else:\\n                ret[B[j][1]] = a; j -= 1\\n        \\n        return ret\\n```\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        A = deque(sorted(A, reverse=True))\\n\\t\\tret = [...]*len(B)\\n        for b, i in sorted(zip(B, count()), reverse=True):\\n            ret[i] = A.popleft() if A[0] > b else A.pop()\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126022,
                "title": "100-idiomatic-go-solution",
                "content": "```\\nfunc advantageCount(A []int, B []int) []int {\\n\\tsort.Ints(A)\\n\\tb := make([][2]int, len(B))\\n\\tfor i, n := range B {\\n\\t\\tb[i] = [2]int{n, i}\\n\\t}\\n\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\treturn b[i][0] < b[j][0]\\n\\t})\\n\\n\\tresult := make([]int, len(A))\\n\\tleft, right := 0, len(A)-1\\n\\tfor i := len(b) - 1; i >= 0; i-- {\\n\\t\\tval, idx := b[i][0], b[i][1]\\n\\t\\tif A[right] > val {\\n\\t\\t\\tresult[idx] = A[right]\\n\\t\\t\\tright--\\n\\t\\t} else {\\n\\t\\t\\tresult[idx] = A[left]\\n\\t\\t\\tleft++\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc advantageCount(A []int, B []int) []int {\\n\\tsort.Ints(A)\\n\\tb := make([][2]int, len(B))\\n\\tfor i, n := range B {\\n\\t\\tb[i] = [2]int{n, i}\\n\\t}\\n\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\treturn b[i][0] < b[j][0]\\n\\t})\\n\\n\\tresult := make([]int, len(A))\\n\\tleft, right := 0, len(A)-1\\n\\tfor i := len(b) - 1; i >= 0; i-- {\\n\\t\\tval, idx := b[i][0], b[i][1]\\n\\t\\tif A[right] > val {\\n\\t\\t\\tresult[idx] = A[right]\\n\\t\\t\\tright--\\n\\t\\t} else {\\n\\t\\t\\tresult[idx] = A[left]\\n\\t\\t\\tleft++\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125897,
                "title": "python-clean-simple",
                "content": "```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        q = deque(sorted(A))\\n        b = sorted([(num, i) for i, num in enumerate(B)], reverse=True)\\n        result = [0] * len(q) \\n        for num, i in b:\\n            if num < q[-1]:\\n                result[i] = q.pop()\\n            else:\\n                result[i] = q.popleft()\\n        return result\\n```\\n\\nBut of course, lee215\\'s answer looks even neater. \\uD83E\\uDD2F",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        q = deque(sorted(A))\\n        b = sorted([(num, i) for i, num in enumerate(B)], reverse=True)\\n        result = [0] * len(q) \\n        for num, i in b:\\n            if num < q[-1]:\\n                result[i] = q.pop()\\n            else:\\n                result[i] = q.popleft()\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125882,
                "title": "c-greedy-solution-using-sort-explained",
                "content": "The idea is to keep elements of A greater than elements of B, but they have to be closest.\\nsort vector A in order to use upper_bound function.\\nupper_bound returns the next larger value than the value we passed in the function.\\nif we find next largest value, we put that in result vector and erase it from vector A, so we don\\'t use it again.\\nIf we don\\'t find the largest value, then we put the smallest value. The smallest value is located at beginning of vector A (A is sorted). Erase that too.\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> res(A.size());\\n        int i, j, index;\\n        sort(A.begin(), A.end());\\n        for(i=0; i<B.size(); i++)\\n        {\\n            auto ub = upper_bound(A.begin(), A.end(), B[i]);\\n           \\n            if(ub!=A.end())\\n            {\\n                res[i] = A[ub-A.begin()];\\n               index = ub-A.begin();\\n                A.erase(A.begin()+index);\\n            }\\n            else\\n            {\\n                res[i] = A[0];\\n                A.erase(A.begin()+0);\\n            }      \\n        }\\n        return res;\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> res(A.size());\\n        int i, j, index;\\n        sort(A.begin(), A.end());\\n        for(i=0; i<B.size(); i++)\\n        {\\n            auto ub = upper_bound(A.begin(), A.end(), B[i]);\\n           \\n            if(ub!=A.end())\\n            {\\n                res[i] = A[ub-A.begin()];\\n               index = ub-A.begin();\\n                A.erase(A.begin()+index);\\n            }\\n            else\\n            {\\n                res[i] = A[0];\\n                A.erase(A.begin()+0);\\n            }      \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125704,
                "title": "python-greedy-two-pointers",
                "content": "just keep original indices for B, sort and then one more traversal to fill remains\\n\\n```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        res = [None for _ in range(len(A))]\\n        \\n        A.sort(reverse=True)\\n        bb = [[i, B[i]] for i in range(len(B))]\\n        \\n        bb.sort(key=lambda k: k[1], reverse=True)\\n        \\n        i = 0\\n        j = 0\\n        while i < len(B):\\n            if bb[i][1] < A[j]:\\n                res[bb[i][0]] = A[j]\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        \\n        for i in range(len(res)):\\n            if res[i] is None:\\n                res[i] = A[j]\\n                j+=1\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        res = [None for _ in range(len(A))]\\n        \\n        A.sort(reverse=True)\\n        bb = [[i, B[i]] for i in range(len(B))]\\n        \\n        bb.sort(key=lambda k: k[1], reverse=True)\\n        \\n        i = 0\\n        j = 0\\n        while i < len(B):\\n            if bb[i][1] < A[j]:\\n                res[bb[i][0]] = A[j]\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        \\n        for i in range(len(res)):\\n            if res[i] is None:\\n                res[i] = A[j]\\n                j+=1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125646,
                "title": "c-solution-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\t\\t//storing in set to remove the duplicates\\n        multiset<int> s(A.begin(),A.end());\\n        vector<int>ans(n, -1);\\n        for(int i = 0; i < n; i++)\\n        {\\n\\t\\t    // see if is there is any value present which is just greater one \\n            auto itr = s.upper_bound(B[i]);\\n            if(itr != s.end())\\n            {\\n                ans[i] = *itr;\\n                s.erase(itr);\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ans[i] == -1)\\n            {\\n                ans[i] = *s.begin();\\n                s.erase(s.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n\\t\\t//storing in set to remove the duplicates\\n        multiset<int> s(A.begin(),A.end());\\n        vector<int>ans(n, -1);\\n        for(int i = 0; i < n; i++)\\n        {\\n\\t\\t    // see if is there is any value present which is just greater one \\n            auto itr = s.upper_bound(B[i]);\\n            if(itr != s.end())\\n            {\\n                ans[i] = *itr;\\n                s.erase(itr);\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ans[i] == -1)\\n            {\\n                ans[i] = *s.begin();\\n                s.erase(s.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125532,
                "title": "javascript-easy-to-understand-with-explanation-and-commented-code",
                "content": "Ok, so the problem is, given two arrays, A and B, reshuffel A, so that at each position, it is a higher value than B, or at least in the way that gives A, as many indicies with higher value as possible.\\n\\nSo, while maybe not the most optimal solution, one way is to sort A, then iterate though B, beating each value in B with as small a value in A as possible.  When it\\'s not possible to beat the value, simply use the smallest value possible.  \\n\\nIf you sort A, u know that the last value is the largest, the first value the smallest.\\nSo, one by one, is the value of B, smaller than the largest value of A?  If so, it\\'s possible to beat, so lets do it in the smallest way possible (saving larger numbers for use later).\\n\\nSince I didn\\'t sort B in any way, i keep starting at the bottom of A and go until i find the larger A value and swap that value into B.  I could have used another array, but since I don\\'t need previous values of B anymore, why not just reuse that data structure.  When finished, return it.\\n\\n```\\nvar advantageCount = function(A, B) {\\n   let sortedA = A.sort((a,b) => a-b); // sort A\\n   for (let i=0, j=B.length; i<j; i++) { // iterate through B\\n     if (B[i]<A[A.length-1]) { // is it possible to beat the current B?\\n       let ii=0; // we can, so starting at zero, find the first value that beats the current B val\\n       while (B[i]>=A[ii]) ii++ //keep going\\n       B[i] = A.splice(ii,1); // ok, we have a larger A value, so put it into B which we will return\\n     } else {\\n       B[i] = A.shift(); // In this case, the current B is even larger than the largest A, so use the smallest A value\\n     }\\n   }\\n  return B; \\n};\\n```\\n\\nIf this solution helps you, please upvote it so others can notice it, not to mention appreciating a little of my effort.  Thanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar advantageCount = function(A, B) {\\n   let sortedA = A.sort((a,b) => a-b); // sort A\\n   for (let i=0, j=B.length; i<j; i++) { // iterate through B\\n     if (B[i]<A[A.length-1]) { // is it possible to beat the current B?\\n       let ii=0; // we can, so starting at zero, find the first value that beats the current B val\\n       while (B[i]>=A[ii]) ii++ //keep going\\n       B[i] = A.splice(ii,1); // ok, we have a larger A value, so put it into B which we will return\\n     } else {\\n       B[i] = A.shift(); // In this case, the current B is even larger than the largest A, so use the smallest A value\\n     }\\n   }\\n  return B; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125446,
                "title": "rust-solution",
                "content": "Applied the strategy of `\\u7530\\u5FCC\\u8D5B\\u9A6C`  here.\\n\\n```rust\\nimpl Solution {\\n    // time: O(nlogn)\\n    pub fn advantage_count(mut a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n        let n = a.len();\\n        a.sort();\\n        let mut b: Vec<(usize, i32)> = b.into_iter().enumerate().collect();\\n        b.sort_by(|a, b| a.1.cmp(&b.1));\\n\\n        let mut res = vec![0; n];\\n        let mut slow = 0;\\n        let mut fast = n - 1;\\n        while let Some((opponent_idx, opponent)) = b.pop() {\\n            res[opponent_idx] = {\\n                if opponent >= a[fast] {\\n                    let v = a[slow];\\n                    slow += 1;\\n                    v\\n                } else {\\n                    let v = a[fast];\\n                    fast -= 1;\\n                    v\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    // time: O(nlogn)\\n    pub fn advantage_count(mut a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {\\n        let n = a.len();\\n        a.sort();\\n        let mut b: Vec<(usize, i32)> = b.into_iter().enumerate().collect();\\n        b.sort_by(|a, b| a.1.cmp(&b.1));\\n\\n        let mut res = vec![0; n];\\n        let mut slow = 0;\\n        let mut fast = n - 1;\\n        while let Some((opponent_idx, opponent)) = b.pop() {\\n            res[opponent_idx] = {\\n                if opponent >= a[fast] {\\n                    let v = a[slow];\\n                    slow += 1;\\n                    v\\n                } else {\\n                    let v = a[fast];\\n                    fast -= 1;\\n                    v\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125343,
                "title": "c-code-using-multiset",
                "content": "Store all the elements in a multiset and for each element in vector B , select the just greater element from multiset. Incase there is no such element choose the smallest element from set , i.e. the first element and push it into the res vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        // sort(A.begin(), A.end());\\n        vector<int> res ; \\n        int size = B.size();\\n        multiset<int> st;\\n        for(int i = 0; i< size; i++){\\n            st.insert(A[i]);\\n        }\\n        for(int i = 0; i<size; i++){\\n            auto upper1 = st.upper_bound(B[i]);\\n            if(upper1 != st.end()){\\n                res.push_back(*upper1);\\n                st.erase(upper1);\\n            }\\n            else{\\n                res.push_back(*st.begin());\\n                st.erase(st.begin());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        // sort(A.begin(), A.end());\\n        vector<int> res ; \\n        int size = B.size();\\n        multiset<int> st;\\n        for(int i = 0; i< size; i++){\\n            st.insert(A[i]);\\n        }\\n        for(int i = 0; i<size; i++){\\n            auto upper1 = st.upper_bound(B[i]);\\n            if(upper1 != st.end()){\\n                res.push_back(*upper1);\\n                st.erase(upper1);\\n            }\\n            else{\\n                res.push_back(*st.begin());\\n                st.erase(st.begin());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125197,
                "title": "advantage-shuffle-fast-python-multiple-solutions-with-explanation",
                "content": "### Ideas\\nThere are multiple ways to approach this problem. I list them as my thought progresses.\\n\\n#### 1. Sorted container\\nSort `B` from big to small. The optimal pick for `b` is the smallest not-chosen value in `A` that `> b`. \\n\\nThis approach requires a data structure that supports efficient `bisect` query and deletion. `sortedcontainers.SortedList` can come in handy.\\n\\n#### 2. Running stack\\nCan we do it without non-standard libraries? The answer is yes. We can sort `A` as well and maintain a stack of eligible values.  For each `b`, we will add values `> b` from sorted `A` to the stack in descending order and pick the top element for `b`. \\n\\nSee \"Code 2\" below. After the main loop, we fill the unassigned slots in `ans` with unused values from `A`.\\n\\n#### 3. Just pick\\nOnce we have the stack view, one may start to wonder do we really need to pick the smallest value in the stack for each `b`. After all, no matter we pick the smallest or largest, it won\\'t affect the candidate pool\\'s size and consequently the number of winning locations.\\n\\nSo let\\'s try to pick the largest eligible value instead.  One realization is that we don\\'t need a stack at all! The largest eligible value, if there is any, will just be the next biggest value in sorted `A`!\\n\\nWhat if the next biggest value in `A` is `<= b`? Then there is no way to win at `b` and we fill the location with the smallest value that is not yet picked from `A`. \\n\\nSee \"Code 3\" below. Note this also eliminated the extra finishing-up logic at the end of \"Code 2\".\\n\\n### Code 2\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i = j = n - 1\\n        ans = [-1] * n\\n        st = []\\n        for b, j in reversed(sorted_B):\\n            if st:\\n                ans[j] = st.pop()\\n                continue\\n            if sorted_A[i] <= b:\\n                continue\\n            while i >= 0 and sorted_A[i] > b:\\n                st.append(sorted_A[i])\\n                i -= 1\\n            ans[j] = st.pop()\\n        while i >= 0:\\n            st.append(sorted_A[i])\\n            i -= 1\\n        for i in range(n):\\n            if ans[i] == -1:\\n                ans[i] = st.pop()\\n        return ans\\n```\\n\\n### Code 3\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for b, j in reversed(sorted_B):\\n            if sorted_A[i] > b:\\n                ans[j] = sorted_A[i]\\n                i -= 1\\n            else:\\n                ans[j] = sorted_A[k]\\n                k += 1\\n        return ans\\n```\\n\\n\\n### Code 3.1\\nWe could further optimize the foot print of Code 3 by sorting `A` in place and only sorting the index of `B`:\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        A.sort()\\n        sorted_B_idxs = sorted(range(n), key=lambda j: B[j], reverse=True)\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for j in sorted_B_idxs:\\n            if A[i] > B[j]:\\n                ans[j] = A[i]\\n                i -= 1\\n            else:\\n                ans[j] = A[k]\\n                k += 1\\n        return ans\\n```\\n\\n### Complexity\\nFor Code 2:\\n- O(n log n) time. \\nSorting takes O(n log n). The main loop takes O(n), as it walks through both `sorted_A` and `sorted_B` once.\\n- O(n) extra space. \\nThe storage of  `sorted_A`, `sorted_B` and the stack `st`.\\n\\nFor Code 3:\\n- O(n log n) time. \\nThe same argument applies. However, the actual running time is faster as the logic is simpler with no stack operations. \\n- O(n) extra space.\\nWe still need to store `sorted_A`, `sorted_B`, but the space for `st` is saved.\\n\\n### Submission Stats\\nFor Code 2:\\nRuntime: 356 ms (beats 66.12 %)\\nMemory Usage: 18 MB\\n\\nFor Code 3:\\nRuntime: 336 ms (beats 94.14 %)\\nMemory Usage: 17.6 MB\\n\\nFor Code 3.1:\\nRuntime: 332 ms (beats 96.52 %)\\nMemory Usage: 16.9 MB (beats 93.04 %)\\n\\n---\\nIf you find this helpful, please kindly **upvote**! It will greatly encourage me to write more in the future.\\nThanks for reading and happy LeetCoding~!",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i = j = n - 1\\n        ans = [-1] * n\\n        st = []\\n        for b, j in reversed(sorted_B):\\n            if st:\\n                ans[j] = st.pop()\\n                continue\\n            if sorted_A[i] <= b:\\n                continue\\n            while i >= 0 and sorted_A[i] > b:\\n                st.append(sorted_A[i])\\n                i -= 1\\n            ans[j] = st.pop()\\n        while i >= 0:\\n            st.append(sorted_A[i])\\n            i -= 1\\n        for i in range(n):\\n            if ans[i] == -1:\\n                ans[i] = st.pop()\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for b, j in reversed(sorted_B):\\n            if sorted_A[i] > b:\\n                ans[j] = sorted_A[i]\\n                i -= 1\\n            else:\\n                ans[j] = sorted_A[k]\\n                k += 1\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        A.sort()\\n        sorted_B_idxs = sorted(range(n), key=lambda j: B[j], reverse=True)\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for j in sorted_B_idxs:\\n            if A[i] > B[j]:\\n                ans[j] = A[i]\\n                i -= 1\\n            else:\\n                ans[j] = A[k]\\n                k += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125178,
                "title": "python-sort-and-walk",
                "content": "# Idea\\nThe strategy for elements from A is to use them to cover the largest possible element in B. Let\\'s sort both A and B, remembering the indices for the elements in B. Then let\\'s walk back from the end of both arrays and do the following:\\nIf the current element in A is bigger than the one in B, use it to cover that element in B.\\nOtherwise, use the smallest unused element in A (walk from the opposite direction).\\n\\n# Complexity\\nTime: O(NlogN), because of sorting\\nSpace: O(N), for the result and temporary array `c`\\n```\\ndef advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n\\tN = len(A)\\n\\tA.sort()\\n\\tc = sorted([(v, i) for i, v in enumerate(B)])  # sorting B, while keeping the positions\\n\\tresult = [-1] * N\\n\\n\\tli, ri = 0, N-1  # pointers for A\\n\\trj = N-1  # pointer for c\\n\\twhile rj >= 0:\\n\\t\\tcv, ci = c[rj]\\n\\t\\tif cv < A[ri]:\\n\\t\\t\\tresult[ci] = A[ri]\\n\\t\\t\\tri -= 1\\n\\t\\telse:\\n\\t\\t\\tresult[ci] = A[li]\\n\\t\\t\\tli += 1\\n\\t\\trj -= 1\\n\\n\\treturn result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n\\tN = len(A)\\n\\tA.sort()\\n\\tc = sorted([(v, i) for i, v in enumerate(B)])  # sorting B, while keeping the positions\\n\\tresult = [-1] * N\\n\\n\\tli, ri = 0, N-1  # pointers for A\\n\\trj = N-1  # pointer for c\\n\\twhile rj >= 0:\\n\\t\\tcv, ci = c[rj]\\n\\t\\tif cv < A[ri]:\\n\\t\\t\\tresult[ci] = A[ri]\\n\\t\\t\\tri -= 1\\n\\t\\telse:\\n\\t\\t\\tresult[ci] = A[li]\\n\\t\\t\\tli += 1\\n\\t\\trj -= 1\\n\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1125068,
                "title": "python-greedy",
                "content": "Here is one way to construct a valid permutation: Sort `A`. Do not sort `B` itself but get the indices that would do so in `places`. Now we consider elements from sorted `A` and `B` in decreasing order. `i` and `j` point to the beginning and end of `A`, and `k` points to end of sorted `B` (which is equivalent to the end of `places`). Two cases can occur:\\n* If `A[j] > B[places[k]]`, place that `A[j]` to the corresponding location, `ans[places[k]] = A[j]`. Decrement `j`.\\n* Otherwise there is no way we can beat `B[places[k]]`, we can safely place the smallest available element to the corresponding location, `ans[places[k]] = A[i]`. Increment `i`.\\n\\nTime: `O(N logN)` (due to sort)\\nSpace: `O(1)` (apart from array created to return)\\n\\n```python\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        n = len(A)\\n        ans = [0]*n\\n        \\n        #A in increasing order\\n        A.sort()\\n        #B in increasing order\\n        places = list(sorted(range(n), key=B.__getitem__)) \\n        #Two pointers for A, one for B\\n        i, j, k = 0, n-1, n-1\\n        while i <= j:\\n            if A[j] > B[places[k]]: #add from right of sorted A\\n                ans[places[k]] = A[j]\\n                j -= 1\\n            else: #add from left of sorted A\\n                ans[places[k]] = A[i]\\n                i += 1\\n            k -= 1 #go to next element of B\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        n = len(A)\\n        ans = [0]*n\\n        \\n        #A in increasing order\\n        A.sort()\\n        #B in increasing order\\n        places = list(sorted(range(n), key=B.__getitem__)) \\n        #Two pointers for A, one for B\\n        i, j, k = 0, n-1, n-1\\n        while i <= j:\\n            if A[j] > B[places[k]]: #add from right of sorted A\\n                ans[places[k]] = A[j]\\n                j -= 1\\n            else: #add from left of sorted A\\n                ans[places[k]] = A[i]\\n                i += 1\\n            k -= 1 #go to next element of B\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977714,
                "title": "java-treemap-ceilingkey-function",
                "content": "**Upvote if u find this solution useful.**\\n```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int[] ans = new int[A.length];\\n        for (int i : A) {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        int index = 0;\\n        for (int i = 0; i < B.length; i++) {\\n            Integer ceiling = map.ceilingKey(B[i] + 1);\\n            if (ceiling == null) {\\n                final Integer firstKey = map.firstKey();\\n                ans[index++] = firstKey;\\n                map.put(firstKey, map.get(firstKey) - 1);\\n                if (map.get(firstKey) == 0) map.remove(firstKey);\\n            }\\n            else {\\n                ans[index++] = ceiling;\\n                map.put(ceiling, map.get(ceiling) - 1);\\n                if (map.get(ceiling) == 0) map.remove(ceiling);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "**Upvote if u find this solution useful.**\\n```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int[] ans = new int[A.length];\\n        for (int i : A) {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        int index = 0;\\n        for (int i = 0; i < B.length; i++) {\\n            Integer ceiling = map.ceilingKey(B[i] + 1);\\n            if (ceiling == null) {\\n                final Integer firstKey = map.firstKey();\\n                ans[index++] = firstKey;\\n                map.put(firstKey, map.get(firstKey) - 1);\\n                if (map.get(firstKey) == 0) map.remove(firstKey);\\n            }\\n            else {\\n                ans[index++] = ceiling;\\n                map.put(ceiling, map.get(ceiling) - 1);\\n                if (map.get(ceiling) == 0) map.remove(ceiling);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 902900,
                "title": "c-o-nlog-n-using-upper-bound-beats-94-solution",
                "content": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms;\\n        for(auto a: A){\\n            ms.insert(a);\\n        }\\n        vector<int> ans(B.size(), -1);\\n        for(int i = 0; i < B.size(); i++){\\n            auto it = ms.upper_bound(B[i]);\\n            if(it != ms.end()){\\n                ans[i] = *it;\\n            }\\n            else{\\n                it = ms.begin();\\n                ans[i] = *it;\\n            }\\n            ms.erase(it);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms;\\n        for(auto a: A){\\n            ms.insert(a);\\n        }\\n        vector<int> ans(B.size(), -1);\\n        for(int i = 0; i < B.size(); i++){\\n            auto it = ms.upper_bound(B[i]);\\n            if(it != ms.end()){\\n                ans[i] = *it;\\n            }\\n            else{\\n                it = ms.begin();\\n                ans[i] = *it;\\n            }\\n            ms.erase(it);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886254,
                "title": "c-solution-using-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());\\n        vector<int> ans;\\n        for(int i=0;i<B.size();i++){\\n            auto it=upper_bound(A.begin(),A.end(),B[i]);\\n            if(it!=A.end()){\\n                ans.push_back(A[it-A.begin()]);\\n                A.erase(it);\\n            }else{\\n                ans.push_back(A[0]);\\n                A.erase(A.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        sort(A.begin(),A.end());\\n        vector<int> ans;\\n        for(int i=0;i<B.size();i++){\\n            auto it=upper_bound(A.begin(),A.end(),B[i]);\\n            if(it!=A.end()){\\n                ans.push_back(A[it-A.begin()]);\\n                A.erase(it);\\n            }else{\\n                ans.push_back(A[0]);\\n                A.erase(A.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882013,
                "title": "java-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    /*\\n    *Logic:\\n    *   For every element B[i],find the smallest element A[j]\\n    *   such that A[j] > B[i]\\n    *    if no such element exist,append the smallest element of A\\n    *\\n    *   sort the array A ,so that binary search can be used\\n    *   time complexity = O(nlogn)\\n    */\\n    \\n    public int[] advantageCount(int[] A, int[] B) {\\n        \\n        ArrayList<Integer> arrA = new ArrayList<>();\\n        for(int i : A)\\n            arrA.add(i);\\n        \\n        Collections.sort(arrA);\\n        \\n        int j = 0;\\n        for(int i : B)\\n        {\\n            int index = binarySearch(arrA,i);   \\n            if(index!=-1)\\n            {\\n                A[j++] = arrA.get(index);\\n                arrA.remove(index);\\n            }        \\n            else\\n            {\\n                A[j++] = arrA.get(0);\\n                arrA.remove(0);\\n            }\\n        }\\n        return A;\\n    }\\n    \\n    \\n    public int binarySearch(ArrayList<Integer> arr , int key)\\n    {\\n        int start = 0;\\n        int end = arr.size()-1;\\n        int index = -1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            int ele = arr.get(mid);\\n            \\n            if(ele <= key)\\n                start = mid+1;\\n            else\\n            {\\n                index = mid;\\n                end = mid-1;\\n            }\\n        }\\n        \\n        return index;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    *Logic:\\n    *   For every element B[i],find the smallest element A[j]\\n    *   such that A[j] > B[i]\\n    *    if no such element exist,append the smallest element of A\\n    *\\n    *   sort the array A ,so that binary search can be used\\n    *   time complexity = O(nlogn)\\n    */\\n    \\n    public int[] advantageCount(int[] A, int[] B) {\\n        \\n        ArrayList<Integer> arrA = new ArrayList<>();\\n        for(int i : A)\\n            arrA.add(i);\\n        \\n        Collections.sort(arrA);\\n        \\n        int j = 0;\\n        for(int i : B)\\n        {\\n            int index = binarySearch(arrA,i);   \\n            if(index!=-1)\\n            {\\n                A[j++] = arrA.get(index);\\n                arrA.remove(index);\\n            }        \\n            else\\n            {\\n                A[j++] = arrA.get(0);\\n                arrA.remove(0);\\n            }\\n        }\\n        return A;\\n    }\\n    \\n    \\n    public int binarySearch(ArrayList<Integer> arr , int key)\\n    {\\n        int start = 0;\\n        int end = arr.size()-1;\\n        int index = -1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            int ele = arr.get(mid);\\n            \\n            if(ele <= key)\\n                start = mid+1;\\n            else\\n            {\\n                index = mid;\\n                end = mid-1;\\n            }\\n        }\\n        \\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874496,
                "title": "javascript-greedy-brute-force-solution",
                "content": "```\\nconst advantageCount = (A, B) => {\\n    let data = [];\\n    for (const b of B) {\\n        let n = A.length;\\n        A.sort((a, b) => a - b);\\n        let min = A[0];\\n        let max = A[n - 1];\\n        if (b >= max) { // if cannot find a item of A smaller than b, assign the trash (min item) to it (then remove), which means give up this index\\n            data.push(min);\\n            A.shift();\\n        } else { // greedy: find the min value from A which larger than b (then remove), to guarantee better usage of each item in A\\n            let removeIdx;\\n            for (let i = 0; i < n; i++) {\\n                if (A[i] > b) {\\n                    data.push(A[i]);\\n                    removeIdx = i;\\n                    break;\\n                }\\n            }\\n            A.splice(removeIdx, 1);\\n        }\\n    }\\n    return data;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst advantageCount = (A, B) => {\\n    let data = [];\\n    for (const b of B) {\\n        let n = A.length;\\n        A.sort((a, b) => a - b);\\n        let min = A[0];\\n        let max = A[n - 1];\\n        if (b >= max) { // if cannot find a item of A smaller than b, assign the trash (min item) to it (then remove), which means give up this index\\n            data.push(min);\\n            A.shift();\\n        } else { // greedy: find the min value from A which larger than b (then remove), to guarantee better usage of each item in A\\n            let removeIdx;\\n            for (let i = 0; i < n; i++) {\\n                if (A[i] > b) {\\n                    data.push(A[i]);\\n                    removeIdx = i;\\n                    break;\\n                }\\n            }\\n            A.splice(removeIdx, 1);\\n        }\\n    }\\n    return data;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799921,
                "title": "python3-sort-the-indices-of-b-by-element-value-advantage-shuffle",
                "content": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans = [0] * len(A)\\n        index = sorted(range(len(B)), key=lambda x:B[x], reverse=True)\\n        remaining = []\\n        for a in sorted(A):\\n            if a > B[index[-1]]:\\n                ans[index.pop()] = a\\n            else:\\n                remaining.append(a)\\n        for b, a in zip(index, remaining):\\n            ans[b] = a\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans = [0] * len(A)\\n        index = sorted(range(len(B)), key=lambda x:B[x], reverse=True)\\n        remaining = []\\n        for a in sorted(A):\\n            if a > B[index[-1]]:\\n                ans[index.pop()] = a\\n            else:\\n                remaining.append(a)\\n        for b, a in zip(index, remaining):\\n            ans[b] = a\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759665,
                "title": "python-greedy-using-heap",
                "content": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        res = [-1] * len(A)\\n        sA = [(a,i) for i,a in enumerate(A)]\\n        sB = [(b,i) for i,b in enumerate(B)]\\n        heapq.heapify(sA)\\n        heapq.heapify(sB)\\n        remaining  = []\\n        while sA:\\n            a,i = heapq.heappop(sA)\\n            b,j = heapq.heappop(sB)\\n            if a>b:\\n                res[j] = a\\n            else:\\n                remaining.append(a)\\n                heapq.heappush(sB,(b,j))\\n        for i in range(len(res)):\\n            if res[i]==-1:\\n                res[i]=remaining.pop()\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        res = [-1] * len(A)\\n        sA = [(a,i) for i,a in enumerate(A)]\\n        sB = [(b,i) for i,b in enumerate(B)]\\n        heapq.heapify(sA)\\n        heapq.heapify(sB)\\n        remaining  = []\\n        while sA:\\n            a,i = heapq.heappop(sA)\\n            b,j = heapq.heappop(sB)\\n            if a>b:\\n                res[j] = a\\n            else:\\n                remaining.append(a)\\n                heapq.heappush(sB,(b,j))\\n        for i in range(len(res)):\\n            if res[i]==-1:\\n                res[i]=remaining.pop()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747321,
                "title": "c-binary-search-on-a-to-get-next-larger-element-for-b-greedy-simple",
                "content": "Sort vector A\\nTraverse through B\\nFor each element in B, use Binary search to get the smallest element in A which is just larger than B\\'s corresponding element.\\nIf no auch element found, return smallest element of A.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:    \\n\\n\\tint BinarySearchNextLargest(int x, vector<int>& A)\\n    {\\n        int i = 0, j = A.size()-1, mid;\\n        \\n        if(x>=A[A.size()-1])    i = j+1;\\n        \\n        while(i<=j){\\n            mid = (i+j)/2;\\n            \\n            if(A[mid]>x && (mid==0 || A[mid-1]<=x))\\n            {\\n                int tmp = A[mid];\\n                A.erase(A.begin() + mid);\\n                return tmp;\\n            }\\n            else if(A[mid]<=x)\\n                i = mid+1;\\n            \\n            else if(A[mid]>x)\\n                j = mid-1;\\n        }\\n        \\n        int tmp = A[0];\\n        A.erase(A.begin());\\n        return tmp;\\n    }\\n    \\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int> res;\\n        sort(A.begin(), A.end());\\n        \\n        for(int i = 0; i<B.size(); i++)\\n        {\\n            int n = BinarySearchNextLargest(B[i], A);\\n            res.push_back(n);\\n        }\\n        return res;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:    \\n\\n\\tint BinarySearchNextLargest(int x, vector<int>& A)\\n    {\\n        int i = 0, j = A.size()-1, mid;\\n        \\n        if(x>=A[A.size()-1])    i = j+1;\\n        \\n        while(i<=j){\\n            mid = (i+j)/2;\\n            \\n            if(A[mid]>x && (mid==0 || A[mid-1]<=x))\\n            {\\n                int tmp = A[mid];\\n                A.erase(A.begin() + mid);\\n                return tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 719000,
                "title": "c-using-multiset",
                "content": "Multiset has been used which easily allows using `upper_bound`.\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        int n=a.size();\\n        multiset<int> m;\\n        for(auto &it:a)m.insert(it);\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            auto it=m.upper_bound(b[i]);\\n            if(it!=m.end())\\n            {\\n                ans[i]=*it;\\n                m.erase(it);\\n            }\\n        }\\n        vector<int> temp;\\n        for(auto it:m)temp.push_back(it);\\n        for(int i=0;i<n;i++)\\n            if(ans[i]==-1)\\n            {\\n                ans[i]=temp.back();\\n                temp.pop_back();\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        int n=a.size();\\n        multiset<int> m;\\n        for(auto &it:a)m.insert(it);\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            auto it=m.upper_bound(b[i]);\\n            if(it!=m.end())\\n            {\\n                ans[i]=*it;\\n                m.erase(it);\\n            }\\n        }\\n        vector<int> temp;\\n        for(auto it:m)temp.push_back(it);\\n        for(int i=0;i<n;i++)\\n            if(ans[i]==-1)\\n            {\\n                ans[i]=temp.back();\\n                temp.pop_back();\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716520,
                "title": "my-greedy-c-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        vector<pair<int,int>> temp,temp1 ;\\n        for (int i=0;i<A.size();i++) temp.push_back(make_pair(A[i],i)) ;\\n        for (int i=0;i<B.size();i++) temp1.push_back(make_pair(B[i],i)) ;\\n        \\n        sort(temp.begin(),temp.end()) ;\\n        sort(temp1.begin(),temp1.end()) ;\\n        \\n        while (temp.size()>0){\\n            if (temp.back().first>temp1.back().first){\\n                A[temp1.back().second] = temp.back().first ;\\n                temp1.erase(temp1.end()) ;\\n                temp.erase(temp.end()) ;\\n            }else {\\n                A[temp1.back().second] = temp.front().first ;\\n                temp1.erase(temp1.end()) ;\\n                temp.erase(temp.begin()) ;\\n            }\\n        }\\n        return A ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        vector<pair<int,int>> temp,temp1 ;\\n        for (int i=0;i<A.size();i++) temp.push_back(make_pair(A[i],i)) ;\\n        for (int i=0;i<B.size();i++) temp1.push_back(make_pair(B[i],i)) ;\\n        \\n        sort(temp.begin(),temp.end()) ;\\n        sort(temp1.begin(),temp1.end()) ;\\n        \\n        while (temp.size()>0){\\n            if (temp.back().first>temp1.back().first){\\n                A[temp1.back().second] = temp.back().first ;\\n                temp1.erase(temp1.end()) ;\\n                temp.erase(temp.end()) ;\\n            }else {\\n                A[temp1.back().second] = temp.front().first ;\\n                temp1.erase(temp1.end()) ;\\n                temp.erase(temp.begin()) ;\\n            }\\n        }\\n        return A ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687038,
                "title": "c-multiset-solution-easy-and-simple",
                "content": "```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B)\\n    {\\n        multiset<int> st;\\n        for(auto elem : A)st.insert(elem);\\n        \\n        vector<int> ans;\\n        for(auto elem : B)\\n        {\\n            auto it = st.upper_bound(elem);\\n            if(it == st.end())\\n            {ans.pb(*st.begin()); st.erase(st.begin());}\\n            else {ans.pb(*it); st.erase(it);}\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B)\\n    {\\n        multiset<int> st;\\n        for(auto elem : A)st.insert(elem);\\n        \\n        vector<int> ans;\\n        for(auto elem : B)\\n        {\\n            auto it = st.upper_bound(elem);\\n            if(it == st.end())\\n            {ans.pb(*st.begin()); st.erase(st.begin());}\\n            else {ans.pb(*it); st.erase(it);}\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675938,
                "title": "c-only-arrays-used",
                "content": "```\\n vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        \\n       vector<pair<int,int>>c;\\n       int i,j,k,l,m,n;\\n       \\n       for(i=0;i<b.size();i++)\\n       {\\n           pair<int,int>p;\\n           p=make_pair(b[i],i);\\n           c.push_back(p);\\n       }\\n       \\n       n=b.size();\\n       \\n        \\n       vector<int>ans(n,-1);\\n    \\n       sort(a.begin(),a.end());\\n       sort(c.begin(),c.end());\\n       \\n      \\n       vector<int>left;\\n       j=0;\\n        \\n       i=0;\\n          \\n        \\n        while(i<a.size()){\\n            \\n           if(a[i]>c[j].first)\\n           {  \\n             \\n               \\n             ans[c[j].second]=a[i];   \\n             j++;  \\n           }\\n           else \\n           {\\n        \\n               while(i<a.size() &&  a[i]<=c[j].first)\\n               {  \\n                \\n                  left.push_back(a[i]); \\n              \\n                      i++; \\n               }\\n              \\n              if(i<a.size() && a[i]>c[j].first)\\n              {\\n                  ans[c[j].second]=a[i];\\n                  j++;\\n              }\\n           }\\n           \\n            i++;\\n         \\n       }\\n         \\n\\n        \\n       j=0; \\n       i=0;\\n       \\n      while(i<ans.size()) \\n      {  \\n          \\n          if(ans[i]==-1)\\n          {    \\n             ans[i]=left[j];\\n              j++;\\n          }\\n          i++;\\n     \\n      }\\n        \\n       return ans; \\n        \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n vector<int> advantageCount(vector<int>& a, vector<int>& b) {\\n        \\n       vector<pair<int,int>>c;\\n       int i,j,k,l,m,n;\\n       \\n       for(i=0;i<b.size();i++)\\n       {\\n           pair<int,int>p;\\n           p=make_pair(b[i],i);\\n           c.push_back(p);\\n       }\\n       \\n       n=b.size();\\n       \\n        \\n       vector<int>ans(n,-1);\\n    \\n       sort(a.begin(),a.end());\\n       sort(c.begin(),c.end());\\n       \\n      \\n       vector<int>left;\\n       j=0;\\n        \\n       i=0;\\n          \\n        \\n        while(i<a.size()){\\n            \\n           if(a[i]>c[j].first)\\n           {  \\n             \\n               \\n             ans[c[j].second]=a[i];   \\n             j++;  \\n           }\\n           else \\n           {\\n        \\n               while(i<a.size() &&  a[i]<=c[j].first)\\n               {  \\n                \\n                  left.push_back(a[i]); \\n              \\n                      i++; \\n               }\\n              \\n              if(i<a.size() && a[i]>c[j].first)\\n              {\\n                  ans[c[j].second]=a[i];\\n                  j++;\\n              }\\n           }\\n           \\n            i++;\\n         \\n       }\\n         \\n\\n        \\n       j=0; \\n       i=0;\\n       \\n      while(i<ans.size()) \\n      {  \\n          \\n          if(ans[i]==-1)\\n          {    \\n             ans[i]=left[j];\\n              j++;\\n          }\\n          i++;\\n     \\n      }\\n        \\n       return ans; \\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 651733,
                "title": "simple-cpp-sol",
                "content": "Runtime: 256 ms, faster than 43.29% of C++ online submissions for Advantage Shuffle.\\nMemory Usage: 38.5 MB, less than 8.33% of C++ online submissions for Advantage Shuffle.\\n```\\n    bool arrange(pair<int,int> p1, pair<int,int> p2){\\n    return p1.second < p2.second;\\n}\\n    class Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        vector<pair<int,int>> newB;\\n        vector<pair<int,int>> newA;\\n        int i,j;\\n        int n = B.size();\\n        if(n == 0){\\n            return {};\\n        }\\n        vector<int> output(n,0);\\n        for(i = 0; i < n; i++){\\n            newB.push_back({B[i], i});\\n            newA.push_back({A[i], i});\\n        }\\n        sort(newB.begin(), newB.end());\\n        sort(newA.begin(),newA.end());\\n        i = 0;\\n        j = 0;\\n        \\n        while(j < n && i < n){\\n            if(newA[i].first > newB[j].first){\\n                output[newB[j].second] = newA[i].first; \\n                newA[i].second = -1;\\n                newB[j].second = -1;\\n                j++;\\n            }\\n            i++;\\n        }\\n        i = 0;\\n        sort(newB.begin(), newB.end(),arrange);\\n        sort(newA.begin(),newA.end(),arrange);\\n        while(i < n && newB[i].second == -1) i++;\\n        for(;i < n; i++){\\n            output[newB[i].second] = newA[i].first;\\n        }\\n        return output;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        vector<pair<int,int>> newB;\\n        vector<pair<int,int>> newA;\\n        int i,j;\\n        int n = B.size();\\n        if(n == 0){\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 643109,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms(A.begin(), A.end());\\n        vector<int> ans(A.size());\\n        for(int i = 0; i < B.size(); i++) {\\n            auto it = ms.upper_bound(B[i]);\\n            if(it != ms.end()) {\\n                ans[i] = *it;\\n                ms.erase(it);\\n            } else {\\n                ans[i] = *ms.begin();\\n                ms.erase(ms.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms(A.begin(), A.end());\\n        vector<int> ans(A.size());\\n        for(int i = 0; i < B.size(); i++) {\\n            auto it = ms.upper_bound(B[i]);\\n            if(it != ms.end()) {\\n                ans[i] = *it;\\n                ms.erase(it);\\n            } else {\\n                ans[i] = *ms.begin();\\n                ms.erase(ms.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571996,
                "title": "advantage-shuffle-maximize-elements-a-i-b-i",
                "content": "I tried to maximize the advantage using greedy approach  but this problem is more look like maximzing the number of elements greater than B , Shuffle array such that we get maximu A[i]>B[i]\\nHere is the solution for same.\\n   \\n    \\n\\tpublic int[] advantageCount(int[] A, int[] B) {\\n\\n        List<Integer> result = new LinkedList<Integer>();\\n\\t\\tint[] sortedA = A.clone();\\n        List<Integer> list = Arrays.stream(sortedA).boxed().collect(Collectors.toList());\\n        Collections.sort(list,Collections.reverseOrder());\\n        \\n\\t\\tfor (int i = 0; i < B.length; i++) {\\n            int j = 0;\\n            while (j < list.size() &&  B[i] < list.get(j)) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n            \\n            if(j == 0) {\\n                j = list.size();\\n            }\\n            result.add(list.get(j - 1));\\n            list.remove(j-1);\\n            \\n            \\n       }\\n       return result.stream().mapToInt(k -> k).toArray();\\n\\n\\t}\\n",
                "solutionTags": [],
                "code": "I tried to maximize the advantage using greedy approach  but this problem is more look like maximzing the number of elements greater than B , Shuffle array such that we get maximu A[i]>B[i]\\nHere is the solution for same.\\n   \\n    \\n\\tpublic int[] advantageCount(int[] A, int[] B) {\\n\\n        List<Integer> result = new LinkedList<Integer>();\\n\\t\\tint[] sortedA = A.clone();\\n        List<Integer> list = Arrays.stream(sortedA).boxed().collect(Collectors.toList());\\n        Collections.sort(list,Collections.reverseOrder());\\n        \\n\\t\\tfor (int i = 0; i < B.length; i++) {\\n            int j = 0;\\n            while (j < list.size() &&  B[i] < list.get(j)) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n            \\n            if(j == 0) {\\n                j = list.size();\\n            }\\n            result.add(list.get(j - 1));\\n            list.remove(j-1);\\n            \\n            \\n       }\\n       return result.stream().mapToInt(k -> k).toArray();\\n\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 434799,
                "title": "clean-simple-java-solution-with-java-8",
                "content": "```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        Queue<Integer> heapA = new PriorityQueue<Integer>((i,j) -> A[j]-A[i]);\\n        Queue<Integer> heapB = new PriorityQueue<Integer>((i,j) -> B[j]-B[i]);\\n        for(int i = 0; i<A.length; i++){\\n            heapA.add(i);\\n            heapB.add(i);\\n        }\\n        \\n        HashSet<Integer> nonAdvantageIndices = new HashSet();\\n        while(!heapB.isEmpty()){\\n            if(A[heapA.peek()] > B[heapB.peek()]){\\n                result[heapB.poll()] = A[heapA.poll()];\\n            }else{\\n                nonAdvantageIndices.add(heapB.poll());\\n            }\\n        }\\n\\t\\t\\n        nonAdvantageIndices.forEach(i -> result[i] = A[heapA.poll()]);\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        Queue<Integer> heapA = new PriorityQueue<Integer>((i,j) -> A[j]-A[i]);\\n        Queue<Integer> heapB = new PriorityQueue<Integer>((i,j) -> B[j]-B[i]);\\n        for(int i = 0; i<A.length; i++){\\n            heapA.add(i);\\n            heapB.add(i);\\n        }\\n        \\n        HashSet<Integer> nonAdvantageIndices = new HashSet();\\n        while(!heapB.isEmpty()){\\n            if(A[heapA.peek()] > B[heapB.peek()]){\\n                result[heapB.poll()] = A[heapA.poll()];\\n            }else{\\n                nonAdvantageIndices.add(heapB.poll());\\n            }\\n        }\\n\\t\\t\\n        nonAdvantageIndices.forEach(i -> result[i] = A[heapA.poll()]);\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413476,
                "title": "python-use-sort-o-n-log-n-and-then-o-n-with-example",
                "content": "Sort A and B decrease, (save index only to make result)\\nB:[8,6,4,2,],---->B:[8,6,4,2,],---->B:[8,6,4,2,],\\nA:[9,5,3,1,],---->A:[9,  ,5,3,],---->A: [9,1,5,3,]\\nand you can see for num in B, if find max num available in A ,  if fail use it for next num in B\\nfinally put availables in empty position, so put tail ones in fail position has no risk\\n```\\n\\t\\tBdown = sorted(range(len(B)), key=lambda k: B[k] ,reverse = True)\\n        Adown = sorted(range(len(B)), key=lambda k: A[k] ,reverse = True)\\n        Res = [0]*len(B)\\n        \\n        for idx,num in enumerate(Bdown):\\n            if A[Adown[0]] > B[num]:\\n                Res[num] = A[Adown[0]]\\n                del Adown[0]\\n            else :\\n                Res[num] = A[Adown.pop()]\\n        return Res",
                "solutionTags": [],
                "code": "Sort A and B decrease, (save index only to make result)\\nB:[8,6,4,2,],---->B:[8,6,4,2,],---->B:[8,6,4,2,],\\nA:[9,5,3,1,],---->A:[9,  ,5,3,],---->A: [9,1,5,3,]\\nand you can see for num in B, if find max num available in A ,  if fail use it for next num in B\\nfinally put availables in empty position, so put tail ones in fail position has no risk\\n```\\n\\t\\tBdown = sorted(range(len(B)), key=lambda k: B[k] ,reverse = True)\\n        Adown = sorted(range(len(B)), key=lambda k: A[k] ,reverse = True)\\n        Res = [0]*len(B)\\n        \\n        for idx,num in enumerate(Bdown):\\n            if A[Adown[0]] > B[num]:\\n                Res[num] = A[Adown[0]]\\n                del Adown[0]\\n            else :\\n                Res[num] = A[Adown.pop()]\\n        return Res",
                "codeTag": "Unknown"
            },
            {
                "id": 399700,
                "title": "swift",
                "content": "first sort A and B\\nfor each element in A, if we can not have advantage in the current smallest element in B, we pair the current largest element in B. After each pair, shrink B\\n```\\nclass Solution {\\n    func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var result = A\\n        var start = 0\\n        var end = A.count - 1\\n        let sortedA = A.sorted()\\n        let sortedBTuple = B.enumerated().sorted { $0.1 < $1.1 }\\n        \\n        for i in 0..<A.count {\\n            if sortedA[i] > sortedBTuple[start].1 {\\n                result[sortedBTuple[start].0] = sortedA[i]\\n                start += 1\\n            } else {\\n                result[sortedBTuple[end].0] = sortedA[i]\\n                end -= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var result = A\\n        var start = 0\\n        var end = A.count - 1\\n        let sortedA = A.sorted()\\n        let sortedBTuple = B.enumerated().sorted { $0.1 < $1.1 }\\n        \\n        for i in 0..<A.count {\\n            if sortedA[i] > sortedBTuple[start].1 {\\n                result[sortedBTuple[start].0] = sortedA[i]\\n                start += 1\\n            } else {\\n                result[sortedBTuple[end].0] = sortedA[i]\\n                end -= 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374534,
                "title": "easy-to-undersand",
                "content": "1) sort A\\n2) find the index of each element of B in sorted A.\\n3) If the index is equal to length of A which means the current element of B is greater than the current max of A, pop the minimum of A.\\n3) Otherwise, pop the element at the index found in step 2.\\n4) Append the popped element to the result.\\n\\n\\n```\\n\\t\\timport bisect\\n        ans = []\\n        A.sort()\\n        for num in B:\\n            indx = bisect.bisect_right(A, num)\\n            if indx == len(A):\\n                ans.append(A.pop(0))\\n            else:\\n                ans.append(A.pop(indx))\\n        return ans\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\n\\t\\timport bisect\\n        ans = []\\n        A.sort()\\n        for num in B:\\n            indx = bisect.bisect_right(A, num)\\n            if indx == len(A):\\n                ans.append(A.pop(0))\\n            else:\\n                ans.append(A.pop(indx))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 363681,
                "title": "treemap-and-two-pointers-solutions",
                "content": "treeMap solution\\n```\\npublic int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        for (int num : A){\\n            treeMap.put(num, treeMap.getOrDefault(num, 0)+1);\\n        }\\n        int[] ans = new int[A.length];\\n        for (int i=0;i<B.length;i++){\\n            Integer k = treeMap.higherKey(B[i]);\\n            if (k==null){\\n                int n = treeMap.firstKey();\\n                ans[i] = n;\\n            }else {\\n                ans[i] = k;\\n            }\\n            treeMap.put(ans[i], treeMap.get(ans[i])-1);\\n            if (treeMap.get(ans[i])==0){\\n                treeMap.remove(ans[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\ntwo pointers sort solution\\n```\\npublic int[] advantageCount3(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int[][] temp = new int[B.length][2];\\n        for (int i=0;i<B.length;i++){\\n            temp[i] = new int[]{B[i],i};\\n        }\\n        Arrays.sort(temp, (a1, a2)->a1[0]-a2[0]);\\n        int[] ans = new int[A.length];\\n        int l = 0, r = A.length-1;\\n        for (int i=temp.length-1;i>=0;i--){\\n            if (temp[i][0] < A[r]){\\n                ans[temp[i][1]] = A[r--];\\n            }else {\\n                ans[temp[i][1]] = A[l++];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>();\\n        for (int num : A){\\n            treeMap.put(num, treeMap.getOrDefault(num, 0)+1);\\n        }\\n        int[] ans = new int[A.length];\\n        for (int i=0;i<B.length;i++){\\n            Integer k = treeMap.higherKey(B[i]);\\n            if (k==null){\\n                int n = treeMap.firstKey();\\n                ans[i] = n;\\n            }else {\\n                ans[i] = k;\\n            }\\n            treeMap.put(ans[i], treeMap.get(ans[i])-1);\\n            if (treeMap.get(ans[i])==0){\\n                treeMap.remove(ans[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic int[] advantageCount3(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        int[][] temp = new int[B.length][2];\\n        for (int i=0;i<B.length;i++){\\n            temp[i] = new int[]{B[i],i};\\n        }\\n        Arrays.sort(temp, (a1, a2)->a1[0]-a2[0]);\\n        int[] ans = new int[A.length];\\n        int l = 0, r = A.length-1;\\n        for (int i=temp.length-1;i>=0;i--){\\n            if (temp[i][0] < A[r]){\\n                ans[temp[i][1]] = A[r--];\\n            }else {\\n                ans[temp[i][1]] = A[l++];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349558,
                "title": "java-greedy-with-list-and-memory-usage-less-than-86-11-of-java-online-submissions",
                "content": "\\'\\'\\'\\npublic static <T> int[] advantageCount(int[] A, int[] B) {\\n\\t\\t\\n\\t     int anss[]=new int[A.length];     \\n\\t     List<Integer> bb =Arrays.stream(B).boxed().collect(Collectors.toList());\\n\\t     Arrays.sort(A);\\n\\t     int k=0;\\n\\t     int kl=anss.length-1;\\n\\t     for(int i=0;i<anss.length;i++)\\n\\t     {\\n\\t    \\t int maxb =Collections.max(bb); \\n\\t    \\t int maxindexb=bb.indexOf(maxb);\\t\\n\\t    \\t int maxa =A[kl]; \\n\\t    \\t if(maxa>maxb)\\n\\t    \\t {\\n\\t    \\t\\t anss[maxindexb]=maxa;\\n\\t    \\t\\t bb.remove(maxindexb);\\n\\t    \\t\\t bb.add(maxindexb, -1);\\n\\t    \\t\\t kl--;\\n\\t    \\t }\\n\\t    \\t else\\n\\t    \\t {\\n\\t    \\t\\t anss[maxindexb]=A[k];\\n\\t    \\t\\t k++;\\n\\t    \\t\\t bb.remove(maxindexb);\\n\\t    \\t\\t bb.add(maxindexb, -1);\\n\\t    \\t }\\t \\n\\t      }\\t     \\n\\t     return anss;\\n\\t    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\npublic static <T> int[] advantageCount(int[] A, int[] B) {\\n\\t\\t\\n\\t     int anss[]=new int[A.length];     \\n\\t     List<Integer> bb =Arrays.stream(B).boxed().collect(Collectors.toList());\\n\\t     Arrays.sort(A);\\n\\t     int k=0;\\n\\t     int kl=anss.length-1;\\n\\t     for(int i=0;i<anss.length;i++)\\n\\t     {\\n\\t    \\t int maxb =Collections.max(bb); \\n\\t    \\t int maxindexb=bb.indexOf(maxb);\\t\\n\\t    \\t int maxa =A[kl]; \\n\\t    \\t if(maxa>maxb)\\n\\t    \\t {\\n\\t    \\t\\t anss[maxindexb]=maxa;\\n\\t    \\t\\t bb.remove(maxindexb);\\n\\t    \\t\\t bb.add(maxindexb, -1);\\n\\t    \\t\\t kl--;\\n\\t    \\t }\\n\\t    \\t else\\n\\t    \\t {\\n\\t    \\t\\t anss[maxindexb]=A[k];\\n\\t    \\t\\t k++;\\n\\t    \\t\\t bb.remove(maxindexb);\\n\\t    \\t\\t bb.add(maxindexb, -1);\\n\\t    \\t }\\t \\n\\t      }\\t     \\n\\t     return anss;\\n\\t    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 342789,
                "title": "c-concise-and-easy-to-understand-using-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms(A.begin(), A.end());\\n        vector<int> ans(A.size());\\n        for(int i = 0; i < B.size(); i++) {\\n            auto it = ms.upper_bound(B[i]); // find the smallest number greater than this current number in B in A\\n            if(it != ms.end()) {\\n                ans[i] = *it;\\n                ms.erase(it);\\n            }\\n            else {\\n                ans[i] = *ms.begin();\\n                ms.erase(ms.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        multiset<int> ms(A.begin(), A.end());\\n        vector<int> ans(A.size());\\n        for(int i = 0; i < B.size(); i++) {\\n            auto it = ms.upper_bound(B[i]); // find the smallest number greater than this current number in B in A\\n            if(it != ms.end()) {\\n                ans[i] = *it;\\n                ms.erase(it);\\n            }\\n            else {\\n                ans[i] = *ms.begin();\\n                ms.erase(ms.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321568,
                "title": "c-two-pointer-solution-beats-97",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // A comparator adapter that uses the values from a secondary vector to determine ordering.\\n    template<class T, class C>\\n    class alt_order {\\n    private:\\n        const vector<T>& order_;\\n        C c_;\\n\\n    public:\\n        alt_order(const vector<T>& order) : order_(order), c_() {}\\n\\n        bool operator()(size_t a, size_t b) const {\\n            return c_(order_[a], order_[b]);\\n        }\\n    };\\n\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        size_t N = A.size();\\n\\n        // Generate order, a vector of indicies from 0..N-1, and sort it such that when iterated, the values,\\n        // when used to index B, would iterate B in ascending order.\\n        vector<size_t> order(N);\\n        iota(order.begin(), order.end(), 0);\\n        sort(order.begin(), order.end(), alt_order<int, less<int>>(B));\\n\\n        // Sort A in ascending order.\\n        sort(A.begin(), A.end());\\n\\n        vector<int> ans(N);\\n\\n        size_t i = 0, j = 0, k = N;\\n\\n        while(j < N) {\\n            // If the next value in A is > the next value in B (using the order vector to iterate B in ascending order),\\n            // then the A value should be paired with the B value in the answer vector.\\n            if(A[j] > B[order[i]]) {\\n                ans[order[i]] = A[j];\\n                ++i;\\n            }\\n            // Otherwise, the A value will never be greater than any upcoming B value, so pair it with the next largest\\n            // value in B (iterating the order vector backwards iterates B in descending order).\\n            else {\\n                ans[order[--k]] = A[j];\\n            }\\n            ++j;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // A comparator adapter that uses the values from a secondary vector to determine ordering.\\n    template<class T, class C>\\n    class alt_order {\\n    private:\\n        const vector<T>& order_;\\n        C c_;\\n\\n    public:\\n        alt_order(const vector<T>& order) : order_(order), c_() {}\\n\\n        bool operator()(size_t a, size_t b) const {\\n            return c_(order_[a], order_[b]);\\n        }\\n    };\\n\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        size_t N = A.size();\\n\\n        // Generate order, a vector of indicies from 0..N-1, and sort it such that when iterated, the values,\\n        // when used to index B, would iterate B in ascending order.\\n        vector<size_t> order(N);\\n        iota(order.begin(), order.end(), 0);\\n        sort(order.begin(), order.end(), alt_order<int, less<int>>(B));\\n\\n        // Sort A in ascending order.\\n        sort(A.begin(), A.end());\\n\\n        vector<int> ans(N);\\n\\n        size_t i = 0, j = 0, k = N;\\n\\n        while(j < N) {\\n            // If the next value in A is > the next value in B (using the order vector to iterate B in ascending order),\\n            // then the A value should be paired with the B value in the answer vector.\\n            if(A[j] > B[order[i]]) {\\n                ans[order[i]] = A[j];\\n                ++i;\\n            }\\n            // Otherwise, the A value will never be greater than any upcoming B value, so pair it with the next largest\\n            // value in B (iterating the order vector backwards iterates B in descending order).\\n            else {\\n                ans[order[--k]] = A[j];\\n            }\\n            ++j;\\n        }\\n\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306652,
                "title": "c-ordering",
                "content": "```\\n        public int[] AdvantageCount(int[] A, int[] B) {\\n            int len = A.Length;\\n            int[] C = Enumerable.Range(0, len).ToArray();\\n            Array.Sort(A);\\n            Array.Sort(B, C);\\n            int[] res = new int[len];\\n            int end = len - 1, cur = 0;\\n            for(int i = 0; i < len; i++) {\\n                if(A[i] > B[cur]) {\\n                    res[cur] = A[i];\\n                    cur++;\\n                } else {\\n                    res[end] = A[i];\\n                    end--;\\n                }\\n            }\\n            Array.Sort(C, res);\\n            return res;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public int[] AdvantageCount(int[] A, int[] B) {\\n            int len = A.Length;\\n            int[] C = Enumerable.Range(0, len).ToArray();\\n            Array.Sort(A);\\n            Array.Sort(B, C);\\n            int[] res = new int[len];\\n            int end = len - 1, cur = 0;\\n            for(int i = 0; i < len; i++) {\\n                if(A[i] > B[cur]) {\\n                    res[cur] = A[i];\\n                    cur++;\\n                } else {\\n                    res[end] = A[i];\\n                    end--;\\n                }\\n            }\\n            Array.Sort(C, res);\\n            return res;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287152,
                "title": "binary-search-solution",
                "content": "The idea is that \\n* First sort A in ascending order.\\n* Then use priority queue to store index of B by its correspoding B[index] in desending order.\\n* For each number b in B, use a binary search in A to find smallest number that is larger than b and not visited yet, write as a. If that a does not exist, use a pointer from the begining of A to find the smallest number that is not visited, use that as a.\\n```\\n public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((x, y) -> (B[y] - B[x]));\\n        // From the largest to smallest.\\n        for (int i = 0; i < B.length; i++) {\\n            queue.add(i);\\n        }\\n        boolean[] visited = new boolean[A.length];\\n        // Use the binary search to pair each number.\\n        int[] res = new int[B.length];\\n        while (!queue.isEmpty()) {\\n            int bIndex = queue.poll();\\n            int b = B[bIndex];\\n            int a = binarySearch(A, visited, b);\\n            res[bIndex] = a;\\n        }\\n        return res;\\n    }\\n    public int binarySearch(int[] A, boolean[] visited, int b) {\\n        int left = 0;\\n        int right = A.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (A[mid] <= b) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        while (left < A.length && visited[left]) {\\n            left ++;\\n        }\\n        if (left < A.length && A[left] > b) {\\n            visited[left] = true;\\n            return A[left];\\n        }\\n        right = 0;\\n        while (right < A.length && visited[right]) {\\n            right ++;\\n        }\\n        visited[right] = true;\\n        return A[right];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((x, y) -> (B[y] - B[x]));\\n        // From the largest to smallest.\\n        for (int i = 0; i < B.length; i++) {\\n            queue.add(i);\\n        }\\n        boolean[] visited = new boolean[A.length];\\n        // Use the binary search to pair each number.\\n        int[] res = new int[B.length];\\n        while (!queue.isEmpty()) {\\n            int bIndex = queue.poll();\\n            int b = B[bIndex];\\n            int a = binarySearch(A, visited, b);\\n            res[bIndex] = a;\\n        }\\n        return res;\\n    }\\n    public int binarySearch(int[] A, boolean[] visited, int b) {\\n        int left = 0;\\n        int right = A.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (A[mid] <= b) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        while (left < A.length && visited[left]) {\\n            left ++;\\n        }\\n        if (left < A.length && A[left] > b) {\\n            visited[left] = true;\\n            return A[left];\\n        }\\n        right = 0;\\n        while (right < A.length && visited[right]) {\\n            right ++;\\n        }\\n        visited[right] = true;\\n        return A[right];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282771,
                "title": "go-one-pass-solution-without-map",
                "content": "If we record origin position of elements in `B` We can do it one pass:\\n1. if `a` (from sorted `A`) is larger than `b` (from sorted `B`), then place `a` at the index of `b`, remove `b` from `B`\\n2. else, place `a` at the index of `bb`, which is the largest element of sorted `B`. remove `bb` from `B`\\n\\n## Code\\n\\n```go\\nimport (\\n\\t\"sort\"\\n)\\n\\ntype indexedInt struct {\\n\\tidx, val int\\n}\\n\\ntype IdxList []indexedInt\\n\\nfunc (l IdxList) Len() int           { return len(l) }\\nfunc (l IdxList) Less(i, j int) bool { return l[i].val < l[j].val }\\nfunc (l IdxList) Swap(i, j int)      { l[i], l[j] = l[j], l[i] }\\n\\nfunc advantageCount(A []int, B []int) []int {\\n\\tvar ans = make([]int, len(A))\\n\\tBList := IdxList{}\\n\\tfor i, b := range B {\\n\\t\\tBList = append(BList, indexedInt{i, b})\\n\\t}\\n\\tsort.Ints(A)\\n\\tsort.Sort(BList)\\n\\tfor _, a := range A {\\n\\t\\tif a > BList[0].val {\\n\\t\\t\\tidx := BList[0].idx\\n\\t\\t\\tans[idx] = a\\n\\t\\t\\tBList = BList[1:]\\n\\t\\t} else {\\n\\t\\t\\tn := BList.Len()\\n\\t\\t\\tidx := BList[n-1].idx\\n\\t\\t\\tans[idx] = a\\n\\t\\t\\tBList = BList[:n-1]\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nimport (\\n\\t\"sort\"\\n)\\n\\ntype indexedInt struct {\\n\\tidx, val int\\n}\\n\\ntype IdxList []indexedInt\\n\\nfunc (l IdxList) Len() int           { return len(l) }\\nfunc (l IdxList) Less(i, j int) bool { return l[i].val < l[j].val }\\nfunc (l IdxList) Swap(i, j int)      { l[i], l[j] = l[j], l[i] }\\n\\nfunc advantageCount(A []int, B []int) []int {\\n\\tvar ans = make([]int, len(A))\\n\\tBList := IdxList{}\\n\\tfor i, b := range B {\\n\\t\\tBList = append(BList, indexedInt{i, b})\\n\\t}\\n\\tsort.Ints(A)\\n\\tsort.Sort(BList)\\n\\tfor _, a := range A {\\n\\t\\tif a > BList[0].val {\\n\\t\\t\\tidx := BList[0].idx\\n\\t\\t\\tans[idx] = a\\n\\t\\t\\tBList = BList[1:]\\n\\t\\t} else {\\n\\t\\t\\tn := BList.Len()\\n\\t\\t\\tidx := BList[n-1].idx\\n\\t\\t\\tans[idx] = a\\n\\t\\t\\tBList = BList[:n-1]\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 275497,
                "title": "python-with-explanation",
                "content": "```\\nfrom bisect import bisect_right as bs\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        r = []\\n        for n in B[:-1]:\\n            i = bs(A, n)\\n            if i == len(A):\\n                r.append(A.pop(0))\\n            else:\\n                r.append(A.pop(i)) # don\\'t use A = A[:i] + A[i + 1:], that\\'s much much slower and will cause TLE\\n        r.append(A[0])\\n        return r\\n```\\n\\nexplanation of the story of Ji Tian\\'s Horse Race (\\u7530\\u5FCC\\u8D5B\\u9A6C):\\n    About 2400 years ago, in ancient China, there was a noble called Ji Tian (\\u7530\\u5FCC) in the principality Qi (\\u9F50). One day he was having a horse race with the lord of Qi. They both had 3 horses, classified by their speeds as the best, the media and the worst. First, Tian sended his best, media and worst horse against the lord\\'s best, media and worst respectively, and they all lost. While Tian was sad, one of his hanger-ons called Bin Sun (\\u5B59\\u8191), who became a very famous strategist later, told him that even though all Tian\\'s horses lost, the gaps werer all close, so with some arrangements Tian could win the lord. Then Sun sended Tian\\'s worst horse against the lord\\'s best horse and was laughed because the gap was too big and others thought he was too crazy. You know the rest and Tian finally won with a 2:1 vs the lord.",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_right as bs\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        A.sort()\\n        r = []\\n        for n in B[:-1]:\\n            i = bs(A, n)\\n            if i == len(A):\\n                r.append(A.pop(0))\\n            else:\\n                r.append(A.pop(i)) # don\\'t use A = A[:i] + A[i + 1:], that\\'s much much slower and will cause TLE\\n        r.append(A[0])\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266669,
                "title": "a-java-solution-with-treemap",
                "content": "Simple application of Java TreeMap is good enough to ace this problem.\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int a : A) {\\n            map.put(a, map.getOrDefault(a, 0) + 1);\\n        }\\n        int[] ans = new int[A.length];\\n        for (int i = 0;i < B.length;i++) {\\n            Integer key = map.higherKey(B[i]);\\n            if (key == null) ans[i] = -1;\\n            else {\\n                ans[i] = key;\\n                map.put(key, map.get(key) - 1);\\n                if (map.get(key) == 0) map.remove(key);\\n            }\\n        }\\n        for (int i = 0;i < ans.length;i++) {\\n            if (ans[i] == -1) {\\n                int firstKey = map.firstKey();\\n                ans[i] = firstKey;\\n                map.put(firstKey, map.get(firstKey) - 1);\\n                if (map.get(firstKey) == 0) map.remove(firstKey);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int a : A) {\\n            map.put(a, map.getOrDefault(a, 0) + 1);\\n        }\\n        int[] ans = new int[A.length];\\n        for (int i = 0;i < B.length;i++) {\\n            Integer key = map.higherKey(B[i]);\\n            if (key == null) ans[i] = -1;\\n            else {\\n                ans[i] = key;\\n                map.put(key, map.get(key) - 1);\\n                if (map.get(key) == 0) map.remove(key);\\n            }\\n        }\\n        for (int i = 0;i < ans.length;i++) {\\n            if (ans[i] == -1) {\\n                int firstKey = map.firstKey();\\n                ans[i] = firstKey;\\n                map.put(firstKey, map.get(firstKey) - 1);\\n                if (map.get(firstKey) == 0) map.remove(firstKey);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231399,
                "title": "swift-one-time-pass",
                "content": "```\\nclass Solution {\\n    func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var leftArr = [Int]()\\n        var ans = [Int](repeating: Int.min, count: A.count)\\n        var tupleArrB = [(Int, Int)]()\\n        for i in 0..<B.count {\\n            tupleArrB.append((i, B[i]))\\n        }\\n        tupleArrB.sort { $0.1 < $1.1}\\n        var sorteA = A.sorted()\\n        var aIndex = 0\\n        for (bi, v) in tupleArrB {\\n            if aIndex >= sorteA.count { break }\\n            while aIndex < sorteA.count {\\n                let a = sorteA[aIndex]\\n                aIndex += 1\\n                if a > v { ans[bi] = a; break}\\n                leftArr.append(a)\\n            }\\n        }\\n\\n        for i in 0..<ans.count {\\n            if ans[i] == Int.min {\\n                ans[i] = leftArr.removeFirst()\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func advantageCount(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var leftArr = [Int]()\\n        var ans = [Int](repeating: Int.min, count: A.count)\\n        var tupleArrB = [(Int, Int)]()\\n        for i in 0..<B.count {\\n            tupleArrB.append((i, B[i]))\\n        }\\n        tupleArrB.sort { $0.1 < $1.1}\\n        var sorteA = A.sorted()\\n        var aIndex = 0\\n        for (bi, v) in tupleArrB {\\n            if aIndex >= sorteA.count { break }\\n            while aIndex < sorteA.count {\\n                let a = sorteA[aIndex]\\n                aIndex += 1\\n                if a > v { ans[bi] = a; break}\\n                leftArr.append(a)\\n            }\\n        }\\n\\n        for i in 0..<ans.count {\\n            if ans[i] == Int.min {\\n                ans[i] = leftArr.removeFirst()\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229286,
                "title": "scala-o-n-lg-n-concise-purely-functional",
                "content": "```\\nobject Solution {\\n  def advantageCount(a: Array[Int], b: Array[Int]): Array[Int] = {\\n    val bIndicesSorted = b.indices.sortBy(b)\\n    val (bIndexToAElem, _, _) = a.sorted.foldLeft(Map[Int, Int](), 0, bIndicesSorted.length) {\\n      case ((map, start, end), elem) if elem > b(bIndicesSorted(start)) =>\\n        (map + (bIndicesSorted(start) -> elem), start + 1, end)\\n      case ((map, start, end), elem) =>\\n        (map + (bIndicesSorted(end - 1) -> elem), start, end - 1)\\n    }\\n    b.indices.map(bIndexToAElem).toArray\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  def advantageCount(a: Array[Int], b: Array[Int]): Array[Int] = {\\n    val bIndicesSorted = b.indices.sortBy(b)\\n    val (bIndexToAElem, _, _) = a.sorted.foldLeft(Map[Int, Int](), 0, bIndicesSorted.length) {\\n      case ((map, start, end), elem) if elem > b(bIndicesSorted(start)) =>\\n        (map + (bIndicesSorted(start) -> elem), start + 1, end)\\n      case ((map, start, end), elem) =>\\n        (map + (bIndicesSorted(end - 1) -> elem), start, end - 1)\\n    }\\n    b.indices.map(bIndexToAElem).toArray\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 202802,
                "title": "python-greedy-to-beat-the-current-smallest-in-b",
                "content": "```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sorted_B = sorted(B, reverse = True)\\n        assigned = {b:[] for b in B+[-1]}\\n                \\n        b = sorted_B.pop()\\n        for a in sorted(A):\\n            if a > b:\\n                assigned[b].append(a)\\n                b = sorted_B.pop() if sorted_B else -1\\n            else:\\n                assigned[-1].append(a)\\n        \\n        return [assigned[b].pop() if assigned[b] else assigned[-1].pop() for b in B]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sorted_B = sorted(B, reverse = True)\\n        assigned = {b:[] for b in B+[-1]}\\n                \\n        b = sorted_B.pop()\\n        for a in sorted(A):\\n            if a > b:\\n                assigned[b].append(a)\\n                b = sorted_B.pop() if sorted_B else -1\\n            else:\\n                assigned[-1].append(a)\\n        \\n        return [assigned[b].pop() if assigned[b] else assigned[-1].pop() for b in B]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172852,
                "title": "c-solution-using-max-heap-beats-98-88",
                "content": "// algo is to use greedy. add elements of A in max heap pq. then sort elements of B along with its original index location (you can use this by // creating a new vector containing pair(B[i],[i]) elements.\\n// navigate through sorted BB and insert pq.top() in original B\\'s index if it is greater than the BB[i].\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\tvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> result(B.size(),-1);\\n        \\n        vector<pair<int,int>> BB;\\n        for(int i=0; i<B.size(); i++)\\n            BB.push_back(make_pair(B[i],i));\\n        \\n        sort(BB.begin(), BB.end(), std::greater<pair<int,int>>());\\n        \\n        priority_queue<int> pq;\\n        for(auto a:A)\\n            pq.push(a);\\n        \\n        for(int i=0; i<BB.size(); i++)\\n            if(BB[i].first < pq.top())\\n                {result[BB[i].second] = pq.top(); pq.pop();}\\n        \\n        if(!pq.empty())\\n            for(int i=0; i<result.size(); i++)\\n                if(result[i]<0)\\n                    {result[i]=pq.top(); pq.pop();}\\n        \\n        return result;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\tvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> result(B.size(),-1);\\n        \\n        vector<pair<int,int>> BB;\\n        for(int i=0; i<B.size(); i++)\\n            BB.push_back(make_pair(B[i],i));\\n        \\n        sort(BB.begin(), BB.end(), std::greater<pair<int,int>>());\\n        \\n        priority_queue<int> pq;\\n        for(auto a:A)\\n            pq.push(a);\\n        \\n        for(int i=0; i<BB.size(); i++)\\n            if(BB[i].first < pq.top())\\n                {result[BB[i].second] = pq.top(); pq.pop();}",
                "codeTag": "Java"
            },
            {
                "id": 172218,
                "title": "short-python-beats-95-by-mapping-index-between-sorted-b-and-b",
                "content": "The main idea is building a mapping between the index of sorted(B) and B, i.e. Bmapping = sorted(range(n), key=lambda k: B[k])\\nThe meaning of every element in list Bmapping is: for the i-th smallest element in B, what is its index in B.\\nFor example, if B = [2,3,1,4,0], then sorted(B) = [0,1,2,3,4], then Bmapping = [4,2,0,1,3].\\nBy going through the index in the reverse Bmapping order, we check every item in B from the largest to the smallest.\\n\\nAt the same time, we sort A, and use 2 pointers: start mark the index of the current unused smallest element in A, and end mark the index of the current unused largest element in A. If the current B element if larger than the remaining largest element in A, then we put the smallest A element in the corresponding final result location; or else put the largest A element in the correpsonding final result location.\\n```\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(B)\\n        if n < 2: return A\\n        \\n        newA = sorted(A)\\n        Bmapping = sorted(range(n), key=lambda k: B[k])\\n        \\n        finals = [0 for i in xrange(n)]\\n        start = 0\\n        end = n-1\\n        for i in Bmapping[::-1]:\\n            if B[i] >= newA[end]:\\n                finals[i] = newA[start]\\n                start += 1\\n            else:\\n                finals[i] = newA[end]\\n                end -= 1\\n                \\n        return finals\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def advantageCount(self, A, B):\\n        \"\"\"\\n        :type A: List[int]\\n        :type B: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(B)\\n        if n < 2: return A\\n        \\n        newA = sorted(A)\\n        Bmapping = sorted(range(n), key=lambda k: B[k])\\n        \\n        finals = [0 for i in xrange(n)]\\n        start = 0\\n        end = n-1\\n        for i in Bmapping[::-1]:\\n            if B[i] >= newA[end]:\\n                finals[i] = newA[start]\\n                start += 1\\n            else:\\n                finals[i] = newA[end]\\n                end -= 1\\n                \\n        return finals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155798,
                "title": "10-lines-javascript-solution-with-deque",
                "content": "```js\\nfunction advantageCount(A, B) {\\n  const idxs = B.map((v, i) => i).sort((a, b) => B[b]-B[a]);\\n  A.sort((a, b) => b-a);\\n  \\n  const res = [];\\n  for (let i = 0; i < B.length; i++) {\\n    res[idxs[i]] = A[0] > B[idxs[i]] ? A.shift() : A.pop();\\n  }\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction advantageCount(A, B) {\\n  const idxs = B.map((v, i) => i).sort((a, b) => B[b]-B[a]);\\n  A.sort((a, b) => b-a);\\n  \\n  const res = [];\\n  for (let i = 0; i < B.length; i++) {\\n    res[idxs[i]] = A[0] > B[idxs[i]] ? A.shift() : A.pop();\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150105,
                "title": "c-straight-forward-solution-using-multiset-details-explained",
                "content": "//  Greedy method solution.\\n//  Insert all elements of `A` into a multiset, now all are sorted,\\n//  For each element of `B[i]`, find the smallest element of `A` which is `>` than `B`, when found store it at `i-th` position of `A`.\\n// if not found, store the smallest element of A at `i-th` position.\\n```\\n    \\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        multiset<int> ss(begin(A), end(A));      //  create a multiset with A\\'s elements.\\n        \\n        for (auto i = 0; i < B.size(); ++i) {\\n\\n            auto p = ss.upper_bound(B[i]);       //  Find the smallest value in A which is > B[i].\\n\\n            if(p != ss.end()) A[i] = *p;         //  when found, store that element at i-th position of A.\\n\\n            else {p = ss.begin(); A[i] = *p;}    //  if not-found, store the smallest element at i-th position of A.\\n\\n    ss.erase(p);\\n  }\\n  return A;\\n} \\n```",
                "solutionTags": [],
                "code": "```\\n    \\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        \\n        multiset<int> ss(begin(A), end(A));      //  create a multiset with A\\'s elements.\\n        \\n        for (auto i = 0; i < B.size(); ++i) {\\n\\n            auto p = ss.upper_bound(B[i]);       //  Find the smallest value in A which is > B[i].\\n\\n            if(p != ss.end()) A[i] = *p;         //  when found, store that element at i-th position of A.\\n\\n            else {p = ss.begin(); A[i] = *p;}    //  if not-found, store the smallest element at i-th position of A.\\n\\n    ss.erase(p);\\n  }\\n  return A;\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150094,
                "title": "java-treemap-greedy-method-w-explanations-o-nlogn-time-o-n-space",
                "content": "The idea of greedy method is to:\\nFor each element in B, select the smallest element in A that satisfies A > B. If there is no such element, find the smallest element in A.\\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        //Put nums in A into TreeMap\\n        TreeMap<Integer, Integer> tm = new TreeMap<Integer, Integer>();\\n        for (int n : A){\\n            if (!tm.containsKey(n - 1)) tm.put(n - 1, 1);\\n            else tm.put(n - 1, tm.get(n - 1) + 1);\\n        }\\n        int[] ans = new int[A.length];\\n        int cur = -1;\\n        for (int i = 0; i < B.length; i++){\\n            if (tm.ceilingKey(B[i]) == null){\\n                cur = tm.firstKey();\\n            } else {\\n                cur = tm.ceilingKey(B[i]);\\n            }\\n            ans[i] = cur + 1;\\n            if (tm.get(cur) == 1) tm.remove(cur);\\n            else tm.put(cur, tm.get(cur) - 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        //Put nums in A into TreeMap\\n        TreeMap<Integer, Integer> tm = new TreeMap<Integer, Integer>();\\n        for (int n : A){\\n            if (!tm.containsKey(n - 1)) tm.put(n - 1, 1);\\n            else tm.put(n - 1, tm.get(n - 1) + 1);\\n        }\\n        int[] ans = new int[A.length];\\n        int cur = -1;\\n        for (int i = 0; i < B.length; i++){\\n            if (tm.ceilingKey(B[i]) == null){\\n                cur = tm.firstKey();\\n            } else {\\n                cur = tm.ceilingKey(B[i]);\\n            }\\n            ans[i] = cur + 1;\\n            if (tm.get(cur) == 1) tm.remove(cur);\\n            else tm.put(cur, tm.get(cur) - 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149908,
                "title": "c-solution-sort-both-in-descending-order-and-find-closest-match",
                "content": " * sort both in descending order and find closest match\\n * stored not matched positions in B, then fill by not matched numbers in A\\n```\\npublic class Solution {\\n    public class Sorted {\\n        public int b;\\n        public int position;\\n    }\\n    public int[] AdvantageCount(int[] A, int[] B) {\\n        List<int> o = new List<int>();\\n        for(int c = 0; c < A.Length; c++)\\n            o.Add(-1);\\n        int[] output = o.ToArray<int>();\\n        var listB = new List<Sorted>();\\n        for(int bc = 0; bc < B.Length; bc++)\\n            listB.Add(new Sorted() { b = B[bc], position = bc });\\n        var sortedB = listB.ToArray<Sorted>();\\n        Array.Sort(sortedB, (s1, s2) => s2.b - s1.b);\\n        var positions = new HashSet<int>();\\n        for(int p = 0; p < A.Length; p++)\\n            positions.Add(p);\\n        var notPaired = new List<int>();\\n        Array.Sort(A, (a1, a2) => a2 - a1);\\n        foreach(int a in A) {\\n            int selection = -1;\\n            for(int bc = 0; bc < sortedB.Length; bc++)\\n                if (output[sortedB[bc].position] == -1 && a > sortedB[bc].b) {\\n                    selection = sortedB[bc].position;\\n                    break;\\n                }\\n            if (selection != -1) {\\n                positions.Remove(selection);\\n                output[selection] = a;\\n            } else {\\n                notPaired.Add(a);\\n            }\\n        }\\n        int np = 0;\\n        foreach(int oc in positions) {\\n            output[oc] = notPaired[np];\\n            np++;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public class Sorted {\\n        public int b;\\n        public int position;\\n    }\\n    public int[] AdvantageCount(int[] A, int[] B) {\\n        List<int> o = new List<int>();\\n        for(int c = 0; c < A.Length; c++)\\n            o.Add(-1);\\n        int[] output = o.ToArray<int>();\\n        var listB = new List<Sorted>();\\n        for(int bc = 0; bc < B.Length; bc++)\\n            listB.Add(new Sorted() { b = B[bc], position = bc });\\n        var sortedB = listB.ToArray<Sorted>();\\n        Array.Sort(sortedB, (s1, s2) => s2.b - s1.b);\\n        var positions = new HashSet<int>();\\n        for(int p = 0; p < A.Length; p++)\\n            positions.Add(p);\\n        var notPaired = new List<int>();\\n        Array.Sort(A, (a1, a2) => a2 - a1);\\n        foreach(int a in A) {\\n            int selection = -1;\\n            for(int bc = 0; bc < sortedB.Length; bc++)\\n                if (output[sortedB[bc].position] == -1 && a > sortedB[bc].b) {\\n                    selection = sortedB[bc].position;\\n                    break;\\n                }\\n            if (selection != -1) {\\n                positions.Remove(selection);\\n                output[selection] = a;\\n            } else {\\n                notPaired.Add(a);\\n            }\\n        }\\n        int np = 0;\\n        foreach(int oc in positions) {\\n            output[oc] = notPaired[np];\\n            np++;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149895,
                "title": "java-solution-using-treemap",
                "content": "Usint treemap to get the optimized solution for each B[i], if we cant get anything bigger than B[i], just use the least value.\\n\\n```\\n\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> a = new TreeMap<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            if (a.containsKey(A[i])) {\\n                a.put(A[i], a.get(A[i]) + 1);\\n            } else {\\n                a.put(A[i], 1);\\n            }\\n        }\\n        int[] res = new int[A.length];\\n        for (int i = 0; i < A.length; ++i) {\\n            if (a.higherKey(B[i]) != null && a.get(a.higherKey(B[i])) > 0) {\\n                res[i] = a.higherKey(B[i]);\\n                a.put(a.higherKey(B[i]), a.get(a.higherKey(B[i])) - 1);\\n                if (a.get(a.higherKey(B[i])) == 0) {\\n                    a.remove(a.higherKey(B[i]));\\n                }\\n            } else {\\n                int key = a.firstKey();\\n                res[i] = key;\\n                a.put(key, a.get(key) - 1);\\n                if (a.get(key) == 0) {\\n                    a.remove(key);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> a = new TreeMap<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            if (a.containsKey(A[i])) {\\n                a.put(A[i], a.get(A[i]) + 1);\\n            } else {\\n                a.put(A[i], 1);\\n            }\\n        }\\n        int[] res = new int[A.length];\\n        for (int i = 0; i < A.length; ++i) {\\n            if (a.higherKey(B[i]) != null && a.get(a.higherKey(B[i])) > 0) {\\n                res[i] = a.higherKey(B[i]);\\n                a.put(a.higherKey(B[i]), a.get(a.higherKey(B[i])) - 1);\\n                if (a.get(a.higherKey(B[i])) == 0) {\\n                    a.remove(a.higherKey(B[i]));\\n                }\\n            } else {\\n                int key = a.firstKey();\\n                res[i] = key;\\n                a.put(key, a.get(key) - 1);\\n                if (a.get(key) == 0) {\\n                    a.remove(key);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149880,
                "title": "greedy-approach-using-treemap",
                "content": "Put the array A in a TreeMap with a following structure : \\n`key : number , value : count `\\n\\nParse the Array B, while filling the result as follows : \\nfor any element `num` in B\\n1. find the next value greater that `num` in treemap and put in result. \\n2. If no greater value exists put the smallest value in the result. \\n\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n = A.length; \\n        TreeMap<Integer, Integer> map  = new TreeMap<>(); \\n        for(int num : A)\\n            map.put(num, map.getOrDefault(num, 0)+1); \\n        int[] nA = new int[n]; \\n        for(int i = 0 ; i < n ; ++i){\\n            int val = B[i]; \\n            int key = map.higherKey(val) == null ? map.firstKey() : map.higherKey(val); \\n            map.put(key, map.get(key)-1); \\n            if(map.get(key) == 0)\\n                map.remove(key); \\n            nA[i] = key;\\n        }\\n        return nA; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int n = A.length; \\n        TreeMap<Integer, Integer> map  = new TreeMap<>(); \\n        for(int num : A)\\n            map.put(num, map.getOrDefault(num, 0)+1); \\n        int[] nA = new int[n]; \\n        for(int i = 0 ; i < n ; ++i){\\n            int val = B[i]; \\n            int key = map.higherKey(val) == null ? map.firstKey() : map.higherKey(val); \\n            map.put(key, map.get(key)-1); \\n            if(map.get(key) == 0)\\n                map.remove(key); \\n            nA[i] = key;\\n        }\\n        return nA; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149832,
                "title": "easy-understand-java-greedy-solution",
                "content": "  Sort A upfront. If A[i] <= B[i], find the first number in A[i+1, n) that is bigger than B[i] and shift A. At this moment, A[0, i] are fixed. \\n\\t \\n\\t \\n\\tpublic int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        for (int i=0; i<A.length; i++) {\\n            if (A[i] <= B[i]) {\\n                for (int j=i+1; j<A.length; j++) {\\n                    if (A[j] > B[i]) {\\n                        shift(A, i, j);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n    \\n    public void shift(int[] A, int i, int j) {\\n        int tmp = A[j];\\n        for (int k=j; k>i; k--) {\\n            A[k] = A[k-1];\\n        }\\n        A[i] = tmp;\\n    }",
                "solutionTags": [],
                "code": "  Sort A upfront. If A[i] <= B[i], find the first number in A[i+1, n) that is bigger than B[i] and shift A. At this moment, A[0, i] are fixed. \\n\\t \\n\\t \\n\\tpublic int[] advantageCount(int[] A, int[] B) {\\n        Arrays.sort(A);\\n        for (int i=0; i<A.length; i++) {\\n            if (A[i] <= B[i]) {\\n                for (int j=i+1; j<A.length; j++) {\\n                    if (A[j] > B[i]) {\\n                        shift(A, i, j);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n    \\n    public void shift(int[] A, int i, int j) {\\n        int tmp = A[j];\\n        for (int k=j; k>i; k--) {\\n            A[k] = A[k-1];\\n        }\\n        A[i] = tmp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 149824,
                "title": "simple-python-solution-based-on-binary-search",
                "content": "```\\n    def advantageCount(self, a, b):\\n        b = sorted(enumerate(b), key=lambda x: x[1])\\n        sorted_a = sorted(a)\\n\\n        unused, prev, res = set(range(len(a))), 0, [0] * len(a)\\n        for i in range(len(b)):\\n            idx = bisect_right(sorted_a, b[i][1], prev)\\n            if idx != len(a):\\n                res[b[i][0]] = sorted_a[idx]\\n                unused.remove(idx)\\n                prev = idx + 1\\n            else:\\n                res[b[i][0]] = sorted_a[unused.pop()]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def advantageCount(self, a, b):\\n        b = sorted(enumerate(b), key=lambda x: x[1])\\n        sorted_a = sorted(a)\\n\\n        unused, prev, res = set(range(len(a))), 0, [0] * len(a)\\n        for i in range(len(b)):\\n            idx = bisect_right(sorted_a, b[i][1], prev)\\n            if idx != len(a):\\n                res[b[i][0]] = sorted_a[idx]\\n                unused.remove(idx)\\n                prev = idx + 1\\n            else:\\n                res[b[i][0]] = sorted_a[unused.pop()]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4054593,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        PriorityQueue<int[]> maxpq = new PriorityQueue<>(\\n            (int[] pair1, int[] pair2) -> {\\n                return pair2[1] - pair1[1];\\n            }\\n        );\\n        for (int i = 0; i < n; i++) {\\n            maxpq.offer(new int[]{i, nums2[i]});\\n        }\\n\\n        int left = 0, right = n - 1;\\n        int[] res = new int[n];\\n        while (!maxpq.isEmpty()) {\\n            int[] pair = maxpq.poll();\\n            int i = pair[0];\\n            int val = pair[1];\\n            if (nums1[right] > val) {\\n                res[i] = nums1[right];\\n                right--;\\n            }\\n            else {\\n                res[i] = nums1[left];\\n                left++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        sort(nums1.begin(), nums1.end());\\n        vector<int>res(n);\\n        vector<pair<int,int>>p;\\n        for(int i=0;i<n;i++)\\n        p.push_back({nums2[i],i});\\n        sort(p.begin(), p.end());\\n        int l=0, r=n-1;\\n        for(int x : nums1){\\n            if(p[l].first < x)\\n            res[p[l++].second]=x;\\n\\n            else\\n            res[p[r--].second] =x;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        Arrays.sort(nums1);\\n        PriorityQueue<int[]> maxpq = new PriorityQueue<>(\\n            (int[] pair1, int[] pair2) -> {\\n                return pair2[1] - pair1[1];\\n            }\\n        );\\n        for (int i = 0; i < n; i++) {\\n            maxpq.offer(new int[]{i, nums2[i]});\\n        }\\n\\n        int left = 0, right = n - 1;\\n        int[] res = new int[n];\\n        while (!maxpq.isEmpty()) {\\n            int[] pair = maxpq.poll();\\n            int i = pair[0];\\n            int val = pair[1];\\n            if (nums1[right] > val) {\\n                res[i] = nums1[right];\\n                right--;\\n            }\\n            else {\\n                res[i] = nums1[left];\\n                left++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        sort(nums1.begin(), nums1.end());\\n        vector<int>res(n);\\n        vector<pair<int,int>>p;\\n        for(int i=0;i<n;i++)\\n        p.push_back({nums2[i],i});\\n        sort(p.begin(), p.end());\\n        int l=0, r=n-1;\\n        for(int x : nums1){\\n            if(p[l].first < x)\\n            res[p[l++].second]=x;\\n\\n            else\\n            res[p[r--].second] =x;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045950,
                "title": "python-video-walkthrough-time-o-nlogn-space-o-n",
                "content": "[Click Here For Video](https://youtu.be/nz0_sRskx5U)\\n```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        I, res, _ = deque(sorted(range(len(nums2)),key = lambda idx: nums2[idx])), [-1] * len(nums1), nums1.sort()\\n        for boy in nums1:\\n            if boy > nums2[I[0]]: res[I.popleft()] = boy\\n            else: res[I.pop()] = boy\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        I, res, _ = deque(sorted(range(len(nums2)),key = lambda idx: nums2[idx])), [-1] * len(nums1), nums1.sort()\\n        for boy in nums1:\\n            if boy > nums2[I[0]]: res[I.popleft()] = boy\\n            else: res[I.pop()] = boy\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006265,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        Integer[] index = new Integer[nums2.length];\\n        for(int i = 0; i < nums2.length; i++){\\n            index[i] = i;\\n        }\\n        Arrays.sort(index, (a, b) -> (nums2[a] - nums2[b]));\\n        Arrays.sort(nums1);\\n        int[] res = new int[nums1.length];\\n        int i = 0, j = nums1.length - 1;\\n        for(int k = nums2.length - 1; k >= 0; k--){\\n            int num = nums2[index[k]];\\n            if(nums1[j] > num){\\n                res[index[k]] = nums1[j];\\n                j--;\\n            }else{\\n                res[index[k]] = nums1[i];\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        Integer[] index = new Integer[nums2.length];\\n        for(int i = 0; i < nums2.length; i++){\\n            index[i] = i;\\n        }\\n        Arrays.sort(index, (a, b) -> (nums2[a] - nums2[b]));\\n        Arrays.sort(nums1);\\n        int[] res = new int[nums1.length];\\n        int i = 0, j = nums1.length - 1;\\n        for(int k = nums2.length - 1; k >= 0; k--){\\n            int num = nums2[index[k]];\\n            if(nums1[j] > num){\\n                res[index[k]] = nums1[j];\\n                j--;\\n            }else{\\n                res[index[k]] = nums1[i];\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916789,
                "title": "python3",
                "content": "# Intuition\\n\\nsort nums2 desc\\nsort nums1 asc\\nif the max val in nums1 is less than the max val in nums2,\\nchoose the min val in nums1\\n\\n# Code\\n```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        nums1.sort()\\n\\n        heap = []\\n        for i, num in enumerate(nums2):\\n            heapq.heappush(heap, (-num, i))\\n        print(\\'heap\\', heap)\\n\\n        left, right = 0, len(nums1)-1\\n        res = [0]*(len(nums1))\\n\\n        while heap:\\n            maxnum2, idx = heapq.heappop(heap)\\n            print(\\'22\\', maxnum2, idx)\\n            maxnum2 = -maxnum2\\n            \\n          \\n            if maxnum2 < nums1[right]:\\n                res[idx] = nums1[right]\\n                right -= 1\\n            else:\\n                res[idx] = nums1[left]\\n                left += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        nums1.sort()\\n\\n        heap = []\\n        for i, num in enumerate(nums2):\\n            heapq.heappush(heap, (-num, i))\\n        print(\\'heap\\', heap)\\n\\n        left, right = 0, len(nums1)-1\\n        res = [0]*(len(nums1))\\n\\n        while heap:\\n            maxnum2, idx = heapq.heappop(heap)\\n            print(\\'22\\', maxnum2, idx)\\n            maxnum2 = -maxnum2\\n            \\n          \\n            if maxnum2 < nums1[right]:\\n                res[idx] = nums1[right]\\n                right -= 1\\n            else:\\n                res[idx] = nums1[left]\\n                left += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915209,
                "title": "java-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to sort the two arrays, but we can\\'t change the order of the elements in nums2, because the order of the results depends on the order of nums2, so we can\\'t sort nums2 directly, need to use other data structures to help.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        // sort nums2 in descending order\\n        PriorityQueue<int[]> maxpq = new PriorityQueue<>(\\n            (int[] pair1, int[] pair2) -> {\\n                return pair2[1] - pair1[1];\\n            }\\n        );\\n        for (int i = 0; i < n; i++) {\\n            maxpq.offer(new int[]{i, nums2[i]});\\n        }\\n        // sort nums1 in ascending order\\n        Arrays.sort(nums1);\\n\\n        // nums1[left] is the minimum, nums1[right] is the maximum\\n        int left = 0, right = n - 1;\\n        int[] res = new int[n];\\n\\n        while (!maxpq.isEmpty()) {\\n            int[] pair = maxpq.poll();\\n            int i = pair[0];\\n            int maxval = pair[1];\\n            if (nums1[right] > maxval) {\\n                res[i] = nums1[right];\\n                right--;\\n            } else {\\n                res[i] = nums1[left];\\n                left++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        // sort nums2 in descending order\\n        PriorityQueue<int[]> maxpq = new PriorityQueue<>(\\n            (int[] pair1, int[] pair2) -> {\\n                return pair2[1] - pair1[1];\\n            }\\n        );\\n        for (int i = 0; i < n; i++) {\\n            maxpq.offer(new int[]{i, nums2[i]});\\n        }\\n        // sort nums1 in ascending order\\n        Arrays.sort(nums1);\\n\\n        // nums1[left] is the minimum, nums1[right] is the maximum\\n        int left = 0, right = n - 1;\\n        int[] res = new int[n];\\n\\n        while (!maxpq.isEmpty()) {\\n            int[] pair = maxpq.poll();\\n            int i = pair[0];\\n            int maxval = pair[1];\\n            if (nums1[right] > maxval) {\\n                res[i] = nums1[right];\\n                right--;\\n            } else {\\n                res[i] = nums1[left];\\n                left++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911784,
                "title": "java-simple-sol-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < nums1.length; i++){\\n            map.put(nums1[i],map.getOrDefault(nums1[i],0)+1);\\n        }\\n        int []arr= new int[nums1.length];\\n        for(int i=0;i<nums1.length;i++){\\n            Map.Entry<Integer,Integer> lrgr=map.higherEntry(nums2[i]);\\n            if(lrgr==null){\\n                Map.Entry<Integer,Integer> smlr = map.firstEntry();\\n                arr[i]= smlr.getKey();\\n                if(smlr.getValue()==1){map.remove(smlr.getKey());}\\n                else{map.put(smlr.getKey(),smlr.getValue()-1);}\\n\\n            }\\n            else{\\n                arr[i]= lrgr.getKey();\\n                if(lrgr.getValue()==1){map.remove(lrgr.getKey());}\\n                else{map.put(lrgr.getKey(),lrgr.getValue()-1);}\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] advantageCount(int[] nums1, int[] nums2) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < nums1.length; i++){\\n            map.put(nums1[i],map.getOrDefault(nums1[i],0)+1);\\n        }\\n        int []arr= new int[nums1.length];\\n        for(int i=0;i<nums1.length;i++){\\n            Map.Entry<Integer,Integer> lrgr=map.higherEntry(nums2[i]);\\n            if(lrgr==null){\\n                Map.Entry<Integer,Integer> smlr = map.firstEntry();\\n                arr[i]= smlr.getKey();\\n                if(smlr.getValue()==1){map.remove(smlr.getKey());}\\n                else{map.put(smlr.getKey(),smlr.getValue()-1);}\\n\\n            }\\n            else{\\n                arr[i]= lrgr.getKey();\\n                if(lrgr.getValue()==1){map.remove(lrgr.getKey());}\\n                else{map.put(lrgr.getKey(),lrgr.getValue()-1);}\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565493,
                "content": [
                    {
                        "username": "Yuandong-Chen",
                        "content": "Why greedy algorithm? The official solution don\\'t justify the correctness of greedy algorithm, so as many posts did. I think it is necessary to prove the correctness. (I think this is the first post in the discuss to prove the algorithm itself for this problem)\\n\\nWithout loss of generality, suppose A and B is sorted, for example, A = [2, 4, 6, 10]\\nB = [1, 3, 3, 17]. For any permutation of P(A), we can always find the equivalent permutation P*(A) = [a_0, a_1, ..., a_n] that has the same adavantage as P(A) and also has following property (named as GP):\\n\\n\\tThere exists integer k in [0, n], such that:\\n    (a) a_i > b_i for any [0, k] and a_i <= b_i for any [k+1, n]\\n\\t(b) Also for any 0<= i < j <=k, a_i <= a_j\\nWhat does this GP tell us? Since the advantage of any permutation of GP is k by definition, our goal is to enlarge k. Also find that, permutation of GP is a non-decreasing array until k. It is clear that the greedy strategy as follows could always find the maximum advantage permutation of GP:\\nB[0] = 1, we find the left most element in A that is larger than B[0] is 2, so P*(A)[0] = 2\\nB[1] = 3, so P*(A)[1] = 4\\nB[2] = 3, so P*(A)[2] = 6 since 4 is already taken for B[1]\\nB[3] = 17, so P*(A)[3] = 10, since we have no element in A that is larger than 17, it doesn\\'t matter to choose any element left over.\\n\\nThe only left question is how to transfer any permutation to its equivalent permutation of GP. Actually, it is quite easy. Suppose we have permutation P:\\n\\nIf P(A)[i] < B[i], and also j > i, P(A)[j] > B[j], we rearrange it and let B[i] <--> P(A)[j] and B[j] <--> P(A)[i], since P(A)[j] > B[j] > B[i] (note: B is sorted), P(A)[i] < B[i] < B[j], it doesn\\'t change the advantge of Permutation, but after limited number of this operations, we achieve the (a) part of GP.\\n\\nwhat about (b) part of GP? 0<= i < j < =k, P(A)[i] < B[i], P(A)[j] < B[j] and P(A)[i] >= P(A)[j], we just rearrange it as before let B[i] <--> P(A)[j], B[j] <--> P(A)[i]. Obviously, it also doesn\\'t change the advantage of Permutation.\\n\\nQED\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] sortedA = A.clone();\\n        Arrays.sort(sortedA);\\n        int[] sortedB = B.clone();\\n        Arrays.sort(sortedB);\\n\\n        // assigned[b] = list of a that are assigned to beat b\\n        Map<Integer, Deque<Integer>> assigned = new HashMap();\\n        for (int b: B) assigned.put(b, new LinkedList());\\n\\n        // remaining = list of a that are not assigned to any b\\n        Deque<Integer> remaining = new LinkedList();\\n\\n        // populate (assigned, remaining) appropriately\\n        // sortedB[j] is always the smallest unassigned element in B\\n        int j = 0;\\n        for (int a: sortedA) {\\n            if (a > sortedB[j]) {\\n                assigned.get(sortedB[j++]).add(a);\\n            } else {\\n                remaining.add(a);\\n            }\\n        }\\n\\n        // Reconstruct the answer from annotations (assigned, remaining)\\n        int[] ans = new int[B.length];\\n        for (int i = 0; i < B.length; ++i) {\\n            // if there is some a assigned to b...\\n            if (assigned.get(B[i]).size() > 0)\\n                ans[i] = assigned.get(B[i]).pop();\\n            else\\n                ans[i] = remaining.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1764221,
                "content": [
                    {
                        "username": "Yuandong-Chen",
                        "content": "Why greedy algorithm? The official solution don\\'t justify the correctness of greedy algorithm, so as many posts did. I think it is necessary to prove the correctness. (I think this is the first post in the discuss to prove the algorithm itself for this problem)\\n\\nWithout loss of generality, suppose A and B is sorted, for example, A = [2, 4, 6, 10]\\nB = [1, 3, 3, 17]. For any permutation of P(A), we can always find the equivalent permutation P*(A) = [a_0, a_1, ..., a_n] that has the same adavantage as P(A) and also has following property (named as GP):\\n\\n\\tThere exists integer k in [0, n], such that:\\n    (a) a_i > b_i for any [0, k] and a_i <= b_i for any [k+1, n]\\n\\t(b) Also for any 0<= i < j <=k, a_i <= a_j\\nWhat does this GP tell us? Since the advantage of any permutation of GP is k by definition, our goal is to enlarge k. Also find that, permutation of GP is a non-decreasing array until k. It is clear that the greedy strategy as follows could always find the maximum advantage permutation of GP:\\nB[0] = 1, we find the left most element in A that is larger than B[0] is 2, so P*(A)[0] = 2\\nB[1] = 3, so P*(A)[1] = 4\\nB[2] = 3, so P*(A)[2] = 6 since 4 is already taken for B[1]\\nB[3] = 17, so P*(A)[3] = 10, since we have no element in A that is larger than 17, it doesn\\'t matter to choose any element left over.\\n\\nThe only left question is how to transfer any permutation to its equivalent permutation of GP. Actually, it is quite easy. Suppose we have permutation P:\\n\\nIf P(A)[i] < B[i], and also j > i, P(A)[j] > B[j], we rearrange it and let B[i] <--> P(A)[j] and B[j] <--> P(A)[i], since P(A)[j] > B[j] > B[i] (note: B is sorted), P(A)[i] < B[i] < B[j], it doesn\\'t change the advantge of Permutation, but after limited number of this operations, we achieve the (a) part of GP.\\n\\nwhat about (b) part of GP? 0<= i < j < =k, P(A)[i] < B[i], P(A)[j] < B[j] and P(A)[i] >= P(A)[j], we just rearrange it as before let B[i] <--> P(A)[j], B[j] <--> P(A)[i]. Obviously, it also doesn\\'t change the advantage of Permutation.\\n\\nQED\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        int[] sortedA = A.clone();\\n        Arrays.sort(sortedA);\\n        int[] sortedB = B.clone();\\n        Arrays.sort(sortedB);\\n\\n        // assigned[b] = list of a that are assigned to beat b\\n        Map<Integer, Deque<Integer>> assigned = new HashMap();\\n        for (int b: B) assigned.put(b, new LinkedList());\\n\\n        // remaining = list of a that are not assigned to any b\\n        Deque<Integer> remaining = new LinkedList();\\n\\n        // populate (assigned, remaining) appropriately\\n        // sortedB[j] is always the smallest unassigned element in B\\n        int j = 0;\\n        for (int a: sortedA) {\\n            if (a > sortedB[j]) {\\n                assigned.get(sortedB[j++]).add(a);\\n            } else {\\n                remaining.add(a);\\n            }\\n        }\\n\\n        // Reconstruct the answer from annotations (assigned, remaining)\\n        int[] ans = new int[B.length];\\n        for (int i = 0; i < B.length; ++i) {\\n            // if there is some a assigned to b...\\n            if (assigned.get(B[i]).size() > 0)\\n                ans[i] = assigned.get(B[i]).pop();\\n            else\\n                ans[i] = remaining.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Refueling Stops",
        "question_content": "<p>A car travels from a starting position to a destination which is <code>target</code> miles east of the starting position.</p>\n\n<p>There are gas stations along the way. The gas stations are represented as an array <code>stations</code> where <code>stations[i] = [position<sub>i</sub>, fuel<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> gas station is <code>position<sub>i</sub></code> miles east of the starting position and has <code>fuel<sub>i</sub></code> liters of gas.</p>\n\n<p>The car starts with an infinite tank of gas, which initially has <code>startFuel</code> liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.</p>\n\n<p>Return <em>the minimum number of refueling stops the car must make in order to reach its destination</em>. If it cannot reach the destination, return <code>-1</code>.</p>\n\n<p>Note that if the car reaches a gas station with <code>0</code> fuel left, the car can still refuel there. If the car reaches the destination with <code>0</code> fuel left, it is still considered to have arrived.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 1, startFuel = 1, stations = []\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> We can reach the target without refueling.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 100, startFuel = 1, stations = [[10,100]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> We can not reach the target (or even the first gas station).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target, startFuel &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= stations.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= position<sub>i</sub> &lt; position<sub>i+1</sub> &lt; target</code></li>\n\t<li><code>1 &lt;= fuel<sub>i</sub> &lt; 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 294025,
                "title": "java-simple-code-greedy",
                "content": "Let\\'s start with an example:\\n\\n- Start at `0`, with start fuel = `35`\\n- Stations = `[(10, 25), (20, 12), (30,21), (40, 5), (50,3)]`\\n\\n`35.......25.......12.......21.......5........3...................` `(fuel)`\\n`|--------|--------|--------|--------|--------|------------------>` (`stations`)\\n`0.......10.......20.......30........40.......50..................` `(distance)`\\n\\nObviously, with **`0`** steps, the `max distance` we can reach is `35`.\\nThe question now is with **`1`** steps, what is the `max distance` we can reach?\\n\\n`35.......25.......12.......21.......5........3...................` `(fuel)`\\n`|--------|--------|--------|--------|--------|------------------>` (`stations`)\\n`0.......10.......20.......30...|....40.......50..................` `(distance)`\\n`...............................|.................................`\\n`...............................35................................` `(max distance can reach after 0 step)`\\n\\nWhen we reach `35`, we pass by 3 stations `[10, 20, 30]`. It means we can possibly refuel at these stations.\\n- Refuel at `10`: `max distance = 10 + (35 - 10 + 25) = 35 + 25 = 60`\\n- Refuel at `20`: `max distance = 20 + (35 - 20 + 12) = 35 + 12 = 47`\\n- Refuel at `30`: `max distance = 30 + (35 - 30 + 21) = 35 + 21 = 56`\\n\\nWe notice that apparently the max distance **does not** depends on the station\\'s **position**, but the station\\'s **fuel**. \\nApparently, the maximum distance of `k+1` steps = maximum distance of `k` steps + maximum fuel of stations that the car has passed by (counting from the last station that makes the previous maximum distance)\\n\\n`35......[25]......12.......21.......5........3...................` `(fuel)`\\n`|--------|--------|--------|--------|--------|------------------>` (`stations`)\\n`0.......[10]......20.......30...|...40.......50..................` `(distance)`\\n`...............................|....................|............`\\n`...............................35...................|............` `(max distance can reach after 0 step)`\\n`....................................................60...........` `(max distance can reach after 1 step)`\\n\\nWhen we reach `60`, we reach more 2 stations `[40, 50]`, so if :\\n\\n- Refuel at `20`: `max distance = 10 + (60-10) - (20-10) + (20-10) + 12 =  60 + 12 = 72`\\n- Refuel at `30`: `max distance = 10 + (60-10) - (30-10) + (30-10) + 21 = 60 + 21 = 81`\\n- Refuel at `40`: `max distance = 10 + (60-10) - (40-10) + (40-10) + 5 = 60 + 5 = 65`\\n- Refuel at `50`: `max distance = 10 + (60-10) - (50-10) + (50-10) + 3 = 60 + 3 = 63`\\n\\nOur guess is correct, the max distance only depends on the amount of fuel at each station. And each time, we should choose the largest amount of fuel. We come up with the following code:\\n\\n````\\npublic int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if (startFuel >= target) return 0;\\n        Queue<Integer> queue = new PriorityQueue<>((a,b) -> b-a);\\n        int i = 0, n = stations.length, stops = 0, maxDistance = startFuel;\\n        while (maxDistance < target) {\\n            while (i < n && stations[i][0] <= maxDistance) {\\n                queue.offer(stations[i++][1]);\\n            }\\n            if (queue.isEmpty()) return -1;\\n            maxDistance += queue.poll();\\n            stops++;\\n        }\\n        return stops;\\n}\\n````\\n\\nNot sure in the real interview if we should prove why we must choose the largest amount of fuel every time?",
                "solutionTags": [],
                "code": "````\\npublic int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if (startFuel >= target) return 0;\\n        Queue<Integer> queue = new PriorityQueue<>((a,b) -> b-a);\\n        int i = 0, n = stations.length, stops = 0, maxDistance = startFuel;\\n        while (maxDistance < target) {\\n            while (i < n && stations[i][0] <= maxDistance) {\\n                queue.offer(stations[i++][1]);\\n            }\\n            if (queue.isEmpty()) return -1;\\n            maxDistance += queue.poll();\\n            stops++;\\n        }\\n        return stops;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149839,
                "title": "dp-o-n-2-and-priority-queue-o-nlogn",
                "content": "## Approach 1: 1D DP, O(N^2)\\n\\n`dp[t]` means the furthest distance that we can get with `t` times of refueling.\\n\\nSo for every station `s[i]`,\\nif the current distance `dp[t] >= s[i][0]`, we can refuel:\\n`dp[t + 1] = max(dp[t + 1], dp[t] + s[i][1])`\\n\\nIn the end, we\\'ll return the first `t` with `dp[t] >= target`,\\notherwise we\\'ll return -1.\\n\\n\\n**C++:**\\n```\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>> s) {\\n        long dp[501] = {startFuel};\\n        for (int i = 0; i < s.size(); ++i)\\n            for (int t = i; t >= 0 && dp[t] >= s[i][0]; --t)\\n                dp[t + 1] = max(dp[t + 1], dp[t] + s[i][1]);\\n        for (int t = 0; t <= s.size(); ++t)\\n            if (dp[t] >= target) return t;\\n        return -1;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int minRefuelStops(int target, int startFuel, int[][] s) {\\n        long[] dp = new long[s.length + 1];\\n        dp[0] = startFuel;\\n        for (int i = 0; i < s.length; ++i)\\n            for (int t = i; t >= 0 && dp[t] >= s[i][0]; --t)\\n                dp[t + 1] = Math.max(dp[t + 1], dp[t] + s[i][1]);\\n        for (int t = 0; t <= s.length; ++t)\\n            if (dp[t] >= target) return t;\\n        return -1;\\n    }\\n```\\n**Python:**\\n```\\n    def minRefuelStops(self, target, startFuel, s):\\n        dp = [startFuel] + [0] * len(s)\\n        for i in range(len(s)):\\n            for t in range(i + 1)[::-1]:\\n                if dp[t] >= s[i][0]:\\n                    dp[t + 1] = max(dp[t + 1], dp[t] + s[i][1])\\n        for t, d in enumerate(dp):\\n            if d >= target: return t\\n        return -1\\n```\\n\\n\\n## Approach 2: Priority Queue, O(NlogN)\\n\\n`i` is the index of next stops to refuel.\\n`res` is the times that we have refeuled.\\n`pq` is a priority queue that we store all available gas.\\n\\n\\nWe initial `res = 0` and in every loop:\\n1. We add all reachable stop to priority queue.\\n2. We pop out the largest gas from `pq` and refeul once.\\n3. If we can\\'t refuel, means that we can not go forward and return `-1`\\n\\n\\n**C++:**\\n```\\n    int minRefuelStops(int target, int cur, vector<vector<int>> s) {\\n        int i = 0, res;\\n        priority_queue<int>pq;\\n        for (res = 0; cur < target; res++) {\\n            while (i < s.size() && s[i][0] <= cur)\\n                pq.push(s[i++][1]);\\n            if (pq.empty()) return -1;\\n            cur += pq.top(), pq.pop();\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int minRefuelStops(int target, int cur, int[][] s) {\\n        Queue<Integer> pq = new PriorityQueue<>();\\n        int i = 0, res;\\n        for (res = 0; cur < target; res++) {\\n            while (i < s.length && s[i][0] <= cur)\\n                pq.offer(-s[i++][1]);\\n            if (pq.isEmpty()) return -1;\\n            cur += -pq.poll();\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def minRefuelStops(self, target, cur, s):\\n        pq = []\\n        res = i = 0\\n        while cur < target:\\n            while i < len(s) and s[i][0] <= cur:\\n                heapq.heappush(pq, -s[i][1])\\n                i += 1\\n            if not pq: return -1\\n            cur += -heapq.heappop(pq)\\n            res += 1\\n        return res\\n\\n```\\nApproach 2 inspired by @laiden.",
                "solutionTags": [],
                "code": "```\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>> s) {\\n        long dp[501] = {startFuel};\\n        for (int i = 0; i < s.size(); ++i)\\n            for (int t = i; t >= 0 && dp[t] >= s[i][0]; --t)\\n                dp[t + 1] = max(dp[t + 1], dp[t] + s[i][1]);\\n        for (int t = 0; t <= s.size(); ++t)\\n            if (dp[t] >= target) return t;\\n        return -1;\\n    }\\n```\n```\\n    public int minRefuelStops(int target, int startFuel, int[][] s) {\\n        long[] dp = new long[s.length + 1];\\n        dp[0] = startFuel;\\n        for (int i = 0; i < s.length; ++i)\\n            for (int t = i; t >= 0 && dp[t] >= s[i][0]; --t)\\n                dp[t + 1] = Math.max(dp[t + 1], dp[t] + s[i][1]);\\n        for (int t = 0; t <= s.length; ++t)\\n            if (dp[t] >= target) return t;\\n        return -1;\\n    }\\n```\n```\\n    def minRefuelStops(self, target, startFuel, s):\\n        dp = [startFuel] + [0] * len(s)\\n        for i in range(len(s)):\\n            for t in range(i + 1)[::-1]:\\n                if dp[t] >= s[i][0]:\\n                    dp[t + 1] = max(dp[t + 1], dp[t] + s[i][1])\\n        for t, d in enumerate(dp):\\n            if d >= target: return t\\n        return -1\\n```\n```\\n    int minRefuelStops(int target, int cur, vector<vector<int>> s) {\\n        int i = 0, res;\\n        priority_queue<int>pq;\\n        for (res = 0; cur < target; res++) {\\n            while (i < s.size() && s[i][0] <= cur)\\n                pq.push(s[i++][1]);\\n            if (pq.empty()) return -1;\\n            cur += pq.top(), pq.pop();\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int minRefuelStops(int target, int cur, int[][] s) {\\n        Queue<Integer> pq = new PriorityQueue<>();\\n        int i = 0, res;\\n        for (res = 0; cur < target; res++) {\\n            while (i < s.length && s[i][0] <= cur)\\n                pq.offer(-s[i++][1]);\\n            if (pq.isEmpty()) return -1;\\n            cur += -pq.poll();\\n        }\\n        return res;\\n    }\\n```\n```\\n    def minRefuelStops(self, target, cur, s):\\n        pq = []\\n        res = i = 0\\n        while cur < target:\\n            while i < len(s) and s[i][0] <= cur:\\n                heapq.heappush(pq, -s[i][1])\\n                i += 1\\n            if not pq: return -1\\n            cur += -heapq.heappop(pq)\\n            res += 1\\n        return res\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2451321,
                "title": "python-96-pretend-we-can-time-travel-heap-with-explantion-best-solution-easy-understand",
                "content": "**Idea:**\\n* We have a Time Machine\\n* We keep driving forward until we run out of fuel, then we time travel back to get the gas.\\n\\nHere\\'s an example for better understand:\\n![image](https://assets.leetcode.com/users/images/e8dab0de-afcb-463a-b378-d439676d6fdf_1660962554.9242887.png)\\n\\n**Python Code:**\\n```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        \\n        stations.append([target, 0])    # regard target as a station\\n        fuel = startFuel\\n        cnt, prev = 0, 0\\n        miss = []\\n        \\n        for pos, gas in stations:\\n            dis, prev = pos - prev, pos    # calculate the distance between two stations\\n            \\n            if fuel < dis:  # we are running out of fuel\\n                \\n                while miss and fuel < dis:  # use Time machine to get some fuel we missed~\\n                    fuel += -heapq.heappop(miss)\\n                    cnt += 1    # cnt is how many times we travel back to get gas\\n                    \\n                if fuel < dis: return -1    # we have used all the gas, but still cannot get to the next station\\n                \\n            fuel -= dis\\n            heapq.heappush(miss, -gas)  # we don\\'t need the gas until we run out of all fuel\\n            \\n        return cnt\\n```\\n\\n**Here\\'s how the code work:**\\n1. We loop throught every stations, get its position and how much gas that station has.\\n`dis` is the distance between current position and next station. \\n`miss` is how many gas we have missed.(We don\\'t refuel at every station.)\\n2. We use `if fuel < dis:` to check if the car\\'s fuel is enough to drive to that station.\\n3. Image the car keep driving forward until it runs out of fuel. (`fuel < dis\\')\\n4. Once the car is out of fuel, we check what is in `miss`.\\nWe simply grab the biggest number in `miss` using `heapq.heappop`.\\nOne refuel, we add 1 to `cnt`.\\nIf we already add everything in `miss` to our fuel, the car still cannot drive to the next station, we `return -1`.\\n5. After the loop, the  car is at its destination, so we can `return  cnt`.\\n(cnt is the answer which is how many time we refuel.)\\n\\n**Please UPVOTE if you LIKE!!**\\n\\n![image](https://assets.leetcode.com/users/images/8bdefc62-c167-4777-a0f8-2f50fac2e06c_1660962036.945542.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        \\n        stations.append([target, 0])    # regard target as a station\\n        fuel = startFuel\\n        cnt, prev = 0, 0\\n        miss = []\\n        \\n        for pos, gas in stations:\\n            dis, prev = pos - prev, pos    # calculate the distance between two stations\\n            \\n            if fuel < dis:  # we are running out of fuel\\n                \\n                while miss and fuel < dis:  # use Time machine to get some fuel we missed~\\n                    fuel += -heapq.heappop(miss)\\n                    cnt += 1    # cnt is how many times we travel back to get gas\\n                    \\n                if fuel < dis: return -1    # we have used all the gas, but still cannot get to the next station\\n                \\n            fuel -= dis\\n            heapq.heappush(miss, -gas)  # we don\\'t need the gas until we run out of all fuel\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613853,
                "title": "python-5-solutions-gradually-optimizing-from-naive-dfs-to-o-n-space-dp",
                "content": "\\nNotes:\\n- For a problem with no clear DP idea, always start with **DFS/BFS** solution\\n- A DFS solution with `return values` instead of a `self.rst` global value can be **easier to be rewrotten with memorization**\\n- For knapsack problems, when the **value amount is too large** or there is a limitation on value to reach, consider to build a `dp[i][j]` with former `i` bags, pick `j` of them instead of the regular way `dp[i][j]` with former `i` bags, value `j` can be constructed or not.\\n\\t- **Original** 0-1 knapsack: maximum value given # of bags limitation: `dp[i][j] = bool`, in former `i` bags, `j` **VALUE** can be constructed or not.\\n\\t- **Reversed** 0-1 knapsack: minimum # of bags used to reach a given value `dp[i][j] = value`, in former `i` bags, `j` **# OF BAGS** being picked, what is the maximum value.\\n- In a space-uncompressed `dp` solution, inner loop\\'s left to right / right to left  **updating direction  doesn\\'t matter when `dp[i][j]` not related to `dp[i][j +/-1]`** , but the compressed `1-d dp`\\'s **updating direction matters a lot**, because last row\\'s results might be replaced by current row\\'s ones. Check [here](https://leetcode.com/problems/ones-and-zeroes/discuss/609509/Python-Three-recursive-and-two-DP-solutions) for anthoer exapmle where updating direction needs to be modified because of space optimization.\\n![image](https://assets.leetcode.com/users/oldeelk/image_1588647514.png)\\n\\n \\n```py\\nclass Solution(object):\\n    def minRefuelStops(self, target, startFuel, stations):\\n        \"\"\"\\n        :type target: int\\n        :type startFuel: int\\n        :type stations: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # 1) Naive DFS\\n        self.full_target = target\\n        def dfs(curFuel, start, target):\\n            if curFuel >= target:\\n                return 0\\n            rst = sys.maxsize\\n            for i in xrange(start, len(stations)):\\n                dis, fuel = stations[i][0] - (self.full_target - target), stations[i][1]\\n                if curFuel - dis >= 0:\\n                    rst = min(rst, dfs(curFuel - dis + fuel, i + 1, target - dis) + 1)\\n            return rst\\n        stops = dfs(startFuel, 0, target)\\n        return stops if stops != sys.maxsize else -1\\n\\t\\t\\n        # 2) DFS with for loops subset implementation + memorization\\n        self.full_target = target\\n        mem = dict()\\n        def dfs(curFuel, start, target):\\n            if curFuel >= target:\\n                return 0\\n            \\n            if (curFuel, start, target) in mem:\\n                return mem[(curFuel, start, target)]\\n            \\n            rst = sys.maxsize\\n            for i in xrange(start, len(stations)):\\n                dis, fuel = stations[i][0] - (self.full_target - target), stations[i][1]\\n                if curFuel - dis >= 0:\\n                    rst = min(rst, dfs(curFuel - dis + fuel, i + 1, target - dis) + 1)\\n            mem[(curFuel, start, target)] = rst\\n            return mem[(curFuel, start, target)]\\n        \\n        stops = dfs(startFuel, 0, target)\\n        return stops if stops != sys.maxsize else -1\\n\\t\\t\\n\\t\\t# 3) DFS taken/not taken subset implementation + memorization\\n        self.full_target = target\\n        mem = dict()\\n        def dfs(curFuel, start, target):\\n            if curFuel >= target:\\n                return 0\\n            \\n            if start == len(stations):\\n                return sys.maxsize\\n            \\n            if (curFuel, start, target) in mem:\\n                return mem[(curFuel, start, target)]\\n            \\n            dis, fuel = stations[start][0] - (self.full_target - target), stations[start][1]\\n            taken, not_taken = sys.maxsize, sys.maxsize\\n            if curFuel - dis >= 0:\\n                taken = dfs(curFuel - dis + fuel, start + 1, target - dis) + 1\\n                not_taken = dfs(curFuel - dis, start + 1, target - dis)\\n                \\n            mem[(curFuel, start, target)] = min(taken, not_taken)\\n            return mem[(curFuel, start, target)]\\n        \\n        stops = dfs(startFuel, 0, target)\\n        return stops if stops != sys.maxsize else -1\\n\\n\\t\\t# 4) DP: reversed 0-1 knapsack. \\n        # Original 0-1 knapsack: maximum value given # of bags limitation: dp[i][j] = bool -- former i bags, j VALUE can be constructed or not \\n        # Reversed 0-1 knapsack: minimum # of bags used to reach a given value dp[i][j] = value -- former i bags, j # OF BAGS being picked, what is the maximum value\\n        \\n        if startFuel >= target:\\n            return 0\\n        \\n        n = len(stations)\\n        # dp[i][j]: in former i stations, pick j stations to fuel, how far it can mostly reach\\n        dp = [[0] * (n + 1) for _ in xrange(n + 1)]\\n        for i in range(n + 1):\\n            dp[i][0] = startFuel\\n            \\n        rst = sys.maxsize\\n        for i in range(1, n + 1):\\n            # for j in range(i, 0, -1): ... both works, as long as the i - 1 row has finished, updating i row from left to right/right to left doesn\\'t matter \\n            for j in range(1, i + 1):  # j <= i because in former i stations, at most i stations can be picked\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\\n                if dp[i - 1][j - 1] >= stations[i - 1][0]:\\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + stations[i - 1][1])\\n                if dp[i][j] >= target:\\n                    rst = min(rst, j)\\n        return rst if rst != sys.maxsize else -1\\n\\t\\t\\n\\t\\t# 5) DP, space optimized\\n        if startFuel >= target:\\n            return 0\\n        \\n        n = len(stations)\\n        # dp[j]: in former i stations, pick j stations to fuel, how far it can mostly reach\\n        dp = [startFuel] + [0] * n\\n        rst = sys.maxsize\\n        for i in range(1, n + 1):\\n            # since dp[i][j] relates to dp[i - 1][j] and dp[i - 1][j - 1],\\n            # if updating the compressed 1-d dp array left -> right, dp[j - 1] is updated before dp[j] with row i\\'s dp[i][j - 1] value, which replaced the target value dp[i - 1][j - 1]\\n            # if updating the compressed 1-d dp array right -> left, dp[j - 1] hasn\\'t been udpated when calculating dp[j], which remains the target value dp[i - 1][j - 1]\\n            for j in range(i, 0, -1): \\n                if dp[j - 1] >= stations[i - 1][0]:\\n                    dp[j] = max(dp[j], dp[j - 1] + stations[i - 1][1])\\n                if dp[j] >= target:\\n                    rst = min(rst, j)\\n        return rst if rst != sys.maxsize else -1\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution(object):\\n    def minRefuelStops(self, target, startFuel, stations):\\n        \"\"\"\\n        :type target: int\\n        :type startFuel: int\\n        :type stations: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # 1) Naive DFS\\n        self.full_target = target\\n        def dfs(curFuel, start, target):\\n            if curFuel >= target:\\n                return 0\\n            rst = sys.maxsize\\n            for i in xrange(start, len(stations)):\\n                dis, fuel = stations[i][0] - (self.full_target - target), stations[i][1]\\n                if curFuel - dis >= 0:\\n                    rst = min(rst, dfs(curFuel - dis + fuel, i + 1, target - dis) + 1)\\n            return rst\\n        stops = dfs(startFuel, 0, target)\\n        return stops if stops != sys.maxsize else -1\\n\\t\\t\\n        # 2) DFS with for loops subset implementation + memorization\\n        self.full_target = target\\n        mem = dict()\\n        def dfs(curFuel, start, target):\\n            if curFuel >= target:\\n                return 0\\n            \\n            if (curFuel, start, target) in mem:\\n                return mem[(curFuel, start, target)]\\n            \\n            rst = sys.maxsize\\n            for i in xrange(start, len(stations)):\\n                dis, fuel = stations[i][0] - (self.full_target - target), stations[i][1]\\n                if curFuel - dis >= 0:\\n                    rst = min(rst, dfs(curFuel - dis + fuel, i + 1, target - dis) + 1)\\n            mem[(curFuel, start, target)] = rst\\n            return mem[(curFuel, start, target)]\\n        \\n        stops = dfs(startFuel, 0, target)\\n        return stops if stops != sys.maxsize else -1\\n\\t\\t\\n\\t\\t# 3) DFS taken/not taken subset implementation + memorization\\n        self.full_target = target\\n        mem = dict()\\n        def dfs(curFuel, start, target):\\n            if curFuel >= target:\\n                return 0\\n            \\n            if start == len(stations):\\n                return sys.maxsize\\n            \\n            if (curFuel, start, target) in mem:\\n                return mem[(curFuel, start, target)]\\n            \\n            dis, fuel = stations[start][0] - (self.full_target - target), stations[start][1]\\n            taken, not_taken = sys.maxsize, sys.maxsize\\n            if curFuel - dis >= 0:\\n                taken = dfs(curFuel - dis + fuel, start + 1, target - dis) + 1\\n                not_taken = dfs(curFuel - dis, start + 1, target - dis)\\n                \\n            mem[(curFuel, start, target)] = min(taken, not_taken)\\n            return mem[(curFuel, start, target)]\\n        \\n        stops = dfs(startFuel, 0, target)\\n        return stops if stops != sys.maxsize else -1\\n\\n\\t\\t# 4) DP: reversed 0-1 knapsack. \\n        # Original 0-1 knapsack: maximum value given # of bags limitation: dp[i][j] = bool -- former i bags, j VALUE can be constructed or not \\n        # Reversed 0-1 knapsack: minimum # of bags used to reach a given value dp[i][j] = value -- former i bags, j # OF BAGS being picked, what is the maximum value\\n        \\n        if startFuel >= target:\\n            return 0\\n        \\n        n = len(stations)\\n        # dp[i][j]: in former i stations, pick j stations to fuel, how far it can mostly reach\\n        dp = [[0] * (n + 1) for _ in xrange(n + 1)]\\n        for i in range(n + 1):\\n            dp[i][0] = startFuel\\n            \\n        rst = sys.maxsize\\n        for i in range(1, n + 1):\\n            # for j in range(i, 0, -1): ... both works, as long as the i - 1 row has finished, updating i row from left to right/right to left doesn\\'t matter \\n            for j in range(1, i + 1):  # j <= i because in former i stations, at most i stations can be picked\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\\n                if dp[i - 1][j - 1] >= stations[i - 1][0]:\\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + stations[i - 1][1])\\n                if dp[i][j] >= target:\\n                    rst = min(rst, j)\\n        return rst if rst != sys.maxsize else -1\\n\\t\\t\\n\\t\\t# 5) DP, space optimized\\n        if startFuel >= target:\\n            return 0\\n        \\n        n = len(stations)\\n        # dp[j]: in former i stations, pick j stations to fuel, how far it can mostly reach\\n        dp = [startFuel] + [0] * n\\n        rst = sys.maxsize\\n        for i in range(1, n + 1):\\n            # since dp[i][j] relates to dp[i - 1][j] and dp[i - 1][j - 1],\\n            # if updating the compressed 1-d dp array left -> right, dp[j - 1] is updated before dp[j] with row i\\'s dp[i][j - 1] value, which replaced the target value dp[i - 1][j - 1]\\n            # if updating the compressed 1-d dp array right -> left, dp[j - 1] hasn\\'t been udpated when calculating dp[j], which remains the target value dp[i - 1][j - 1]\\n            for j in range(i, 0, -1): \\n                if dp[j - 1] >= stations[i - 1][0]:\\n                    dp[j] = max(dp[j], dp[j - 1] + stations[i - 1][1])\\n                if dp[j] >= target:\\n                    rst = min(rst, j)\\n        return rst if rst != sys.maxsize else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267000,
                "title": "c-3-approaches-full-story-like-explanation-o-n-2-dp-o-n-dp-o-nlogn-using-max-heap",
                "content": "```\\n//Approach-1 ( O(n^2) DP)\\ntypedef unsigned long long ull;\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        \\n        vector<vector<ull>> t(n+1, vector<ull>(n+1, 0));\\n        //t[i][j] = Maximum distance reached if I stopped at \\'j\\' fuelStops from total of \\'i\\' fuelStops\\n        //i.e. j <= i\\n        \\n        //If j = 0, i.e. I did not use any fuelStops, Then maximum I can reach is \\'startFuel\\' which I had initially\\n        \\n        //So, initialize the dp array with this information\\n        for(int i = 0; i<n+1; i++) {\\n            t[i][0] = startFuel;\\n        }\\n        \\n        //There is no point of filling 1st row because \\n        //t[0][j] means I used j fuelStops from 0 fuelStops which doesn\\'t make any sense for (j>0)\\n        //That\\'s why I start from i = 1 and obviously j = 1 because for j = 0 we already populated the dp array\\n        \\n        for(int i = 1; i < n+1; i++) {\\n            for(int j = 1; j <= i; j++) { //I can use j=1 to j=i fuel stops and find max distance for t[i][j]\\n                //case-1 (I don\\'t refuel at current fuelstop)\\n                //If I didn\\'t refuel at current stop, the max distance I can cover is equal to maximum\\n                //distance I could cover from previous state\\n                t[i][j] = t[i-1][j];\\n                \\n                //case-2 (I will refuel at current fuelStop)\\n                //But check if you can even reach this station (stations[i-1][0]) or not from your previous station\\n                if(t[i-1][j-1] >= stations[i-1][0]) {\\n                    t[i][j] = max(t[i][j], t[i-1][j-1] + stations[i-1][1]);\\n                }\\n                \\n            }\\n        }\\n        \\n        //After you end up with all stations, check which t[n][j] was best for reaching target\\n        //Best means, minimum j used by you to reach target\\n        for(int j = 0; j<n+1; j++) {\\n            if(t[n][j] >= target)\\n                return j;\\n        }\\n        \\n        //You could never reach target, so return -1\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 : O(n^2)dp\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        \\n        vector<long long> t(n+1, 0);\\n        //t[j] = max distance that I can reach using j fuelStops\\n        \\n        //When I don\\'t use any fuelStop, I can travel as much as I had startFuel in the beginning\\n        t[0] = startFuel;\\n        \\n        for(int i = 1; i<n+1; i++) {\\n            //traverse on all fuel stops\\n            \\n            //I can use all i fuelStops, or (i-1), or (i-2) ... till 0 to find which gave me best result\\n            //So. j goes from j = i to j = 0\\n            for(int j = i; j>=0; j--) {\\n                //But first, I need to check If I can even reach curr station or not to use it\\n                if(t[j] >= stations[i-1][0]) {\\n                    //So, we can use this fuelStop and now we are using (j+1) fuelStops\\n                    t[j+1] = max(t[j+1], t[j] + stations[i-1][1]);\\n                }\\n            }\\n        }\\n        \\n        //After you end up with all stations, check which was best for reaching target\\n        //Best means, minimum j used by you to reach target\\n        \\n        for(int j = 0; j<n+1; j++) {\\n            if(t[j] >= target)\\n                return j;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 : O(nlog(n)) using max-heap\\n//Similar Problem : Leetcode 1642. Furthest Building You Can Reach\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        \\n        priority_queue<int> pq; //max heap\\n        /*\\n\\t\\t\\tif we can\\'t reach target, I will first use the largestfuel Station\\n\\t\\t\\t(which can take me farthest) and move ahead and keep doing this.\\n        */\\n        int curr = startFuel; //my current position\\n        int i = 0; //station index\\n        int result = 0;\\n        while(curr < target) { //until I reach my target\\n            while(i < n && curr >= stations[i][0]) {\\n                /*\\n\\t\\t\\t\\t\\t  Sice, I am already ahead of or at this station\\n\\t\\t\\t\\t\\t  (i.e. curr >= stations[i][0])  we don\\'t use this\\n\\t\\t\\t\\t\\t  station and try to move ahead but I store this\\n\\t\\t\\t\\t\\t  station in maxheap to use in future\\n\\t\\t\\t\\t*/\\n                pq.push(stations[i][1]);\\n\\t\\t\\t\\t//Keep the station at top which can take me farthest (maximum gas)\\n                i++;\\n            }\\n            \\n            if(pq.empty()) //we can\\'t move further now\\n                return -1;\\n            \\n            int dist = pq.top();\\n            pq.pop();\\n            \\n            curr += dist;\\n            result++;\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 ( O(n^2) DP)\\ntypedef unsigned long long ull;\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        \\n        vector<vector<ull>> t(n+1, vector<ull>(n+1, 0));\\n        //t[i][j] = Maximum distance reached if I stopped at \\'j\\' fuelStops from total of \\'i\\' fuelStops\\n        //i.e. j <= i\\n        \\n        //If j = 0, i.e. I did not use any fuelStops, Then maximum I can reach is \\'startFuel\\' which I had initially\\n        \\n        //So, initialize the dp array with this information\\n        for(int i = 0; i<n+1; i++) {\\n            t[i][0] = startFuel;\\n        }\\n        \\n        //There is no point of filling 1st row because \\n        //t[0][j] means I used j fuelStops from 0 fuelStops which doesn\\'t make any sense for (j>0)\\n        //That\\'s why I start from i = 1 and obviously j = 1 because for j = 0 we already populated the dp array\\n        \\n        for(int i = 1; i < n+1; i++) {\\n            for(int j = 1; j <= i; j++) { //I can use j=1 to j=i fuel stops and find max distance for t[i][j]\\n                //case-1 (I don\\'t refuel at current fuelstop)\\n                //If I didn\\'t refuel at current stop, the max distance I can cover is equal to maximum\\n                //distance I could cover from previous state\\n                t[i][j] = t[i-1][j];\\n                \\n                //case-2 (I will refuel at current fuelStop)\\n                //But check if you can even reach this station (stations[i-1][0]) or not from your previous station\\n                if(t[i-1][j-1] >= stations[i-1][0]) {\\n                    t[i][j] = max(t[i][j], t[i-1][j-1] + stations[i-1][1]);\\n                }\\n                \\n            }\\n        }\\n        \\n        //After you end up with all stations, check which t[n][j] was best for reaching target\\n        //Best means, minimum j used by you to reach target\\n        for(int j = 0; j<n+1; j++) {\\n            if(t[n][j] >= target)\\n                return j;\\n        }\\n        \\n        //You could never reach target, so return -1\\n        return -1;\\n    }\\n};\\n```\n```\\n//Approach-2 : O(n^2)dp\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        \\n        vector<long long> t(n+1, 0);\\n        //t[j] = max distance that I can reach using j fuelStops\\n        \\n        //When I don\\'t use any fuelStop, I can travel as much as I had startFuel in the beginning\\n        t[0] = startFuel;\\n        \\n        for(int i = 1; i<n+1; i++) {\\n            //traverse on all fuel stops\\n            \\n            //I can use all i fuelStops, or (i-1), or (i-2) ... till 0 to find which gave me best result\\n            //So. j goes from j = i to j = 0\\n            for(int j = i; j>=0; j--) {\\n                //But first, I need to check If I can even reach curr station or not to use it\\n                if(t[j] >= stations[i-1][0]) {\\n                    //So, we can use this fuelStop and now we are using (j+1) fuelStops\\n                    t[j+1] = max(t[j+1], t[j] + stations[i-1][1]);\\n                }\\n            }\\n        }\\n        \\n        //After you end up with all stations, check which was best for reaching target\\n        //Best means, minimum j used by you to reach target\\n        \\n        for(int j = 0; j<n+1; j++) {\\n            if(t[j] >= target)\\n                return j;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\n//Approach-3 : O(nlog(n)) using max-heap\\n//Similar Problem : Leetcode 1642. Furthest Building You Can Reach\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        \\n        priority_queue<int> pq; //max heap\\n        /*\\n\\t\\t\\tif we can\\'t reach target, I will first use the largestfuel Station\\n\\t\\t\\t(which can take me farthest) and move ahead and keep doing this.\\n        */\\n        int curr = startFuel; //my current position\\n        int i = 0; //station index\\n        int result = 0;\\n        while(curr < target) { //until I reach my target\\n            while(i < n && curr >= stations[i][0]) {\\n                /*\\n\\t\\t\\t\\t\\t  Sice, I am already ahead of or at this station\\n\\t\\t\\t\\t\\t  (i.e. curr >= stations[i][0])  we don\\'t use this\\n\\t\\t\\t\\t\\t  station and try to move ahead but I store this\\n\\t\\t\\t\\t\\t  station in maxheap to use in future\\n\\t\\t\\t\\t*/\\n                pq.push(stations[i][1]);\\n\\t\\t\\t\\t//Keep the station at top which can take me farthest (maximum gas)\\n                i++;\\n            }\\n            \\n            if(pq.empty()) //we can\\'t move further now\\n                return -1;\\n            \\n            int dist = pq.top();\\n            pq.pop();\\n            \\n            curr += dist;\\n            result++;\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149858,
                "title": "simple-java-solution-using-priorityqueue-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        Queue<Integer> queue = new PriorityQueue<>();\\n        long dist = startFuel;\\n        int res = 0;\\n        int idx = 0;\\n        while (true) {\\n            while (idx < stations.length && stations[idx][0] <= dist) {\\n                queue.offer(-stations[idx][1]);\\n                idx++;\\n            }\\n            \\n            if (dist >= target) return res;\\n            if (queue.isEmpty()) return -1;\\n            dist += -queue.poll();\\n            res++;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        Queue<Integer> queue = new PriorityQueue<>();\\n        long dist = startFuel;\\n        int res = 0;\\n        int idx = 0;\\n        while (true) {\\n            while (idx < stations.length && stations[idx][0] <= dist) {\\n                queue.offer(-stations[idx][1]);\\n                idx++;\\n            }\\n            \\n            if (dist >= target) return res;\\n            if (queue.isEmpty()) return -1;\\n            dist += -queue.poll();\\n            res++;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151850,
                "title": "c-dp-solution-space-complexity-from-o-n-2-to-o-n",
                "content": "Denote by dp[i][j] the farthest location we can get to using exactly j refueling stops among the first i refueling stops, for j <= i.\\n\\nInitially dp[i][0] = startFuel, for i = 0, ..., n. \\n\\ndp[][] is updated as follows. For the gas station i, one can either refuel the car at this station if dp[i-1][j-1] >= stations[i][0], and dp[i][j] = max(dp[i][j], dp[i-1][j-1] + stations[i][1]). Or one can choose to not refuel the car, and dp[i][j] = max(dp[i][j], dp[i-1][j]) if j <= i-1.\\n\\nHere is the code for O(n^2) space complexity dynamic programming.\\n\\n```\\nfor (int i = 0; i <= n; i++) dp[i][0] = startFuel;\\n\\nfor (int i = 0; i < n; i++)\\n\\tfor (int j = 0; j <= i; j++) {\\n\\t\\tif (i >= j+1)\\n\\t\\t\\tdp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j+1]);\\n\\t\\tif (dp[i][j] >= stations[i][0])\\n\\t\\t\\tdp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + stations[i][1]);\\n\\t}\\n```\\n\\nIt is worth pointing out that the (i+1)-th raws depends only on the values on the i-th raws. Hence, we can reduce the space complexity. \\nThe previous code is equivalent to \\n```\\ndp[0] = startFuel;\\nfor (int i = 0; i < n; i++)\\n\\tfor (int j = i; j >= 0; j--) {\\n\\t\\tif (dp[j] >= stations[i][0])\\n\\t\\t\\tdp[j+1] = max(dp[j+1], dp[j] + stations[i][1]);\\n\\t}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nfor (int i = 0; i <= n; i++) dp[i][0] = startFuel;\\n\\nfor (int i = 0; i < n; i++)\\n\\tfor (int j = 0; j <= i; j++) {\\n\\t\\tif (i >= j+1)\\n\\t\\t\\tdp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j+1]);\\n\\t\\tif (dp[i][j] >= stations[i][0])\\n\\t\\t\\tdp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + stations[i][1]);\\n\\t}\\n```\n```\\ndp[0] = startFuel;\\nfor (int i = 0; i < n; i++)\\n\\tfor (int j = i; j >= 0; j--) {\\n\\t\\tif (dp[j] >= stations[i][0])\\n\\t\\t\\tdp[j+1] = max(dp[j+1], dp[j] + stations[i][1]);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150514,
                "title": "simple-c-greedy-using-pq-with-explanation",
                "content": "```\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int> pq;\\n        int ret = 0, stationId = 0, range = startFuel;\\n        while (range < target) {\\n            while (stationId < stations.size() && stations[stationId][0] <= range) {\\n                pq.push(stations[stationId++][1]);\\n            }\\n            if (pq.empty()) return -1;\\n            range += pq.top();\\n            pq.pop();\\n            ++ret;\\n        }\\n        return ret;\\n    }\\n```\\nExplanation:\\nInitially you have a range(startFuel), before you run out of fuel, you can stop by any station within your range.\\nThe greedy idea is to put all the stations within your range into a candidate list (pq), then you always pick the station with the most fuel supply one at a time to extend your range until your range reaches the target.\\nOnce your range is extended, you can add more stations to your candidate list. \\nIf you have exhausted the stations in your list(pq) and still can\\'t reach the target, return -1.",
                "solutionTags": [],
                "code": "```\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int> pq;\\n        int ret = 0, stationId = 0, range = startFuel;\\n        while (range < target) {\\n            while (stationId < stations.size() && stations[stationId][0] <= range) {\\n                pq.push(stations[stationId++][1]);\\n            }\\n            if (pq.empty()) return -1;\\n            range += pq.top();\\n            pq.pop();\\n            ++ret;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1266490,
                "title": "minimum-number-of-refueling-stops-greedy-priorityqueue",
                "content": "**Intuition:**\\n\\n```\\n1) we need to keep track of all the stations where car can reach with current fuel.\\n2) And from all the stations, we need to stop at that station which can fill the car with maximum fuel.\\n\\nCases To Consider:\\n1. What if the car is not having enogh fuel to reach at any station.\\n2. What if the car covers all the stations but still car is not having enough fuel to reach the target.\\n\\nIn both the above cases we need to return -1, as car cannot reach the target.\\n\\nNow, the main thing is to identify which Data Structure to use for this situation,\\nAs we have seen that , we need to keep track of all the stations that car can cover and from among them car can stop at the station which has maximum Fuel.\\n\\nSo, it is clear that we need to keep track of maximum Fuel among all the reachable stations.\\nAnd it can be achieved by using Max Heap.\\n```\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int> pq;\\n        int minStops=0;\\n        int currentStationIndex = 0;\\n        int totalStations = size(stations);\\n        while(startFuel<target)\\n        {\\n            while(currentStationIndex < totalStations and stations[currentStationIndex][0]<=startFuel)\\n            {\\n                pq.push(stations[currentStationIndex][1]);\\n                currentStationIndex++;\\n            }\\n            if(pq.empty())\\n                return -1;\\n            startFuel+=pq.top();\\n            pq.pop();\\n            minStops++;\\n        }\\n        return minStops;\\n    }\\n};\\n```\\n\\n\\n**Time Complexity:** ```O(nlog(n))```\\n**Space Complexity:** ```O(n)```\\nwhere **n**--> Number of Fuel Stations.\\n\\n```\\n If you find this post useful, then don\\'t forget to upvote this.\\nHappy Coding :) \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1) we need to keep track of all the stations where car can reach with current fuel.\\n2) And from all the stations, we need to stop at that station which can fill the car with maximum fuel.\\n\\nCases To Consider:\\n1. What if the car is not having enogh fuel to reach at any station.\\n2. What if the car covers all the stations but still car is not having enough fuel to reach the target.\\n\\nIn both the above cases we need to return -1, as car cannot reach the target.\\n\\nNow, the main thing is to identify which Data Structure to use for this situation,\\nAs we have seen that , we need to keep track of all the stations that car can cover and from among them car can stop at the station which has maximum Fuel.\\n\\nSo, it is clear that we need to keep track of maximum Fuel among all the reachable stations.\\nAnd it can be achieved by using Max Heap.\\n```\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int> pq;\\n        int minStops=0;\\n        int currentStationIndex = 0;\\n        int totalStations = size(stations);\\n        while(startFuel<target)\\n        {\\n            while(currentStationIndex < totalStations and stations[currentStationIndex][0]<=startFuel)\\n            {\\n                pq.push(stations[currentStationIndex][1]);\\n                currentStationIndex++;\\n            }\\n            if(pq.empty())\\n                return -1;\\n            startFuel+=pq.top();\\n            pq.pop();\\n            minStops++;\\n        }\\n        return minStops;\\n    }\\n};\\n```\n```O(nlog(n))```\n```O(n)```\n```\\n If you find this post useful, then don\\'t forget to upvote this.\\nHappy Coding :) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451314,
                "title": "c-full-explained-code-with-comments-clean-code",
                "content": "**Solution 1**\\nOne of the solution use dynamic programming. Let dp[i][j] be a maximum amount of fuel we can have, when we reached station number i and refueled j times before this station (not included). Let us also add two more points to our stops: starting one and ending one. Then, how we can update dp[i][j]: we can\\n\\nEither refuel on previous station, than we have dp[i-1][j-1] minus distance we covered between i-1 and i stations and plus amount of fuel we get at last station.\\nOr it can be dp[i-1][j] plus distance we covered between i-1 and i stations.\\nIf we have cand < 0 in our code, than it means we can not reach position i with j refuels, so we leave it equal to minus infinity. Finally, in the end we check last station and find the smallest index where value is not negative and return it.\\n\\nComplexity\\nTime complexity is O(n^2), space is O(n^2) as well. Space can be reduced to O(n).\\n\\n//Approach-1 ( O(n^2) DP)\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        \\n        vector<vector<ull>> t(n+1, vector<ull>(n+1, 0));\\n        //t[i][j] = Maximum distance reached if I stopped at \\'j\\' fuelStops from total of \\'i\\' fuelStops\\n        //i.e. j <= i\\n        \\n        //If j = 0, i.e. I did not use any fuelStops, Then maximum I can reach is \\'startFuel\\' which I had initially\\n        \\n        //So, initialize the dp array with this information\\n        for(int i = 0; i<n+1; i++) {\\n            t[i][0] = startFuel;\\n        }\\n        \\n        //There is no point of filling 1st row because \\n        //t[0][j] means I used j fuelStops from 0 fuelStops which doesn\\'t make any sense for (j>0)\\n        //That\\'s why I start from i = 1 and obviously j = 1 because for j = 0 we already populated the dp array\\n        \\n        for(int i = 1; i < n+1; i++) {\\n            for(int j = 1; j <= i; j++) { //I can use j=1 to j=i fuel stops and find max distance for t[i][j]\\n                //case-1 (I don\\'t refuel at current fuelstop)\\n                //If I didn\\'t refuel at current stop, the max distance I can cover is equal to maximum\\n                //distance I could cover from previous state\\n                t[i][j] = t[i-1][j];\\n                \\n                //case-2 (I will refuel at current fuelStop)\\n                //But check if you can even reach this station (stations[i-1][0]) or not from your previous station\\n                if(t[i-1][j-1] >= stations[i-1][0]) {\\n                    t[i][j] = max(t[i][j], t[i-1][j-1] + stations[i-1][1]);\\n                }\\n                \\n            }\\n        }\\n        \\n        //After you end up with all stations, check which t[n][j] was best for reaching target\\n        //Best means, minimum j used by you to reach target\\n        for(int j = 0; j<n+1; j++) {\\n            if(t[n][j] >= target)\\n                return j;\\n        }\\n        \\n        //You could never reach target, so return -1\\n        return -1;\\n    }\\n};\\n```\\n**Solution 2:**\\n\\nThere is also O(n log n) complexity solution, using heaps! Let us follow the following strategy: ride until we can, and if we can not, choose the biggest of stations we met previously and refuel at this station. Why it is working? Because in any case we need to spend target amount of fuel, and if we choose station with biggest amount of fuel inside, then we always better if we choose other station. So, the algorithm will work like this:\\n\\nAdd starting and ending position to our stations\\nIterate through positions: update fuel: subtract distance we passed\\nIf it happen that we have negative amount of fuel, we need to refuel at some station previously, we choose the biggest one, increase answer\\nIf it happen, that we can not reach zero level, it means we are stuck and we can return -1 immediately.\\nPush new amount of fuel to our heap for just visited station.\\nQuestion\\nWhat happens if we have situation like this? -----10-------9--!---, we are at the moment at place ! and we meet two stations previously with fuel 9 recently and with fuel 10 some time ago. Then it seems like it is better to refuel at station with 9. However it is not the case and I spend some time realizing it. If we change from station with 9 to station with 10, when we reach !, we will have more fuel, because we always travel the same distance, but now we have more fuel in our tank.\\n\\nComplexity\\nTime complexity is O(n log n), space complexity is O(n).\\n\\n//Approach-2 : O(nlog(n)) using max-heap\\n//Similar Problem : Leetcode 1642. Furthest Building You Can Reach\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        \\n        priority_queue<int> pq; //max heap\\n        /*\\n\\t\\t\\tif we can\\'t reach target, I will first use the largestfuel Station\\n\\t\\t\\t(which can take me farthest) and move ahead and keep doing this.\\n        */\\n        int curr = startFuel; //my current position\\n        int i = 0; //station index\\n        int result = 0;\\n        while(curr < target) { //until I reach my target\\n            while(i < n && curr >= stations[i][0]) {\\n                /*\\n\\t\\t\\t\\t\\t  Sice, I am already ahead of or at this station\\n\\t\\t\\t\\t\\t  (i.e. curr >= stations[i][0])  we don\\'t use this\\n\\t\\t\\t\\t\\t  station and try to move ahead but I store this\\n\\t\\t\\t\\t\\t  station in maxheap to use in future\\n\\t\\t\\t\\t*/\\n                pq.push(stations[i][1]);\\n\\t\\t\\t\\t//Keep the station at top which can take me farthest (maximum gas)\\n                i++;\\n            }\\n            \\n            if(pq.empty()) //we can\\'t move further now\\n                return -1;\\n            \\n            int dist = pq.top();\\n            pq.pop();\\n            \\n            curr += dist;\\n            result++;\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```\\n\\n**IF YOU LIKE IT,  THEN JUST PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        \\n        vector<vector<ull>> t(n+1, vector<ull>(n+1, 0));\\n        //t[i][j] = Maximum distance reached if I stopped at \\'j\\' fuelStops from total of \\'i\\' fuelStops\\n        //i.e. j <= i\\n        \\n        //If j = 0, i.e. I did not use any fuelStops, Then maximum I can reach is \\'startFuel\\' which I had initially\\n        \\n        //So, initialize the dp array with this information\\n        for(int i = 0; i<n+1; i++) {\\n            t[i][0] = startFuel;\\n        }\\n        \\n        //There is no point of filling 1st row because \\n        //t[0][j] means I used j fuelStops from 0 fuelStops which doesn\\'t make any sense for (j>0)\\n        //That\\'s why I start from i = 1 and obviously j = 1 because for j = 0 we already populated the dp array\\n        \\n        for(int i = 1; i < n+1; i++) {\\n            for(int j = 1; j <= i; j++) { //I can use j=1 to j=i fuel stops and find max distance for t[i][j]\\n                //case-1 (I don\\'t refuel at current fuelstop)\\n                //If I didn\\'t refuel at current stop, the max distance I can cover is equal to maximum\\n                //distance I could cover from previous state\\n                t[i][j] = t[i-1][j];\\n                \\n                //case-2 (I will refuel at current fuelStop)\\n                //But check if you can even reach this station (stations[i-1][0]) or not from your previous station\\n                if(t[i-1][j-1] >= stations[i-1][0]) {\\n                    t[i][j] = max(t[i][j], t[i-1][j-1] + stations[i-1][1]);\\n                }\\n                \\n            }\\n        }\\n        \\n        //After you end up with all stations, check which t[n][j] was best for reaching target\\n        //Best means, minimum j used by you to reach target\\n        for(int j = 0; j<n+1; j++) {\\n            if(t[n][j] >= target)\\n                return j;\\n        }\\n        \\n        //You could never reach target, so return -1\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        \\n        priority_queue<int> pq; //max heap\\n        /*\\n\\t\\t\\tif we can\\'t reach target, I will first use the largestfuel Station\\n\\t\\t\\t(which can take me farthest) and move ahead and keep doing this.\\n        */\\n        int curr = startFuel; //my current position\\n        int i = 0; //station index\\n        int result = 0;\\n        while(curr < target) { //until I reach my target\\n            while(i < n && curr >= stations[i][0]) {\\n                /*\\n\\t\\t\\t\\t\\t  Sice, I am already ahead of or at this station\\n\\t\\t\\t\\t\\t  (i.e. curr >= stations[i][0])  we don\\'t use this\\n\\t\\t\\t\\t\\t  station and try to move ahead but I store this\\n\\t\\t\\t\\t\\t  station in maxheap to use in future\\n\\t\\t\\t\\t*/\\n                pq.push(stations[i][1]);\\n\\t\\t\\t\\t//Keep the station at top which can take me farthest (maximum gas)\\n                i++;\\n            }\\n            \\n            if(pq.empty()) //we can\\'t move further now\\n                return -1;\\n            \\n            int dist = pq.top();\\n            pq.pop();\\n            \\n            curr += dist;\\n            result++;\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149867,
                "title": "simple-java-using-pq-with-explanation",
                "content": "```Java\\npublic int minRefuelStops(int target, int startFuel, int[][] stations) {\\n    int curFarthest = startFuel, refuel = 0;\\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n    for (int[] station : stations) {\\n        // check if we can reach this station\\n        // if we cannot reach this station, refuel the gas from the previous station with most gas\\n        // redo the operation until we get enough gas to reach this station\\n        while (curFarthest < station[0]) {\\n            if (pq.isEmpty()) return -1; // if we reful in each station but still cannot reach this station, return -1\\n            curFarthest += pq.poll();\\n            refuel++;\\n        }\\n        pq.offer(station[1]);\\n    }\\n    // now we have reached the last station, check if we can reach the target\\n    while (curFarthest < target) {\\n        if (pq.isEmpty()) return -1;\\n        curFarthest += pq.poll();\\n        refuel++;\\n    }\\n    return refuel;\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\npublic int minRefuelStops(int target, int startFuel, int[][] stations) {\\n    int curFarthest = startFuel, refuel = 0;\\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n    for (int[] station : stations) {\\n        // check if we can reach this station\\n        // if we cannot reach this station, refuel the gas from the previous station with most gas\\n        // redo the operation until we get enough gas to reach this station\\n        while (curFarthest < station[0]) {\\n            if (pq.isEmpty()) return -1; // if we reful in each station but still cannot reach this station, return -1\\n            curFarthest += pq.poll();\\n            refuel++;\\n        }\\n        pq.offer(station[1]);\\n    }\\n    // now we have reached the last station, check if we can reach the target\\n    while (curFarthest < target) {\\n        if (pq.isEmpty()) return -1;\\n        curFarthest += pq.poll();\\n        refuel++;\\n    }\\n    return refuel;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1266495,
                "title": "python-2-solutions-dp-and-greedy-heap-explained",
                "content": "#### Solution 1\\nOne of the solution use dynamic programming. Let `dp[i][j]` be a maximum amount of fuel we can have, when we reached station number `i` and refueled `j` times before this station (not included). Let us also add two more points to our stops: starting one and ending one. Then, how we can update `dp[i][j]`: we can \\n1. Either refuel on previous station, than we have `dp[i-1][j-1]` minus distance we covered between `i-1` and `i` stations and plus amount of fuel we get at last station. \\n2. Or it can be `dp[i-1][j]` plus distance we covered between `i-1` and `i` stations. \\n\\nIf we have `cand < 0` in our code, than it means we can not reach position `i` with `j` refuels, so we leave it equal to minus infinity. Finally, in the end we check last station and find the smallest index where value is not negative and return it.\\n\\n#### Complexity\\nTime complexity is `O(n^2)`, space is `O(n^2)` as well. Space can be reduced to `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minRefuelStops(self, target, startFuel, s):\\n        s = [[0, startFuel]] + s + [[target, 0]]\\n        n = len(s)\\n        t = [(s[i-1][0] - s[i][0], s[i-1][1] + s[i-1][0] - s[i][0]) for i in range(1, n)]\\n        dp = [[-float(\"inf\")] * n for _ in range(n)]\\n        dp[0][0] = 0\\n        \\n        for i in range(1, n):\\n            for j in range(1, i+1):\\n                cand = max(dp[i-1][j] + t[i-1][0], dp[i-1][j-1] + t[i-1][1])\\n                if cand >= 0: dp[i][j] = cand\\n        \\n        for i, elem in enumerate(dp[-1]):\\n            if elem >= 0: return i - 1\\n                    \\n        return -1\\n```\\n\\n#### Solution 2\\nThere is also `O(n log n)` complexity solution, using heaps! Let us follow the  following strategy: ride until we can, and if we can not, choose the biggest of stations we met previously and refuel at this station. Why it is working? Because in any case we need to spend `target` amount of fuel, and if we choose station with biggest amount of fuel inside, then we always better if we choose other station. So, the algorithm will work like this:\\n\\n1. Add starting and ending position to our stations\\n2. Iterate through positions: update fuel: subtract distance we passed\\n3. If it happen that we have negative amount of fuel, we need to refuel at some station previously, we choose the biggest one, increase answer\\n4. If it happen, that we can not reach zero level, it means we are stuck and we can return `-1` immediately.\\n5. Push new amount of fuel to our heap for just visited station.\\n\\n**Question**\\nWhat happens if we have situation like this?  `-----10-------9--!---`, we are at the moment at place `!` and we meet two stations previously with fuel `9` recently and with fuel `10` some time ago. Then it seems like it is better to refuel at station with `9`. However it is not the case and I spend some time realizing it. If we change from station with `9` to station with `10`, when we reach `!`, we will have more fuel, because we always travel the same distance, but now we have more fuel in our tank.\\n\\n#### Complexity\\nTime complexity is `O(n log n)`, space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minRefuelStops(self, target, fuel, s):\\n        heap = [] \\n        s = [(0, 0)] + s + [(target, 0)]\\n        n, ans = len(s), 0\\n        \\n        for i in range(1, n):\\n            fuel -= s[i][0] - s[i-1][0]\\n            while heap and fuel < 0:\\n                fuel -= heappop(heap)\\n                ans += 1\\n            if fuel < 0: return -1\\n            heappush(heap, -s[i][1])\\n            \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minRefuelStops(self, target, startFuel, s):\\n        s = [[0, startFuel]] + s + [[target, 0]]\\n        n = len(s)\\n        t = [(s[i-1][0] - s[i][0], s[i-1][1] + s[i-1][0] - s[i][0]) for i in range(1, n)]\\n        dp = [[-float(\"inf\")] * n for _ in range(n)]\\n        dp[0][0] = 0\\n        \\n        for i in range(1, n):\\n            for j in range(1, i+1):\\n                cand = max(dp[i-1][j] + t[i-1][0], dp[i-1][j-1] + t[i-1][1])\\n                if cand >= 0: dp[i][j] = cand\\n        \\n        for i, elem in enumerate(dp[-1]):\\n            if elem >= 0: return i - 1\\n                    \\n        return -1\\n```\n```python\\nclass Solution:\\n    def minRefuelStops(self, target, fuel, s):\\n        heap = [] \\n        s = [(0, 0)] + s + [(target, 0)]\\n        n, ans = len(s), 0\\n        \\n        for i in range(1, n):\\n            fuel -= s[i][0] - s[i-1][0]\\n            while heap and fuel < 0:\\n                fuel -= heappop(heap)\\n                ans += 1\\n            if fuel < 0: return -1\\n            heappush(heap, -s[i][1])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342310,
                "title": "difference-between-this-problem-and-the-jump-game-ii",
                "content": "In the beginning, I thought this problem is same as jump game II. However, I can\\'t pass the example case:\\n1000\\n299\\n[[13,21],[26,115],[100,47],[225,99],[299,141],[444,198],[608,190],[636,157],[647,255],[841,123]] (it failed at [444,198])\\n\\nThen I realized that there is difference between this one and jump game II:\\nfor this problem, we can accumulatively add fuel (jump power) to the curr_fuel (jump max), writing as curr_fuel += fuel_in_this_station\\nfor jump game II, we can only CHOOSE one station as the new jump point, writting as jump_max = max(jump_max, curr_index + jump_power). You can consider it as we can only choose one station from previous station for current jump.\\n\\nHope this can help people with same confusion. My python solution with heap:\\n\\n```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        stations.append([target, 0])\\n        refuel_count = 0\\n        curr_fuel = startFuel\\n        heap = []\\n        for curr_mile, fuel in stations:\\n            while curr_fuel < curr_mile and heap:\\n                curr_fuel -= heapq.heappop(heap)\\n                refuel_count += 1\\n            if curr_fuel < curr_mile:\\n                return -1\\n            heapq.heappush(heap, -fuel)\\n\\n        return refuel_count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        stations.append([target, 0])\\n        refuel_count = 0\\n        curr_fuel = startFuel\\n        heap = []\\n        for curr_mile, fuel in stations:\\n            while curr_fuel < curr_mile and heap:\\n                curr_fuel -= heapq.heappop(heap)\\n                refuel_count += 1\\n            if curr_fuel < curr_mile:\\n                return -1\\n            heapq.heappush(heap, -fuel)\\n\\n        return refuel_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451490,
                "title": "c-max-heap-short-clean-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n1. Starting Index => i =0.\\n2. Build a max heap and it will store the max dist that can be travlled form a station\\n3. Now iterate until currFuel < target\\n4. If currFuel >= stations[i][0] i.e. position of pump, add it\\'s fuel capacity into max heap\\n5. If heap is empty just return -1\\n6. Else update currFuel by adding pq.top and increment result\\n7. Lastly, when currFuel >= target, exit from while loop and return res.\\n\\n----------------------------------------------------------------------------------------------------------------------------------\\n\\t\\n\\tint minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int n=stations.size();\\n        int currFuel=startFuel, i=0;     //i -> starting index\\n        int res=0;\\n        \\n        priority_queue<int> pq;      //max heap -> it will store the max distance travelled from a petrol pump\\n        \\n        while(currFuel < target){\\n            \\n            while(i<n && currFuel >= stations[i][0]){    //if at a particular station, currFuel>= position of pump\\n                pq.push(stations[i][1]);                 // i.e. currFuel >= stations[i][0]\\n                i++;                                     //then push it\\'s fuel into max heap\\n            }\\n            \\n            if(pq.empty()) return -1;          //if pq is empty just return -1\\n            \\n            currFuel += pq.top();              //update currFuel by adding pq.top()\\n            pq.pop();\\n            \\n            res++;                             //increment res\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n1. Starting Index => i =0.\\n2. Build a max heap and it will store the max dist that can be travlled form a station\\n3. Now iterate until currFuel < target\\n4. If currFuel >= stations[i][0] i.e. position of pump, add it\\'s fuel capacity into max heap\\n5. If heap is empty just return -1\\n6. Else update currFuel by adding pq.top and increment result\\n7. Lastly, when currFuel >= target, exit from while loop and return res.\\n\\n----------------------------------------------------------------------------------------------------------------------------------\\n\\t\\n\\tint minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int n=stations.size();\\n        int currFuel=startFuel, i=0;     //i -> starting index\\n        int res=0;\\n        \\n        priority_queue<int> pq;      //max heap -> it will store the max distance travelled from a petrol pump\\n        \\n        while(currFuel < target){\\n            \\n            while(i<n && currFuel >= stations[i][0]){    //if at a particular station, currFuel>= position of pump\\n                pq.push(stations[i][1]);                 // i.e. currFuel >= stations[i][0]\\n                i++;                                     //then push it\\'s fuel into max heap\\n            }\\n            \\n            if(pq.empty()) return -1;          //if pq is empty just return -1\\n            \\n            currFuel += pq.top();              //update currFuel by adding pq.top()\\n            pq.pop();\\n            \\n            res++;                             //increment res\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2452673,
                "title": "python-easily-understood-faster-than-90-fast",
                "content": "```\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n\\tcur_fuel = startFuel\\n\\tmissed_fuel = []\\n\\theapq.heapify(missed_fuel)\\n\\tstations.append([target, 0])\\n\\trefuel_count = 0\\n\\tprev_location = 0\\n\\n\\tfor station in stations:\\n\\t\\tcur_fuel -= station[0] - prev_location\\n\\t\\twhile cur_fuel < 0:\\n\\t\\t\\tif len(missed_fuel) == 0:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tcur_fuel -= heapq.heappop(missed_fuel)\\n\\t\\t\\trefuel_count += 1\\n\\t\\theapq.heappush(missed_fuel, -station[1])\\n\\t\\tprev_location = station[0]\\n\\n\\treturn refuel_count\\n```\\n\\n**Time Complexity**: `O(n log n)`\\n**Space Complexity**: `O(n)`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n\\tcur_fuel = startFuel\\n\\tmissed_fuel = []\\n\\theapq.heapify(missed_fuel)\\n\\tstations.append([target, 0])\\n\\trefuel_count = 0\\n\\tprev_location = 0\\n\\n\\tfor station in stations:\\n\\t\\tcur_fuel -= station[0] - prev_location\\n\\t\\twhile cur_fuel < 0:\\n\\t\\t\\tif len(missed_fuel) == 0:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tcur_fuel -= heapq.heappop(missed_fuel)\\n\\t\\t\\trefuel_count += 1\\n\\t\\theapq.heappush(missed_fuel, -station[1])\\n\\t\\tprev_location = station[0]\\n\\n\\treturn refuel_count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2452689,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\nAPPROACH- 1 Video Explanation \\uD83E\\uDC83\\uD83E\\uDC83\\nhttps://www.youtube.com/watch?v=iJfEo9g2zs4\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n**C++ Approach-1** \\n```\\n class Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n= stations.size();\\n        long dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[0]= startFuel;\\n        for(int i=0; i< n; i++){\\n           for(int j=i; j>=0 && dp[j]>= stations[i][0]; j--) {\\n          dp[j+1] = max(dp[j+1], (dp[j]+ stations[i][1]));\\n               }  \\n        }\\n        for(int i=0; i<=n ; i++){\\n            if(dp[i]>=target) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**C++ Approach-2** \\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n   int n= stations.size();\\n        int fuel=startFuel; int fuelno=0;\\n        int ans=0;\\n        priority_queue<int> pq;\\n        while(fuel<target){\\n           while(fuelno<n && fuel>= stations[fuelno][0]) \\n           { \\n               pq.push(stations[fuelno][1]);\\n\\n            fuelno++;\\n           }\\n            \\n            \\n            \\n            \\n            if(pq.empty()) return -1;\\n          fuel = fuel+ pq.top();\\n            pq.pop();\\n            \\n            ans++;\\n\\n        }\\n          return ans;\\n    }\\n};\\n```\\n\\n**PYTHON**(copied)-https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/2451158/Java-Python-or-Heap-or-4ms-185ms\\n\\n```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        fuelInStation = []\\n        res = 0\\n        fuel = startFuel\\n        \\n        for station in stations:\\n            while (fuel < station[0]):\\n                if (not fuelInStation):\\n                    return -1\\n                fuel -= heapq.heappop(fuelInStation)\\n                res += 1\\n            heapq.heappush(fuelInStation, -station[1])\\n        \\n        while (fuel < target):\\n            if (not fuelInStation):\\n                return -1\\n            fuel -= heapq.heappop(fuelInStation)\\n            res += 1\\n        \\n        return res\\n```\\n**JAVA**(copied)-https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/2451158/Java-Python-or-Heap-or-4ms-185ms\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer> fuelInStation = new PriorityQueue<>((x, y) -> (y - x));\\n        \\n        int res = 0;\\n        int fuel = startFuel;\\n        \\n        for (int[] station : stations) {\\n            while (fuel < station[0]) {\\n                if (fuelInStation.isEmpty()) return -1;\\n                fuel += fuelInStation.poll();\\n                res++;\\n            }\\n            fuelInStation.offer(station[1]);\\n        }\\n        \\n        while (fuel < target) {\\n            if (fuelInStation.isEmpty()) return -1;\\n            fuel += fuelInStation.poll();\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n**Please UPVOTE  to motivate me for solving more questions like this and clubbing all languages solution!!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n= stations.size();\\n        long dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[0]= startFuel;\\n        for(int i=0; i< n; i++){\\n           for(int j=i; j>=0 && dp[j]>= stations[i][0]; j--) {\\n          dp[j+1] = max(dp[j+1], (dp[j]+ stations[i][1]));\\n               }  \\n        }\\n        for(int i=0; i<=n ; i++){\\n            if(dp[i]>=target) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n   int n= stations.size();\\n        int fuel=startFuel; int fuelno=0;\\n        int ans=0;\\n        priority_queue<int> pq;\\n        while(fuel<target){\\n           while(fuelno<n && fuel>= stations[fuelno][0]) \\n           { \\n               pq.push(stations[fuelno][1]);\\n\\n            fuelno++;\\n           }\\n            \\n            \\n            \\n            \\n            if(pq.empty()) return -1;\\n          fuel = fuel+ pq.top();\\n            pq.pop();\\n            \\n            ans++;\\n\\n        }\\n          return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        fuelInStation = []\\n        res = 0\\n        fuel = startFuel\\n        \\n        for station in stations:\\n            while (fuel < station[0]):\\n                if (not fuelInStation):\\n                    return -1\\n                fuel -= heapq.heappop(fuelInStation)\\n                res += 1\\n            heapq.heappush(fuelInStation, -station[1])\\n        \\n        while (fuel < target):\\n            if (not fuelInStation):\\n                return -1\\n            fuel -= heapq.heappop(fuelInStation)\\n            res += 1\\n        \\n        return res\\n```\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer> fuelInStation = new PriorityQueue<>((x, y) -> (y - x));\\n        \\n        int res = 0;\\n        int fuel = startFuel;\\n        \\n        for (int[] station : stations) {\\n            while (fuel < station[0]) {\\n                if (fuelInStation.isEmpty()) return -1;\\n                fuel += fuelInStation.poll();\\n                res++;\\n            }\\n            fuelInStation.offer(station[1]);\\n        }\\n        \\n        while (fuel < target) {\\n            if (fuelInStation.isEmpty()) return -1;\\n            fuel += fuelInStation.poll();\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149981,
                "title": "this-is-a-backpack-problem",
                "content": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int len = stations.length;\\n        long[] dp = new long[len + 1];\\n        dp[0] = startFuel;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j > 0 && dp[j - 1] >= stations[i][0]; j--) {\\n                dp[j] = Math.max(dp[j], dp[j - 1] + stations[i][1]);\\n            }\\n        }\\n        for (int i = 0; i <= len; i++) {\\n            if (dp[i] >= target) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int len = stations.length;\\n        long[] dp = new long[len + 1];\\n        dp[0] = startFuel;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j > 0 && dp[j - 1] >= stations[i][0]; j--) {\\n                dp[j] = Math.max(dp[j], dp[j - 1] + stations[i][1]);\\n            }\\n        }\\n        for (int i = 0; i <= len; i++) {\\n            if (dp[i] >= target) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452236,
                "title": "c-recursion-memoization-max-heap",
                "content": "```\\n// Recursion - TLE (Time - 2^n, Space - 0(n))\\n    int helper(int target, int fuel, vector<vector<int>>& s, int i, int prev_stop, vector<vector<vector<int>>> &dp){\\n        \\n        if(target <= fuel) return 0;\\n        \\n        if(i == s.size()) return INT_MAX-1;\\n        \\n        int distance = s[i][0] - prev_stop;\\n        \\n        if(fuel < distance )  return INT_MAX-1; \\n        \\n        int take_fuel = 1 + helper(target - distance, fuel + s[i][1] - distance, s, i+1, s[i][0], dp);\\n        int not_take_fuel = helper(target, fuel, s, i+1, prev_stop, dp);\\n        \\n        return  min(take_fuel, not_take_fuel);\\n    }    \\n\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int ans = helper(target, startFuel, stations, 0, 0, dp);\\n        \\n        if(ans == INT_MAX-1) return -1;\\n        \\n        return ans;\\n    }\\n\\t\\n// Memoization - Out of memory  (Time - O(n^2), Space - O( target * target * n)\\n\\t    int helper(int target, int fuel, vector<vector<int>>& s, int i, int prev_stop, vector<vector<vector<int>>> &dp){\\n        \\n        if(target <= fuel) return 0;\\n        \\n        if(i == s.size()) return INT_MAX-1;\\n        \\n        int distance = s[i][0] - prev_stop;\\n        \\n        if(fuel < distance )  return INT_MAX-1;\\n        \\n        if(dp[target][fuel][i] != -1) return dp[target][fuel][i];\\n        \\n        \\n        int take_fuel = 1 + helper(target - distance, fuel + s[i][1] - distance, s, i+1, s[i][0], dp);\\n        int not_take_fuel = helper(target, fuel, s, i+1, prev_stop, dp);\\n        \\n        \\n        return dp[target][fuel][i] = min(take_fuel, not_take_fuel);\\n    }    \\n\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int n = stations.size();\\n        vector<vector<vector<int>>> dp(target+1, vector<vector<int>>(target+1, vector<int>(n+1, -1)));\\n        \\n        int ans = helper(target, startFuel, stations, 0, 0, dp);\\n        \\n        if(ans == INT_MAX-1) return -1;\\n        \\n        return ans;\\n    }\\n\\t\\n//\\tPriority Queue (Time - nlogn, space - O(n)) \\n\\t    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n       int ans = 0;\\n        priority_queue<int> pq;\\n        \\n        for(auto s: stations) {\\n            \\n            while(startFuel < s[0] && pq.size()) {\\n                startFuel += pq.top();\\n                pq.pop();\\n                ans++;\\n            }      \\n            \\n            if(startFuel < s[0]) return -1;\\n            \\n            pq.push(s[1]);\\n        }\\n        \\n        while(startFuel < target && pq.size()) {\\n            startFuel += pq.top();\\n            pq.pop();\\n            ans++;\\n        }\\n        \\n        if(startFuel < target) return -1;\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Recursion",
                    "Memoization",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Recursion - TLE (Time - 2^n, Space - 0(n))\\n    int helper(int target, int fuel, vector<vector<int>>& s, int i, int prev_stop, vector<vector<vector<int>>> &dp){\\n        \\n        if(target <= fuel) return 0;\\n        \\n        if(i == s.size()) return INT_MAX-1;\\n        \\n        int distance = s[i][0] - prev_stop;\\n        \\n        if(fuel < distance )  return INT_MAX-1; \\n        \\n        int take_fuel = 1 + helper(target - distance, fuel + s[i][1] - distance, s, i+1, s[i][0], dp);\\n        int not_take_fuel = helper(target, fuel, s, i+1, prev_stop, dp);\\n        \\n        return  min(take_fuel, not_take_fuel);\\n    }    \\n\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int ans = helper(target, startFuel, stations, 0, 0, dp);\\n        \\n        if(ans == INT_MAX-1) return -1;\\n        \\n        return ans;\\n    }\\n\\t\\n// Memoization - Out of memory  (Time - O(n^2), Space - O( target * target * n)\\n\\t    int helper(int target, int fuel, vector<vector<int>>& s, int i, int prev_stop, vector<vector<vector<int>>> &dp){\\n        \\n        if(target <= fuel) return 0;\\n        \\n        if(i == s.size()) return INT_MAX-1;\\n        \\n        int distance = s[i][0] - prev_stop;\\n        \\n        if(fuel < distance )  return INT_MAX-1;\\n        \\n        if(dp[target][fuel][i] != -1) return dp[target][fuel][i];\\n        \\n        \\n        int take_fuel = 1 + helper(target - distance, fuel + s[i][1] - distance, s, i+1, s[i][0], dp);\\n        int not_take_fuel = helper(target, fuel, s, i+1, prev_stop, dp);\\n        \\n        \\n        return dp[target][fuel][i] = min(take_fuel, not_take_fuel);\\n    }    \\n\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int n = stations.size();\\n        vector<vector<vector<int>>> dp(target+1, vector<vector<int>>(target+1, vector<int>(n+1, -1)));\\n        \\n        int ans = helper(target, startFuel, stations, 0, 0, dp);\\n        \\n        if(ans == INT_MAX-1) return -1;\\n        \\n        return ans;\\n    }\\n\\t\\n//\\tPriority Queue (Time - nlogn, space - O(n)) \\n\\t    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n       int ans = 0;\\n        priority_queue<int> pq;\\n        \\n        for(auto s: stations) {\\n            \\n            while(startFuel < s[0] && pq.size()) {\\n                startFuel += pq.top();\\n                pq.pop();\\n                ans++;\\n            }      \\n            \\n            if(startFuel < s[0]) return -1;\\n            \\n            pq.push(s[1]);\\n        }\\n        \\n        while(startFuel < target && pq.size()) {\\n            startFuel += pq.top();\\n            pq.pop();\\n            ans++;\\n        }\\n        \\n        if(startFuel < target) return -1;\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1268139,
                "title": "js-python-java-c-easy-max-pq-heap-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince this problem is asking for the least amount of refuelings, we should attempt a **greedy** approach to the solution. To accomplish that, we should start with **0** refuelings and keep attempting one additional refueling until we find a working solution.\\n\\nIn a naive approach, we would attempt every single combination of **1** refueling station, then every single combination of **2** refueling stations, etc., but that would take way too long.\\n\\nInstead, let\\'s consider the natural progression of iterating through the list of stations (**S**). At each station (**S[i]**) we should first check to see if we have enough fuel to get there.\\n\\n_(**Note**: Since the station distances are measured in distance from the start, not distance from the last station, it\\'s easier to keep track of the total fuel obtained (**F**), rather than the unspent fuel, because we can directly compare that to the distance traveled (**dist**).)_\\n\\nIf we didn\\'t have enough fuel to get to the current station, then we should have refueled somewhere. Only a station seen before **S[i]** is available for this retroactive refueling, however, so we need to choose a prior station at which to have refueled. Given our choice, we should naturally pick the station with the largest reserve of fuel.\\n\\nRather than attempting to sort a portion of **S** each time, we should instead use a **max priority queue** (or **max heap**) (**pq**/**heap**) to store the previously visited stations\\' fuel reserves so that we can always choose the ideal station at any point along our iteration.\\n\\nWhen we find ourselves unable to reach the next station, we should continue to pull fuel reserves from **pq** until we have enough. If we run out of reserves while **F < dist**, then we can never reach the target (**T**), and should **return -1**.\\n\\nWe should also keep track of the total number of times (**ans**) we\\'ve removed fuel from the reserves in **pq**, and iterate one extra time to reach **T** from the last station. Upon successfully reaching **T**, we can **return ans**.\\n\\n - _**Time Complexity: O(N log N)** where **N** is the length of **S**, for up to **N** insertions and **N** removals from **pq**/**heap**_\\n - _**Space Complexity: O(N)** for **pq**/**heap**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript\\'s **MaxPriorityQueue()** npm is easier to use than, but not as efficient as, a custom **max heap** implementation. Both are included below for comparison.\\n\\nPython defaults to a **min heap**, so we can reverse the signs upon insertion and extraction to achieve an effective **max heap** implementation. \\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n***w/ MaxPriorityQueue():***\\nThe best result for the code below is **104ms / 43.9MB** (beats 68% / 27%).\\n```javascript\\nvar minRefuelStops = function(T, F, S) {\\n    let n = S.length, pq = new MaxPriorityQueue(), ans = 0\\n    for (let i = 0; i <= n; i++) {\\n        let dist = i === n ? T : S[i][0]\\n        while (F < dist) {\\n            if (!pq.size()) return -1\\n            F += pq.dequeue().element, ans++\\n        }\\n        if (i < n) pq.enqueue(S[i][1])\\n    }\\n    return ans\\n};\\n```\\n\\n***w/ custom Max Heap:***\\nThe best result for the code below is **80ms / 41.0MB** (beats 100% / 82%).\\n```javascript\\nvar minRefuelStops = function(T, F, S) {\\n    let n = S.length, ans = 0\\n    \\n    // custom Max Heap implementation\\n    let heap = [,]\\n    const hpush = val => {\\n        let i = heap.length, par = i >> 1, temp\\n        heap.push(val)\\n        while (heap[par] < heap[i]) {\\n            temp = heap[par], heap[par] = heap[i], heap[i] = temp\\n            i = par, par = i >> 1\\n        }\\n    }\\n    const hpop = () => {\\n        if (heap.length === 1) return null\\n        let top = heap[1], left, right, temp,\\n            i = 1, child = heap[3] > heap[2] ? 3 : 2\\n        if (heap.length > 2) heap[1] = heap.pop()\\n        else heap.pop()\\n        while (heap[i] < heap[child]) {\\n            temp = heap[child], heap[child] = heap[i], heap[i] = temp\\n            i = child, left = i << 1, right = left + 1\\n            child = heap[right] > heap[left] ? right : left\\n        }\\n        return top\\n    }\\n    \\n    for (let i = 0; i <= n; i++) {\\n        let dist = i === n ? T : S[i][0]\\n        while (F < dist) {\\n            if (heap.length === 1) return -1\\n            F += hpop(), ans++\\n        }\\n        if (i < n) hpush(S[i][1])\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **104ms / 14.4MB** (beats 100% / 96%).\\n```python\\nclass Solution:\\n    def minRefuelStops(self, T: int, F: int, S: List[List[int]]) -> int:\\n        n, heap, ans = len(S), [], 0\\n        for i in range(n+1):\\n            dist = T if i == n else S[i][0]\\n            while F < dist:\\n                if len(heap) == 0: return -1\\n                F -= heappop(heap)\\n                ans += 1\\n            if i < n: heappush(heap, -S[i][1])\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 38.8MB** (beats 100% / 89%).\\n```java\\nclass Solution {\\n    public int minRefuelStops(int T, int F, int[][] S) {\\n        int n = S.length, ans = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b - a);\\n        for (int i = 0; i <= n; i++) {\\n            int dist = i == n ? T : S[i][0];\\n            while (F < dist) {\\n                if (pq.size() == 0) return -1;\\n                F += pq.poll();\\n                ans++;\\n            }\\n            if (i < n) pq.add(S[i][1]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **20ms / 16.1MB** (beats 96% / 91%).\\n```c++\\nclass Solution {\\npublic:\\n    int minRefuelStops(int T, int F, vector<vector<int>>& S) {\\n        int n = S.size(), ans = 0;\\n        priority_queue<int> pq;\\n        for (int i = 0; i <= n; i++) {\\n            int dist = i == n ? T : S[i][0];\\n            while (F < dist) {\\n                if (!pq.size()) return -1;\\n                F += pq.top(), ans++;\\n                pq.pop();\\n            }\\n            if (i < n) pq.push(S[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minRefuelStops = function(T, F, S) {\\n    let n = S.length, pq = new MaxPriorityQueue(), ans = 0\\n    for (let i = 0; i <= n; i++) {\\n        let dist = i === n ? T : S[i][0]\\n        while (F < dist) {\\n            if (!pq.size()) return -1\\n            F += pq.dequeue().element, ans++\\n        }\\n        if (i < n) pq.enqueue(S[i][1])\\n    }\\n    return ans\\n};\\n```\n```javascript\\nvar minRefuelStops = function(T, F, S) {\\n    let n = S.length, ans = 0\\n    \\n    // custom Max Heap implementation\\n    let heap = [,]\\n    const hpush = val => {\\n        let i = heap.length, par = i >> 1, temp\\n        heap.push(val)\\n        while (heap[par] < heap[i]) {\\n            temp = heap[par], heap[par] = heap[i], heap[i] = temp\\n            i = par, par = i >> 1\\n        }\\n    }\\n    const hpop = () => {\\n        if (heap.length === 1) return null\\n        let top = heap[1], left, right, temp,\\n            i = 1, child = heap[3] > heap[2] ? 3 : 2\\n        if (heap.length > 2) heap[1] = heap.pop()\\n        else heap.pop()\\n        while (heap[i] < heap[child]) {\\n            temp = heap[child], heap[child] = heap[i], heap[i] = temp\\n            i = child, left = i << 1, right = left + 1\\n            child = heap[right] > heap[left] ? right : left\\n        }\\n        return top\\n    }\\n    \\n    for (let i = 0; i <= n; i++) {\\n        let dist = i === n ? T : S[i][0]\\n        while (F < dist) {\\n            if (heap.length === 1) return -1\\n            F += hpop(), ans++\\n        }\\n        if (i < n) hpush(S[i][1])\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def minRefuelStops(self, T: int, F: int, S: List[List[int]]) -> int:\\n        n, heap, ans = len(S), [], 0\\n        for i in range(n+1):\\n            dist = T if i == n else S[i][0]\\n            while F < dist:\\n                if len(heap) == 0: return -1\\n                F -= heappop(heap)\\n                ans += 1\\n            if i < n: heappush(heap, -S[i][1])\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int minRefuelStops(int T, int F, int[][] S) {\\n        int n = S.length, ans = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b - a);\\n        for (int i = 0; i <= n; i++) {\\n            int dist = i == n ? T : S[i][0];\\n            while (F < dist) {\\n                if (pq.size() == 0) return -1;\\n                F += pq.poll();\\n                ans++;\\n            }\\n            if (i < n) pq.add(S[i][1]);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minRefuelStops(int T, int F, vector<vector<int>>& S) {\\n        int n = S.size(), ans = 0;\\n        priority_queue<int> pq;\\n        for (int i = 0; i <= n; i++) {\\n            int dist = i == n ? T : S[i][0];\\n            while (F < dist) {\\n                if (!pq.size()) return -1;\\n                F += pq.top(), ans++;\\n                pq.pop();\\n            }\\n            if (i < n) pq.push(S[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268141,
                "title": "minimum-number-of-refueling-stops-js-python-java-c-easy-max-pq-heap-solution-w-expl",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince this problem is asking for the least amount of refuelings, we should attempt a **greedy** approach to the solution. To accomplish that, we should start with **0** refuelings and keep attempting one additional refueling until we find a working solution.\\n\\nIn a naive approach, we would attempt every single combination of **1** refueling station, then every single combination of **2** refueling stations, etc., but that would take way too long.\\n\\nInstead, let\\'s consider the natural progression of iterating through the list of stations (**S**). At each station (**S[i]**) we should first check to see if we have enough fuel to get there.\\n\\n_(**Note**: Since the station distances are measured in distance from the start, not distance from the last station, it\\'s easier to keep track of the total fuel obtained (**F**), rather than the unspent fuel, because we can directly compare that to the distance traveled (**dist**).)_\\n\\nIf we didn\\'t have enough fuel to get to the current station, then we should have refueled somewhere. Only a station seen before **S[i]** is available for this retroactive refueling, however, so we need to choose a prior station at which to have refueled. Given our choice, we should naturally pick the station with the largest reserve of fuel.\\n\\nRather than attempting to sort a portion of **S** each time, we should instead use a **max priority queue** (or **max heap**) (**pq**/**heap**) to store the previously visited stations\\' fuel reserves so that we can always choose the ideal station at any point along our iteration.\\n\\nWhen we find ourselves unable to reach the next station, we should continue to pull fuel reserves from **pq** until we have enough. If we run out of reserves while **F < dist**, then we can never reach the target (**T**), and should **return -1**.\\n\\nWe should also keep track of the total number of times (**ans**) we\\'ve removed fuel from the reserves in **pq**, and iterate one extra time to reach **T** from the last station. Upon successfully reaching **T**, we can **return ans**.\\n\\n - _**Time Complexity: O(N log N)** where **N** is the length of **S**, for up to **N** insertions and **N** removals from **pq**/**heap**_\\n - _**Space Complexity: O(N)** for **pq**/**heap**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript\\'s **MaxPriorityQueue()** npm is easier to use than, but not as efficient as, a custom **max heap** implementation. Both are included below for comparison.\\n\\nPython defaults to a **min heap**, so we can reverse the signs upon insertion and extraction to achieve an effective **max heap** implementation. \\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n***w/ MaxPriorityQueue():***\\nThe best result for the code below is **104ms / 43.9MB** (beats 68% / 27%).\\n```javascript\\nvar minRefuelStops = function(T, F, S) {\\n    let n = S.length, pq = new MaxPriorityQueue(), ans = 0\\n    for (let i = 0; i <= n; i++) {\\n        let dist = i === n ? T : S[i][0]\\n        while (F < dist) {\\n            if (!pq.size()) return -1\\n            F += pq.dequeue().element, ans++\\n        }\\n        if (i < n) pq.enqueue(S[i][1])\\n    }\\n    return ans\\n};\\n```\\n\\n***w/ custom Max Heap:***\\nThe best result for the code below is **80ms / 41.0MB** (beats 100% / 82%).\\n```javascript\\nvar minRefuelStops = function(T, F, S) {\\n    let n = S.length, ans = 0\\n    \\n    // custom Max Heap implementation\\n    let heap = [,]\\n    const hpush = val => {\\n        let i = heap.length, par = i >> 1, temp\\n        heap.push(val)\\n        while (heap[par] < heap[i]) {\\n            temp = heap[par], heap[par] = heap[i], heap[i] = temp\\n            i = par, par = i >> 1\\n        }\\n    }\\n    const hpop = () => {\\n        if (heap.length === 1) return null\\n        let top = heap[1], left, right, temp,\\n            i = 1, child = heap[3] > heap[2] ? 3 : 2\\n        if (heap.length > 2) heap[1] = heap.pop()\\n        else heap.pop()\\n        while (heap[i] < heap[child]) {\\n            temp = heap[child], heap[child] = heap[i], heap[i] = temp\\n            i = child, left = i << 1, right = left + 1\\n            child = heap[right] > heap[left] ? right : left\\n        }\\n        return top\\n    }\\n    \\n    for (let i = 0; i <= n; i++) {\\n        let dist = i === n ? T : S[i][0]\\n        while (F < dist) {\\n            if (heap.length === 1) return -1\\n            F += hpop(), ans++\\n        }\\n        if (i < n) hpush(S[i][1])\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **104ms / 14.4MB** (beats 100% / 96%).\\n```python\\nclass Solution:\\n    def minRefuelStops(self, T: int, F: int, S: List[List[int]]) -> int:\\n        n, heap, ans = len(S), [], 0\\n        for i in range(n+1):\\n            dist = T if i == n else S[i][0]\\n            while F < dist:\\n                if len(heap) == 0: return -1\\n                F -= heappop(heap)\\n                ans += 1\\n            if i < n: heappush(heap, -S[i][1])\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 38.8MB** (beats 100% / 89%).\\n```java\\nclass Solution {\\n    public int minRefuelStops(int T, int F, int[][] S) {\\n        int n = S.length, ans = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b - a);\\n        for (int i = 0; i <= n; i++) {\\n            int dist = i == n ? T : S[i][0];\\n            while (F < dist) {\\n                if (pq.size() == 0) return -1;\\n                F += pq.poll();\\n                ans++;\\n            }\\n            if (i < n) pq.add(S[i][1]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **20ms / 16.1MB** (beats 96% / 91%).\\n```c++\\nclass Solution {\\npublic:\\n    int minRefuelStops(int T, int F, vector<vector<int>>& S) {\\n        int n = S.size(), ans = 0;\\n        priority_queue<int> pq;\\n        for (int i = 0; i <= n; i++) {\\n            int dist = i == n ? T : S[i][0];\\n            while (F < dist) {\\n                if (!pq.size()) return -1;\\n                F += pq.top(), ans++;\\n                pq.pop();\\n            }\\n            if (i < n) pq.push(S[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar minRefuelStops = function(T, F, S) {\\n    let n = S.length, pq = new MaxPriorityQueue(), ans = 0\\n    for (let i = 0; i <= n; i++) {\\n        let dist = i === n ? T : S[i][0]\\n        while (F < dist) {\\n            if (!pq.size()) return -1\\n            F += pq.dequeue().element, ans++\\n        }\\n        if (i < n) pq.enqueue(S[i][1])\\n    }\\n    return ans\\n};\\n```\n```javascript\\nvar minRefuelStops = function(T, F, S) {\\n    let n = S.length, ans = 0\\n    \\n    // custom Max Heap implementation\\n    let heap = [,]\\n    const hpush = val => {\\n        let i = heap.length, par = i >> 1, temp\\n        heap.push(val)\\n        while (heap[par] < heap[i]) {\\n            temp = heap[par], heap[par] = heap[i], heap[i] = temp\\n            i = par, par = i >> 1\\n        }\\n    }\\n    const hpop = () => {\\n        if (heap.length === 1) return null\\n        let top = heap[1], left, right, temp,\\n            i = 1, child = heap[3] > heap[2] ? 3 : 2\\n        if (heap.length > 2) heap[1] = heap.pop()\\n        else heap.pop()\\n        while (heap[i] < heap[child]) {\\n            temp = heap[child], heap[child] = heap[i], heap[i] = temp\\n            i = child, left = i << 1, right = left + 1\\n            child = heap[right] > heap[left] ? right : left\\n        }\\n        return top\\n    }\\n    \\n    for (let i = 0; i <= n; i++) {\\n        let dist = i === n ? T : S[i][0]\\n        while (F < dist) {\\n            if (heap.length === 1) return -1\\n            F += hpop(), ans++\\n        }\\n        if (i < n) hpush(S[i][1])\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def minRefuelStops(self, T: int, F: int, S: List[List[int]]) -> int:\\n        n, heap, ans = len(S), [], 0\\n        for i in range(n+1):\\n            dist = T if i == n else S[i][0]\\n            while F < dist:\\n                if len(heap) == 0: return -1\\n                F -= heappop(heap)\\n                ans += 1\\n            if i < n: heappush(heap, -S[i][1])\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int minRefuelStops(int T, int F, int[][] S) {\\n        int n = S.length, ans = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b - a);\\n        for (int i = 0; i <= n; i++) {\\n            int dist = i == n ? T : S[i][0];\\n            while (F < dist) {\\n                if (pq.size() == 0) return -1;\\n                F += pq.poll();\\n                ans++;\\n            }\\n            if (i < n) pq.add(S[i][1]);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minRefuelStops(int T, int F, vector<vector<int>>& S) {\\n        int n = S.size(), ans = 0;\\n        priority_queue<int> pq;\\n        for (int i = 0; i <= n; i++) {\\n            int dist = i == n ? T : S[i][0];\\n            while (F < dist) {\\n                if (!pq.size()) return -1;\\n                F += pq.top(), ans++;\\n                pq.pop();\\n            }\\n            if (i < n) pq.push(S[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236562,
                "title": "c-framing-the-problem-in-terms-of-knapsack-problem",
                "content": "Knapsack Problem:\\n```\\n// dp[i][j] = Using first i items and max weight allowed is j, what is the maximum value of the knapsack?\\ndp[i][j] = max (\\n\\t\\t\\tdp[i - 1][j] // Do not use the i\\'th item \\n\\t\\t\\tdp[i - 1][j - weight[i]] + value[i] // Use the i\\'th item (max weight allowed reduces by weight of i\\'th item, and total value increases by value of i\\'th item)\\n\\t\\t)\\n```\\nRefueling Problem:\\n```\\n// dp[i][j] = Using first i stations and max refuels allowed is j, what is the maximum distance you can travel?\\ndp[i][j] = max (\\n\\t\\t\\tdp[i - 1][j] // Do not use the i\\'th station\\n\\t\\t\\tdp[i - 1][j - 1] + station[i][1] // Use th i\\'th station (max refuels allowed reduces by 1, and total distance increases by fuel in the i\\'th station.\\n\\t\\t)\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        vector<long long> dp(505);\\n        int res = INT_MAX;\\n        for (int i = 0; i <= stations.size(); ++i) {\\n            for (int j = i; j >= 0; --j) {\\n                if (i == 0 || j == 0)\\n                    dp[j] = startFuel;\\n                else if (dp[j - 1] >= stations[i - 1][0])\\n                    dp[j] = max(dp[j], dp[j - 1] + stations[i - 1][1]);\\n                if (dp[j] >= target)\\n                    res = min(j, res);\\n            }\\n        }\\n        if (res == INT_MAX)\\n            return -1;\\n        return res;\\n    }\\n};\\n```\\n\\n**Do upvote if this helped you.**",
                "solutionTags": [],
                "code": "```\\n// dp[i][j] = Using first i items and max weight allowed is j, what is the maximum value of the knapsack?\\ndp[i][j] = max (\\n\\t\\t\\tdp[i - 1][j] // Do not use the i\\'th item \\n\\t\\t\\tdp[i - 1][j - weight[i]] + value[i] // Use the i\\'th item (max weight allowed reduces by weight of i\\'th item, and total value increases by value of i\\'th item)\\n\\t\\t)\\n```\n```\\n// dp[i][j] = Using first i stations and max refuels allowed is j, what is the maximum distance you can travel?\\ndp[i][j] = max (\\n\\t\\t\\tdp[i - 1][j] // Do not use the i\\'th station\\n\\t\\t\\tdp[i - 1][j - 1] + station[i][1] // Use th i\\'th station (max refuels allowed reduces by 1, and total distance increases by fuel in the i\\'th station.\\n\\t\\t)\\n```\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        vector<long long> dp(505);\\n        int res = INT_MAX;\\n        for (int i = 0; i <= stations.size(); ++i) {\\n            for (int j = i; j >= 0; --j) {\\n                if (i == 0 || j == 0)\\n                    dp[j] = startFuel;\\n                else if (dp[j - 1] >= stations[i - 1][0])\\n                    dp[j] = max(dp[j], dp[j - 1] + stations[i - 1][1]);\\n                if (dp[j] >= target)\\n                    res = min(j, res);\\n            }\\n        }\\n        if (res == INT_MAX)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451928,
                "title": "c-commented-most-detailed-explanation-90-faster",
                "content": "```\\n\\n\\nint minRefuelStops(int target, int startFuel, vector<vector<int>> &stations){\\n\\n    int max_reach = startFuel;   // max_reach stores the max distance we can reach with the fuel we have with us\\n\\n    priority_queue<int> pq;  // stores the refuling capacity of every station we have encountered so far but have not used\\n\\n    int cnt = 0;   // storres the number of stops we made at fuel stations for refuling\\n \\n    int idx = 0;  // index of next station\\n\\n    while(max_reach < target){\\n        \\n        // since max_reach < target, we need to refuel at some station\\n        // this step will store all the gas stations fuels which are withing range of max_reach\\n        // store all the stations we reached while moving towards destination\\n        while(idx < stations.size() && stations[idx][0] <= max_reach){\\n            pq.push(stations[idx][1]);\\n            idx++;\\n        }\\n\\n        // max_reach < target and there is no station we can refuel at. hence we cannot reach\\n        if(pq.empty()){\\n            return -1;\\n        }\\n\\n        // we can refuel\\n        max_reach += pq.top();\\n        pq.pop();\\n        cnt++;\\n\\n    }\\n\\n    return cnt;\\n    \\n}\\n\\n\\n```\\n\\nUpvote if it helped!",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n\\nint minRefuelStops(int target, int startFuel, vector<vector<int>> &stations){\\n\\n    int max_reach = startFuel;   // max_reach stores the max distance we can reach with the fuel we have with us\\n\\n    priority_queue<int> pq;  // stores the refuling capacity of every station we have encountered so far but have not used\\n\\n    int cnt = 0;   // storres the number of stops we made at fuel stations for refuling\\n \\n    int idx = 0;  // index of next station\\n\\n    while(max_reach < target){\\n        \\n        // since max_reach < target, we need to refuel at some station\\n        // this step will store all the gas stations fuels which are withing range of max_reach\\n        // store all the stations we reached while moving towards destination\\n        while(idx < stations.size() && stations[idx][0] <= max_reach){\\n            pq.push(stations[idx][1]);\\n            idx++;\\n        }\\n\\n        // max_reach < target and there is no station we can refuel at. hence we cannot reach\\n        if(pq.empty()){\\n            return -1;\\n        }\\n\\n        // we can refuel\\n        max_reach += pq.top();\\n        pq.pop();\\n        cnt++;\\n\\n    }\\n\\n    return cnt;\\n    \\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1449400,
                "title": "bfs-solution-c-easy-to-understand",
                "content": "Done using the conventional BFS template\\nTime Complexity - O(NlogN)\\n\\n```\\nint minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int idx=0,stock = 0,ans=0;\\n        priority_queue<int> pq;\\n        pq.push(startFuel);\\n        while(!pq.empty())\\n        {\\n            int currFuel = pq.top();\\n            pq.pop();\\n            stock+=currFuel;\\n            if(stock >= target)\\n                return ans;\\n            while(idx < stations.size() and stock >= stations[idx][0])\\n            {\\n                pq.push(stations[idx][1]);\\n                idx++;\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int idx=0,stock = 0,ans=0;\\n        priority_queue<int> pq;\\n        pq.push(startFuel);\\n        while(!pq.empty())\\n        {\\n            int currFuel = pq.top();\\n            pq.pop();\\n            stock+=currFuel;\\n            if(stock >= target)\\n                return ans;\\n            while(idx < stations.size() and stock >= stations[idx][0])\\n            {\\n                pq.push(stations[idx][1]);\\n                idx++;\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2452429,
                "title": "java-2d-dp-1d-dp-heap-solution-with-pictorial-explanation",
                "content": "## DP\\n\\nLet\\'s define `dp[i][j]` as the maximum distance someone can get by making `j` refueling stops and considering only `i` stations.\\n\\nApproach\\n- Initialize `dp` array of size `(n+1)*(n+1)`.\\n- Base case - We do not use any fuel stop then (zero stops) then max distance will be start fuel.\\n- For each station `i`,\\n  - For each stop `j = 1` to `j = i`\\n    - If we can reach next station (dp[i - 1][j - 1]), then update `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + station i\\'s fuel)`\\n    - Else max distance will be max reachable distance of previous station. `dp[i][j] = dp[i - 1][j]`\\n- After visiting all the stations, find mininum j which has `distance >= target`\\n\\nExample - \\n\\n![image](https://assets.leetcode.com/users/images/7eea625e-8fab-4459-9647-3e29a9f93075_1660982619.33672.png)\\n\\n```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        int[][] dp = new int[n + 1][n + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = startFuel;\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= i; j++) {\\n                if (dp[i - 1][j - 1] >= stations[i - 1][0]) {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + stations[i - 1][1]);\\n                } else {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i <= n; i++) {\\n            if (dp[n][i] >= target) return i;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n**Time Complexity** - O(n^2)\\\\\\n**Space Complexity** - O(n^2)\\n\\n\\n## 1-D DP\\n\\nIn the 2-D dynamic programing apporach we can see that we only need result of previous state so we can optimize space by using only 1D array.\\n\\nWhile looping through `j = 1` to `j = i` we need value of previous state so we cannot directly update value in `dp` array. We need to maintain temp array for every station to update value.\\n\\n```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        int[] dp = new int[n + 1];\\n\\n        dp[0] = startFuel;\\n\\n        for (int i = 0; i < n; i++) {\\n            int[] temp = Arrays.copyOf(dp, dp.length);\\n            for (int j = 1; j <= i + 1; j++) {\\n                if (dp[j - 1] >= stations[i][0]) {\\n                    temp[j] = Math.max(temp[j], dp[j - 1] + stations[i][1]);\\n                }\\n            }\\n            dp = temp;\\n        }\\n\\n        for (int i = 0; i <= n; i++) {\\n            if (dp[i] >= target) return i;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\nTo avoid copying dp array into temp array, we can calculate in in reverse order. By this we can avoid reading wrong value of previous state.\\n\\n```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        int[] dp = new int[n + 1];\\n\\n        dp[0] = startFuel;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j >= 0; j--) {\\n                if (dp[j] >= stations[i][0]) {\\n                    dp[j + 1] = Math.max(dp[j + 1], dp[j] + stations[i][1]);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i <= n; i++) {\\n            if (dp[i] >= target) return i;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n**Time Complexity** - O(n^2)\\\\\\n**Space Complexity** - O(n)\\n\\n\\n## Heap\\n\\n**Intuition**\\nWhile visiting fuel stations remember the amount of fuel it contained. We will not decide yet whether to fuel up here or not. Once we run out of the fuel, i.e, cannot visit next station then we will retrospectively fuel up by greedily choosing station with largest fuel first.\\n\\nAs you noticed we need to store fuel of each station in decreasing order. Heap is best fit for this purpose.\\n\\nExample - \\n\\n![image](https://user-images.githubusercontent.com/46988084/185735360-1bf25268-119a-4c52-9213-fd59a3a2febd.png)\\n\\n```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int prevLocation = 0;\\n        int curFuel = startFuel;\\n        int refuel = 0;\\n\\n        for (int[] station: stations) {\\n            int location = station[0];\\n            int fuel = station[1];\\n\\n            curFuel = curFuel - (location - prevLocation);\\n\\n            // refuel from previously visited station until current fuel level remains below zero\\n            while (curFuel < 0 && !pq.isEmpty()) {\\n                curFuel += pq.poll();\\n                refuel++;\\n            }\\n\\n            // if we cannot get enough fuel then return -1\\n            if (curFuel < 0) return -1;\\n\\n            pq.add(fuel);\\n            prevLocation = location;\\n        }\\n\\n        curFuel = curFuel - (target - prevLocation);\\n\\n        // if there is not enough fuel to reach target location from last visited station then \\n        // take fuel from previously visited stations\\n        while (curFuel < 0 && !pq.isEmpty()) {\\n            curFuel += pq.poll();\\n            refuel++;\\n        }\\n\\n        // if we cannot get enough fuel then return -1\\n        if (curFuel < 0) return -1;\\n        return refuel;\\n    }\\n}\\n```\\n\\n**Time Complexity** - O(n * log(n))\\\\\\n**Space Complexity** - O(n)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        int[][] dp = new int[n + 1][n + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = startFuel;\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= i; j++) {\\n                if (dp[i - 1][j - 1] >= stations[i - 1][0]) {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + stations[i - 1][1]);\\n                } else {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i <= n; i++) {\\n            if (dp[n][i] >= target) return i;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        int[] dp = new int[n + 1];\\n\\n        dp[0] = startFuel;\\n\\n        for (int i = 0; i < n; i++) {\\n            int[] temp = Arrays.copyOf(dp, dp.length);\\n            for (int j = 1; j <= i + 1; j++) {\\n                if (dp[j - 1] >= stations[i][0]) {\\n                    temp[j] = Math.max(temp[j], dp[j - 1] + stations[i][1]);\\n                }\\n            }\\n            dp = temp;\\n        }\\n\\n        for (int i = 0; i <= n; i++) {\\n            if (dp[i] >= target) return i;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        int[] dp = new int[n + 1];\\n\\n        dp[0] = startFuel;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j >= 0; j--) {\\n                if (dp[j] >= stations[i][0]) {\\n                    dp[j + 1] = Math.max(dp[j + 1], dp[j] + stations[i][1]);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i <= n; i++) {\\n            if (dp[i] >= target) return i;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int prevLocation = 0;\\n        int curFuel = startFuel;\\n        int refuel = 0;\\n\\n        for (int[] station: stations) {\\n            int location = station[0];\\n            int fuel = station[1];\\n\\n            curFuel = curFuel - (location - prevLocation);\\n\\n            // refuel from previously visited station until current fuel level remains below zero\\n            while (curFuel < 0 && !pq.isEmpty()) {\\n                curFuel += pq.poll();\\n                refuel++;\\n            }\\n\\n            // if we cannot get enough fuel then return -1\\n            if (curFuel < 0) return -1;\\n\\n            pq.add(fuel);\\n            prevLocation = location;\\n        }\\n\\n        curFuel = curFuel - (target - prevLocation);\\n\\n        // if there is not enough fuel to reach target location from last visited station then \\n        // take fuel from previously visited stations\\n        while (curFuel < 0 && !pq.isEmpty()) {\\n            curFuel += pq.poll();\\n            refuel++;\\n        }\\n\\n        // if we cannot get enough fuel then return -1\\n        if (curFuel < 0) return -1;\\n        return refuel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516910,
                "title": "python-dp-o-n-seeing-the-problem-as-knapsack",
                "content": "We can see this problem as a variation of Knapsack :\\nour bag size = number of refuellings stop\\nour bag value = fuel inside the car (which is what we want to maximize)\\nThe only difference is from where we begin .. In knapsack we can begin from left or from right of the array, it doesn\\'t matter. Here however we need to begin from the right in order to be able to check if we can effectively skip or not the current station (remember Knapsack is binary choice : we take an element or we don\\'t take. Here we take a station, or we don\\'t take it ).\\n\\n```\\nDP[k][i] = max amout of fuels we can get by doing k refueling trips amongst the ith first stations.\\n```\\n\\nHere is my solution\\n```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        self.stations = stations\\n        self.startFuel = startFuel\\n        for k in range(len(stations)+1):\\n            if self.dp(k,len(stations)-1) >= target:\\n                return k\\n        return -1\\n    \\n    import functools\\n    @functools.lru_cache(10**6)\\n    def dp(self,k,i):\\n        if i==-1:\\n            return self.startFuel \\n        if k==0:\\n            return self.startFuel\\n        return max(self.dp(k-1,i-1)+self.stations[i][1] if self.dp(k-1,i-1)>=self.stations[i][0] else 0, self.dp(k,i-1))\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nDP[k][i] = max amout of fuels we can get by doing k refueling trips amongst the ith first stations.\\n```\n```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        self.stations = stations\\n        self.startFuel = startFuel\\n        for k in range(len(stations)+1):\\n            if self.dp(k,len(stations)-1) >= target:\\n                return k\\n        return -1\\n    \\n    import functools\\n    @functools.lru_cache(10**6)\\n    def dp(self,k,i):\\n        if i==-1:\\n            return self.startFuel \\n        if k==0:\\n            return self.startFuel\\n        return max(self.dp(k-1,i-1)+self.stations[i][1] if self.dp(k-1,i-1)>=self.stations[i][0] else 0, self.dp(k,i-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290185,
                "title": "top-down",
                "content": "**Approach:** Let f(index, used) be the farthest point that can be reached by refuelling at exactly *used*  number of refueling stations among first *index* number of refuelling stations. \\n**Then:** f(index, used) = max( f(index-1, used-1)+fuel at station index , f(index-1, used) ). \\n```\\nclass Solution {\\n    \\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        int memo[][] = new int[n+1][n+1];\\n        for(int[] arr:memo) {\\n            Arrays.fill(arr, -1);\\n        }\\n        for(int i=0;i<=n;i++)\\n            f(n, i, startFuel, stations, memo);\\n        int result = -1;\\n        for(int i=0;i<=n;i++) {\\n            if(memo[n][i]>=target){\\n                result = i;\\n                break;\\n            } \\n        }\\n        return result;\\n    }\\n    \\n    int f(int index, int used, int curFuel, int[][] stations, int[][] memo) {\\n        if(used==0) {\\n            memo[index][used] = curFuel;\\n            return memo[index][used];\\n        }\\n        if(used>index) {\\n            memo[index][used] = Integer.MIN_VALUE;\\n            return memo[index][used];\\n        }\\n        if(memo[index][used]!=-1) return memo[index][used];\\n        int result1 = f(index-1, used, curFuel, stations, memo);\\n        int result2 = f(index-1, used-1, curFuel, stations, memo);\\n        memo[index][used] = Math.max(result1, result2<stations[index-1][0]?Integer.MIN_VALUE:result2+stations[index-1][1]);\\n        return memo[index][used];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        int memo[][] = new int[n+1][n+1];\\n        for(int[] arr:memo) {\\n            Arrays.fill(arr, -1);\\n        }\\n        for(int i=0;i<=n;i++)\\n            f(n, i, startFuel, stations, memo);\\n        int result = -1;\\n        for(int i=0;i<=n;i++) {\\n            if(memo[n][i]>=target){\\n                result = i;\\n                break;\\n            } \\n        }\\n        return result;\\n    }\\n    \\n    int f(int index, int used, int curFuel, int[][] stations, int[][] memo) {\\n        if(used==0) {\\n            memo[index][used] = curFuel;\\n            return memo[index][used];\\n        }\\n        if(used>index) {\\n            memo[index][used] = Integer.MIN_VALUE;\\n            return memo[index][used];\\n        }\\n        if(memo[index][used]!=-1) return memo[index][used];\\n        int result1 = f(index-1, used, curFuel, stations, memo);\\n        int result2 = f(index-1, used-1, curFuel, stations, memo);\\n        memo[index][used] = Math.max(result1, result2<stations[index-1][0]?Integer.MIN_VALUE:result2+stations[index-1][1]);\\n        return memo[index][used];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279737,
                "title": "help-with-memoization-solution-what-to-memoize",
                "content": "This is \\u0430 straightforward backtracking solution, which, of course, gets TLE.\\nSo a memoization should kick in, however I\\'m having a hard time figuring out what to memoize.\\nAny ideas? Is there a valid top-down memoization solution?\\n\\n```\\n\\tprivate static int minCount;\\n\\n    public int minRefuelStopsBackTrack(int target, int startFuel, int[][] stations) {\\n        minCount = Integer.MAX_VALUE;\\n        findMinStops(target, startFuel, stations, 0, 0);\\n        return minCount == Integer.MAX_VALUE ? -1 : minCount;\\n    }\\n\\n    public void findMinStops(int target, int curFuel, int[][] stations, int count, int position) {\\n        if (curFuel + position >= target) {\\n            minCount = Math.min(count, minCount);\\n            return;\\n        }\\n\\n        for (int i = 0; i < stations.length; i++) {\\n            if (stations[i][0] <= position) {\\n                continue;\\n            }\\n            if (stations[i][0] > curFuel + position) {\\n                break;\\n            }\\n            curFuel += stations[i][1] - stations[i][0] + position;\\n            count++;\\n            findMinStops(target, curFuel, stations, count, stations[i][0]);\\n            curFuel -= stations[i][1] - stations[i][0] + position;        //backtrack\\n            count--;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tprivate static int minCount;\\n\\n    public int minRefuelStopsBackTrack(int target, int startFuel, int[][] stations) {\\n        minCount = Integer.MAX_VALUE;\\n        findMinStops(target, startFuel, stations, 0, 0);\\n        return minCount == Integer.MAX_VALUE ? -1 : minCount;\\n    }\\n\\n    public void findMinStops(int target, int curFuel, int[][] stations, int count, int position) {\\n        if (curFuel + position >= target) {\\n            minCount = Math.min(count, minCount);\\n            return;\\n        }\\n\\n        for (int i = 0; i < stations.length; i++) {\\n            if (stations[i][0] <= position) {\\n                continue;\\n            }\\n            if (stations[i][0] > curFuel + position) {\\n                break;\\n            }\\n            curFuel += stations[i][1] - stations[i][0] + position;\\n            count++;\\n            findMinStops(target, curFuel, stations, count, stations[i][0]);\\n            curFuel -= stations[i][1] - stations[i][0] + position;        //backtrack\\n            count--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 245652,
                "title": "greedy-logical-thinking",
                "content": "> Given stops to final destination and ask for overall optimal choice, we always think about Greedy algoritm. \\n> Local optimal solution to each stop construct the global optimal solution to `target`.\\n\\n\\n> **When do we refuel to minimize times of refueling?**\\n> \\n>We should have refueled when we can\\'t reach the next gas station / target with current fuel.\\n>So we record `curGas` and `curDist`, we refuel only if `curDist + curGas < stations[i][0] / target`.\\n\\n> **Which gas station do we refuel at to minimize times of refueling?**\\n> \\n>We choose the passed gas station with the most fuel. So we maintain a `maxHeap`  of gas passed stations have.\\n\\n****\\n```\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if (startFuel >= target) return 0;\\n        if (stations.length == 0) return -1;\\n        \\n        // Max heap of gas passed stations have\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        int minRefuel = 0;\\n        int curDist = 0;\\n        int curGas = startFuel;\\n        \\n        int i = 0;\\n        while (i < stations.length) {\\n            while (curDist + curGas < stations[i][0]) {\\n                // Unable to reach stations[i][0]\\n                if (maxHeap.isEmpty()) {\\n                    return -1;\\n                }\\n                // Refuel\\n                int liters = maxHeap.poll(); \\n                curGas += liters;\\n                minRefuel++;\\n            }\\n            \\n            // Reach stations[i][0]\\n            curGas -= stations[i][0] - curDist;\\n            curDist = stations[i][0];\\n            \\n            // Record stations[i][1]\\n            maxHeap.offer(stations[i][1]);\\n            i++;\\n        }\\n        \\n        while (curDist + curGas < target) {\\n            // Unable to reach target\\n            if (maxHeap.isEmpty()) {\\n                return -1;\\n            }\\n            // Refuel\\n            int liters = maxHeap.poll(); \\n            curGas += liters;\\n            minRefuel++;\\n        }\\n        \\n        return minRefuel;\\n    }\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if (startFuel >= target) return 0;\\n        if (stations.length == 0) return -1;\\n        \\n        // Max heap of gas passed stations have\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        int minRefuel = 0;\\n        int curDist = 0;\\n        int curGas = startFuel;\\n        \\n        int i = 0;\\n        while (i < stations.length) {\\n            while (curDist + curGas < stations[i][0]) {\\n                // Unable to reach stations[i][0]\\n                if (maxHeap.isEmpty()) {\\n                    return -1;\\n                }\\n                // Refuel\\n                int liters = maxHeap.poll(); \\n                curGas += liters;\\n                minRefuel++;\\n            }\\n            \\n            // Reach stations[i][0]\\n            curGas -= stations[i][0] - curDist;\\n            curDist = stations[i][0];\\n            \\n            // Record stations[i][1]\\n            maxHeap.offer(stations[i][1]);\\n            i++;\\n        }\\n        \\n        while (curDist + curGas < target) {\\n            // Unable to reach target\\n            if (maxHeap.isEmpty()) {\\n                return -1;\\n            }\\n            // Refuel\\n            int liters = maxHeap.poll(); \\n            curGas += liters;\\n            minRefuel++;\\n        }\\n        \\n        return minRefuel;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453053,
                "title": "python-99-5-greedy-constant-memory",
                "content": "\\n#### Idea\\n\\n1. **We only go to the station with most fuel within our travel range.**\\ne.g. *target = 100, startFuel = 40, stations = [[10,40],[20,60],[40,30],[50,70]]*\\nWith startFuel = 40, we are able to reach stations[0], stations[1] and stations[2].  \\nBecause stations[1] has the most fuel available, we will stop there and get enough fuel to finish the course. \\nHence stopCont = 1 in this case.\\n\\n2. **We are allowed to be regretted AND time travel back to the station with second (or more) most fuel if we had passed by.**\\ne.g. *target = 110, startFuel = 40, stations = [[10,40],[20,60],[40,30]]*\\nThe first stop decision is same as above, i.e. stop at stations[1].\\nBut this time startFuel and the refuel from the first stop are not enough to finish the course, we need addtional stop(s).\\nThe nmber of additional stop is same as the case with *target = 110, startFuel = 40+60 = 100, stations = [[10,40],~~[20,60]~~,[40,30]]*.\\nBecause stations[0] has more fuel available, we stop at stations[0] and regardless of the second stop is physically ahead of the first stop.\\nHence we stop at stations[0] and stations[1] with stopCont = 2 in this case.\\n\\n#### Code\\n\\n```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        stopCount = 0\\n\\t\\t# We sort the `stations` by the amount of fuel descendingly.\\n        stations.sort(key = lambda x : x[1], reverse = True)\\n\\t\\t# To check if our carrying fuel is enough to finish the course\\n        while startFuel < target:\\n            for i in range(len(stations)):\\n\\t\\t\\t\\t# To check if the `stations[i]` is within our range.\\n                if stations[i][0] <= startFuel:\\n                    startFuel += stations[i][1]\\n                    stopCount += 1\\n                    stations.pop(i)\\n                    break\\n\\t\\t\\t# No available stations within our range OR no more stations left.\\n            else:\\n                return -1\\n        return stopCount\\n```\\n\\n#### Performance\\n\\n - Time Complexity : Best Case O(N log(N)); Worst Case O(N^2) with N is the `len(stations)`\\n - Space Complexity : O(1)\\n \\n| Time Submitted | Status | Runtime | Memory | Language |\\n| --- | --- | --- | --- | --- |\\n| 08/20/2022 17:21 | Accepted | 115 ms | 14.2 MB | python3 |\\n\\n#### Performance Analysis\\n\\n - **Time Complexity :**\\n  stations.sort(...) takes at least O(N log(N)) time, with N is the `len(stations)`\\n  **Best case:** We do not need to time travel backward, i.e. the given `stations` is already ordered with the amount of fuel descendingly. \\n  The time complexity for the `while` loop is O(M), with M is the `stopCount` and `M <= N`.\\n  **Worst case:** Opposite to the best case, we always need to  time travel backward to refuel.\\n   The time complexity for the `while` loop is O((2N-M)*M/2) = O(NM - M^2/2) ~ O(N^2), with N is the `len(stations)`, M is the `stopCount` and `M <= N`.\\n \\n -  **Space Complexity:**\\n  We only introduced one new variable `stopCount` for storing integer, so it only takes O(1).",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        stopCount = 0\\n\\t\\t# We sort the `stations` by the amount of fuel descendingly.\\n        stations.sort(key = lambda x : x[1], reverse = True)\\n\\t\\t# To check if our carrying fuel is enough to finish the course\\n        while startFuel < target:\\n            for i in range(len(stations)):\\n\\t\\t\\t\\t# To check if the `stations[i]` is within our range.\\n                if stations[i][0] <= startFuel:\\n                    startFuel += stations[i][1]\\n                    stopCount += 1\\n                    stations.pop(i)\\n                    break\\n\\t\\t\\t# No available stations within our range OR no more stations left.\\n            else:\\n                return -1\\n        return stopCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907698,
                "title": "python-2d-dp-more-easy-to-understand",
                "content": "```\\n\\'\\'\\'\\ndp[i][j] represent the maximum distance the car can drive by refusing i times on first j refusing stops (j >= i)\\n\\nif dp[i-1][j-1] >= stations[j-1][0]: \\n    means by refusing (i-1) times on first (j-1) stops we can reach to the jth station:\\n    so dp[i][j] = max(dp[i][j-1], dp[i-1][j-1] + stations[j-1][1])\\nelse:\\n    means consider the maximum distance by refusing i tims on first (j-1) stops\\n    dp[i][j] = dp[i][j-1]\\n\\nif dp[i][N] >= target: \\n    means by refusing i times, we can reach over target distance\\n    then return i\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(N^2)\\n\\'\\'\\'\\nclass Solution1(object):\\n    def minRefuelStops(self, target, startFuel, stations):\\n        \\n        if startFuel >= target: return 0\\n        \\n        N = len(stations)\\n        dp = [[0] * (N+1) for _ in range(N+1)]\\n        \\n        for j in range(N+1):\\n            dp[0][j] = startFuel\\n        \\n        for i in range(1, N+1):\\n            for j in range(i, N+1):\\n                if dp[i-1][j-1] >= stations[j-1][0]:\\n                    dp[i][j] = max(dp[i][j-1], dp[i-1][j-1] + stations[j-1][1])\\n                else:\\n                    dp[i][j] = dp[i][j-1]\\n                     \\n            if dp[i][N] >= target: return i\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\ndp[i][j] represent the maximum distance the car can drive by refusing i times on first j refusing stops (j >= i)\\n\\nif dp[i-1][j-1] >= stations[j-1][0]: \\n    means by refusing (i-1) times on first (j-1) stops we can reach to the jth station:\\n    so dp[i][j] = max(dp[i][j-1], dp[i-1][j-1] + stations[j-1][1])\\nelse:\\n    means consider the maximum distance by refusing i tims on first (j-1) stops\\n    dp[i][j] = dp[i][j-1]\\n\\nif dp[i][N] >= target: \\n    means by refusing i times, we can reach over target distance\\n    then return i\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(N^2)\\n\\'\\'\\'\\nclass Solution1(object):\\n    def minRefuelStops(self, target, startFuel, stations):\\n        \\n        if startFuel >= target: return 0\\n        \\n        N = len(stations)\\n        dp = [[0] * (N+1) for _ in range(N+1)]\\n        \\n        for j in range(N+1):\\n            dp[0][j] = startFuel\\n        \\n        for i in range(1, N+1):\\n            for j in range(i, N+1):\\n                if dp[i-1][j-1] >= stations[j-1][0]:\\n                    dp[i][j] = max(dp[i][j-1], dp[i-1][j-1] + stations[j-1][1])\\n                else:\\n                    dp[i][j] = dp[i][j-1]\\n                     \\n            if dp[i][N] >= target: return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451800,
                "title": "java-solution-with-comments-priority-queue-5-ms-runtime",
                "content": "PLEASE UPVOTE IF IT\\'S HELPFUL-\\n\\n* Initial distance we can go is startFuel. Assign same to max_reach variable.\\n* After that we will add stations fuel within the range to match target.\\n* Add station in pririty Queue.\\n* While looping add top fuel from priority queue to the max_reach variable. Remove it from pq.\\n* Return count value as soon as target is reached or exceeded.\\n\\n**code-**\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        //initial start fuel\\n        int max_reach=startFuel;\\n        //pq to store max fuel in descending order\\n        PriorityQueue<int[]> pq =new PriorityQueue<>((a,b) -> b[1]-a[1]);\\n        int count=0;\\n        int index=0;\\n        \\n        while(max_reach<target){\\n            //1st condition to avoid index out of bound exception\\n            //stations[index][0] is the location, while location is < max_reach dist\\n            while(index<stations.length && stations[index][0]<=max_reach){\\n                \\n                //store fuel in pq\\n                pq.add(stations[index]);\\n                index++;\\n            }\\n            \\n            if(pq.isEmpty())  \\n                return -1;\\n            \\n            max_reach +=pq.remove()[1];  //add top fuel value & remove if from pq\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```\\n**198 / 198 test cases passed.\\nStatus: Accepted\\nRuntime: 5 ms\\nMemory Usage: 48.6 MB**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        //initial start fuel\\n        int max_reach=startFuel;\\n        //pq to store max fuel in descending order\\n        PriorityQueue<int[]> pq =new PriorityQueue<>((a,b) -> b[1]-a[1]);\\n        int count=0;\\n        int index=0;\\n        \\n        while(max_reach<target){\\n            //1st condition to avoid index out of bound exception\\n            //stations[index][0] is the location, while location is < max_reach dist\\n            while(index<stations.length && stations[index][0]<=max_reach){\\n                \\n                //store fuel in pq\\n                pq.add(stations[index]);\\n                index++;\\n            }\\n            \\n            if(pq.isEmpty())  \\n                return -1;\\n            \\n            max_reach +=pq.remove()[1];  //add top fuel value & remove if from pq\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271523,
                "title": "easy-to-understand-java-solution-explanation-with-comments-with-greedy-approach-o-n",
                "content": "```\\nclass Solution {\\n    \\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n                \\n        /*  Approach:\\n        \\n            We will create a priority queue which will store the the fuels (arr[i][1]) in descending order\\n            The stations with more fuel will be ahead (reverse sorting) so that max fuel can be taken when needed\\n            \\n        */\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        \\n        int countStops = 0;\\n        int currStation = 0;\\n        int currFuel = startFuel;\\n\\n        // Loop till current fuel is less than required fuel. Else return as currFuel is sufficient to reach target.\\n        \\n        while (currFuel < target) {\\n            \\n            // Traverse next station till current station are not completed.\\n            // and current fuel is more than sufficient to reach current station\\n            \\n            while (currStation < stations.length && currFuel >= stations[currStation][0])  {\\n                pq.add(stations[currStation][1]);\\n                currStation++;\\n            }\\n            \\n            // If at any time no element present, means till we reach nearest fuel pump, car already exhausted.\\n            if (pq.size() <= 0) {\\n                return -1;  // not possible.\\n            }\\n            \\n            // When above while loop breaks, then update current fuel to add more Max(fuels seen till now)\\n            currFuel = currFuel + pq.remove();\\n            countStops++;\\n            \\n        }\\n        \\n        return countStops;   \\n        \\n    }\\n}\\n```\\n\\n**Please Upvote if you find it helpful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n                \\n        /*  Approach:\\n        \\n            We will create a priority queue which will store the the fuels (arr[i][1]) in descending order\\n            The stations with more fuel will be ahead (reverse sorting) so that max fuel can be taken when needed\\n            \\n        */\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        \\n        int countStops = 0;\\n        int currStation = 0;\\n        int currFuel = startFuel;\\n\\n        // Loop till current fuel is less than required fuel. Else return as currFuel is sufficient to reach target.\\n        \\n        while (currFuel < target) {\\n            \\n            // Traverse next station till current station are not completed.\\n            // and current fuel is more than sufficient to reach current station\\n            \\n            while (currStation < stations.length && currFuel >= stations[currStation][0])  {\\n                pq.add(stations[currStation][1]);\\n                currStation++;\\n            }\\n            \\n            // If at any time no element present, means till we reach nearest fuel pump, car already exhausted.\\n            if (pq.size() <= 0) {\\n                return -1;  // not possible.\\n            }\\n            \\n            // When above while loop breaks, then update current fuel to add more Max(fuels seen till now)\\n            currFuel = currFuel + pq.remove();\\n            countStops++;\\n            \\n        }\\n        \\n        return countStops;   \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266974,
                "title": "c-heap-based-solution-explained-100-time-50-space",
                "content": "Sometimes one\\'s perception of a problem is biased depending on what you know the most/are more familiar with. But I have to admit this is the very first time I thought that the problem was easy when, in fact, it was ranked as hard - and still not sure why, since it does not require much sophistication and/or non-trivial tweaking of common patterns, unlike most other problems in this range.\\n\\nAnyway, down to business!\\n\\nIn order to have our problem solved as expected, we will first of all add another extra station - one with coordinates `{target, 0}`, to help us avoid a few extra edge cases and otherwise annoying repeated checks - crossing fingers that it won\\'t cause a reallocation.\\n\\nWe will then declare a few support variables:\\n* `res` is our accumulator variable, increased every time we have to use a station and initially set to `0`;\\n* `pos` will track our current position, initially set to be `fuel` (ie: how much we could reach with our first amount of fuel in the tank);\\n* `currStationPos` is a pointer that will keep track of the last station we parsed, initially set to `0`;\\n* `len` will store the amount of available stations;\\n* `nextStation` keeps track of the last unparsed station, initially set to be `station[0]`;\\n* `fuelOptions` is our max heap where we will store all the available refuelling options we encountered moving up to `pos`.\\n\\nWe will then have our main loop work as long as `pos < target` and:\\n* keep track of all the new stations encountered up to `pos` and:\\n\\t* add the fuel in `nextStation` to `fuelOptions`;\\n\\t* update `nextStation` after increasing `currStationPos` and taking the new station it points at;\\n* add fuel as needed so that we can reach the (possibly new) value of `nextStation` in few simple steps:\\n\\t* increase `pos` by the top of `fuelOptions` (ie: the highest available value found so far);\\n\\t* pop said value out of `fuelOptions` (we used it!);\\n\\t* increase `res` by `1` (we used one station, after all);\\n* if by now we are still away from `nextStation`, there is no way we can continue, so we will just `return` `-1`.\\n\\nIf we ever exit the loop, it will mean that `pos. >= target`, so we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int fuel, vector<vector<int>>& stations) {\\n        // adding target station\\n        stations.push_back({target, 0});\\n        // support variables\\n        int res = 0, pos = fuel, currStationPos = 0, len = stations.size();\\n        auto nextStation = stations[0];\\n        priority_queue<int> fuelOptions;\\n        // computing the path to target\\n        while (pos < target) {\\n            // keeping track of the stations encountered\\n            while (nextStation[0] <= pos && currStationPos < len) {\\n                fuelOptions.push(nextStation[1]);\\n                nextStation = stations[++currStationPos];\\n            }\\n            // adding fuel as needed to reach the next station from here\\n            while (nextStation[0] > pos && fuelOptions.size()) {\\n                pos += fuelOptions.top();\\n                fuelOptions.pop();\\n                res++;\\n            }\\n            // checking if we cannot reach the next station from here\\n            if (nextStation[0] > pos) return -1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int fuel, vector<vector<int>>& stations) {\\n        // adding target station\\n        stations.push_back({target, 0});\\n        // support variables\\n        int res = 0, pos = fuel, currStationPos = 0, len = stations.size();\\n        auto nextStation = stations[0];\\n        priority_queue<int> fuelOptions;\\n        // computing the path to target\\n        while (pos < target) {\\n            // keeping track of the stations encountered\\n            while (nextStation[0] <= pos && currStationPos < len) {\\n                fuelOptions.push(nextStation[1]);\\n                nextStation = stations[++currStationPos];\\n            }\\n            // adding fuel as needed to reach the next station from here\\n            while (nextStation[0] > pos && fuelOptions.size()) {\\n                pos += fuelOptions.top();\\n                fuelOptions.pop();\\n                res++;\\n            }\\n            // checking if we cannot reach the next station from here\\n            if (nextStation[0] > pos) return -1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591059,
                "title": "easy-explanation-what-the-for-loop-in-the-dp-solution-is-doing-in-human-lang",
                "content": "The dp array invariant is that after seeing stations[:i] (ith iteration), dp[t] is the furthest distance you can travel when allowed t refuels. So you\\'re travelling with completely zero info available at first. Then with each station you encounter, you question your past decisions.\\n```\\n# Knowing that there is a new station you\\'re allowed to use at location \\'location\\' offering \\'capacity\\'\\nfor i, (location, capacity) in enumerate(stations):\\n            for t in xrange(i, -1, -1):\\n\\t\\t\\t\\t# Would you be able to arrive at that station when allowed t refuels only?\\n                if dp[t] >= location:\\n\\t\\t\\t\\t\\t# Would it make your choice of the t+1th station to refuel any different?\\n\\t\\t\\t\\t\\t# i.e when allowed t+1 refuels, would you refuel here instead of some past station?\\n                    dp[t+1] = max(dp[t+1], dp[t] + capacity)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n# Knowing that there is a new station you\\'re allowed to use at location \\'location\\' offering \\'capacity\\'\\nfor i, (location, capacity) in enumerate(stations):\\n            for t in xrange(i, -1, -1):\\n\\t\\t\\t\\t# Would you be able to arrive at that station when allowed t refuels only?\\n                if dp[t] >= location:\\n\\t\\t\\t\\t\\t# Would it make your choice of the t+1th station to refuel any different?\\n\\t\\t\\t\\t\\t# i.e when allowed t+1 refuels, would you refuel here instead of some past station?\\n                    dp[t+1] = max(dp[t+1], dp[t] + capacity)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455515,
                "title": "plan-your-road-trip-in-advance-clear-explanation-o-nlogn-python-heap",
                "content": "**Intuition**\\nFor some problems involving distance or travelling, it works well to imagine taking the trip and moving from point to point in real time. Not so much for this problem! I\\'m going to show a clear explanation where we intuitively think about **planning our entire road trip in advance**.\\n\\nYou can also think about this like seeing \"miles until empty/km until empty\" on the dashboard of your car. Here\\'s the question we will ask and keep asking: **what is our range?** How far could we travel in total with our current plan for a road trip?\\n\\nWhen we begin planning our trip, the `startFuel` in our tank is our total range for driving. \\n* There might be gas stations we can reach on the way, but we should only use them if we absolutely have to. Once we make a plan that can reach our destination, there is no more need to add refueling stops.\\n* If we really do need to refuel on our trip, we should plan to refuel at the **best** (most fuel) **possible** (reachable in our current range of travel) station that is still available.\\n* We can\\'t refuel twice at the same station, so after planning to stop at a certain station we should remove that station from consideration afterwards. \\n* Whenever we add plans to refuel somewhere, this provides us more fuel to drive with. Each planned refuelling stop will extend our total reach and allow us to reach more locations on our trip. \\n\\n**Example**\\nLet\\'s look at an example of road trip planning using this way of thinking about the problem.\\n```\\n       \\u26FD[5,10]           \\u26FD[15,15]                             \\u26FD[35,6]        \\uD83C\\uDFE842\\n\\uD83D\\uDE97===================================>20\\nstartFuel = 20\\n```\\nHere we have a starting range of 20, which allows us to plan a trip that reaches any/all of the first two gas stations. \\nWe can\\'t make it to our destination yet, so we need to plan a fuel stop.\\nOf the two gas stations we could plan to stop at, the one at position 15 has more fuel.\\n```\\n       \\u26FD[5,10]           \\u26FD[15,\\u2714\\uFE0F]                             \\u26FD[35,6]       \\uD83C\\uDFE842\\n\\uD83D\\uDE97=============================================================>35\\nstartFuel = 20, refuel stop A = 15\\n```\\nGaining an extra 15 fuel for our plans gives us more reach - a total of 35. Now we can reach an new station also.\\nWe still can\\'t reach our destination with this plan, so we need another fuel stop.\\nWe already made plans to visit station [15,15], so we can\\'t use it again. But we also gain a new option at [35,6] that we didn\\'t have before. But of the two gas stations we could plan to use, the earlier one at position 5 has more fuel.\\n```\\n       \\u26FD[5,\\u2714\\uFE0F]           \\u26FD[15,\\u2714\\uFE0F]                             \\u26FD[35,6]       \\uD83C\\uDFE842\\n\\uD83D\\uDE97===================================================================================>45\\nstartFuel = 20, refuel stop A = 15, refuel stop B = 10\\n```\\nWe gained 10 more fuel this way, and our total reach will allow us to arrive as far as the destination. Success!\\nWe have optimally planned our trip for minimum refuelling stops. Return number of stops (`2`). If we actually did take this trip after planning it, we would be able to visit all chosen refuelling stations in the order we reached them, *not* the order we selected them,  This way we can take our trip without making any wrong turns or needing to undo any choices. \\n\\n**Implementation**\\n*Iteration over a list:* The list of gas stations comes pre-sorted by position, which is convenient. We can also add our destination to the end of that list to have all key locations along our route in one place and iterate through them.\\n*Heap/priority queue:* When planning extra stops at reachable gas stations, we always want to choose the one with most fuel available. A max priority queue is ideal for storing our options and using the largest one whenever needed. The heapq module in python provides priority queue methods. One catch: heapq only does min-heap, not max-heap. So we will need to flip (negate) all our heap values before insertion and when removing them.\\n\\n**Time and Space Complexity:**\\nTime: **O(nlogn)** | Our station list comes pre-sorted, but we do still need to do insertions and removals to our heap structure in logarithmic time while we iterate over as many as n stations in our list. \\nSpace: **O(n)** | For certain inputs we might need to stuff almost every gas station into our heap. So in worst case our maximum heap size will scale with size of our input.\\n\\n**Solution with Comments**\\n```\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        \"\"\"\\n        O(nlogn) time solution: we will plan our entire trip before committing to any itinerary.\\n        To do this, we track our range of reachable miles, and if we will run out of fuel somewhere then\\n        we choose the best gas station (most fuel) of any we can reach and plan a refuelling stop along\\n        the way to extend our reach. Note that the stations are already sorted increasing by position.\\n        \"\"\"\\n        reachable_distance = startFuel\\n        if reachable_distance >= target:\\n            return 0\\n        \\n        # include final destination in our location list (putting 0 fuel doesn\\'t matter as it\\'s not a gas station)\\n        stations.append([target, 0])\\n        num_refuelling_stops = 0\\n        gas_station_choices = []  # heap of fuel amounts at available stations: values flipped to use minheap\\n        \\n        for location, fuel in stations:\\n            while reachable_distance < location:  # if our current plan can\\'t reach to this location\\n                if not gas_station_choices:\\n                    return -1  # we used up all reachable stations already\\n                \\n                num_refuelling_stops += 1  # plan a refueling stop at the best station available\\n                reachable_distance += -heappop(gas_station_choices)\\n                \\n                if reachable_distance >= target:  # Are We There Yet?\\n                    return num_refuelling_stops\\n                \\n            heappush(gas_station_choices, -fuel)  # add the new station to our available options\\n            \\n        # don\\'t need a return here; we always succeed or fail in loop to reach final location (target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n       \\u26FD[5,10]           \\u26FD[15,15]                             \\u26FD[35,6]        \\uD83C\\uDFE842\\n\\uD83D\\uDE97===================================>20\\nstartFuel = 20\\n```\n```\\n       \\u26FD[5,10]           \\u26FD[15,\\u2714\\uFE0F]                             \\u26FD[35,6]       \\uD83C\\uDFE842\\n\\uD83D\\uDE97=============================================================>35\\nstartFuel = 20, refuel stop A = 15\\n```\n```\\n       \\u26FD[5,\\u2714\\uFE0F]           \\u26FD[15,\\u2714\\uFE0F]                             \\u26FD[35,6]       \\uD83C\\uDFE842\\n\\uD83D\\uDE97===================================================================================>45\\nstartFuel = 20, refuel stop A = 15, refuel stop B = 10\\n```\n```\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        \"\"\"\\n        O(nlogn) time solution: we will plan our entire trip before committing to any itinerary.\\n        To do this, we track our range of reachable miles, and if we will run out of fuel somewhere then\\n        we choose the best gas station (most fuel) of any we can reach and plan a refuelling stop along\\n        the way to extend our reach. Note that the stations are already sorted increasing by position.\\n        \"\"\"\\n        reachable_distance = startFuel\\n        if reachable_distance >= target:\\n            return 0\\n        \\n        # include final destination in our location list (putting 0 fuel doesn\\'t matter as it\\'s not a gas station)\\n        stations.append([target, 0])\\n        num_refuelling_stops = 0\\n        gas_station_choices = []  # heap of fuel amounts at available stations: values flipped to use minheap\\n        \\n        for location, fuel in stations:\\n            while reachable_distance < location:  # if our current plan can\\'t reach to this location\\n                if not gas_station_choices:\\n                    return -1  # we used up all reachable stations already\\n                \\n                num_refuelling_stops += 1  # plan a refueling stop at the best station available\\n                reachable_distance += -heappop(gas_station_choices)\\n                \\n                if reachable_distance >= target:  # Are We There Yet?\\n                    return num_refuelling_stops\\n                \\n            heappush(gas_station_choices, -fuel)  # add the new station to our available options\\n            \\n        # don\\'t need a return here; we always succeed or fail in loop to reach final location (target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012556,
                "title": "priority-queue-solution-with-clear-explanation-c",
                "content": "The idea is, \\n1 Since we need minimum stop, we only add fuel when we can not reach next station\\n2 If we need to add fuel from one of the station we already travalled, the best policy is to choose the one maximum the fuel we have\\n3 So we can add the unnecessay station fuels to an optional priority queue, and take the maximum one when we need more fuel to reach next station\\n4 For better consistency, I add the target as the final station. If we can not add fuel to reach next station, it means we can not get a solution; otherwise, when we reach the final one, we get the minimum stop we need.\\n\\nThe time complexity is O(NlogN) and space O(N).\\n\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n\\t\\t\\tstations.push_back({target,0});\\n\\t\\t\\tint min_stops = 0;\\n\\t\\t\\tint cur_fuel = startFuel;\\n\\t\\t\\tint cur_pos = 0;\\n\\t\\t\\tpriority_queue<int> optional;\\n\\t\\t\\tfor(int i = 0; i < stations.size();i++){\\n\\t\\t\\t\\tint required_fuel = stations[i][0] - cur_pos;\\n\\t\\t\\t\\t// if we need more fuel, take some from the station we have travelled\\n\\t\\t\\t\\twhile(cur_fuel < required_fuel && !optional.empty()){\\n\\t\\t\\t\\t\\tint top_fuel = optional.top();\\n\\t\\t\\t\\t\\toptional.pop();\\n\\t\\t\\t\\t\\tcur_fuel += top_fuel;\\n\\t\\t\\t\\t\\tmin_stops++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(required_fuel <= cur_fuel){\\n\\t\\t\\t\\t\\tcur_fuel -= required_fuel;\\n\\t\\t\\t\\t\\tcur_pos += required_fuel;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse return -1;\\n\\t\\t\\t\\t// if we can reach the current station, add it to optional\\n\\t\\t\\t\\toptional.push(stations[i][1]);\\n\\t\\t\\t}\\n\\t\\t\\treturn min_stops;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n\\t\\t\\tstations.push_back({target,0}",
                "codeTag": "Java"
            },
            {
                "id": 875953,
                "title": "c-easy-to-understand-dp-solution-with-comments",
                "content": "If facing any problem with below code , please let me know in comments. Thanks a lot in advance.\\n```\\n\\nclass Solution {\\npublic:  \\n    static bool comparator_sort(const vector<int> &x,const vector<int> &y){\\n        return x[0] < y[0];\\n    }\\n    int minRefuelStops(int target, int start_fuel, vector<vector<int>>& stations) {\\n        if(start_fuel > target)\\n            return 0;\\n        int n=stations.size();\\n        int curr_fuel=start_fuel;\\n        vector<long long int> dp(n+1 ,0);\\n\\t\\t\\n        **//dp[i] => Max distance that can be travelled with i stops**\\n        \\n\\t\\tdp[0]=curr_fuel;\\n        sort(stations.begin(),stations.end(),comparator_sort);\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i;j>=0;j--){\\n                if(dp[j]>=stations[i][0]){\\n                    dp[j+1]=max(dp[j+1],dp[j]+stations[i][1]);\\n                }\\n                else \\n                    break;\\n            }    \\n        }\\n        for(int i=0;i<=n;i++){\\n            if(dp[i]>=target)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:  \\n    static bool comparator_sort(const vector<int> &x,const vector<int> &y){\\n        return x[0] < y[0];\\n    }\\n    int minRefuelStops(int target, int start_fuel, vector<vector<int>>& stations) {\\n        if(start_fuel > target)\\n            return 0;\\n        int n=stations.size();\\n        int curr_fuel=start_fuel;\\n        vector<long long int> dp(n+1 ,0);\\n\\t\\t\\n        **//dp[i] => Max distance that can be travelled with i stops**\\n        \\n\\t\\tdp[0]=curr_fuel;\\n        sort(stations.begin(),stations.end(),comparator_sort);\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i;j>=0;j--){\\n                if(dp[j]>=stations[i][0]){\\n                    dp[j+1]=max(dp[j+1],dp[j]+stations[i][1]);\\n                }\\n                else \\n                    break;\\n            }    \\n        }\\n        for(int i=0;i<=n;i++){\\n            if(dp[i]>=target)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603310,
                "title": "c-dp-solution",
                "content": "- DP State: `for reaching ith stop by taking j petrol stops maximum petrol so far` \\n- It is similar to this question: https://codingcompetitions.withgoogle.com/kickstart/round/0000000000201b77/0000000000201bfd\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long int dp[555][555];\\n    \\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        stations.insert(stations.begin(), {0, startFuel});\\n        stations.push_back({target, 0});\\n        int n = stations.size();\\n        memset(dp, -1, sizeof dp);\\n        \\n        dp[0][0] = 0;\\n        \\n        // n-1 since we dont need to refuel on target we just need the answer on it.\\n        for(int i=0;i<n-1;i++)\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(dp[i][j] >= 0)\\n                {\\n                    // without petrol\\n                    if(dp[i][j] >= stations[i+1][0] - stations[i][0])\\n                        dp[i+1][j] = max(dp[i+1][j], dp[i][j] - stations[i+1][0] + stations[i][0]);\\n                    \\n                    // with petrol\\n                    if(dp[i][j] + stations[i][1] >= stations[i+1][0] - stations[i][0])\\n                        dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + stations[i][1]- stations[i+1][0] + stations[i][0]);    \\n                }\\n            }\\n        \\n        int ans = 0;\\n        // n-1th index is the target\\n        for(int j=0;j<n;j++)\\n            if(dp[n-1][j] >= 0)\\n            {\\n                ans = j;\\n                break;\\n            }\\n        // subtratcing -1 since for stating we are adding + 1 for taking starting fuel.\\n        return ans-1;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long int dp[555][555];\\n    \\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        stations.insert(stations.begin(), {0, startFuel});\\n        stations.push_back({target, 0});\\n        int n = stations.size();\\n        memset(dp, -1, sizeof dp);\\n        \\n        dp[0][0] = 0;\\n        \\n        // n-1 since we dont need to refuel on target we just need the answer on it.\\n        for(int i=0;i<n-1;i++)\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(dp[i][j] >= 0)\\n                {\\n                    // without petrol\\n                    if(dp[i][j] >= stations[i+1][0] - stations[i][0])\\n                        dp[i+1][j] = max(dp[i+1][j], dp[i][j] - stations[i+1][0] + stations[i][0]);\\n                    \\n                    // with petrol\\n                    if(dp[i][j] + stations[i][1] >= stations[i+1][0] - stations[i][0])\\n                        dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + stations[i][1]- stations[i+1][0] + stations[i][0]);    \\n                }\\n            }\\n        \\n        int ans = 0;\\n        // n-1th index is the target\\n        for(int j=0;j<n;j++)\\n            if(dp[n-1][j] >= 0)\\n            {\\n                ans = j;\\n                break;\\n            }\\n        // subtratcing -1 since for stating we are adding + 1 for taking starting fuel.\\n        return ans-1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149941,
                "title": "python-o-nlogn",
                "content": "```\\nclass Solution:\\n    def minRefuelStops(self, target, start_fuel, stations):\\n        stations.append([target, 0])\\n        pq_passed_stations = []\\n        tank = start_fuel\\n        ret = 0\\n\\n        for mile, gas in stations:\\n            while pq_passed_stations and tank < mile:\\n                tank += -heapq.heappop(pq_passed_stations)\\n                ret += 1\\n\\n            if tank < mile:\\n                return -1\\n\\n            heapq.heappush(pq_passed_stations, -gas)\\n\\n        return ret\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minRefuelStops(self, target, start_fuel, stations):\\n        stations.append([target, 0])\\n        pq_passed_stations = []\\n        tank = start_fuel\\n        ret = 0\\n\\n        for mile, gas in stations:\\n            while pq_passed_stations and tank < mile:\\n                tank += -heapq.heappop(pq_passed_stations)\\n                ret += 1\\n\\n            if tank < mile:\\n                return -1\\n\\n            heapq.heappush(pq_passed_stations, -gas)\\n\\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451137,
                "title": "daily-leetcoding-challenge-august-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-number-of-refueling-stops/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Heap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-number-of-refueling-stops/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1362077,
                "title": "javascript-dp-maxheap-depth-first-search-tle",
                "content": "(MaxHeap and DP solutions based on solution tab) \\n* **MaxHeap Idea**: The heap will always keep the best option encountered previously. Utilize that as you need, like a greedy approach.\\n* **DP Idea**: Build a DP array based on number of stops to best reach. At each  `dp[t]`, see if you can improve `dp[t+1]`\\'th step by taking the fuel.\\n* **DFS Idea**: something I tried by examining each option (*take* or *not take*) and pruning the search tree when we know that an answer deeper down won\\'t help our best result.\\n```javascript\\n// MaxHeap\\nvar minRefuelStops = function(target, startFuel, stations) {\\n  const pq = new MaxPriorityQueue();\\n  let currentPos = 0;\\n  let currentFuel = startFuel;\\n  let currentStops = 0;\\n\\n  for (let i=0; i<stations.length; i++) {\\n    const [stationPos, stationFuel] = stations[i];\\n    currentFuel -= stationPos - currentPos;\\n    \\n    while (currentFuel < 0) {\\n      if (pq.size() === 0) return -1;\\n      \\n      const fuel = pq.dequeue().priority;\\n      currentFuel += fuel;\\n      currentStops++;\\n    }\\n    \\n    currentPos = stationPos;\\n    pq.enqueue(stationFuel);\\n  }\\n  \\n  // same logic start - as inside the for loop, one more time for end-target\\n  currentFuel -= target - currentPos;\\n  while (currentFuel < 0) {\\n    if (pq.size() === 0) return -1;\\n\\n    const fuel = pq.dequeue().priority;\\n    currentFuel += fuel;\\n    currentStops++;\\n  }\\n  // same logic end\\n  \\n  return currentStops;\\n}\\n```\\n\\n```javascript\\n// N2, DP\\nvar minRefuelStopsDP = function(target, startFuel, stations) {\\n  let N = stations.length;\\n  let dp = new Array(N+1).fill(0); // dp[i] means best reach with i stops, we have at most N stops\\n  dp[0] = startFuel;\\n  \\n  for (let i=0; i< N; i++) { // for all stations\\n    const [stationPos, stationFuel] = stations[i];\\n    for (let t = i; t >= 0; t--) { // for all steps we calculated so far\\n      if (dp[t] >= stationPos) { // if you can reach current station with t steps\\n        dp[t+1] = Math.max(dp[t+1], dp[t] + stationFuel); // see how current station\\'s fuel can help you in t+1 steps \\n      }\\n    }\\n  }\\n  \\n  // Linear search for first available value that meets condition\\n  for (let i = 0; i <= N; i++) {\\n    if (dp[i] >= target) return i;\\n  }\\n  return -1;\\n}\\n```\\n\\n```javascript\\n// TLE, DFS\\nvar minRefuelStopsDFS = function(target, startFuel, stations) {\\n  let bestResult = Number.MAX_SAFE_INTEGER;\\n  \\n  const dfs = (nextStationIndex, stopsSoFar, currentFuel, currentLocation) => {\\n    // end condition \\n    if (currentLocation + currentFuel >= target) {\\n        return bestResult = Math.min(bestResult, stopsSoFar);\\n    } \\n    \\n    // no more stations, exit\\n    if (nextStationIndex >= stations.length) return;\\n    \\n    const [stationLocation, stationFuel] = stations[nextStationIndex];\\n    const distanceToCover = stationLocation - currentLocation;\\n    \\n    // can\\'t make to the next station, exit\\n    if (currentFuel < distanceToCover) return;\\n    \\n    if (stopsSoFar < bestResult) {\\n      dfs (nextStationIndex + 1, stopsSoFar + 1, currentFuel - distanceToCover + stationFuel, stationLocation)  // assume stopping\\n      dfs (nextStationIndex + 1, stopsSoFar, currentFuel - distanceToCover, stationLocation)  // assume not\\n    }\\n  }\\n  \\n  dfs(0, 0, startFuel, 0);\\n  \\n  return bestResult === Number.MAX_SAFE_INTEGER ? -1 : bestResult;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```javascript\\n// MaxHeap\\nvar minRefuelStops = function(target, startFuel, stations) {\\n  const pq = new MaxPriorityQueue();\\n  let currentPos = 0;\\n  let currentFuel = startFuel;\\n  let currentStops = 0;\\n\\n  for (let i=0; i<stations.length; i++) {\\n    const [stationPos, stationFuel] = stations[i];\\n    currentFuel -= stationPos - currentPos;\\n    \\n    while (currentFuel < 0) {\\n      if (pq.size() === 0) return -1;\\n      \\n      const fuel = pq.dequeue().priority;\\n      currentFuel += fuel;\\n      currentStops++;\\n    }\\n    \\n    currentPos = stationPos;\\n    pq.enqueue(stationFuel);\\n  }\\n  \\n  // same logic start - as inside the for loop, one more time for end-target\\n  currentFuel -= target - currentPos;\\n  while (currentFuel < 0) {\\n    if (pq.size() === 0) return -1;\\n\\n    const fuel = pq.dequeue().priority;\\n    currentFuel += fuel;\\n    currentStops++;\\n  }\\n  // same logic end\\n  \\n  return currentStops;\\n}\\n```\n```javascript\\n// N2, DP\\nvar minRefuelStopsDP = function(target, startFuel, stations) {\\n  let N = stations.length;\\n  let dp = new Array(N+1).fill(0); // dp[i] means best reach with i stops, we have at most N stops\\n  dp[0] = startFuel;\\n  \\n  for (let i=0; i< N; i++) { // for all stations\\n    const [stationPos, stationFuel] = stations[i];\\n    for (let t = i; t >= 0; t--) { // for all steps we calculated so far\\n      if (dp[t] >= stationPos) { // if you can reach current station with t steps\\n        dp[t+1] = Math.max(dp[t+1], dp[t] + stationFuel); // see how current station\\'s fuel can help you in t+1 steps \\n      }\\n    }\\n  }\\n  \\n  // Linear search for first available value that meets condition\\n  for (let i = 0; i <= N; i++) {\\n    if (dp[i] >= target) return i;\\n  }\\n  return -1;\\n}\\n```\n```javascript\\n// TLE, DFS\\nvar minRefuelStopsDFS = function(target, startFuel, stations) {\\n  let bestResult = Number.MAX_SAFE_INTEGER;\\n  \\n  const dfs = (nextStationIndex, stopsSoFar, currentFuel, currentLocation) => {\\n    // end condition \\n    if (currentLocation + currentFuel >= target) {\\n        return bestResult = Math.min(bestResult, stopsSoFar);\\n    } \\n    \\n    // no more stations, exit\\n    if (nextStationIndex >= stations.length) return;\\n    \\n    const [stationLocation, stationFuel] = stations[nextStationIndex];\\n    const distanceToCover = stationLocation - currentLocation;\\n    \\n    // can\\'t make to the next station, exit\\n    if (currentFuel < distanceToCover) return;\\n    \\n    if (stopsSoFar < bestResult) {\\n      dfs (nextStationIndex + 1, stopsSoFar + 1, currentFuel - distanceToCover + stationFuel, stationLocation)  // assume stopping\\n      dfs (nextStationIndex + 1, stopsSoFar, currentFuel - distanceToCover, stationLocation)  // assume not\\n    }\\n  }\\n  \\n  dfs(0, 0, startFuel, 0);\\n  \\n  return bestResult === Number.MAX_SAFE_INTEGER ? -1 : bestResult;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 930948,
                "title": "explanation-with-pictures-for-both-dp-greedy-solutions",
                "content": "**Greedy Solution:**\\n\\n**Logic:**\\n\\nCheck the current fuel level\\nif there is enough fuel to reach the next station, skip this station, go to the next station.\\nIf there is not enough fuel to reach the next station, must refuel, options are: \\n1. \\tRefuel from the current station \\n2. \\tOr from one of the previously skipped stations\\n\\nWhich one to choose? Of course the station with the most fuel. (if you choose a station with less fuel, you will have to refuel more often later)\\n\\n![image](https://assets.leetcode.com/users/images/939e4380-f270-4e1e-86a1-ea4a8fd5dc01_1605030396.7368991.png)\\n\\n**Implementation:**\\n\\nAt every station (O(n))\\nIf there is enough fuel to reach here\\n*    put the current station on a standby list (do not refuel)\\n     (we will always pick the \"max\" fuel later, so use a MaxHeap/MaxPriorityQueue as storage (Log N))\\n\\nIf not enough fuel\\n1. \\ttake a \"max\" fuel, add it to the current fuel (Log N)\\n1. \\trefuel count + 1\\n1. \\tIf still not enough fuel, repeat taking \"max\" fuel (return -1 if no more stations from standby list)\\n2. \\tIf received enough fuel from the standby list, put the current station on a standby list, go to next station\\n\\n```python\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        stations.append([target, 0])\\n        fuel = startFuel\\n        fuelTanks = []\\n        count = 0\\n        \\n        for distance, fuelTank in stations:\\n            while distance > fuel:\\n                if fuelTanks:\\n                    fuel -= heapq.heappop(fuelTanks)\\n                    count += 1\\n                else:\\n                    return -1\\n            heapq.heappush(fuelTanks, -fuelTank)\\n        \\n        return count\\n```\\n\\n```javascript\\nfunction greedy (target, startFuel, stations) {\\n    const standByStations = new MaxHeap();\\n    let refuelCount = 0;\\n\\n    let fuelInCar = startFuel;\\n    for (const [distance, fuel] of [...stations, [target, 0]]) {\\n        while (fuelInCar < distance) {\\n            if (standByStations.size() === 0) return -1;\\n            fuelInCar += standByStations.pop();\\n            refuelCount++;\\n        }\\n        standByStations.push(fuel);\\n    }\\n    \\n    return refuelCount;\\n}\\n\\nclass MaxHeap {\\n    constructor () {\\n        this.data = [];\\n    }\\n    \\n    size () {\\n        return this.data.length;\\n    }\\n    \\n    push (value) {\\n        this.data.push(value);\\n        this.heapUp(this.data.length - 1);\\n    }\\n    \\n    pop () {\\n        const max = this.data[0];\\n        this.data[0] = this.data[this.data.length - 1];\\n        this.data.pop();\\n        this.heapDown(0);\\n        return max;\\n    }\\n    \\n    heapUp (index) {\\n        const parentIndex = (index - 1) >> 1;\\n        if (this.data[parentIndex] < this.data[index]) {\\n            [this.data[parentIndex], this.data[index]] = [this.data[index], this.data[parentIndex]];\\n            this.heapUp(parentIndex);\\n        }\\n    }\\n    \\n    heapDown (index) {\\n        let leftChild = index * 2 + 1;\\n        let rightChild = index * 2 + 2;\\n        \\n        if (this.data[leftChild] === undefined) leftChild = index;\\n        if (this.data[rightChild] === undefined) rightChild = leftChild;\\n        \\n        const biggerChild = this.data[leftChild] > this.data[rightChild] ? leftChild : rightChild;\\n        \\n        if (this.data[index] < this.data[biggerChild]) {\\n            [this.data[index], this.data[biggerChild]] = [this.data[biggerChild], this.data[index]];\\n            this.heapDown(biggerChild);\\n        }\\n    }\\n}\\n```\\n\\n**DP Solution**\\n\\nRecord the maximum fuel after refuelling 0, 1, 2, \\u2026 n times at each station.\\n\\nAt each station, read the maximum fuel after refuelling 0, 1, 2, \\u2026 n times from the previous station\\nAfter refuelling x times at the previous station, if there is enough fuel to reach the current station\\n* \\tThe maximum fuel after refuelling x times at the current station is either:\\n\\t1. same as the previous station (since it can reach here) or\\n\\t2. Refuelling x - 1 times at previous station + refuel at the current station\\n* \\tThe maximum fuel after refuelling x + 1 times at the current station is\\n\\t- Refuelling x times at previous station + refuel at the current station\\n\\nAfter the calculation, you have the maximum fuel after refuelling 0 to n times at the last station.\\n\\nCheck from refuelling 0 times to n times at last station, pick the smallest refuelling time which has fuel greater than the target.\\n\\n![image](https://assets.leetcode.com/users/images/10398c87-913a-4cac-ace2-835410c5b820_1605030910.1144764.png)\\n\\n```javascript\\nfunction dp (target, startFuel, stations) {\\n    const dp = Array(stations.length + 1).fill(0).map(() => Array(stations.length + 1).fill(0));\\n    dp[0][0] = startFuel;\\n    \\n    for (let i = 1; i <= stations.length; i++) { // at each station\\n        for (let j = 0; j < dp[i - 1].length; j++) { // check previous station\\n            if (dp[i - 1][j] >= stations[i - 1][0]) { // if at the previous station, after refuel j times, it can reach the current station\\n                dp[i][j] = Math.max(dp[i][j] || 0, dp[i - 1][j]); // the max fuel at the current station, after refuel j times is same as the max fuel at previous station refuel j times\\n                dp[i][j + 1] = dp[i - 1][j] + stations[i - 1][1]; // use the fuel at the current station, refuel times will be j + 1, the maximum fuel after refuel j + 1 times is max fuel from previous station + fuel from current station\\n            }\\n        }\\n    }\\n        \\n    for (let i = 0; i < dp[stations.length].length; i++) {\\n        if (dp[stations.length][i] >= target) return i;\\n    }\\n    \\n    return -1;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        stations.append([target, 0])\\n        fuel = startFuel\\n        fuelTanks = []\\n        count = 0\\n        \\n        for distance, fuelTank in stations:\\n            while distance > fuel:\\n                if fuelTanks:\\n                    fuel -= heapq.heappop(fuelTanks)\\n                    count += 1\\n                else:\\n                    return -1\\n            heapq.heappush(fuelTanks, -fuelTank)\\n        \\n        return count\\n```\n```javascript\\nfunction greedy (target, startFuel, stations) {\\n    const standByStations = new MaxHeap();\\n    let refuelCount = 0;\\n\\n    let fuelInCar = startFuel;\\n    for (const [distance, fuel] of [...stations, [target, 0]]) {\\n        while (fuelInCar < distance) {\\n            if (standByStations.size() === 0) return -1;\\n            fuelInCar += standByStations.pop();\\n            refuelCount++;\\n        }\\n        standByStations.push(fuel);\\n    }\\n    \\n    return refuelCount;\\n}\\n\\nclass MaxHeap {\\n    constructor () {\\n        this.data = [];\\n    }\\n    \\n    size () {\\n        return this.data.length;\\n    }\\n    \\n    push (value) {\\n        this.data.push(value);\\n        this.heapUp(this.data.length - 1);\\n    }\\n    \\n    pop () {\\n        const max = this.data[0];\\n        this.data[0] = this.data[this.data.length - 1];\\n        this.data.pop();\\n        this.heapDown(0);\\n        return max;\\n    }\\n    \\n    heapUp (index) {\\n        const parentIndex = (index - 1) >> 1;\\n        if (this.data[parentIndex] < this.data[index]) {\\n            [this.data[parentIndex], this.data[index]] = [this.data[index], this.data[parentIndex]];\\n            this.heapUp(parentIndex);\\n        }\\n    }\\n    \\n    heapDown (index) {\\n        let leftChild = index * 2 + 1;\\n        let rightChild = index * 2 + 2;\\n        \\n        if (this.data[leftChild] === undefined) leftChild = index;\\n        if (this.data[rightChild] === undefined) rightChild = leftChild;\\n        \\n        const biggerChild = this.data[leftChild] > this.data[rightChild] ? leftChild : rightChild;\\n        \\n        if (this.data[index] < this.data[biggerChild]) {\\n            [this.data[index], this.data[biggerChild]] = [this.data[biggerChild], this.data[index]];\\n            this.heapDown(biggerChild);\\n        }\\n    }\\n}\\n```\n```javascript\\nfunction dp (target, startFuel, stations) {\\n    const dp = Array(stations.length + 1).fill(0).map(() => Array(stations.length + 1).fill(0));\\n    dp[0][0] = startFuel;\\n    \\n    for (let i = 1; i <= stations.length; i++) { // at each station\\n        for (let j = 0; j < dp[i - 1].length; j++) { // check previous station\\n            if (dp[i - 1][j] >= stations[i - 1][0]) { // if at the previous station, after refuel j times, it can reach the current station\\n                dp[i][j] = Math.max(dp[i][j] || 0, dp[i - 1][j]); // the max fuel at the current station, after refuel j times is same as the max fuel at previous station refuel j times\\n                dp[i][j + 1] = dp[i - 1][j] + stations[i - 1][1]; // use the fuel at the current station, refuel times will be j + 1, the maximum fuel after refuel j + 1 times is max fuel from previous station + fuel from current station\\n            }\\n        }\\n    }\\n        \\n    for (let i = 0; i < dp[stations.length].length; i++) {\\n        if (dp[stations.length][i] >= target) return i;\\n    }\\n    \\n    return -1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442422,
                "title": "javascript-easy-to-understand-solution-using-priority-queue",
                "content": "Javascript version of https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/150514/Simple-c%2B%2B-greedy-using-pq-with-explanation\\n\\n```\\nvar minRefuelStops = function(target, startFuel, stations) {\\n    let pq = [];\\n    let ret = 0, stationId = 0, range = startFuel;\\n    while (range < target) {\\n       while (stationId < stations.length && stations[stationId][0] <= range) {\\n            pq.push(stations[stationId++][1]);\\n        }\\n        if (!pq.length) return -1;\\n        let max = Math.max(...pq)\\n        range += max;\\n        pq.splice(pq.indexOf(max),1);\\n        ret++;\\n    }\\n    return ret;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minRefuelStops = function(target, startFuel, stations) {\\n    let pq = [];\\n    let ret = 0, stationId = 0, range = startFuel;\\n    while (range < target) {\\n       while (stationId < stations.length && stations[stationId][0] <= range) {\\n            pq.push(stations[stationId++][1]);\\n        }\\n        if (!pq.length) return -1;\\n        let max = Math.max(...pq)\\n        range += max;\\n        pq.splice(pq.indexOf(max),1);\\n        ret++;\\n    }\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149958,
                "title": "does-anyone-have-a-top-down-dp-version-of-this",
                "content": "I got the recursive solution, but I am getting memory limit exceeded whenever I try to memoize.\\n\\n```\\nclass Solution {\\n    \\n    int N;\\n    int [][] stations;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    int [][] memo;\\n    \\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        this.N = stations.length;\\n        this.stations = stations;\\n        for(int i = 0; i < stations.length; ++i){\\n            int [] s = stations[i];\\n            map.put(s[0], i);\\n        }\\n        map.put(0, -1);\\n        memo = new int[stations.length + 1][10000000 + 1];\\n        for(int [] arr : memo) Arrays.fill(arr, -1);\\n        \\n        int sol = helper(0, startFuel, target);\\n        return (sol >= N + 1) ? -1 : sol;\\n    }\\n    \\n    public int helper(int station, int fuel, int target){\\n        if(memo[station][fuel] != -1) return memo[station][fuel];\\n        if(station + fuel >= target) return 0;\\n        if(fuel <= 0) return N + 1;\\n        int cur = N + 1;\\n        for(int i = map.get(station) + 1; i < stations.length; ++i){\\n            int [] current = stations[i];\\n            if(fuel - (current[0] - station) < 0) continue;\\n            cur = Math.min(cur, 1 + helper(current[0], fuel - (current[0] - station) + current[1], target));\\n        }\\n        memo[station][fuel] = cur;\\n        return cur;\\n    }\\n}\\n```\\n\\nThis does **not work** I am getting memory and time limit exceeded. Does anyone have an idea how to fix this?\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int N;\\n    int [][] stations;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    int [][] memo;\\n    \\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        this.N = stations.length;\\n        this.stations = stations;\\n        for(int i = 0; i < stations.length; ++i){\\n            int [] s = stations[i];\\n            map.put(s[0], i);\\n        }\\n        map.put(0, -1);\\n        memo = new int[stations.length + 1][10000000 + 1];\\n        for(int [] arr : memo) Arrays.fill(arr, -1);\\n        \\n        int sol = helper(0, startFuel, target);\\n        return (sol >= N + 1) ? -1 : sol;\\n    }\\n    \\n    public int helper(int station, int fuel, int target){\\n        if(memo[station][fuel] != -1) return memo[station][fuel];\\n        if(station + fuel >= target) return 0;\\n        if(fuel <= 0) return N + 1;\\n        int cur = N + 1;\\n        for(int i = map.get(station) + 1; i < stations.length; ++i){\\n            int [] current = stations[i];\\n            if(fuel - (current[0] - station) < 0) continue;\\n            cur = Math.min(cur, 1 + helper(current[0], fuel - (current[0] - station) + current[1], target));\\n        }\\n        memo[station][fuel] = cur;\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458788,
                "title": "intuition-explained-greedy-approach-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is to start using initial fuel, and keep updating/increasing max range till we reach target.\\n\\t* And try to collect/refill maximum amount of fuel, with least amount of stops.\\n* At the same time keep track of all fuel stations that were crossed, uptil current **`range`**.\\n* When we can no longer move futher i.e range is over. WE need to refuel.\\n* Thus to refuel, pick the station where we can get max fuel, and that is situated within range. \\n* Why this, because with current remaining fuel, we can atleast cover distance without refueling.\\n* But in order to continue further, we need to refuel so that we can go beyond current range.\\n* Also when we refuel, update range as well as stops. \\n* And continue to keep track of stations with fuels, that can give us most amount of fuel.\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t|<--------  range   --------->|\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t<- - -S0 - - -S1 - - - -S2 - -> \\n\\t\\t\\t\\t\\t (F0)    (F1)      (F2)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t-> Here range is the distance we can move with current amount of fuel in tank.\\n\\t\\t\\t\\t-> Lets say S1 has max fuel F1, as compared to S0, S3.\\n\\t\\t\\t\\t-> So, if we do not refill, we can move till range.\\n\\t\\t\\t\\t-> But, if we refuel, we can move till (range + F0) distance.\\n\\t\\t\\t\\t-> So, next we can update the range, and get new stops.\\n\\t\\t\\t\\t\\t\\n# Code : \\n\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int n = stations.size();\\n\\t\\t// Initial range will be the amount of fuel present in tank at start of our journey\\n        int range = startFuel, i = 0, stops = 0;  \\n        \\n        priority_queue<int> pq; // max heap\\n        \\n        while(range < target) {\\n\\t\\t\\t// Keep addding stations that are within range\\n\\t\\t\\t// Out of these, station with max fuel will be used to refill\\n            while(i < n && stations[i][0] <= range) {\\n                pq.push(stations[i][1]);\\n                i++;\\n            }\\n            \\n\\t\\t\\t// If no station is present within range, return -1\\n            if(!pq.size()) return -1;\\n            \\n\\t\\t\\t// Update range by refuelling tank from station with max fuel available\\n            range += pq.top(); \\n            pq.pop();\\n            \\n\\t\\t\\t// Increment count of stops used for refuelling\\n            stops++;\\n        }\\n        \\n        return stops;\\n    }\\n};\\n```\\n\\n**Complexity ;**\\n\\n* **Time** : `O(N logN)`\\n* **Space** : `O(N)`\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int n = stations.size();\\n\\t\\t// Initial range will be the amount of fuel present in tank at start of our journey\\n        int range = startFuel, i = 0, stops = 0;  \\n        \\n        priority_queue<int> pq; // max heap\\n        \\n        while(range < target) {\\n\\t\\t\\t// Keep addding stations that are within range\\n\\t\\t\\t// Out of these, station with max fuel will be used to refill\\n            while(i < n && stations[i][0] <= range) {\\n                pq.push(stations[i][1]);\\n                i++;\\n            }\\n            \\n\\t\\t\\t// If no station is present within range, return -1\\n            if(!pq.size()) return -1;\\n            \\n\\t\\t\\t// Update range by refuelling tank from station with max fuel available\\n            range += pq.top(); \\n            pq.pop();\\n            \\n\\t\\t\\t// Increment count of stops used for refuelling\\n            stops++;\\n        }\\n        \\n        return stops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451744,
                "title": "java-priority-queue-explained",
                "content": "From a starting point we can drive startFuel distance and while doing this we can refuel at some amount of stations. The most reanoble for us it to pick the station that gives us the longest distance at the end. This depends on 2 things - when we reach that station, how much fule we had, and how much fule we can take from there.\\nFor example, we start with 20 fuel and stations are [5, 10], [10, 40], [20, 10]. Distances we can have from each station area: 20 - 5 + 10 = 25, 20 - 10 + 40 = 50, 20 - 20 + 10 = 10, so best choice is 2nd station with distance 50.\\nWe can do same operation for each next station. Stations can be saved in priority queue ordered by station location, on each step we fill up the queue with all stations reachable from out current point. \\nWe continue to repeat steps until we reach the destination. \\nIf at some point our queue gor exhausted that means we cannot reach target and we can exit with -1.\\n\\ntime O(nlgn) - we iteration over each station, using priority queue at each step is O(lgn).\\nspace O(n) - all stations may end up in the queue.\\n\\n```\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int res = 0, curDist = startFuel;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> stations[b][1] - stations[a][1]);\\n        int i = 0; \\n        while (curDist < target) {\\n            while (i < stations.length && stations[i][0] <= curDist) {\\n                pq.add(i++);\\n            }\\n            if (pq.isEmpty()) {\\n                return -1;\\n            }\\n            curDist+= stations[pq.poll()][1];\\n            ++res;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int res = 0, curDist = startFuel;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> stations[b][1] - stations[a][1]);\\n        int i = 0; \\n        while (curDist < target) {\\n            while (i < stations.length && stations[i][0] <= curDist) {\\n                pq.add(i++);\\n            }\\n            if (pq.isEmpty()) {\\n                return -1;\\n            }\\n            curDist+= stations[pq.poll()][1];\\n            ++res;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451408,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Max. Heap***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int start_fuel, vector<vector<int>>& stations) {\\n        \\n        int n = stations.size();\\n        \\n        // declare a max. heap\\n        \\n        priority_queue<int> pq;\\n        \\n        int curr_dist = start_fuel;\\n        \\n        // count will store the no. of stops required\\n        \\n        int count = 0;\\n        \\n        int i = 0;\\n        \\n        // run the loop until curr_dist < target\\n        \\n        while(curr_dist < target)\\n        {\\n            // push the fuel into pq. until farthest position we can reach\\n            \\n            while(i < n && stations[i][0] <= curr_dist)\\n            {\\n                pq.push(stations[i][1]);\\n                \\n                i++;\\n            }\\n            \\n            // if pq is empty, then it is not possible to reach the target, return -1\\n            \\n            if(pq.empty())\\n                return -1;\\n            \\n            // add the max. fuel from pq\\n            \\n            curr_dist += pq.top();\\n            \\n            pq.pop();\\n            \\n            // increment the no. of stops\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int start_fuel, vector<vector<int>>& stations) {\\n        \\n        int n = stations.size();\\n        \\n        // declare a max. heap\\n        \\n        priority_queue<int> pq;\\n        \\n        int curr_dist = start_fuel;\\n        \\n        // count will store the no. of stops required\\n        \\n        int count = 0;\\n        \\n        int i = 0;\\n        \\n        // run the loop until curr_dist < target\\n        \\n        while(curr_dist < target)\\n        {\\n            // push the fuel into pq. until farthest position we can reach\\n            \\n            while(i < n && stations[i][0] <= curr_dist)\\n            {\\n                pq.push(stations[i][1]);\\n                \\n                i++;\\n            }\\n            \\n            // if pq is empty, then it is not possible to reach the target, return -1\\n            \\n            if(pq.empty())\\n                return -1;\\n            \\n            // add the max. fuel from pq\\n            \\n            curr_dist += pq.top();\\n            \\n            pq.pop();\\n            \\n            // increment the no. of stops\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048003,
                "title": "great-heap-solution-in-python-time-o-nlgn-very-easy-to-understand",
                "content": "Hard but **great** question!\\n\\nUse **Heap**!\\n\\nInitiate a **heap**, go through the station list, storing all the fuel capacity on the path already reached.\\n**Once** we reach a location **beyond** current total fuel, we will **pop the max** fuel capacity currently in the heap.\\n\\n**Note:**\\nThis question is similar to **\"Q45: Jump Game II\"**, however, there is big difference!\\nIn this question, we **can store a fuel**.\\nIn Q45, we **can not store a jump**!\\n\\n**Reference:**\\nhttps://leetcode.com/problems/jump-game-ii/\\nhttps://leetcode.com/problems/jump-game-ii/discuss/2055683/Greatly-Explained-Two-Greedy-Solutions-in-Python-Time-O(n)-Easy-to-Understand!!!\\n\\n**Time:** O(nlgn)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        \\n        stations.append((target, 0))       \\n        heap = []\\n        totalFuel = startFuel\\n        res = 0\\n        \\n        for location, fuel in stations:\\n            \\n            while heap and totalFuel < location:\\n                totalFuel += -heapq.heappop(heap)\\n                res += 1\\n            if totalFuel < location:\\n                return -1\\n            heapq.heappush(heap, -fuel)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        \\n        stations.append((target, 0))       \\n        heap = []\\n        totalFuel = startFuel\\n        res = 0\\n        \\n        for location, fuel in stations:\\n            \\n            while heap and totalFuel < location:\\n                totalFuel += -heapq.heappop(heap)\\n                res += 1\\n            if totalFuel < location:\\n                return -1\\n            heapq.heappush(heap, -fuel)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674862,
                "title": "java-complete-observation-detailed-solution",
                "content": "Explanation Flow : \\n* Observations.\\n* Terminology in code\\n* Example and Logic\\n* Complete Approach\\n* Code w/ and w/o comment\\n* **Refactored Code** [ *Simpler Implementation* ]\\n* Analysis\\n\\n*****\\n\\nLet\\'s take a sample input : ( I feel it intuitive to add units as well )\\n* Stations = `[[10, 25], [20, 12], [30,21], [40, 5], [50,3]]`\\n* target = `80 km`\\n* startFuel = `35 L`\\n\\n\\u2714\\uFE0F **Observations:**\\nIf we do not stop at any station, what is the maximum distance we could travel to ?\\nAs we started of having an initial fuel capacity of `35L` and ( `It uses one liter of gas per one km that it drives` ) thus, we could at max reach `35km` and then we are out of fuel. So, we should have stopped at `a/some` station(/s) to get a refuel such that we are able to reach the target location. ( which is still `80-35=45 km ahead`).\\n\\nThinking practically, as we need to minimize the number of stoppage for refuel so, we need to have a refill at that station which could help us go maximum distance ahead. ( `GREEDY APPROACH` )\\n****\\n\\u2714\\uFE0F **Terminology in Code:**\\n* `dis` : The distance I can travel ahead (i.e. the amount of fuel I currently have) \\n* `pS` : previous stoppage/station I had a refill\\n* `stops` : # of stops made\\n*  `target` : dis I need to travel more\\n\\n****\\n\\u2714\\uFE0F **Observations:**\\n1. If I exhaust my initial fuel then, I would pass by 3 stations at which I could have refilled my tank.\\nFrom the stations that I have passed through, I need to choose that station which will help me go to a maximum distance ahead.\\n\\t* For eg : \\n\\t\\t`35.......25.......12.....21` `fuel`\\n\\t\\t`|--------|--------|-------|` `station`\\n\\t\\t`0.......10.......20.......30`  `distance`\\n\\t\\t`^`\\n\\t `(initial)`\\n\\t When we reach 35, we pass by 3 stations `[10, 20, 30]`. It means we can possibly refuel at these stations. \\n\\t\\t * `dis` ( dis I can travel ahead ) = `(remaining fuel)` + `( the amount of fuel added at the stoppage )`\\n\\t\\t * If we refill at `10` : \\n\\t\\t\\t *  `dis` : `(35-10)` + `25` = `50`. ( `I can travel 50 km more if I had a refill at 10`)\\n\\t\\t*  If we refill at `20` : \\n\\t\\t\\t*  `dis` : `(35-20)` + `12` = `27`. ( `I can travel 27 km more if I had a refill at 20`)\\n\\t\\t*  If we refill at `30` : \\n\\t\\t\\t*  `dis` : `(35-30)` + `21` = `26`. ( `I can travel 26 km more if I had a refill at 30`)\\n\\t\\t\\t\\n      So, we choose to have a refill at `station positioned at 10`.\\n2. In order to pick the station that could help us reach to a maximum distance ahead ( and close the gap with the destination ) we need to have a `data structrue` that helps us pick the maximum amount (`fuel offered`) from a given set and rearranges itself everytime we add a new station. Rings a bell ? yes, `Max-Heap PriorityQueue`!\\n\\n3. Current state of variables : \\n\\t* `pS` : `10`\\n\\t* `dis`:  `50`\\n\\t* `stops`: `1`\\n\\t* `pq` : `[30, 21], [20,12]`\\n\\t* `target` : `70`\\n\\n4. Complete Approach : \\n\\t* Start journey\\n\\t* Keep account of all the stations we can cross w/o a refill.\\n\\t* Find station which offers max fuel and mark it as `pS` ( previous stoppage )\\n\\t* Update the `currFuel`or `dis` we have and the `target` we need to cover ahead.\\n\\t* Now, treat `pS` as the new starting position and repeat the process.\\n\\n\\n****\\n# \\u2714\\uFE0F Code w/ comments : \\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int currFuel, int[][] stations) {\\n\\t\\n        if(currFuel >= target) return 0;\\n        \\n        int stops = 0, dis = currFuel; // dis I can travel ahead\\n\\t\\t\\n\\t\\t// maxheap -> max fuel station at the top\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((s1, s2)->{\\n            return Integer.compare(s2[1], s1[1]);\\n        });\\n        \\n        int i=0, n = stations.length, pS = 0;\\n\\t\\t\\n        while(dis < target) {\\n\\t\\t\\t// if I have enough fuel to reach to the next station from the stoppage point\\n            while(i<n && dis >= (stations[i][0]-pS)) {\\n                pq.add(stations[i]);\\n                i++;\\n            }\\n            if(pq.isEmpty()) return -1;\\n\\t\\t\\t\\n            int[] refillAt = pq.poll();\\n\\t\\t\\t\\n            // dis I can travel ahead = remaining fuel + amount refilled\\n\\t\\t\\t// remaining fuel = fuel i started with - distance I travelled ahead from previous stoppage\\n            dis = dis-(refillAt[0]-pS) + refillAt[1];\\n\\t\\t\\t\\n            // dis I need to travel more\\n            target = target-(refillAt[0]-pS);\\n            pS = refillAt[0];\\n            stops++;\\n        }\\n        return stops;\\n    }\\n}\\n```\\n****\\n# \\u2714\\uFE0F Code w/o comments : \\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int currFuel, int[][] stations) {\\n\\t\\n        if(currFuel >= target) return 0;\\n        \\n        int stops = 0, dis = currFuel;\\n\\t\\t\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((s1, s2)->{\\n            return Integer.compare(s2[1], s1[1]);\\n        });\\n        \\n        int i=0, n = stations.length, pS = 0;\\n\\t\\t\\n        while(dis < target) {\\n\\t\\t\\n            while(i<n && dis >= (stations[i][0]-pS)) {\\n                pq.add(stations[i]);\\n                i++;\\n            }\\n            if(pq.isEmpty()) return -1;\\n\\t\\t\\t\\n            int[] refillAt = pq.poll();\\n\\t\\t\\t\\n            dis = dis-(refillAt[0]-pS) + refillAt[1];\\n\\t\\t\\t\\n            target = target-(refillAt[0]-pS);\\n            pS = refillAt[0];\\n            stops++;\\n        }\\n        return stops;\\n    }\\n}\\n```\\n\\n****\\n# \\u2714\\uFE0F Refactored Code : \\nThe above code can be refactored easily to remove the `pS` parameter. Above approach was my initial thought process, this one, is a bit more simpler in implementation .\\n\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int currFuel, int[][] stations) {\\n        if(currFuel >= target)\\n            return 0;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((s1, s2) -> {\\n            return s2[1] - s1[1];\\n        });\\n        \\n        int stops = 0;\\n        int i=0, n = stations.length;\\n        while(currFuel < target) {\\n            // keep in check those stations which we can pass wothout stopping\\n            while(i<n && currFuel-stations[i][0] >= 0) {\\n                pq.add(stations[i]);\\n                i++;\\n            }\\n            \\n            if(pq.size() == 0)\\n                return -1;\\n            \\n            int[] refillAt = pq.poll();\\n            currFuel = currFuel + refillAt[1];\\n            stops++;\\n        }\\n        \\n        return stops;\\n    }\\n}\\n```\\n\\n****\\n\\u2714\\uFE0F **Complexity Analysis**:\\nThe maximum number of stops we can make is equal to the total number of stations we have. Thus,\\n* TC : `O(nlogn)`, `n = # of stations`\\n* SC : `O(n)`, `space used by the pq to store n stations`\\n\\n****\\n\\u2714\\uFE0F **Results**:\\n![image](https://assets.leetcode.com/users/images/ee60af4d-6230-48fc-8e8b-e3ef8b252903_1641642506.9199684.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int currFuel, int[][] stations) {\\n\\t\\n        if(currFuel >= target) return 0;\\n        \\n        int stops = 0, dis = currFuel; // dis I can travel ahead\\n\\t\\t\\n\\t\\t// maxheap -> max fuel station at the top\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((s1, s2)->{\\n            return Integer.compare(s2[1], s1[1]);\\n        });\\n        \\n        int i=0, n = stations.length, pS = 0;\\n\\t\\t\\n        while(dis < target) {\\n\\t\\t\\t// if I have enough fuel to reach to the next station from the stoppage point\\n            while(i<n && dis >= (stations[i][0]-pS)) {\\n                pq.add(stations[i]);\\n                i++;\\n            }\\n            if(pq.isEmpty()) return -1;\\n\\t\\t\\t\\n            int[] refillAt = pq.poll();\\n\\t\\t\\t\\n            // dis I can travel ahead = remaining fuel + amount refilled\\n\\t\\t\\t// remaining fuel = fuel i started with - distance I travelled ahead from previous stoppage\\n            dis = dis-(refillAt[0]-pS) + refillAt[1];\\n\\t\\t\\t\\n            // dis I need to travel more\\n            target = target-(refillAt[0]-pS);\\n            pS = refillAt[0];\\n            stops++;\\n        }\\n        return stops;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int currFuel, int[][] stations) {\\n\\t\\n        if(currFuel >= target) return 0;\\n        \\n        int stops = 0, dis = currFuel;\\n\\t\\t\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((s1, s2)->{\\n            return Integer.compare(s2[1], s1[1]);\\n        });\\n        \\n        int i=0, n = stations.length, pS = 0;\\n\\t\\t\\n        while(dis < target) {\\n\\t\\t\\n            while(i<n && dis >= (stations[i][0]-pS)) {\\n                pq.add(stations[i]);\\n                i++;\\n            }\\n            if(pq.isEmpty()) return -1;\\n\\t\\t\\t\\n            int[] refillAt = pq.poll();\\n\\t\\t\\t\\n            dis = dis-(refillAt[0]-pS) + refillAt[1];\\n\\t\\t\\t\\n            target = target-(refillAt[0]-pS);\\n            pS = refillAt[0];\\n            stops++;\\n        }\\n        return stops;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int currFuel, int[][] stations) {\\n        if(currFuel >= target)\\n            return 0;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((s1, s2) -> {\\n            return s2[1] - s1[1];\\n        });\\n        \\n        int stops = 0;\\n        int i=0, n = stations.length;\\n        while(currFuel < target) {\\n            // keep in check those stations which we can pass wothout stopping\\n            while(i<n && currFuel-stations[i][0] >= 0) {\\n                pq.add(stations[i]);\\n                i++;\\n            }\\n            \\n            if(pq.size() == 0)\\n                return -1;\\n            \\n            int[] refillAt = pq.poll();\\n            currFuel = currFuel + refillAt[1];\\n            stops++;\\n        }\\n        \\n        return stops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266797,
                "title": "rust-4ms-iterative-memoization",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_refuel_stops(target: i32, start_fuel: i32, stations: Vec<Vec<i32>>) -> i32 {\\n        let mut mem = vec![start_fuel; stations.len() + 1];\\n        for (i, s) in stations.iter().enumerate() {\\n            for j in (0..=i).rev() {\\n                if s[0] <= mem[j] {\\n                    mem[j + 1] = mem[j + 1].max(s[1] + mem[j]);\\n                }\\n            }\\n        }\\n        mem.iter().position(|&d| d >= target).map_or(-1, |i| i as _)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_refuel_stops(target: i32, start_fuel: i32, stations: Vec<Vec<i32>>) -> i32 {\\n        let mut mem = vec![start_fuel; stations.len() + 1];\\n        for (i, s) in stations.iter().enumerate() {\\n            for j in (0..=i).rev() {\\n                if s[0] <= mem[j] {\\n                    mem[j + 1] = mem[j + 1].max(s[1] + mem[j]);\\n                }\\n            }\\n        }\\n        mem.iter().position(|&d| d >= target).map_or(-1, |i| i as _)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1266663,
                "title": "minimum-number-of-refueling-stops-line-by-line-explanation-of-code-c-greedy",
                "content": "**INTUITION:**\\nThis is the simple implementation(**greedy**) problem.\\n* So, here we only care about the **checkpoints** where we ran out of fuel and at the checkpoint choose the station with maximum gas which lie in between our path from previous checkpoint.\\n* In order to get the station with maximum gas,we maintain a **max pq** for it.\\n* So wherever we ran out of fuel we use the max gas station from the pq by accessing its top element and remove it from pq and if the pq is empty means there is no unused station left till here so we cant go ahead.\\n\\n*FOR LINE BY LINE EXPLANATION PLEASE REFER CODE..........*\\n**TIME COMPLEXITY:** `O(NLOGN)`\\n**SPACE COMPLEXITY:** `O(N)`   (N is number of stations)\\n**CODE:**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minRefuelStops(int t, int sf, vector<vector<int>>& st) {\\n        priority_queue<int>pq;\\n        int cf=sf;   // current fuel\\n        int ans=0;\\n        int cd=0;     // current distance\\n        int i=0,n=st.size();\\n        while(cd<t){               // until we won\\'t reach target loop goes on\\n            cd+=cf;                //  cover distance which we can reach by current fuel  \\n            cf=0;                     // so now we had cover all distance by the fuel we had so the fuel is over\\n            if(cd>=t) return ans;          // if the covered distance is greater than target position return the number of stations we used\\n            while(i<n && st[i][0]<=cd){  // else add all the station\\'s gas which lie in between the distance from previous check point to here\\n                pq.push(st[i++][1]);  \\n            }\\n            if(pq.empty()) return -1;      // if pq is empty means there isn\\'t any station lie between previous check point till here so we can\\'t go ahead so return -1\\n            cf+=pq.top();                // else add the max gas among all the stations we covered \\n            pq.pop();                     // and delete it from the pq\\n            ans++;                       // and increase the counter\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minRefuelStops(int t, int sf, vector<vector<int>>& st) {\\n        priority_queue<int>pq;\\n        int cf=sf;   // current fuel\\n        int ans=0;\\n        int cd=0;     // current distance\\n        int i=0,n=st.size();\\n        while(cd<t){               // until we won\\'t reach target loop goes on\\n            cd+=cf;                //  cover distance which we can reach by current fuel  \\n            cf=0;                     // so now we had cover all distance by the fuel we had so the fuel is over\\n            if(cd>=t) return ans;          // if the covered distance is greater than target position return the number of stations we used\\n            while(i<n && st[i][0]<=cd){  // else add all the station\\'s gas which lie in between the distance from previous check point to here\\n                pq.push(st[i++][1]);  \\n            }\\n            if(pq.empty()) return -1;      // if pq is empty means there isn\\'t any station lie between previous check point till here so we can\\'t go ahead so return -1\\n            cf+=pq.top();                // else add the max gas among all the stations we covered \\n            pq.pop();                     // and delete it from the pq\\n            ans++;                       // and increase the counter\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179803,
                "title": "java-explanation-of-why-dynamic-programming-actually-works",
                "content": "Before finishing this article, I have not seen any satisfying explaination of Dynamic Programming Solution. These explainations either does not give a clear defition of dp\\\\[i\\\\]\\\\[j\\\\], or leaves some ambiguity in the relationship between subproblems. \\n\\nThis article aims to give a explaination of why DP-Solotion actually works without leaving any ambiguity. Again beforing jumping into 1-Dimension DP-Solution, we need to understand how 2-Dimension DP-Solution works.\\n\\nWe define the value of dp\\\\[i\\\\]\\\\[j\\\\] as follow: dp\\\\[i\\\\]\\\\[j\\\\] equals \\n1. -1   <==  if we can\\'t arrive at station i with j refuels\\n2. maximum distance we may reach   <==   if we can arrive at station i with j refuels\\n            \\nFirst of all,  dp\\\\[i\\\\]\\\\[j\\\\] == -1 if and only if either\\n1. we failed to reach station i-1 with j refuels  <==>  dp\\\\[i-1\\\\]\\\\[j\\\\] == -1\\n2. we reach station i-1 with j refuels but not enough to reach station i  <==> dp\\\\[i-1\\\\]\\\\[j\\\\] < stations\\\\[i\\\\]\\\\[0\\\\]\\n            \\nThus to simplify these condition dp\\\\[i\\\\]\\\\[j\\\\] == -1 <==> dp\\\\[i-1\\\\]\\\\[j\\\\] < stations\\\\[i\\\\]\\\\[0\\\\]\\n        \\nThen suffice to consider the case that we arrive at station i with j refuels. Namely, we want to calcualte the maximum distance we may reach with j refuels. \\n        \\nConsider these j refuels, we may **disjointly partition** into these two cases: \\n1. the last refuel happens before station i\\n2. the last refuel happens at station i \\n            \\nCase 1: all j refuels are at/before station i-1, then the maximum distance is still dp\\\\[i-1\\\\]\\\\[j\\\\] Case 2: if the last refuel happens at station i, we then assume we only use j-1 refuels to reach station\\\\[i\\\\]\\\\[0\\\\]\\n        \\nThen this is equivalent to both\\n1. we reach station i-1 with j-1 refuels  <==> dp\\\\[i-1\\\\]\\\\[j-1\\\\] != -1\\n2. the gas is enough to reach station i   <==> dp\\\\[i-1\\\\]\\\\[j-1\\\\] >= station\\\\[i\\\\]\\\\[0\\\\]\\n\\nAgian we can simplify these condition  dp\\\\[i-1\\\\]\\\\[j-1\\\\] >= stations\\\\[i\\\\]\\\\[0\\\\]. Then the maximum distance becomse dp\\\\[i-1\\\\]\\\\[j-1\\\\] + stations\\\\[i\\\\]\\\\[1\\\\]\\n        \\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n  \\n        int[][] dp = new int[n+1][n+1];\\n        for (int[] arr : dp) Arrays.fill(arr, -1);\\n        \\n        // 0 refuel\\n        dp[0][0] = startFuel;\\n        for (int i = 1; i <= n; i++) {\\n            if (stations[i-1][0] > startFuel) break;\\n            dp[i][0] = startFuel;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= i; j++) {\\n                if (dp[i-1][j] >= stations[i-1][0]) {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                \\n                \\n                if (dp[i-1][j-1] >= stations[i-1][0]) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-1][j-1] + stations[i-1][1]);\\n                }\\n                \\n            }\\n        }\\n        \\n  \\n        \\n        for (int i = 0; i <= n; i++) {\\n            if (dp[n][i] >= target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\nNow reducing this 2-Dim DP-Solution into 1-Dim one is very straightforward. \\n\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        \\n        int[] dp = new int[n+1];\\n        dp[0] = startFuel;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int[] next = new int[n+1];\\n            Arrays.fill(next, -1);\\n            if (stations[i-1][0] <= startFuel) next[0] = startFuel;\\n            \\n            for (int j = 1; j <= i; j++) {\\n                if (dp[j] >= stations[i-1][0]) {\\n                    next[j] = dp[j];\\n                }\\n                \\n                if (dp[j-1] >= stations[i-1][0]) {\\n                    next[j] = Math.max(next[j], dp[j-1] + stations[i-1][1]);\\n                }\\n                \\n            }\\n            \\n            dp = next;\\n        }\\n        \\n\\n        for (int i = 0; i <= n; i++) {\\n            if (dp[i] >= target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\nHowever, using PriorityQueue in this problem is still superior. Here I will paste my Solution, too. Just a quick note, this problem reminds me another problem\\n* [1642. Furthest Building You Can Reach](https://leetcode.com/problems/furthest-building-you-can-reach/)\\n\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int tank, int[][] stations) {\\n        // max heap storing liters of gas in stations\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a,b) -> b-a);\\n        int res = 0, prevLoc = 0;\\n        \\n        for (int[] station: stations) {\\n            int loc = station[0];\\n            int gas = station[1];\\n            \\n            tank -= (loc - prevLoc);\\n            \\n            // retrospectively refuel\\n            while (!heap.isEmpty() && tank < 0) { \\n                tank += heap.poll();\\n                res++;\\n            }\\n\\n            if (tank < 0) return -1;\\n            \\n            heap.offer(gas);\\n            prevLoc = loc;\\n        }\\n\\n        \\n        // now assume we reach the target \\n        tank -= (target - prevLoc);\\n        while (!heap.isEmpty() && tank < 0) {\\n            tank += heap.poll();\\n            res++;\\n        }\\n        \\n        if (tank < 0) return -1;\\n        return res;\\n    }\\n}\\n```\\n    \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n  \\n        int[][] dp = new int[n+1][n+1];\\n        for (int[] arr : dp) Arrays.fill(arr, -1);\\n        \\n        // 0 refuel\\n        dp[0][0] = startFuel;\\n        for (int i = 1; i <= n; i++) {\\n            if (stations[i-1][0] > startFuel) break;\\n            dp[i][0] = startFuel;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= i; j++) {\\n                if (dp[i-1][j] >= stations[i-1][0]) {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                \\n                \\n                if (dp[i-1][j-1] >= stations[i-1][0]) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-1][j-1] + stations[i-1][1]);\\n                }\\n                \\n            }\\n        }\\n        \\n  \\n        \\n        for (int i = 0; i <= n; i++) {\\n            if (dp[n][i] >= target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        \\n        int[] dp = new int[n+1];\\n        dp[0] = startFuel;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int[] next = new int[n+1];\\n            Arrays.fill(next, -1);\\n            if (stations[i-1][0] <= startFuel) next[0] = startFuel;\\n            \\n            for (int j = 1; j <= i; j++) {\\n                if (dp[j] >= stations[i-1][0]) {\\n                    next[j] = dp[j];\\n                }\\n                \\n                if (dp[j-1] >= stations[i-1][0]) {\\n                    next[j] = Math.max(next[j], dp[j-1] + stations[i-1][1]);\\n                }\\n                \\n            }\\n            \\n            dp = next;\\n        }\\n        \\n\\n        for (int i = 0; i <= n; i++) {\\n            if (dp[i] >= target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int tank, int[][] stations) {\\n        // max heap storing liters of gas in stations\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a,b) -> b-a);\\n        int res = 0, prevLoc = 0;\\n        \\n        for (int[] station: stations) {\\n            int loc = station[0];\\n            int gas = station[1];\\n            \\n            tank -= (loc - prevLoc);\\n            \\n            // retrospectively refuel\\n            while (!heap.isEmpty() && tank < 0) { \\n                tank += heap.poll();\\n                res++;\\n            }\\n\\n            if (tank < 0) return -1;\\n            \\n            heap.offer(gas);\\n            prevLoc = loc;\\n        }\\n\\n        \\n        // now assume we reach the target \\n        tank -= (target - prevLoc);\\n        while (!heap.isEmpty() && tank < 0) {\\n            tank += heap.poll();\\n            res++;\\n        }\\n        \\n        if (tank < 0) return -1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870295,
                "title": "javascript-array-faster-than-94-12-of-js-submissions",
                "content": "Based on finding the maximum distance you can cover and get the maximum fuel out of it. You can make class for priority queue as well for pushing and extracting maximum\\n\\n```\\nvar minRefuelStops = function(target, startFuel, stations) {\\n    let curr = startFuel;\\n    let len = stations.length;\\n    stations.sort(function(x,y) {return x[0] - y[0]});\\n    let pq = new Array();\\n    let i = 0, count = 0;\\n    while (curr < target) {\\n        count++;\\n        while (i < len && stations[i][0] <= curr) {\\n            pq.push(stations[i][1]);\\n            i++;\\n        }\\n        if (!pq.length)\\n            break;\\n        let max = Math.max(...pq);\\n        curr += max;\\n        pq.splice(pq.indexOf(max), 1);\\n    }\\n    return curr >= target ? count : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minRefuelStops = function(target, startFuel, stations) {\\n    let curr = startFuel;\\n    let len = stations.length;\\n    stations.sort(function(x,y) {return x[0] - y[0]});\\n    let pq = new Array();\\n    let i = 0, count = 0;\\n    while (curr < target) {\\n        count++;\\n        while (i < len && stations[i][0] <= curr) {\\n            pq.push(stations[i][1]);\\n            i++;\\n        }\\n        if (!pq.length)\\n            break;\\n        let max = Math.max(...pq);\\n        curr += max;\\n        pq.splice(pq.indexOf(max), 1);\\n    }\\n    return curr >= target ? count : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525715,
                "title": "similar-to-bounded-knapsack-dp-o-n-2-for-better-intuition",
                "content": "i -> station (item in case of knapsack)\\nj -> max_stops (similar to max_weight in case of knapsack)\\n\\ndp[i][j] ->  max distance we can travel by stopping at j stations to refill from [0, i] stations,\\nwhile 0 <= j <= i, since number of times we stop cannot be greater than no of stations under consideration \\n \\n1.) DP O(n^2) Space\\n\\n```\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n\\n\\tn = len(stations)\\n\\t\\n\\tdp = [[0 for _ in range(n+1)] for _ in range(n+1)]\\n\\n\\tdp[0][0] = startFuel\\n\\n\\tfor i in range(1,n+1):\\n\\t\\tfor j in range(i+1):\\n\\t\\t\\tif j > 0 and dp[i-1][j-1] >= stations[i-1][0]:\\n\\t\\t\\t\\tdp[i][j] = max(dp[i-1][j], dp[i-1][j-1]+stations[i-1][1])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j]\\n\\n\\tfor i in range(n+1):\\n\\t\\tif dp[-1][i]>=target:\\n\\t\\t\\treturn i\\n\\n\\treturn -1\\n```\\n\\n2) DP O(n) Space\\n\\n ```\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        \\n        n = len(stations)\\n    \\n        dp = [0 for _ in range(n+1)]      \\n    \\n        dp[0] = startFuel\\n        \\n        for i in range(1,n+1):\\n            for j in range(i+1,-1,-1):\\n                if j > 0 and dp[j-1] >= stations[i-1][0]:\\n                    dp[j] = max(dp[j], dp[j-1]+stations[i-1][1])\\n        \\n        for i in range(n+1):\\n            if dp[i]>=target:\\n                return i\\n        \\n        return -1\\n            \\n```\\n\\n            \\n",
                "solutionTags": [],
                "code": "```\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n\\n\\tn = len(stations)\\n\\t\\n\\tdp = [[0 for _ in range(n+1)] for _ in range(n+1)]\\n\\n\\tdp[0][0] = startFuel\\n\\n\\tfor i in range(1,n+1):\\n\\t\\tfor j in range(i+1):\\n\\t\\t\\tif j > 0 and dp[i-1][j-1] >= stations[i-1][0]:\\n\\t\\t\\t\\tdp[i][j] = max(dp[i-1][j], dp[i-1][j-1]+stations[i-1][1])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j]\\n\\n\\tfor i in range(n+1):\\n\\t\\tif dp[-1][i]>=target:\\n\\t\\t\\treturn i\\n\\n\\treturn -1\\n```\n```\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        \\n        n = len(stations)\\n    \\n        dp = [0 for _ in range(n+1)]      \\n    \\n        dp[0] = startFuel\\n        \\n        for i in range(1,n+1):\\n            for j in range(i+1,-1,-1):\\n                if j > 0 and dp[j-1] >= stations[i-1][0]:\\n                    dp[j] = max(dp[j], dp[j-1]+stations[i-1][1])\\n        \\n        for i in range(n+1):\\n            if dp[i]>=target:\\n                return i\\n        \\n        return -1\\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2455457,
                "title": "871-minimum-number-of-refueling-stops-o-n-2-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();        \\n        vector<vector<long long>> t(n+1, vector<long long>(n+1, 0));\\n        for(int i = 0; i<n+1; i++) \\n        {\\n            t[i][0] = startFuel;\\n        }        \\n        for(int i = 1; i < n+1; i++) \\n        {\\n            for(int j = 1; j <= i; j++) \\n            { \\n                \\n                t[i][j] = t[i-1][j];\\n                if(t[i-1][j-1] >= stations[i-1][0]) \\n                {\\n                    t[i][j] = max(t[i][j], t[i-1][j-1] + stations[i-1][1]);\\n                }\\n                \\n            }\\n        }\\n        for(int j = 0; j<n+1; j++) \\n        {\\n            if(t[n][j] >= target)\\n                return j;\\n        }\\n        //we can not reach\\n        return -1;\\n    }\\n};\\n\\nOne of the solution use dynamic programming. Let dp[i][j] be a maximum amount of fuel we can have, when we reached station number i and refueled j times before this station (not included). Let us also add two more points to our stops: starting one and ending one. Then, how we can update dp[i][j]: we can\\n\\nEither refuel on previous station, than we have dp[i-1][j-1] minus distance we covered between i-1 and i stations and plus amount of fuel we get at last station.\\nOr it can be dp[i-1][j] plus distance we covered between i-1 and i stations.\\nIf we have cand < 0 in our code, than it means we can not reach position i with j refuels, so we leave it equal to minus infinity. Finally, in the end we check last station and find the smallest index where value is not negative and return it.\\n\\nComplexity\\nTime complexity is O(n^2), space is O(n^2) as well. Space can be reduced to O(n).\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();        \\n        vector<vector<long long>> t(n+1, vector<long long>(n+1, 0));\\n        for(int i = 0; i<n+1; i++) \\n        {\\n            t[i][0] = startFuel;\\n        }        \\n        for(int i = 1; i < n+1; i++) \\n        {\\n            for(int j = 1; j <= i; j++) \\n            { \\n                \\n                t[i][j] = t[i-1][j];\\n                if(t[i-1][j-1] >= stations[i-1][0]) \\n                {\\n                    t[i][j] = max(t[i][j], t[i-1][j-1] + stations[i-1][1]);\\n                }\\n                \\n            }\\n        }\\n        for(int j = 0; j<n+1; j++) \\n        {\\n            if(t[n][j] >= target)\\n                return j;\\n        }\\n        //we can not reach\\n        return -1;\\n    }\\n};\\n\\nOne of the solution use dynamic programming. Let dp[i][j] be a maximum amount of fuel we can have, when we reached station number i and refueled j times before this station (not included). Let us also add two more points to our stops: starting one and ending one. Then, how we can update dp[i][j]: we can\\n\\nEither refuel on previous station, than we have dp[i-1][j-1] minus distance we covered between i-1 and i stations and plus amount of fuel we get at last station.\\nOr it can be dp[i-1][j] plus distance we covered between i-1 and i stations.\\nIf we have cand < 0 in our code, than it means we can not reach position i with j refuels, so we leave it equal to minus infinity. Finally, in the end we check last station and find the smallest index where value is not negative and return it.\\n\\nComplexity\\nTime complexity is O(n^2), space is O(n^2) as well. Space can be reduced to O(n).\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454821,
                "title": "recursive-solution-easy-to-understand-giving-tle",
                "content": "Its giving **TLE**, but this is the approach i was able to come up with.\\n\\n```\\nclass Solution {\\n\\tpublic int minRefuelStops(int target, int startFuel, int[][] stations) {\\n \\t\\tArrays.sort(stations,(A,B)->(A[0]-B[0]));\\n        int res  = recursion(target,startFuel,stations,0,0);\\n \\t\\treturn res>=Integer.MAX_VALUE/2?-1:res;\\n    }\\n\\n    public int recursion(int target,int startFuel,int[][] stations,int currPosition,int index){\\n    \\tif(target<=startFuel+currPosition)\\n    \\t\\treturn 0;\\n\\n    \\tif(index>=stations.length)\\n    \\t\\treturn Integer.MAX_VALUE/2;\\n\\n    \\tint pick = Integer.MAX_VALUE/2;\\n    \\tint notPick = Integer.MAX_VALUE/2;\\n\\n    \\tint weCanReach = startFuel+currPosition;\\n    \\tif(weCanReach>=stations[index][0]){\\n    \\t\\tpick = 1 + recursion(target,startFuel-(stations[index][0]-currPosition)+stations[index][1],stations,stations[index][0],index+1);\\n    \\t\\tnotPick = recursion(target,startFuel-(stations[index][0]-currPosition),stations,stations[index][0],index+1);\\n    \\t}\\n\\n    \\treturn Math.min(pick,notPick);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic int minRefuelStops(int target, int startFuel, int[][] stations) {\\n \\t\\tArrays.sort(stations,(A,B)->(A[0]-B[0]));\\n        int res  = recursion(target,startFuel,stations,0,0);\\n \\t\\treturn res>=Integer.MAX_VALUE/2?-1:res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2454099,
                "title": "python3-10-lines-heap-w-explanation-t-m-90-98",
                "content": "```\\nclass Solution:          # Here\\'s the plan:\\n                         # \\n                         # 1) We only need to be concerned with two quantities: the dist traveled (pos)\\n                         #    and the fuel acquired (fuel). We have to refuel before pos > fuel.\\n                         # \\n                         # 2) Because  we have an infinite capacity tank, we only have to plan where to acquire\\n                         #    fuel before pos > fuel, and common sense says to stop at the station within range\\n                         #    with the most fuel.\\n                         # \\n                         # 3) And that\\'s a job for a heap. we heappush the stations that are within range of present\\n                         #    fuel, and heappop the best choice if and when we need fuel.\\n                         #  \\n                         # 4) We are finished when a) we have acquired sufficient fuel such that fuel >= target \\n                         #    (return # of fuelings), or b) fuel < target and the heap is empty (return -1).\\n                       \\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n\\n        fuel, heap, count = startFuel, [], 0            # <-- initialize some stuff\\n        \\n        stations.append([target, 0])                    # <-- this handles the \"stations = []\" test\\n\\n        while stations:\\n            if fuel >= target: return count             # <-- 4)            \\n\\n            while stations and stations[0][0] <= fuel:  # <-- 3)\\n                _, liters = stations.pop(0)\\n                heappush(heap,-liters)\\n\\n            if not heap: return -1                      # <-- 4)\\n            fuel-= heappop(heap)\\n\\n            count+= 1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:          # Here\\'s the plan:\\n                         # \\n                         # 1) We only need to be concerned with two quantities: the dist traveled (pos)\\n                         #    and the fuel acquired (fuel). We have to refuel before pos > fuel.\\n                         # \\n                         # 2) Because  we have an infinite capacity tank, we only have to plan where to acquire\\n                         #    fuel before pos > fuel, and common sense says to stop at the station within range\\n                         #    with the most fuel.\\n                         # \\n                         # 3) And that\\'s a job for a heap. we heappush the stations that are within range of present\\n                         #    fuel, and heappop the best choice if and when we need fuel.\\n                         #  \\n                         # 4) We are finished when a) we have acquired sufficient fuel such that fuel >= target \\n                         #    (return # of fuelings), or b) fuel < target and the heap is empty (return -1).\\n                       \\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n\\n        fuel, heap, count = startFuel, [], 0            # <-- initialize some stuff\\n        \\n        stations.append([target, 0])                    # <-- this handles the \"stations = []\" test\\n\\n        while stations:\\n            if fuel >= target: return count             # <-- 4)            \\n\\n            while stations and stations[0][0] <= fuel:  # <-- 3)\\n                _, liters = stations.pop(0)\\n                heappush(heap,-liters)\\n\\n            if not heap: return -1                      # <-- 4)\\n            fuel-= heappop(heap)\\n\\n            count+= 1",
                "codeTag": "Java"
            },
            {
                "id": 2453021,
                "title": "javascript-dp-with-illustrations-solution-using-maxheap",
                "content": "# DP Solution\\n\\nI had quite hard time trying to understand this solution https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/149839/DP-O(N2)-and-Priority-Queue-O(NlogN) so I made an illustration for it. It\\'s not comprehensive in any way but for beginners I hope it will help to understand this solution.\\n\\nYou start with 2 simplifications:\\n1. Forget about position. The only part of the algorithm when we care about position is ```dp[t] >= s[i][0]```. Which means \"Can we reach this position with the current fuel level?\"\\n2. The re-fuel process is not linear. It can pass the best fuel station and then return to it later to perform the best refuel (that\\'s what inner loop is doing).\\n\\n\\n![image](https://assets.leetcode.com/users/images/2e109c77-3e16-4573-8d90-743536d5dc81_1661005876.70484.png)\\n\\n\\n```\\nvar minRefuelStops = function(target, startFuel, stations) {\\n    let dp = new Array(stations.length + 1).fill(0);\\n    dp[0] = startFuel;\\n    for (let i = 0; i < stations.length; i++) {\\n        for (let t = i; t >=0 && dp[t] >= stations[i][0]; t--) {\\n            dp[t + 1] = Math.max(dp[t + 1], dp[t] + stations[i][1])\\n        }\\n    }\\n    for (let i = 0; i <= stations.length; i++) {\\n        if (dp[i] >= target) return i;\\n    }\\n    \\n    return -1;\\n};\\n```\\n\\n\\n# MaxHeap Solution\\nMany solutions use MaxPriorityQueue but in fact MaxHeap is enough (I added MaxHeap implementation below).\\nThis is how MaxHeap tree looks in case of stations: **[[10,60],[20,30],[30,30],[60,40]]**\\n![image](https://assets.leetcode.com/users/images/ca7c0ffd-a07b-4482-a2fc-072e606a9837_1661061827.7182305.png)\\n\\nRemoving two max values from MaxHeap (60 and 40) and adding it to startFueld (10) will give us an answer **110**.\\n\\n```\\nvar minRefuelStops = function(target, startFuel, stations) {\\n        if (startFuel >= target) return 0;\\n        let queue = new MaxHeap();\\n        let i = 0, n = stations.length, stops = 0, maxDistance = startFuel;\\n        while (maxDistance < target) {\\n            while (i < n && stations[i][0] <= maxDistance) {\\n                queue.add(stations[i++][1]);\\n            }\\n            if (queue.isEmpty()) return -1;\\n            maxDistance += queue.poll();\\n            stops++;\\n        }\\n        return stops;\\n}\\n\\nclass MaxHeap {\\n  constructor(data = []) {\\n    this.data = data;\\n  }\\n\\n  add(val) {\\n    this.data.push(val);\\n    this.bubbleUp(this.size() - 1);\\n\\n    return this;\\n  }\\n\\n  poll() {\\n    if (this.data.length === 0) return null;\\n    if (this.data.length === 1) return this.data.pop();\\n    let head = this.data[0];\\n    this.data[0] = this.data.pop();\\n\\n    this.bubbleDown();\\n\\n    return head;\\n  }\\n\\n  peek() {\\n    if (this.size() === 0) return null;\\n    return this.data[0];\\n  }\\n\\n  getLeftChildIndex(parentIndex) {\\n    return (2 * parentIndex) + 1;\\n  }\\n\\n  getRightChildIndex(parentIndex) {\\n    return (2 * parentIndex) + 2;\\n  }\\n\\n  getParentIndex(childIndex) {\\n    return Math.floor((childIndex - 1) / 2);\\n  }\\n\\n  hasParent(childIndex) {\\n    return this.getParentIndex(childIndex) >= 0;\\n  }\\n\\n  hasLeftChild(parentIndex) {\\n    return this.getLeftChildIndex(parentIndex) < this.data.length;\\n  }\\n\\n  hasRightChild(parentIndex) {\\n    return this.getRightChildIndex(parentIndex) < this.data.length;\\n  }\\n\\n  leftChild(parentIndex) {\\n    return this.data[this.getLeftChildIndex(parentIndex)];\\n  }\\n\\n  rightChild(parentIndex) {\\n    return this.data[this.getRightChildIndex(parentIndex)];\\n  }\\n\\n  parent(childIndex) {\\n    return this.data[this.getParentIndex(childIndex)];\\n  }\\n\\n  bubbleUp(customStartIndex) {\\n    let currentIndex = customStartIndex || this.data.length - 1;\\n\\n    while (\\n      this.hasParent(currentIndex)\\n      && !this.pairIsInCorrectOrder(this.parent(currentIndex), this.data[currentIndex])\\n    ) {\\n      this.swap(currentIndex, this.getParentIndex(currentIndex));\\n      currentIndex = this.getParentIndex(currentIndex);\\n    }\\n  }\\n\\n  bubbleDown(customStartIndex = 0) {\\n    let currentIndex = customStartIndex;\\n    let nextIndex = null;\\n\\n    while (this.hasLeftChild(currentIndex)) {\\n      if (\\n        this.hasRightChild(currentIndex)\\n        && this.pairIsInCorrectOrder(this.rightChild(currentIndex), this.leftChild(currentIndex))\\n      ) {\\n        nextIndex = this.getRightChildIndex(currentIndex);\\n      } else {\\n        nextIndex = this.getLeftChildIndex(currentIndex);\\n      }\\n\\n      if (this.pairIsInCorrectOrder(\\n        this.data[currentIndex],\\n        this.data[nextIndex],\\n      )) {\\n        break;\\n      }\\n\\n      this.swap(currentIndex, nextIndex);\\n      currentIndex = nextIndex;\\n    }\\n  }\\n\\n  pairIsInCorrectOrder(firstElement, secondElement) {\\n    return (secondElement - firstElement) < 0;\\n  }\\n\\n  swap(idx1, idx2) {\\n    [this.data[idx1], this.data[idx2]] = [this.data[idx2], this.data[idx1]];\\n  }\\n\\n  size() {\\n    return this.data.length;\\n  }\\n\\n  isEmpty() {\\n    return this.data.length === 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```dp[t] >= s[i][0]```\n```\\nvar minRefuelStops = function(target, startFuel, stations) {\\n    let dp = new Array(stations.length + 1).fill(0);\\n    dp[0] = startFuel;\\n    for (let i = 0; i < stations.length; i++) {\\n        for (let t = i; t >=0 && dp[t] >= stations[i][0]; t--) {\\n            dp[t + 1] = Math.max(dp[t + 1], dp[t] + stations[i][1])\\n        }\\n    }\\n    for (let i = 0; i <= stations.length; i++) {\\n        if (dp[i] >= target) return i;\\n    }\\n    \\n    return -1;\\n};\\n```\n```\\nvar minRefuelStops = function(target, startFuel, stations) {\\n        if (startFuel >= target) return 0;\\n        let queue = new MaxHeap();\\n        let i = 0, n = stations.length, stops = 0, maxDistance = startFuel;\\n        while (maxDistance < target) {\\n            while (i < n && stations[i][0] <= maxDistance) {\\n                queue.add(stations[i++][1]);\\n            }\\n            if (queue.isEmpty()) return -1;\\n            maxDistance += queue.poll();\\n            stops++;\\n        }\\n        return stops;\\n}\\n\\nclass MaxHeap {\\n  constructor(data = []) {\\n    this.data = data;\\n  }\\n\\n  add(val) {\\n    this.data.push(val);\\n    this.bubbleUp(this.size() - 1);\\n\\n    return this;\\n  }\\n\\n  poll() {\\n    if (this.data.length === 0) return null;\\n    if (this.data.length === 1) return this.data.pop();\\n    let head = this.data[0];\\n    this.data[0] = this.data.pop();\\n\\n    this.bubbleDown();\\n\\n    return head;\\n  }\\n\\n  peek() {\\n    if (this.size() === 0) return null;\\n    return this.data[0];\\n  }\\n\\n  getLeftChildIndex(parentIndex) {\\n    return (2 * parentIndex) + 1;\\n  }\\n\\n  getRightChildIndex(parentIndex) {\\n    return (2 * parentIndex) + 2;\\n  }\\n\\n  getParentIndex(childIndex) {\\n    return Math.floor((childIndex - 1) / 2);\\n  }\\n\\n  hasParent(childIndex) {\\n    return this.getParentIndex(childIndex) >= 0;\\n  }\\n\\n  hasLeftChild(parentIndex) {\\n    return this.getLeftChildIndex(parentIndex) < this.data.length;\\n  }\\n\\n  hasRightChild(parentIndex) {\\n    return this.getRightChildIndex(parentIndex) < this.data.length;\\n  }\\n\\n  leftChild(parentIndex) {\\n    return this.data[this.getLeftChildIndex(parentIndex)];\\n  }\\n\\n  rightChild(parentIndex) {\\n    return this.data[this.getRightChildIndex(parentIndex)];\\n  }\\n\\n  parent(childIndex) {\\n    return this.data[this.getParentIndex(childIndex)];\\n  }\\n\\n  bubbleUp(customStartIndex) {\\n    let currentIndex = customStartIndex || this.data.length - 1;\\n\\n    while (\\n      this.hasParent(currentIndex)\\n      && !this.pairIsInCorrectOrder(this.parent(currentIndex), this.data[currentIndex])\\n    ) {\\n      this.swap(currentIndex, this.getParentIndex(currentIndex));\\n      currentIndex = this.getParentIndex(currentIndex);\\n    }\\n  }\\n\\n  bubbleDown(customStartIndex = 0) {\\n    let currentIndex = customStartIndex;\\n    let nextIndex = null;\\n\\n    while (this.hasLeftChild(currentIndex)) {\\n      if (\\n        this.hasRightChild(currentIndex)\\n        && this.pairIsInCorrectOrder(this.rightChild(currentIndex), this.leftChild(currentIndex))\\n      ) {\\n        nextIndex = this.getRightChildIndex(currentIndex);\\n      } else {\\n        nextIndex = this.getLeftChildIndex(currentIndex);\\n      }\\n\\n      if (this.pairIsInCorrectOrder(\\n        this.data[currentIndex],\\n        this.data[nextIndex],\\n      )) {\\n        break;\\n      }\\n\\n      this.swap(currentIndex, nextIndex);\\n      currentIndex = nextIndex;\\n    }\\n  }\\n\\n  pairIsInCorrectOrder(firstElement, secondElement) {\\n    return (secondElement - firstElement) < 0;\\n  }\\n\\n  swap(idx1, idx2) {\\n    [this.data[idx1], this.data[idx2]] = [this.data[idx2], this.data[idx1]];\\n  }\\n\\n  size() {\\n    return this.data.length;\\n  }\\n\\n  isEmpty() {\\n    return this.data.length === 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452763,
                "title": "java-3-solutions-3d-dp-tle-2d-dp-tle-greedy-working",
                "content": "```\\nclass Solution {\\n    // using 3D DP -> Memoization approach\\n    // Gives TLE\\n    // public int helper(int target, int fuelLeft, int[][] stations, int i, int pos, Map<List<Integer>, Integer> dp){\\n    //     if(pos+fuelLeft>=target)\\n    //         return 0;\\n    //     if(i>=stations.length)\\n    //         return 502;\\n    //     if(fuelLeft <0)\\n    //         return 502;\\n    //     if(stations[i][0]-pos > fuelLeft)\\n    //         return 502;\\n    //     if(dp.containsKey(Arrays.asList(i, fuelLeft, pos)))\\n    //         return dp.get(Arrays.asList(i, fuelLeft, pos));\\n    //     int avoid = helper(target, pos+fuelLeft-stations[i][0], stations, i+1, stations[i][0], dp);\\n    //     int fill = 1 + helper(target, pos+fuelLeft-stations[i][0]+stations[i][1], stations, i+1, stations[i][0], dp);\\n    //     dp.put(Arrays.asList(i, fuelLeft, pos),Math.min(avoid, fill));\\n    //     return Math.min(avoid, fill);\\n    // }\\n    \\n    // Using 2D DP -> Memoization approach\\n    // Gives TLE\\n    // public int helper(int target, int reach, int[][] stations, int i, Map<Pair<Integer,Integer>, Integer> dp){\\n    //     if(reach>=target)\\n    //         return 0;\\n    //     if(i>=stations.length)\\n    //         return 502;\\n    //     if(stations[i][0] > reach)\\n    //         return 502;\\n    //     Pair<Integer, Integer> pair = new Pair<Integer, Integer>(i, reach);\\n    //     if(dp.containsKey(pair))\\n    //         return dp.get(pair);\\n    //     int avoid = helper(target, reach, stations, i+1, dp);\\n    //     int fill = 1 + helper(target, reach+stations[i][1], stations, i+1, dp);\\n    //     int ans = Math.min(avoid, fill);\\n    //     dp.put(pair, ans);\\n    //     return ans;\\n    // }\\n    \\n    // public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n    //     Map<Pair<Integer,Integer>, Integer> dp = new HashMap<>();\\n    //     int ans = helper(target, startFuel, stations, 0, dp);\\n    //     if(ans>500)\\n    //         return -1;\\n    //     return ans;\\n    // }\\n    \\n\\t// Greedy working approach\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if(startFuel>=target)\\n            return 0;\\n        int n = stations.length;\\n        if(n==0 && target>startFuel)\\n            return -1;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int ans = 0;\\n        int reach = startFuel;\\n        for(int[] station: stations){\\n            \\n            if(station[0]>reach){\\n                while(!maxHeap.isEmpty()){\\n                    reach += maxHeap.poll();\\n                    ans++;\\n                    if(reach >= station[0])\\n                        break;\\n                }\\n                if(reach>=target)\\n                    return ans;\\n                if(station[0]>reach)\\n                    return -1;\\n            }\\n            maxHeap.offer(station[1]);\\n        }\\n        while(!maxHeap.isEmpty()){\\n            reach += maxHeap.poll();\\n            ans++;\\n            if(reach >= target)\\n                return ans;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy",
                    "Memoization",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    // using 3D DP -> Memoization approach\\n    // Gives TLE\\n    // public int helper(int target, int fuelLeft, int[][] stations, int i, int pos, Map<List<Integer>, Integer> dp){\\n    //     if(pos+fuelLeft>=target)\\n    //         return 0;\\n    //     if(i>=stations.length)\\n    //         return 502;\\n    //     if(fuelLeft <0)\\n    //         return 502;\\n    //     if(stations[i][0]-pos > fuelLeft)\\n    //         return 502;\\n    //     if(dp.containsKey(Arrays.asList(i, fuelLeft, pos)))\\n    //         return dp.get(Arrays.asList(i, fuelLeft, pos));\\n    //     int avoid = helper(target, pos+fuelLeft-stations[i][0], stations, i+1, stations[i][0], dp);\\n    //     int fill = 1 + helper(target, pos+fuelLeft-stations[i][0]+stations[i][1], stations, i+1, stations[i][0], dp);\\n    //     dp.put(Arrays.asList(i, fuelLeft, pos),Math.min(avoid, fill));\\n    //     return Math.min(avoid, fill);\\n    // }\\n    \\n    // Using 2D DP -> Memoization approach\\n    // Gives TLE\\n    // public int helper(int target, int reach, int[][] stations, int i, Map<Pair<Integer,Integer>, Integer> dp){\\n    //     if(reach>=target)\\n    //         return 0;\\n    //     if(i>=stations.length)\\n    //         return 502;\\n    //     if(stations[i][0] > reach)\\n    //         return 502;\\n    //     Pair<Integer, Integer> pair = new Pair<Integer, Integer>(i, reach);\\n    //     if(dp.containsKey(pair))\\n    //         return dp.get(pair);\\n    //     int avoid = helper(target, reach, stations, i+1, dp);\\n    //     int fill = 1 + helper(target, reach+stations[i][1], stations, i+1, dp);\\n    //     int ans = Math.min(avoid, fill);\\n    //     dp.put(pair, ans);\\n    //     return ans;\\n    // }\\n    \\n    // public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n    //     Map<Pair<Integer,Integer>, Integer> dp = new HashMap<>();\\n    //     int ans = helper(target, startFuel, stations, 0, dp);\\n    //     if(ans>500)\\n    //         return -1;\\n    //     return ans;\\n    // }\\n    \\n\\t// Greedy working approach\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if(startFuel>=target)\\n            return 0;\\n        int n = stations.length;\\n        if(n==0 && target>startFuel)\\n            return -1;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int ans = 0;\\n        int reach = startFuel;\\n        for(int[] station: stations){\\n            \\n            if(station[0]>reach){\\n                while(!maxHeap.isEmpty()){\\n                    reach += maxHeap.poll();\\n                    ans++;\\n                    if(reach >= station[0])\\n                        break;\\n                }\\n                if(reach>=target)\\n                    return ans;\\n                if(station[0]>reach)\\n                    return -1;\\n            }\\n            maxHeap.offer(station[1]);\\n        }\\n        while(!maxHeap.isEmpty()){\\n            reach += maxHeap.poll();\\n            ans++;\\n            if(reach >= target)\\n                return ans;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452074,
                "title": "c-priority-queue-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n=stations.size();\\n        int prsntFl=startFuel, i=0; \\n        int ans=0;\\n        priority_queue<int> p;\\n        while(prsntFl < target){\\n            while(i<n && prsntFl >= stations[i][0]){\\n                p.push(stations[i][1]);\\n                i++;\\n            }\\n            if(p.empty()) return -1;\\n            prsntFl += p.top();\\n            p.pop();\\n\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n=stations.size();\\n        int prsntFl=startFuel, i=0; \\n        int ans=0;\\n        priority_queue<int> p;\\n        while(prsntFl < target){\\n            while(i<n && prsntFl >= stations[i][0]){\\n                p.push(stations[i][1]);\\n                i++;\\n            }\\n            if(p.empty()) return -1;\\n            prsntFl += p.top();\\n            p.pop();\\n\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451968,
                "title": "java-solution-faster-than-100-1ms-runtime-with-explaination",
                "content": "**Approach Used -**\\n*1. Initailly take max Reachable Distance (maxDist) = startFuel;\\n2. while ( maxReachableDistance < target)\\n    -->> a. search for fuel station with maxFuel (within Range of Max Reachable Distance) and add the Fuel       to maxReachableDistance.\\n\\t-->> b. increment stops\\n3. if at any point no station is available to refuel (within Range of Max Reachable Distance) -> return -1*\\n\\n```java \\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {  \\n        int stops = 0;\\n        int maxReach = startFuel;\\n        while(maxReach<target)\\n        {\\n            int maxFuel = max(maxReach,stations);\\n            if(maxFuel==0)    // If no station is available to refuel \\n                return -1;\\n            maxReach+=maxFuel;\\n            stops++;\\n        }\\n        return stops;\\n    }\\n    \\n    private int max(int maxReach, int[][] stations)\\n    {\\n        int maxFuel=0;\\n        int[] temp = null; \\n        for(int i=0;i<stations.length&&stations[i][0]<=maxReach;i++)  //searching for fuel station with maxFuel in range of Max Reachable Distance\\n        {\\n            if(stations[i][1]>maxFuel)\\n            {\\n             temp = stations[i];\\n             maxFuel=stations[i][1];\\n            }   \\n        }\\n        if(temp!=null)\\n        temp[1]=0;    //all the fuel used up in refueling\\n        return maxFuel;\\n    }\\n}",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {  \\n        int stops = 0;\\n        int maxReach = startFuel;\\n        while(maxReach<target)\\n        {\\n            int maxFuel = max(maxReach,stations);\\n            if(maxFuel==0)    // If no station is available to refuel \\n                return -1;\\n            maxReach+=maxFuel;\\n            stops++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2451683,
                "title": "python-simple-heapq",
                "content": "```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        bag = []\\n        next_stop = startFuel\\n        ans = 0\\n        stations.append([target,0])\\n        for station in stations:\\n            while station[0] > next_stop:\\n                if not bag:\\n                    return -1\\n                else: \\n                    next_stop -= heapq.heappop(bag)\\n                    ans += 1\\n            if station[0] <= next_stop:\\n                heapq.heappush(bag,-1*station[1])\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        bag = []\\n        next_stop = startFuel\\n        ans = 0\\n        stations.append([target,0])\\n        for station in stations:\\n            while station[0] > next_stop:\\n                if not bag:\\n                    return -1\\n                else: \\n                    next_stop -= heapq.heappop(bag)\\n                    ans += 1\\n            if station[0] <= next_stop:\\n                heapq.heappush(bag,-1*station[1])\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451472,
                "title": "c-code-explained-easy-and-short-code-priority-queue",
                "content": "** CORNER CASES:** \\n* if the start fuel is less than then position of the first fuel station than return -1 as its will not be possible to reach the first fuel station\\n\\n* if target distance is smaller than the startfuel return 0 as there will be no need to refill**\\n\\nso first we will check if the first fuel station is at distance <= startfuel if yes then we will push its fuel to max heap\\nand after pushing we will add elements of heap into startfuel until it is equal to target\\n\\n**CODE**\\n\\n  ```\\n int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int i=0 , ans;\\n        priority_queue<int , vector<int>>q;  //     priority queue to push distances travelled by fuel\\n        \\n        for(ans=0 ; startFuel<target ; ans++)\\n        {\\n            while(i<stations.size() and stations[i][0] <= startFuel)\\n            {\\n                q.push(stations[i++][1]);\\n            }\\n            if(q.empty())return -1;\\n            \\n            startFuel+=q.top();\\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n```\\n\\nT.C : O(NlogN)\\n\\nHAPPY CODING PLEASE UPVOTE  ^_^****\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int i=0 , ans;\\n        priority_queue<int , vector<int>>q;  //     priority queue to push distances travelled by fuel\\n        \\n        for(ans=0 ; startFuel<target ; ans++)\\n        {\\n            while(i<stations.size() and stations[i][0] <= startFuel)\\n            {\\n                q.push(stations[i++][1]);\\n            }\\n            if(q.empty())return -1;\\n            \\n            startFuel+=q.top();\\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760015,
                "title": "python-top-down-dp",
                "content": "```\\nclass Solution:\\n    def minRefuelStops(self, target, startFuel, stations):\\n        stations = [[0, startFuel]] + stations + [[target, 0]]\\n        \\n        # dp(i, j) = maximum amount of fuel we can get when we are at station i and we have used j fuel stops (i not included)\\n        \\n        # j should be between [1, i]\\n        @cache\\n        def dp(i, j):\\n            if i == 0 and j == 0:\\n                return 0\\n            if not (1 <= j <= i):\\n                return float(\"-inf\")\\n            \\n            ans1 = dp(i-1, j) - (stations[i][0]-stations[i-1][0])\\n            ans2 = dp(i-1, j-1) - (stations[i][0]-stations[i-1][0]) + stations[i-1][1]\\n            \\n            ans = max(ans1, ans2)\\n            if ans < 0:\\n                return float(\"-inf\")\\n            else:\\n                return ans\\n        \\n        for j in range(len(stations)):\\n            if dp(len(stations)-1, j) >= 0:\\n                return j-1  # we return j-1 since first stop (we added the starting point) is mandatory and hence should be removed from final solution \\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minRefuelStops(self, target, startFuel, stations):\\n        stations = [[0, startFuel]] + stations + [[target, 0]]\\n        \\n        # dp(i, j) = maximum amount of fuel we can get when we are at station i and we have used j fuel stops (i not included)\\n        \\n        # j should be between [1, i]\\n        @cache\\n        def dp(i, j):\\n            if i == 0 and j == 0:\\n                return 0\\n            if not (1 <= j <= i):\\n                return float(\"-inf\")\\n            \\n            ans1 = dp(i-1, j) - (stations[i][0]-stations[i-1][0])\\n            ans2 = dp(i-1, j-1) - (stations[i][0]-stations[i-1][0]) + stations[i-1][1]\\n            \\n            ans = max(ans1, ans2)\\n            if ans < 0:\\n                return float(\"-inf\")\\n            else:\\n                return ans\\n        \\n        for j in range(len(stations)):\\n            if dp(len(stations)-1, j) >= 0:\\n                return j-1  # we return j-1 since first stop (we added the starting point) is mandatory and hence should be removed from final solution \\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484612,
                "title": "c-solution-with-sortedset",
                "content": "Use SortedSet as heap\\n```\\npublic class Solution {\\n    public int MinRefuelStops(int target, int startFuel, int[][] stations) {\\n        SortedSet<(int, int)> ss = new SortedSet<(int, int)>();\\n        int res = 0;\\n        int i=0;\\n        while(startFuel < target){\\n            while(i<stations.Length && stations[i][0]<=startFuel){\\n                ss.Add((stations[i][1], i));\\n                i++;\\n            }\\n            \\n            if(ss.Count ==0) return -1;\\n            \\n            startFuel+= (ss.Max.Item1);\\n            ss.Remove(ss.Max);\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinRefuelStops(int target, int startFuel, int[][] stations) {\\n        SortedSet<(int, int)> ss = new SortedSet<(int, int)>();\\n        int res = 0;\\n        int i=0;\\n        while(startFuel < target){\\n            while(i<stations.Length && stations[i][0]<=startFuel){\\n                ss.Add((stations[i][1], i));\\n                i++;\\n            }\\n            \\n            if(ss.Count ==0) return -1;\\n            \\n            startFuel+= (ss.Max.Item1);\\n            ss.Remove(ss.Max);\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266712,
                "title": "minimum-number-of-refueling-stops-java-priorityqueue-100",
                "content": "The logic here is to keep track of the total amount of fuel you ***can*** collect, given the current amount of fuel. Bacause you want to **minimize the number of stops**, it makes sense to always stop at the fuel station which will give you the **maximum fuel**.\\n\\n1. To remember all reachable stops with current fuel - List or Queue\\n2. To track the most beneficial fuel stop - Sorting\\n\\nBoth requirements are best satisfied by using a Max Heap (PriorityQueue).\\n\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int fuel, int[][] stations) {\\n        \\n        int n = stations.length, i=0, stops=0;\\n        Queue<Integer> fuelTank = new PriorityQueue<>((a,b) -> b-a);\\n        \\n\\t\\t// Amount of fuel in tank == the distance that can be reached\\n        while (fuel < target) {\\n            while (i < n && stations[i][0] <= fuel) {\\n                fuelTank.offer(stations[i][1]);\\n                i++;\\n            }\\n            if (fuelTank.isEmpty()) return -1;\\n            fuel += fuelTank.poll();\\n            stops++;\\n        }\\n        \\n        return stops;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int fuel, int[][] stations) {\\n        \\n        int n = stations.length, i=0, stops=0;\\n        Queue<Integer> fuelTank = new PriorityQueue<>((a,b) -> b-a);\\n        \\n\\t\\t// Amount of fuel in tank == the distance that can be reached\\n        while (fuel < target) {\\n            while (i < n && stations[i][0] <= fuel) {\\n                fuelTank.offer(stations[i][1]);\\n                i++;\\n            }\\n            if (fuelTank.isEmpty()) return -1;\\n            fuel += fuelTank.poll();\\n            stops++;\\n        }\\n        \\n        return stops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911923,
                "title": "python-time-travel",
                "content": "```html5\\n<b>Time Complexity: O(n&middot;log<sub>2</sub>(n))\\nSpace Complexity: O(n)</b>\\n```\\n**Approach:**\\nThis approach is **very** similar to the solution to <b><a href=\"https://leetcode.com/problems/avoid-flood-in-the-city/discuss/838640/Python-Save-it-for-a-rainy-day...\" target=\"_blank\">1488. avoid-flood-in-the-city</a></b>.  \\n\\nThe idea is that we **wait until we run out of gas** to choose where we should refuel.  \\n\\nEach time we pass a station, store the fuel the station holds in a max-heap (**fuel_options**).  \\n\\nThen when we need gas, we can tell our past selves which gas station we should have refueled at by popping the best gas station from fuel_options.  \\n\\n<br>\\n\\n```python\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n\\t\\n\\tfuel = startFuel\\n\\tfuel_options = []\\n\\tstations = stations[::-1]\\n\\tx1 = 0\\n\\tstops = 0\\n\\n\\twhile x1 < target:\\n\\n\\t\\t# If we have enough fuel to reach the finish, return stops taken\\n\\t\\tif target - x1 <= fuel:\\n\\t\\t\\treturn stops\\n\\n\\t\\t# When we reach a station, update the fuel spent to reach it\\n\\t\\t# remember the fuel the station holds (f2) we do not have access to it yet\\n\\t\\tx2, f2 = stations.pop() if stations else (target, 0)\\n\\t\\tfuel -= x2 - x1\\n\\t\\tx1 = x2\\n\\n\\t\\t# While our fuel is negative - pretend we stopped at the best gas station\\n\\t\\t# that we already passed and filled up there\\n\\t\\twhile fuel_options and fuel < 0:\\n\\t\\t\\tfuel += -1 * heapq.heappop(fuel_options)\\n\\t\\t\\tstops += 1\\n\\n\\t\\t# If all the gas stations we passed are not enough to fill the car then our trip has failed\\n\\t\\tif fuel < 0:\\n\\t\\t\\treturn -1\\n\\n\\t\\t# Now that we have at least 0 fuel in the tank, we get access to the current gas station\\n\\t\\theapq.heappush(fuel_options, -f2)\\n\\n\\treturn stops\\n```",
                "solutionTags": [],
                "code": "```html5\\n<b>Time Complexity: O(n&middot;log<sub>2</sub>(n))\\nSpace Complexity: O(n)</b>\\n```\n```python\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n\\t\\n\\tfuel = startFuel\\n\\tfuel_options = []\\n\\tstations = stations[::-1]\\n\\tx1 = 0\\n\\tstops = 0\\n\\n\\twhile x1 < target:\\n\\n\\t\\t# If we have enough fuel to reach the finish, return stops taken\\n\\t\\tif target - x1 <= fuel:\\n\\t\\t\\treturn stops\\n\\n\\t\\t# When we reach a station, update the fuel spent to reach it\\n\\t\\t# remember the fuel the station holds (f2) we do not have access to it yet\\n\\t\\tx2, f2 = stations.pop() if stations else (target, 0)\\n\\t\\tfuel -= x2 - x1\\n\\t\\tx1 = x2\\n\\n\\t\\t# While our fuel is negative - pretend we stopped at the best gas station\\n\\t\\t# that we already passed and filled up there\\n\\t\\twhile fuel_options and fuel < 0:\\n\\t\\t\\tfuel += -1 * heapq.heappop(fuel_options)\\n\\t\\t\\tstops += 1\\n\\n\\t\\t# If all the gas stations we passed are not enough to fill the car then our trip has failed\\n\\t\\tif fuel < 0:\\n\\t\\t\\treturn -1\\n\\n\\t\\t# Now that we have at least 0 fuel in the tank, we get access to the current gas station\\n\\t\\theapq.heappush(fuel_options, -f2)\\n\\n\\treturn stops\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 865777,
                "title": "c-heaps-approach-explained-fully-explained-intuitive-easy-to-understand-100",
                "content": "\\'\\'\\'\\n\\t\\n\\t //max heap nlogn solution\\n        \\n        \\n        // the idea is that we refuel only when the need arises\\n        //AND when does the need arise:\\n        //1. when we are short of visiting the next fuel stations \\n        //2. When we have gone past all gas stations and are short on fuel and haven\\'t reached the target yet\\n        \\n        //Now we have the occassions as to when we have to refill ..now how do we refill\\n        // whenver we are short i.e in the above 2 cases we search for the stations that we have covered till now which has the max fuel and if the max fuel station can not provide enough fuel so that we reach the next station or the target then we need to refuell again\\n        \\n        //used max heap for effiicent max fuel station search \\n        \\n        int n=stations.size();\\n        priority_queue<int> pq;\\n\\n        int can_coverdist=startFuel;    //can_coverdist tells the total dist we can cover cover using the available fuel\\n        int stops=0;\\n        for(int i=0;i<n;i++)\\n        {\\n                if(can_coverdist>=target)\\n                    return stops;\\n            \\n                while(!pq.empty() && can_coverdist<stations[i][0])  //can\\'t reach the curr station so refuelling\\n                {\\n                    can_coverdist+=pq.top();\\n                    pq.pop();\\n                    stops++;\\n                }\\n                \\n                if(pq.empty()&&can_coverdist<stations[i][0])    //can\\'t reach the curr station even with refuelling at all the stations \\n                    return -1;\\n                \\n                pq.push(stations[i][1]);        //if code reaches here that means we can reach till this station so we push into heap so that we can refuel in the future if necessary\\n            \\n        }\\n    //case when we have covered all the stations by refuelling at 0 or more stations and still we haven\\'t reached the target\\n        while(!pq.empty() && can_coverdist<target)      \\n        {\\n            can_coverdist+=pq.top();\\n            pq.pop();\\n            stops++;\\n        }\\n        \\n        return can_coverdist>=target ? stops:-1;\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\'\\'\\'\\n\\t\\n\\t //max heap nlogn solution\\n        \\n        \\n        // the idea is that we refuel only when the need arises\\n        //AND when does the need arise:\\n        //1. when we are short of visiting the next fuel stations \\n        //2. When we have gone past all gas stations and are short on fuel and haven\\'t reached the target yet\\n        \\n        //Now we have the occassions as to when we have to refill ..now how do we refill\\n        // whenver we are short i.e in the above 2 cases we search for the stations that we have covered till now which has the max fuel and if the max fuel station can not provide enough fuel so that we reach the next station or the target then we need to refuell again\\n        \\n        //used max heap for effiicent max fuel station search \\n        \\n        int n=stations.size();\\n        priority_queue<int> pq;\\n\\n        int can_coverdist=startFuel;    //can_coverdist tells the total dist we can cover cover using the available fuel\\n        int stops=0;\\n        for(int i=0;i<n;i++)\\n        {\\n                if(can_coverdist>=target)\\n                    return stops;\\n            \\n                while(!pq.empty() && can_coverdist<stations[i][0])  //can\\'t reach the curr station so refuelling\\n                {\\n                    can_coverdist+=pq.top();\\n                    pq.pop();\\n                    stops++;\\n                }\\n                \\n                if(pq.empty()&&can_coverdist<stations[i][0])    //can\\'t reach the curr station even with refuelling at all the stations \\n                    return -1;\\n                \\n                pq.push(stations[i][1]);        //if code reaches here that means we can reach till this station so we push into heap so that we can refuel in the future if necessary\\n            \\n        }\\n    //case when we have covered all the stations by refuelling at 0 or more stations and still we haven\\'t reached the target\\n        while(!pq.empty() && can_coverdist<target)      \\n        {\\n            can_coverdist+=pq.top();\\n            pq.pop();\\n            stops++;\\n        }\\n        \\n        return can_coverdist>=target ? stops:-1;\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 696235,
                "title": "871-minimum-number-of-refueling-stops-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int> pq;\\n        pq.push({startFuel});\\n        int dist = 0;\\n        int answer = 0;\\n        int i=0;\\n        while(!pq.empty()&&dist<target){\\n            dist+=pq.top();\\n            pq.pop();\\n            answer++;\\n            while(i<stations.size() && stations[i][0]<=dist){\\n                pq.push(stations[i][1]);\\n                i++;\\n            }\\n        }\\n        if(dist<target) return -1;\\n        return answer-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int> pq;\\n        pq.push({startFuel});\\n        int dist = 0;\\n        int answer = 0;\\n        int i=0;\\n        while(!pq.empty()&&dist<target){\\n            dist+=pq.top();\\n            pq.pop();\\n            answer++;\\n            while(i<stations.size() && stations[i][0]<=dist){\\n                pq.push(stations[i][1]);\\n                i++;\\n            }\\n        }\\n        if(dist<target) return -1;\\n        return answer-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690077,
                "title": "this-testcase-is-why-this-isn-t-a-greedy-problem",
                "content": "```\\n100\\n50\\n[[25,50],[50,25]]",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 353576,
                "title": "dynamic-programming-o-n-memory",
                "content": "```csharp\\npublic class Solution \\n{\\n    public int MinRefuelStops(int target, int startFuel, int[][] stations) \\n    {          \\n        long[] d = new long[stations.Length + 1];\\n        d[0] = startFuel;\\n        \\n        for (int i = 0; i < stations.Length; i++) \\n        {\\n            int stopDistance = stations[i][0];\\n            int fuel = stations[i][1];\\n            \\n            for (int j = i + 1; j > 0 && d[j - 1] >= stopDistance; j--) \\n            {\\n                d[j] = Math.Max(d[j], d[j - 1] + fuel);\\n            }\\n        }\\n        \\n        for (int i = 0; i < d.Length; i++) \\n        {\\n            if (d[i] >= target) \\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    public int MinRefuelStops(int target, int startFuel, int[][] stations) \\n    {          \\n        long[] d = new long[stations.Length + 1];\\n        d[0] = startFuel;\\n        \\n        for (int i = 0; i < stations.Length; i++) \\n        {\\n            int stopDistance = stations[i][0];\\n            int fuel = stations[i][1];\\n            \\n            for (int j = i + 1; j > 0 && d[j - 1] >= stopDistance; j--) \\n            {\\n                d[j] = Math.Max(d[j], d[j - 1] + fuel);\\n            }\\n        }\\n        \\n        for (int i = 0; i < d.Length; i++) \\n        {\\n            if (d[i] >= target) \\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333070,
                "title": "python-heap-o-nlgn",
                "content": "```\\n\\t# max-heap O(nlogn) 40ms 98.39%\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        pq = []\\n        fuel = startFuel\\n        refuel = 0\\n        stations = [[0,0]] + stations + [[target,0]]\\n        # print(stations)\\n        for i in range(1, len(stations)): # O(NlgN)\\n            fuel -= stations[i][0]-stations[i-1][0]\\n            while fuel < 0:\\n                if not pq:\\n                    return -1\\n                fuel += -heapq.heappop(pq) # O(lgN)\\n                refuel += 1\\n            if stations[i][0] >= target:\\n                return refuel\\n            heapq.heappush(pq, -stations[i][1])\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\t# max-heap O(nlogn) 40ms 98.39%\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        pq = []\\n        fuel = startFuel\\n        refuel = 0\\n        stations = [[0,0]] + stations + [[target,0]]\\n        # print(stations)\\n        for i in range(1, len(stations)): # O(NlgN)\\n            fuel -= stations[i][0]-stations[i-1][0]\\n            while fuel < 0:\\n                if not pq:\\n                    return -1\\n                fuel += -heapq.heappop(pq) # O(lgN)\\n                refuel += 1\\n            if stations[i][0] >= target:\\n                return refuel\\n            heapq.heappush(pq, -stations[i][1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 263468,
                "title": "python-max-heap-o-nlogn",
                "content": "We can think the problem in that way:\\nOnce the car pass a gas station, it never stops but saves that chance to stop. Once it run out of fuel, it can use those chances to refuel itself. Each chance stands for one stop. It will start using the chance with largest amount of gasoline.\\n\\nE.g. target=100, start fuel = 30, stations=[[10,60], [20,100]]. So the car will save the chances to stop at the1st and the 2nd stations. It will run out of fuel at 30. Then it use the chance to fuel at 2nd station since it has more gas. Then it can reach the target place with only one stops.\\n\\nSo we can iterate the gas stations and push those reached stations into a max heap. For each station, car tank\\'s gas reduces by ```dst-src```. Destination and source are the locations of current station and last station.  When the car run out of fuel, we pop a saved chance with largest volumn of refueling from the max heap. If heap is empty but the car is still out of fuel, then the target is unreachable.\\n```\\ndef minRefuelStops(target, tank_gas, stations):\\n\\theap, src, cnt = [], 0, 0\\n\\tfor dst, gas in stations + [[target, float(\\'inf\\')]]:\\n\\t\\ttank_gas -= dst-src\\n\\t\\twhile heap and tank_gas < 0:         # keep refueling until tank_gas \\u2265 0\\n\\t\\t\\ttank_gas -= heapq.heappop(heap)  # \"maxheap\" stores -gas\\n\\t\\t\\tcnt += 1\\n\\t\\tif tank_gas < 0: return -1\\n\\t\\tsrc = dst\\n\\t\\theapq.heappush(heap, -gas)\\n\\treturn cnt\\n```\\nTime complexity is O(nlogn)",
                "solutionTags": [],
                "code": "```dst-src```\n```\\ndef minRefuelStops(target, tank_gas, stations):\\n\\theap, src, cnt = [], 0, 0\\n\\tfor dst, gas in stations + [[target, float(\\'inf\\')]]:\\n\\t\\ttank_gas -= dst-src\\n\\t\\twhile heap and tank_gas < 0:         # keep refueling until tank_gas \\u2265 0\\n\\t\\t\\ttank_gas -= heapq.heappop(heap)  # \"maxheap\" stores -gas\\n\\t\\t\\tcnt += 1\\n\\t\\tif tank_gas < 0: return -1\\n\\t\\tsrc = dst\\n\\t\\theapq.heappush(heap, -gas)\\n\\treturn cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 192695,
                "title": "8-line-java-greedy",
                "content": "Let `stop` be the maximum distance my car can go. **The final stop is the total amount of fuel ever added to the tank.** The initial stop is the `startFuel`. The goal is to reach `target` with mininal count of refuels.\\n\\nThe `Greedy` is I don\\'t care when the fuels are added, nor how is fuel spent, as long as I can get the optimal result.\\n\\nI keep driving nonstop until I\\'m out of fuel and stoped at stop. Whenever I pass a station I add its fuel volume to a maxHeap. When I stopped, I magically teleport the heap top into my tank, and contintue, and repeat.\\n\\n`O(nlogn)` for heap offers.\\n\\n```\\npublic int minRefuelStops(int target, int startFuel, int[][] stations) {\\n    Queue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n    int stop = startFuel, refuel = 0, i = 0;\\n    while (stop < target) {            \\n        for (; i < stations.length && stations[i][0] <= stop; i++) pq.offer(stations[i][1]);\\n        if (pq.isEmpty()) return -1;\\n        stop += pq.poll();\\n        refuel++;\\n    }\\n    return refuel;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minRefuelStops(int target, int startFuel, int[][] stations) {\\n    Queue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n    int stop = startFuel, refuel = 0, i = 0;\\n    while (stop < target) {            \\n        for (; i < stations.length && stations[i][0] <= stop; i++) pq.offer(stations[i][1]);\\n        if (pq.isEmpty()) return -1;\\n        stop += pq.poll();\\n        refuel++;\\n    }\\n    return refuel;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150310,
                "title": "java-13ms-greedy-with-priorityqueue",
                "content": "    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int ans = 0, fuel= startFuel, i = 0;\\n        while(true) {\\n            if (fuel >= target) return ans;\\n            while(i < stations.length && stations[i][0] <= fuel)\\n                pq.add(stations[i++][1]);\\n            if (pq.isEmpty()) return -1;\\n            fuel += pq.poll();\\n            ans++;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int ans = 0, fuel= startFuel, i = 0;\\n        while(true) {\\n            if (fuel >= target) return ans;\\n            while(i < stations.length && stations[i][0] <= fuel)\\n                pq.add(stations[i++][1]);\\n            if (pq.isEmpty()) return -1;\\n            fuel += pq.poll();\\n            ans++;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 149886,
                "title": "c-dp-with-explanation",
                "content": "`dp[i]` means the farthest distance it can reach with the number of `i` stops.\\nIf the station `i` can be reached with stop `j`, more specifically `dp[j - 1] >= stations[i][0]`, I can use station `i` to update `dp[j]`.\\n`dp[j] = max(d[j], dp[j - 1) + stations[i][1]`\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        vector<int> dp(stations.size() + 1, 0);\\n        dp[0] = startFuel;\\n        int ans = stations.size() + 2;\\n        if(startFuel >= target) return 0;\\n        for(int i = 0; i < stations.size(); i++) {\\n            for(int j = i + 1; j >= 1; j--) {\\t// in decending order to make sure every stop can only be reached once\\n                if(dp[j - 1] >= stations[i][0]) {\\n                    int tmp = dp[j - 1] + stations[i][1];\\n                    dp[j] = max(dp[j], tmp);\\n                    if(dp[j] >= target) ans = min(ans, j);\\n                }\\n            }\\n        }\\n        if(ans == stations.size() + 2) ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        vector<int> dp(stations.size() + 1, 0);\\n        dp[0] = startFuel;\\n        int ans = stations.size() + 2;\\n        if(startFuel >= target) return 0;\\n        for(int i = 0; i < stations.size(); i++) {\\n            for(int j = i + 1; j >= 1; j--) {\\t// in decending order to make sure every stop can only be reached once\\n                if(dp[j - 1] >= stations[i][0]) {\\n                    int tmp = dp[j - 1] + stations[i][1];\\n                    dp[j] = max(dp[j], tmp);\\n                    if(dp[j] >= target) ans = min(ans, j);\\n                }\\n            }\\n        }\\n        if(ans == stations.size() + 2) ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149877,
                "title": "o-n-simple-and-concise-c-solution-using-priority-queue-need-no-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int nowpos=startFuel;\\n        int counter=0,p=0;\\n        priority_queue<int>pq;\\n        while(1){\\n            while(p<(int)stations.size()&&stations[p][0]<=nowpos){\\n                pq.push(stations[p][1]);\\n                p++;\\n            }\\n            if(nowpos>=target)return counter;\\n            if(pq.empty())return -1;\\n            nowpos+=pq.top();pq.pop();\\n            counter++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int nowpos=startFuel;\\n        int counter=0,p=0;\\n        priority_queue<int>pq;\\n        while(1){\\n            while(p<(int)stations.size()&&stations[p][0]<=nowpos){\\n                pq.push(stations[p][1]);\\n                p++;\\n            }\\n            if(nowpos>=target)return counter;\\n            if(pq.empty())return -1;\\n            nowpos+=pq.top();pq.pop();\\n            counter++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796406,
                "title": "easy-code",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int minRefuelStops(int target, int curr, vector<vector < int>> &stations)\\n        {\\n            priority_queue<int> heap;\\n            int cnt = 0;\\n            for (int i = 0; i < stations.size(); i++)\\n            {\\n                if (curr < stations[i][0] and!heap.size())\\n                    return -1;\\n                else if (curr < stations[i][0])\\n                {\\n                    while (heap.size() and curr < stations[i][0])\\n                    {\\n                        curr += heap.top();\\n                        cnt += 1;\\n                        heap.pop();\\n                    }\\n                    if (curr < stations[i][0])\\n                        return -1;\\n                }\\n                heap.push(stations[i][1]);\\n            }\\n            while (heap.size() and curr < target)\\n            {\\n                curr += heap.top();\\n                cnt += 1;\\n                heap.pop();\\n            }\\n            if (curr < target)\\n                return -1;\\n            else\\n                return cnt;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minRefuelStops(int target, int curr, vector<vector < int>> &stations)\\n        {\\n            priority_queue<int> heap;\\n            int cnt = 0;\\n            for (int i = 0; i < stations.size(); i++)\\n            {\\n                if (curr < stations[i][0] and!heap.size())\\n                    return -1;\\n                else if (curr < stations[i][0])\\n                {\\n                    while (heap.size() and curr < stations[i][0])\\n                    {\\n                        curr += heap.top();\\n                        cnt += 1;\\n                        heap.pop();\\n                    }\\n                    if (curr < stations[i][0])\\n                        return -1;\\n                }\\n                heap.push(stations[i][1]);\\n            }\\n            while (heap.size() and curr < target)\\n            {\\n                curr += heap.top();\\n                cnt += 1;\\n                heap.pop();\\n            }\\n            if (curr < target)\\n                return -1;\\n            else\\n                return cnt;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783397,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n    \\n    int n=stations.size();\\n    int currFuel=startFuel, i=0;     \\n    int res=0;\\n    \\n    priority_queue<int> pq;     \\n    \\n    while(currFuel < target){\\n        \\n        while(i<n && currFuel >= stations[i][0]){    \\n            pq.push(stations[i][1]);                \\n            i++;                                     \\n        }\\n        \\n        if(pq.empty()) return -1;        \\n        currFuel += pq.top();             \\n        pq.pop();\\n        \\n        res++;                            \\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n    \\n    int n=stations.size();\\n    int currFuel=startFuel, i=0;     \\n    int res=0;\\n    \\n    priority_queue<int> pq;     \\n    \\n    while(currFuel < target){\\n        \\n        while(i<n && currFuel >= stations[i][0]){    \\n            pq.push(stations[i][1]);                \\n            i++;                                     \\n        }\\n        \\n        if(pq.empty()) return -1;        \\n        currFuel += pq.top();             \\n        pq.pop();\\n        \\n        res++;                            \\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661151,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Max. Heap***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& arr) {\\n\\n        int n = arr.size();\\n\\n        int curr_dist = startFuel;\\n\\n        // declare a max heap\\n\\n        // pq will store the station with maximum fuel at top, the stations which we have encountered till now\\n\\n        priority_queue<int> pq;\\n\\n        int count = 0;\\n\\n        int i = 0;\\n\\n        // run the loop till curr_dist < target\\n\\n        while(curr_dist < target)\\n        {\\n            // insert the fuel of the stations into pq, which we will encounter\\n\\n            while(i < n && arr[i][0] <= curr_dist)\\n            {\\n                pq.push(arr[i][1]);\\n\\n                i++;\\n            }\\n\\n            // if we have no station for refueling\\n\\n            if(pq.empty())\\n            {\\n                return -1;\\n            }\\n\\n            // update curr_dist\\n\\n            curr_dist += pq.top();\\n\\n            pq.pop();\\n\\n            // increment no. of stations\\n\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& arr) {\\n\\n        int n = arr.size();\\n\\n        int curr_dist = startFuel;\\n\\n        // declare a max heap\\n\\n        // pq will store the station with maximum fuel at top, the stations which we have encountered till now\\n\\n        priority_queue<int> pq;\\n\\n        int count = 0;\\n\\n        int i = 0;\\n\\n        // run the loop till curr_dist < target\\n\\n        while(curr_dist < target)\\n        {\\n            // insert the fuel of the stations into pq, which we will encounter\\n\\n            while(i < n && arr[i][0] <= curr_dist)\\n            {\\n                pq.push(arr[i][1]);\\n\\n                i++;\\n            }\\n\\n            // if we have no station for refueling\\n\\n            if(pq.empty())\\n            {\\n                return -1;\\n            }\\n\\n            // update curr_dist\\n\\n            curr_dist += pq.top();\\n\\n            pq.pop();\\n\\n            // increment no. of stations\\n\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467037,
                "title": "complete-explanation-with-example-dp-solution",
                "content": "**Explanation :-**\\n\\nWe have created a vector dp, where dp[i] of **size n+1 (n = stations.size())** represents the maximum possible distance you can reach after refulling exactly i times.\\n__________________________\\n\\n**Let\\'s take an example :-**\\ntarget = 100, \\nstartFuel = 10, \\nstations = [[10,60],[20,30],[30,30],[60,40]]\\n\\nCreate a vector dp of size 5\\n**dp[5] = _ , _ , _ , _ , _**\\n___________\\n\\nWe know that, dp[0] will be equal to startFuel, because if we refulled at exactly 0 stations we can reach a max distance of StartFuel. \\n\\ndp[0] = startFuel\\ndp[0] = 10;\\n**dp = 10 , _ , _ , _ , _**\\n__________\\n\\nNow we iterate on all the stations and check the max distance it can reach if we refulled exactly i times.\\n**Run a loop from i = 0 to i < n (iterating all the stations)**\\n______________\\n\\nFor **i = 0, station = [10, 60]**\\n\\nif(we can reach this ith station) dp[1] = 70\\nthat is\\nif(dp[0] >= station[i][0]) dp[1] = 70\\n\\nif we refule at exactly 1 station, for now, we can reach max distance of 70\\n**dp = 10 , 70 , _ , _ , _**\\n______________________\\n\\n\\n\\nNow, dp[2] = max distance reached if we refulled at **exactly 2 stations and i = 1, station = [20,30]**\\n\\nif(dp[1] >= stations[i][0]) dp[2] = max(dp[2], dp[1] + stations[i][1]) = max(0, 70 + 30) = 100\\nif(dp[0] >= stations[i][0]) dp[1] = max(dp[1], dp[0] + stations[i][1]) = max(70, 10 + 30) = 70\\n//updating dp[1] considering the exactly 1 refulling stop as the second station....and similarly we will have to update all the previous indexes\\n\\n**dp = 10 , 70 , 100 , _ , _**\\n_________________\\nNow dp[3] = max distance reached if we refulled at **exactly 3 stations and i = 2, station = [30,30]**\\nif(dp[2] >= stations[i][0]) dp[3] = max(dp[3], dp[2] + stations[i][1]) = max(0, 100 + 30) = 130\\nif(dp[1] >= stations[i][0]) dp[2] = max(dp[2], dp[1] + stations[i][1]) = max(100, 70 + 30) = 100\\nif(dp[0] >= stations[i][0]) dp[1] = max(dp[1], dp[0] + stations[i][1]) = if condition not satisfied\\n\\n**dp = 10, 70, 100, 130, _**\\n_________________________\\nNow dp[4] = max distance reached if we refulled at **exactly 4 stations and i = 3, station = [60,40]**\\nif(dp[3] >= stations[i][0]) dp[4] = max(dp[4], dp[3] + stations[i][1]) = max(0, 130 + 40) = 170\\nif(dp[2] >= stations[i][0]) dp[3] = max(dp[3], dp[2] + stations[i][1]) = max(130, 100 + 40) = 140\\nif(dp[1] >= stations[i][0]) dp[2] = max(dp[2], dp[1] + stations[i][1]) = max(100, 70 + 40) = 110\\nif(dp[0] >= stations[i][0]) dp[1] = max(dp[1], dp[0] + stations[i][1]) = if condition not satisfied\\n\\n**dp = 10, 70, 110, 140, 170**\\n________________________________\\nNow that we have maximum distance if we refulled at exactly i refulling stations, we can easily get the required ans. Just loop over the dp array and find the least index at which dp[i] >= target, that index will be our answer.\\n_________________\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        vector<long long> dp(n+1, 0);\\n       \\n        dp[0] = startFuel;\\n        \\n        for(int i = 0; i < n; i++) {            \\n            for(int t = i; t >= 0; t--){\\n                if(dp[t] >= stations[i][0]){\\n                    dp[t+1] = max(dp[t+1], dp[t] + stations[i][1]);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i<=n; i++){\\n            if(dp[i] >= target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n = stations.size();\\n        vector<long long> dp(n+1, 0);\\n       \\n        dp[0] = startFuel;\\n        \\n        for(int i = 0; i < n; i++) {            \\n            for(int t = i; t >= 0; t--){\\n                if(dp[t] >= stations[i][0]){\\n                    dp[t+1] = max(dp[t+1], dp[t] + stations[i][1]);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i<=n; i++){\\n            if(dp[i] >= target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464803,
                "title": "python-dp-solution",
                "content": "DP solution:\\n\\n```python\\n\\nclass Solution:\\n    def minRefuelStops(\\n        self, target: int, startFuel: int, stations: List[List[int]]\\n    ) -> int:\\n\\n        last_station = {0: startFuel}\\n        for station in stations:\\n            cur_station = {}\\n            for stop, fuel in last_station.items():\\n                if fuel >= station[0]:\\n                    cur_station[stop] = fuel\\n\\n            if last_station[stop] >= station[0]:\\n                cur_station[stop + 1] = last_station[stop] + station[1]\\n\\n            for stop, fuel in last_station.items():\\n                if fuel >= station[0]:\\n                    cur_station[stop + 1] = max(\\n                        fuel + station[1], cur_station[stop + 1]\\n                    )\\n\\n            if not cur_station.keys():\\n                return -1\\n\\n            last_station = cur_station\\n\\n        for stop, fuel in last_station.items():\\n            if fuel >= target:\\n                return stop\\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\n\\nclass Solution:\\n    def minRefuelStops(\\n        self, target: int, startFuel: int, stations: List[List[int]]\\n    ) -> int:\\n\\n        last_station = {0: startFuel}\\n        for station in stations:\\n            cur_station = {}\\n            for stop, fuel in last_station.items():\\n                if fuel >= station[0]:\\n                    cur_station[stop] = fuel\\n\\n            if last_station[stop] >= station[0]:\\n                cur_station[stop + 1] = last_station[stop] + station[1]\\n\\n            for stop, fuel in last_station.items():\\n                if fuel >= station[0]:\\n                    cur_station[stop + 1] = max(\\n                        fuel + station[1], cur_station[stop + 1]\\n                    )\\n\\n            if not cur_station.keys():\\n                return -1\\n\\n            last_station = cur_station\\n\\n        for stop, fuel in last_station.items():\\n            if fuel >= target:\\n                return stop\\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462583,
                "title": "fully-explained-dp-js-solution",
                "content": "Basically i took lee215 solution and tried to convert it into js.\\nBut i also like to comment a few things which improved my personal understanding \\uD83D\\uDE0A\\n\\nThe dp array represents the max travel distance we can travel with j fueling times.\\nFor example: `[10, 70, 110, 140, 170]` is the finished dp for these stations `[[10,60], [20,30], [30, 30], [60,40]]` with a startFuel of `10` and target of `100`.\\nSo if we fuel `0` times we can see in `dp[0]` that we can travel only a distance of `10`.\\nAt `dp[2]` we can travel `110`, thats above the `100` target. Because of that, the result is 2.\\n\\nFor the solution, we init an array called `dp` will zeros and the first position will be filled with the startFuel.\\nSo the dp array will look like : [startFuel, 0, 0, ... ]. \\nThe length will be `stations.length + 1` since we can drive without a station also.\\n\\nThen we iterate through each station and inside this iteration we iterate backwards from the first iteration.\\nThat way we can update all the stations before with the current station iteration.\\n\\nFor the last step, we just check at wich dp position we have the same or higher amount of travel distance, and return its index. \\uD83D\\uDC4C\\n```\\nvar minRefuelStops = function(target, startFuel, stations) {\\n  let dp = new Array(stations.length+1).fill(0);\\n  dp[0] = startFuel;\\n  \\n  for (let i = 0; i < stations.length; i++)\\n    for (let j = i; j >= 0; j--)\\n      if (dp[j] >= stations[i][0])\\n        dp[j+1] = Math.max(dp[j+1], dp[j] + stations[i][1])\\n  \\n  for (let [index, value] of dp.entries()) \\n    if (value >= target) return index;\\n  return -1;\\n};\\n```\\nIf you liked my explanation, please upvote. \\uD83D\\uDE0A",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minRefuelStops = function(target, startFuel, stations) {\\n  let dp = new Array(stations.length+1).fill(0);\\n  dp[0] = startFuel;\\n  \\n  for (let i = 0; i < stations.length; i++)\\n    for (let j = i; j >= 0; j--)\\n      if (dp[j] >= stations[i][0])\\n        dp[j+1] = Math.max(dp[j+1], dp[j] + stations[i][1])\\n  \\n  for (let [index, value] of dp.entries()) \\n    if (value >= target) return index;\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456077,
                "title": "for-who-didn-t-get-the-idea-behind-the-dp-solution",
                "content": "```\\n\\t       for(int i=0; i<stations.size(); i++){\\n            for(int j=i; j>=0; j--){\\n                if(dp[j]>=stations[i][0])\\n                dp[j+1]=max(dp[j+1],dp[j]+stations[i][1]);\\n            }\\n        }\\n```\\nif you are not able to understand this line.\\nLet me help You:\\nsuppose we have an array\\nstartFuel=10, target=100\\n[10,60],[20,20],[30,30],[60,20]\\nso for every station **i** You have to go back and check wheather we can directly come to **i** from j or not or you have to fuel with more stations.. \\n***lets talk about j+1***\\nwe store in j+1 because when we reached jth position with help of previous fuel so we store the currentfuel+is any need to fuel the car or not \\nwhen needed : if we can travel more with fuel..\\nlets talk about second for loop:\\nso think with the help of example:\\nhere for i=0 startFuel=10;\\nand station is at distace of 10 so we can travel of distance 10 and now fuel in our car is 0 so we have to fill the tank otherwise we can\\'t move.\\nafter refueling we can travel upto 60 of distance so atmost total distance we can cover is 70;\\nbut the target is 100 we need 30 fuel more to reach the target so the second while loop helps to go back and check for wheather we can fuel by more station to reach the target or not.\\nso firstl it goes at distance 20 but 70+20<100 then we can add 30 so we get 70+20+30>100\\nthink littlebit here no needof 20 we can directly jump from 30.\\nour dp looks like 10,70,100,120,140\\n\\nif you have any doubt comment below.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t       for(int i=0; i<stations.size(); i++){\\n            for(int j=i; j>=0; j--){\\n                if(dp[j]>=stations[i][0])\\n                dp[j+1]=max(dp[j+1],dp[j]+stations[i][1]);\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454841,
                "title": "c-with-comments-easy-pq",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int count=0; //will store our answer\\n        int maxWeCanReach=startFuel;\\n        int index=0;\\n        priority_queue<int>maxHeap; // to get station with maximum fuel \\n        \\n        while(maxWeCanReach<target) //until we reach the target\\n        {\\n            \\n            //index<stations.size(): \\n            //until we reach to the end\\n            \\n            //stations[index][0]<=maxWeCanReach:\\n            //we have traversed means we could have fueled our car if needed so put in queue\\n            while(index<stations.size() && stations[index][0]<=maxWeCanReach)\\n            {\\n                maxHeap.push(stations[index][1]);\\n                index++;\\n            }\\n            \\n            if(maxHeap.empty()) //no fuel stations but we have not reached yet and we can\\'t now\\n                return -1;\\n            \\n            int getMaxFuel=maxHeap.top();\\n            maxHeap.pop();\\n            \\n            maxWeCanReach +=getMaxFuel;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int count=0; //will store our answer\\n        int maxWeCanReach=startFuel;\\n        int index=0;\\n        priority_queue<int>maxHeap; // to get station with maximum fuel \\n        \\n        while(maxWeCanReach<target) //until we reach the target\\n        {\\n            \\n            //index<stations.size(): \\n            //until we reach to the end\\n            \\n            //stations[index][0]<=maxWeCanReach:\\n            //we have traversed means we could have fueled our car if needed so put in queue\\n            while(index<stations.size() && stations[index][0]<=maxWeCanReach)\\n            {\\n                maxHeap.push(stations[index][1]);\\n                index++;\\n            }\\n            \\n            if(maxHeap.empty()) //no fuel stations but we have not reached yet and we can\\'t now\\n                return -1;\\n            \\n            int getMaxFuel=maxHeap.top();\\n            maxHeap.pop();\\n            \\n            maxWeCanReach +=getMaxFuel;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453822,
                "title": "c-priority-queue-solution",
                "content": "```\\nint minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        // this pq will store the fuel quantity of the stations we can reach \\n        priority_queue<int> pq;\\n        int stops = 0, pos = startFuel;\\n        \\n        for (int p = 0; p < stations.size(); p++) {\\n            // if we cannot reach the current stations then we start filling the fuel from all \\n            // the previously reached stations in order that the one with the highest fuel quantity \\n            // is visited first\\n\\n            while (pos < stations[p][0]) { \\n                if (pq.empty()) return -1;\\n                pos += pq.top();\\n                ++stops;\\n                pq.pop();\\n            }\\n            // we add current station fuel quantity to priority queue because we have reached \\n            // this station and we can fuel at this station if need be\\n            pq.push(stations[p][1]); \\n        }\\n        \\n        // final check if we can reach target consuming fuel from all remaining stations in similar \\n        // order as earlier\\n        while (pos < target) {\\n            if (pq.empty()) return -1;\\n            pos += pq.top();\\n            ++stops;\\n            pq.pop();\\n        }\\n        \\n        return stops;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        // this pq will store the fuel quantity of the stations we can reach \\n        priority_queue<int> pq;\\n        int stops = 0, pos = startFuel;\\n        \\n        for (int p = 0; p < stations.size(); p++) {\\n            // if we cannot reach the current stations then we start filling the fuel from all \\n            // the previously reached stations in order that the one with the highest fuel quantity \\n            // is visited first\\n\\n            while (pos < stations[p][0]) { \\n                if (pq.empty()) return -1;\\n                pos += pq.top();\\n                ++stops;\\n                pq.pop();\\n            }\\n            // we add current station fuel quantity to priority queue because we have reached \\n            // this station and we can fuel at this station if need be\\n            pq.push(stations[p][1]); \\n        }\\n        \\n        // final check if we can reach target consuming fuel from all remaining stations in similar \\n        // order as earlier\\n        while (pos < target) {\\n            if (pq.empty()) return -1;\\n            pos += pq.top();\\n            ++stops;\\n            pq.pop();\\n        }\\n        \\n        return stops;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453525,
                "title": "cpp-100-fastest-no-dp-no-priority-queue-easiest-o-n2",
                "content": "We keep on increasing our window of search and from that we take maximum fuel from one station and then check again.\\nEx- \\nIn TC-\\n1000\\n299\\n[[13,21],[26,115],[100,47],[225,99],[299,141],[444,198],[608,190],[636,157],[647,255],[841,123]]\\n\\nFirst we have window upto distance of 299 miles, so our maximum fuel is 141 that we can get from station 5th.\\n\\nNow, our window of search has increased by (299+141= 440), now we again look for that fuel station that can give us\\nmaximum fuel. \\n\\tNow, fuel station 2 turns out to be that fuel station. Now, our search range will increase by (299+141+115 = 555)   ...\\n\\t\\n\\t\\n\\tIn, this way we keep on looking for the best stations, until we reach the target.  \\n\\t\\n\\tIn worst case when we don\\'t reach to our target, I wrote the case in which moves will be greater than 500. \\n\\tRemember, Only upto 500 stations are possible.\\n\\n```\\n#define ll long long\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        if(startFuel>= target){\\n            return 0;\\n        }\\n       \\n        int move=0;\\n            \\n        ll dis=startFuel;\\n        ll look=startFuel;\\n        ll covered=0;\\n        ll mx=0;\\n        \\n        int j=0;\\n        int x=stations.size();\\n        vector<bool> vis(x+1 ,false);\\n        \\n        while(dis<target){\\n            \\n             mx=INT_MIN; int nowd=-1;\\n            for(int i=0; i<x;i++){\\n               if( stations[i][0] <= look){\\n                   if(!vis[i] && stations[i][1]>=mx){\\n                       mx=stations[i][1];\\n                       nowd=stations[i][0];\\n                       j=i;\\n                   }\\n                   \\n               } else\\n                       break;\\n            }\\n            \\n            vis[j]=true;\\n            \\n            dis+= mx;\\n            look+=mx;\\n            \\n            move++;\\n            if(move>501) return -1;\\n        }\\n        return move;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        if(startFuel>= target){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2453314,
                "title": "python-solution-with-easy-understanding-easy-intuition",
                "content": "This is not a new solution, but I just wanted to explain how I approached this. \\n\\nIdea is :\\n* \\twhen you reach any station, take the fuel with yourself. **ALWAYS**  ( but dont put it into your fuel tank, hence you dont have to count this pick up )\\n* \\tpick up the max fuel in your backup and add it to fuel tank when you run out of fuel. Now you just need to keep count of how many times you used the backup.\\n* \\tEasy peasy ... reach the target now with above appraoch.\\n\\n```\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        prev =  count = 0\\n        remaining = startFuel\\n        backup = []\\n\\t\\t\\n\\t\\t# added target as last station\\n        stations.append((target, 0))\\n        for pos, fuel in stations:\\n            prev, pos = pos, pos-prev\\n            \\n\\t\\t\\t# take the fuel only when you need it and if available\\n            while remaining < pos and backup:\\n\\t\\t\\t\\t# we take the max fuel ( available at the top of the heap ) so that we reach as far as possible\\n                remaining += ( -1 * ( heapq.heappop( backup ) ) )\\n                count += 1\\n\\t\\t\\t\\n\\t\\t\\t# Even after using the backup fuel, if you cant reach the next station...  :(  \\n            if remaining < pos:\\n                return -1\\n\\t\\t\\t\\n            remaining -= pos\\n\\t\\t\\t\\n\\t\\t\\t# lets be greedy, and take the fuel as our backup\\n            heapq.heappush(backup, -1 * fuel) # note that heapq maintains minheap hence we insert fuel in negative so that we have max fuel at the top\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        prev =  count = 0\\n        remaining = startFuel\\n        backup = []\\n\\t\\t\\n\\t\\t# added target as last station\\n        stations.append((target, 0))\\n        for pos, fuel in stations:\\n            prev, pos = pos, pos-prev\\n            \\n\\t\\t\\t# take the fuel only when you need it and if available\\n            while remaining < pos and backup:\\n\\t\\t\\t\\t# we take the max fuel ( available at the top of the heap ) so that we reach as far as possible\\n                remaining += ( -1 * ( heapq.heappop( backup ) ) )\\n                count += 1\\n\\t\\t\\t\\n\\t\\t\\t# Even after using the backup fuel, if you cant reach the next station...  :(  \\n            if remaining < pos:\\n                return -1\\n\\t\\t\\t\\n            remaining -= pos\\n\\t\\t\\t\\n\\t\\t\\t# lets be greedy, and take the fuel as our backup\\n            heapq.heappush(backup, -1 * fuel) # note that heapq maintains minheap hence we insert fuel in negative so that we have max fuel at the top\\n            \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2452628,
                "title": "c-full-explained-clean-code-with-comments",
                "content": "**Easy  Solution Using Priority Queue :**\\n\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n//         max heap \\n        priority_queue<int>p;\\n        \\n        int position = 0;\\n        int fuelFillCount = 0;\\n        int size = stations.size();\\n        \\n        \\n        while(startFuel < target){\\n//             checking how many stations can we reach and the maximum fuel we can have  \\n            while(position < size && startFuel >= stations[position][0]){\\n                \\n                p.push(stations[position][1]);\\n                position++;\\n            \\n            }\\n            \\n//             if no station is arrived with the current fuel => max heap will be empty\\n            if(p.empty()) return -1;\\n            \\n//             if we are here means we have fuel to move further  \\n//             take the max fuel and add it startFuel \\n            int dis = p.top();\\n            p.pop();\\n            \\n            startFuel += dis;\\n            \\n//             we successfully filled fuel at the station \\n            fuelFillCount++;\\n        }\\n        return fuelFillCount;\\n        \\n    }\\n};\\n```\\n**Do UpVote**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n//         max heap \\n        priority_queue<int>p;\\n        \\n        int position = 0;\\n        int fuelFillCount = 0;\\n        int size = stations.size();\\n        \\n        \\n        while(startFuel < target){\\n//             checking how many stations can we reach and the maximum fuel we can have  \\n            while(position < size && startFuel >= stations[position][0]){\\n                \\n                p.push(stations[position][1]);\\n                position++;\\n            \\n            }\\n            \\n//             if no station is arrived with the current fuel => max heap will be empty\\n            if(p.empty()) return -1;\\n            \\n//             if we are here means we have fuel to move further  \\n//             take the max fuel and add it startFuel \\n            int dis = p.top();\\n            p.pop();\\n            \\n            startFuel += dis;\\n            \\n//             we successfully filled fuel at the station \\n            fuelFillCount++;\\n        }\\n        return fuelFillCount;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451482,
                "title": "elixir-rust-priority-queue-solution",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec min_refuel_stops(target :: integer, start_fuel :: integer, stations :: [[integer]]) ::\\n          integer\\n  def min_refuel_stops(target, start_fuel, stations) do\\n    (stations ++ [[target, 0]])\\n    |> Enum.reduce_while({0, start_fuel, :gb_sets.new()}, fn station, {ans, tank, pq} ->\\n      refuel(tank, station, pq, ans)\\n    end)\\n    |> elem(0)\\n  end\\n\\n  def refuel(tank, [pos, fuel], pq, ans) when tank >= pos do\\n    # can\\'t simply add(fuel, pq) because gb_sets ignore duplicate fuel\\n    {:cont, {ans, tank, :gb_sets.add({fuel, pos}, pq)}}\\n  end\\n\\n  def refuel(tank, [pos, fuel], pq, ans) do\\n    if :gb_sets.is_empty(pq) do\\n      {:halt, {-1}}\\n    else\\n      {{f, _}, pq} = :gb_sets.take_largest(pq)\\n      refuel(tank + f, [pos, fuel], pq, ans + 1)\\n    end\\n  end\\nend\\n```\\n\\n```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn min_refuel_stops(target: i32, start_fuel: i32, mut stations: Vec<Vec<i32>>) -> i32 {\\n        let mut pq = BinaryHeap::new();\\n        let mut tank = start_fuel;\\n        let mut ans = 0;\\n        stations.push(vec![target, 0]);\\n        for station in &stations {\\n            while tank < station[0] {\\n                if pq.is_empty() {\\n                    return -1;\\n                }\\n                tank += pq.pop().unwrap();\\n                ans += 1;\\n            }\\n            pq.push(station[1]);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Heap (Priority Queue)"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec min_refuel_stops(target :: integer, start_fuel :: integer, stations :: [[integer]]) ::\\n          integer\\n  def min_refuel_stops(target, start_fuel, stations) do\\n    (stations ++ [[target, 0]])\\n    |> Enum.reduce_while({0, start_fuel, :gb_sets.new()}, fn station, {ans, tank, pq} ->\\n      refuel(tank, station, pq, ans)\\n    end)\\n    |> elem(0)\\n  end\\n\\n  def refuel(tank, [pos, fuel], pq, ans) when tank >= pos do\\n    # can\\'t simply add(fuel, pq) because gb_sets ignore duplicate fuel\\n    {:cont, {ans, tank, :gb_sets.add({fuel, pos}, pq)}}\\n  end\\n\\n  def refuel(tank, [pos, fuel], pq, ans) do\\n    if :gb_sets.is_empty(pq) do\\n      {:halt, {-1}}\\n    else\\n      {{f, _}, pq} = :gb_sets.take_largest(pq)\\n      refuel(tank + f, [pos, fuel], pq, ans + 1)\\n    end\\n  end\\nend\\n```\n```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn min_refuel_stops(target: i32, start_fuel: i32, mut stations: Vec<Vec<i32>>) -> i32 {\\n        let mut pq = BinaryHeap::new();\\n        let mut tank = start_fuel;\\n        let mut ans = 0;\\n        stations.push(vec![target, 0]);\\n        for station in &stations {\\n            while tank < station[0] {\\n                if pq.is_empty() {\\n                    return -1;\\n                }\\n                tank += pq.pop().unwrap();\\n                ans += 1;\\n            }\\n            pq.push(station[1]);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2451372,
                "title": "easy-solution-using-priority-queue-cpp",
                "content": "**Please Upvote....**\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int>q;\\n        \\n        long long int i=startFuel,ans=0,j=0;\\n        \\n        while(target-i>0){\\n            while(j<stations.size() && i>=stations[j][0]){\\n                q.push(stations[j][1]);\\n                j++;\\n            }\\n            \\n            if(i<target){\\n                if(q.empty())return -1;\\n                ans++;\\n                i+=q.top();\\n                q.pop();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int>q;\\n        \\n        long long int i=startFuel,ans=0,j=0;\\n        \\n        while(target-i>0){\\n            while(j<stations.size() && i>=stations[j][0]){\\n                q.push(stations[j][1]);\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2451236,
                "title": "c-dp-heap-aprroaches-l-greedy-l-time-o-n-2-l-space-o-n",
                "content": "Dynamic Programming Approach:\\n\\n```\\nclass Solution {\\n public:\\n  int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n    // dp[i] := farthest position we can reach w/ i refuels\\n    vector<long> dp(stations.size() + 1);\\n    dp[0] = startFuel;\\n\\n    for (int i = 0; i < stations.size(); ++i)\\n      for (int j = i + 1; j > 0; --j)\\n        if (dp[j - 1] >=\\n            stations[i][0])  // with j - 1 refuels, we can reach stations[i][0]\\n          dp[j] = max(dp[j], dp[j - 1] + stations[i][1]);\\n\\n    for (int i = 0; i < dp.size(); ++i)\\n      if (dp[i] >= target)\\n        return i;\\n\\n    return -1;\\n  }\\n};\\n\\n```\\n\\nHeap Approach:\\n```\\nclass Solution {\\n public:\\n  int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n    int ans = 0;\\n    int i = 0;  // stations\\'s index\\n    int curr = startFuel;\\n    priority_queue<int> maxHeap;\\n\\n    while (curr < target) {\\n      // add all reachable stops to maxHeap\\n      while (i < stations.size() && curr >= stations[i][0])\\n        maxHeap.push(stations[i++][1]);\\n      if (maxHeap.empty())  // we can\\'t refuel\\n        return -1;\\n      curr += maxHeap.top(), maxHeap.pop();  // pop out the largest gas\\n      ++ans;                                 // then refuel once\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n    // dp[i] := farthest position we can reach w/ i refuels\\n    vector<long> dp(stations.size() + 1);\\n    dp[0] = startFuel;\\n\\n    for (int i = 0; i < stations.size(); ++i)\\n      for (int j = i + 1; j > 0; --j)\\n        if (dp[j - 1] >=\\n            stations[i][0])  // with j - 1 refuels, we can reach stations[i][0]\\n          dp[j] = max(dp[j], dp[j - 1] + stations[i][1]);\\n\\n    for (int i = 0; i < dp.size(); ++i)\\n      if (dp[i] >= target)\\n        return i;\\n\\n    return -1;\\n  }\\n};\\n\\n```\n```\\nclass Solution {\\n public:\\n  int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n    int ans = 0;\\n    int i = 0;  // stations\\'s index\\n    int curr = startFuel;\\n    priority_queue<int> maxHeap;\\n\\n    while (curr < target) {\\n      // add all reachable stops to maxHeap\\n      while (i < stations.size() && curr >= stations[i][0])\\n        maxHeap.push(stations[i++][1]);\\n      if (maxHeap.empty())  // we can\\'t refuel\\n        return -1;\\n      curr += maxHeap.top(), maxHeap.pop();  // pop out the largest gas\\n      ++ans;                                 // then refuel once\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451229,
                "title": "go-golang-solution",
                "content": "```\\nfunc minRefuelStops(target int, startFuel int, stations [][]int) int {\\n    N, dp := len(stations), make([]int, len(stations)+1)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = startFuel\\n\\t}\\n\\tfor i := 0; i < N; i++ {\\n\\t\\tfor j := i; j >= 0 && dp[j] >= stations[i][0]; j-- {\\n\\t\\t\\tdp[j+1] = max(dp[j+1], dp[j]+stations[i][1])\\n\\t\\t}\\n\\t}\\n\\tfor i := range dp {\\n\\t\\tif dp[i] >= target {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i >= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minRefuelStops(target int, startFuel int, stations [][]int) int {\\n    N, dp := len(stations), make([]int, len(stations)+1)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = startFuel\\n\\t}\\n\\tfor i := 0; i < N; i++ {\\n\\t\\tfor j := i; j >= 0 && dp[j] >= stations[i][0]; j-- {\\n\\t\\t\\tdp[j+1] = max(dp[j+1], dp[j]+stations[i][1])\\n\\t\\t}\\n\\t}\\n\\tfor i := range dp {\\n\\t\\tif dp[i] >= target {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i >= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2184207,
                "title": "c-commented-solution-priority-queue-easy",
                "content": "**PLEASE UPVOTE IF YOU LIKE APPROACH AND IN CASE YOU HAVE ANY DOUBT COMMENT IT PLEASE**\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) \\n    {\\n       //starting from given fuel to reach target\\n       int max_u_can_reach = startFuel;\\n       int count = 0;\\n       int index = 0;     \\n            priority_queue<int>pq;\\n             // if you reach target simple exit from loop\\n            while(max_u_can_reach < target)      \\n            {\\n                    // storing fuel provided by gas staions in priority queue\\n                    while(index < stations.size() && stations[index][0] <= max_u_can_reach)\\n                    {\\n                            pq.push(stations[index][1]);//fuel\\n                            index++;\\n                    }\\n                    \\n                    if(pq.empty()) return -1;\\n                    //max value that you are getting at top of priority queue \\n                    max_u_can_reach += pq.top();\\n                    pq.pop();\\n                    count++;\\n            }\\n            return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) \\n    {\\n       //starting from given fuel to reach target\\n       int max_u_can_reach = startFuel;\\n       int count = 0;\\n       int index = 0;     \\n            priority_queue<int>pq;\\n             // if you reach target simple exit from loop\\n            while(max_u_can_reach < target)      \\n            {\\n                    // storing fuel provided by gas staions in priority queue\\n                    while(index < stations.size() && stations[index][0] <= max_u_can_reach)\\n                    {\\n                            pq.push(stations[index][1]);//fuel\\n                            index++;\\n                    }\\n                    \\n                    if(pq.empty()) return -1;\\n                    //max value that you are getting at top of priority queue \\n                    max_u_can_reach += pq.top();\\n                    pq.pop();\\n                    count++;\\n            }\\n            return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181151,
                "title": "all-3-approaches-2-d-dp-1-d-dp-greedy-c",
                "content": "**Approach-1: 2-D DP**\\n\\ndp[i][j] = farthest distance we can go from 0 while using j stops out of first i stops.\\n\\nBase Case: \\nWithout using any stops, we can only use starting fuel, so, \\ndp[1][0] = dp[2][0] = .... dp[n][0] = startFuel \\n\\nAt each stop, we have to options:\\n*Option1:* To not use the current stop.\\nIf we don\\'t use fuel at current stop, the farthest distance that we can reach will remain the same as at previous stop. (i-1 for previous stop & j because no of stops used didn\\'t change)\\n*Option2*: To use the current stop.\\nIf we use fuel at current stop, the farthest distance that we can go will increase by the fuel present at current stop (a[i-1]). So, it will be The fuel at current stop stop + distance travelled till previous stop. (i-1 for previous stop and j-1 as no of stops used increased at current stop) We also need to check whether we an even reach this fuel station or not.\\n\\nWe, store the maximum of both options at dp[i][j]. \\n\\nNow, columns of the last row of dp will tell us the maximum distance that we can travel while using a maximum of 0,1,2,...,n stops respectively. We will look for the first column where we could actually reach target as that will use smallest no of stops. If no such column exists, then we can\\'t reach the target.\\n\\nTime: O(N^2)\\nSpace: O(N^2)\\n\\nCode:\\n```\\nclass Solution\\n{\\n    public:\\n        int minRefuelStops(int target, int startFuel, vector<vector < int>> &a)\\n        {\\n            int n = a.size(), i, j;\\n            vector<vector < long long int>> dp(n + 1, vector < long long int > (n + 1, 0));\\n            for (i = 0; i <= n; i++)\\n                dp[i][0] = startFuel;\\n            for (i = 1; i <= n; i++)\\n            {\\n                for (j = 1; j <= i; j++)\\n                {\\n                    int op1 = dp[i - 1][j], op2 = 0;\\n                    if (dp[i - 1][j - 1] >= a[i - 1][0])\\n                        op2 = dp[i - 1][j - 1] + a[i - 1][1];\\n                    dp[i][j] = max(op1, op2);\\n                }\\n            }\\n            for (j = 0; j <= n; j++)\\n            {\\n                if (dp[n][j] >= target)\\n                    return j;\\n            }\\n            return -1;\\n        }\\n};\\n```\\n\\n**Approach-2: 1-D DP**\\n\\nObservation-1: While filling each row of dp, we only require the previous row. So, instead of storing all the rows, we can only store the previous row and update it with values for the current row so as to save space.\\n\\nObservation-2:\\nFilling of each column requires values from current as well as previous column. So, dp values for the previous row will be overwrriten with the dp values for the current row (we actually want this, but this will also affect filling of the very next column as the values that it require have just been overwritten). So, we fill each row in reverse.\\n\\nTime: O(N^2)\\nSpace: O(N)\\n\\nCode:\\n```\\nclass Solution\\n{\\n    public:\\n        int minRefuelStops(int target, int startFuel, vector<vector < int>> &a)\\n        {\\n            int i, j, n = a.size();\\n            vector < long long int > dp(n + 1, 0);\\n            dp[0] = startFuel;\\n            for (i = 1; i <= n; i++)\\n            {\\n                for (j = i; j >= 1; j--)\\n                {\\n                    int op1 = dp[j], op2 = 0;\\n                    if (dp[j - 1] >= a[i - 1][0])\\n                        op2 = dp[j - 1] + a[i - 1][1];\\n                    dp[j] = max(op1, op2);\\n                }\\n            }\\n            for (j = 0; j <= n; j++)\\n            {\\n                if (dp[j] >= target)\\n                    return j;\\n            }\\n            return -1;\\n        }\\n};\\n```\\n\\n**Approach-3: Greedy**\\n\\nInstead of filling fuels, we just visit each station and store the amount of fuel available in a max-heap. And when remaining fuel gets finished, we then say that we will use fuel at the station which has the largest fuel available till now. We do so by using value at top of heap and increasing our count of stops used. We keep doing this until either we actually reach the current station with the fuel or all stations have been used.\\n\\nTime: O(N*logN)\\nSpace: O(N)\\n\\nCode:\\n```\\nclass Solution\\n{\\n    public:\\n        int minRefuelStops(int target, int fuel, vector<vector < int>> &a)\\n        {\\n            priority_queue < long long int > pq;\\n            long long int prev = 0, cur, diff, count = 0, i, n = a.size();\\n            for (i = 0; i < n; i++)\\n            {\\n                cur = a[i][0];\\n                diff = cur - prev;\\n                while (!pq.empty() && fuel < diff)\\n                {\\n                    fuel += pq.top();\\n                    pq.pop();\\n                    count++;\\n                }\\n                if (fuel < diff)\\n                    return -1;\\n                fuel -= diff;\\n                pq.push(a[i][1]);\\n                prev = cur;\\n            }\\n            cur = target;\\n            diff = cur - prev;\\n            while (!pq.empty() && fuel < diff)\\n            {\\n                fuel += pq.top();\\n                pq.pop();\\n                count++;\\n            }\\n            if (fuel < diff)\\n                return -1;\\n            else\\n                return count;\\n        }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minRefuelStops(int target, int startFuel, vector<vector < int>> &a)\\n        {\\n            int n = a.size(), i, j;\\n            vector<vector < long long int>> dp(n + 1, vector < long long int > (n + 1, 0));\\n            for (i = 0; i <= n; i++)\\n                dp[i][0] = startFuel;\\n            for (i = 1; i <= n; i++)\\n            {\\n                for (j = 1; j <= i; j++)\\n                {\\n                    int op1 = dp[i - 1][j], op2 = 0;\\n                    if (dp[i - 1][j - 1] >= a[i - 1][0])\\n                        op2 = dp[i - 1][j - 1] + a[i - 1][1];\\n                    dp[i][j] = max(op1, op2);\\n                }\\n            }\\n            for (j = 0; j <= n; j++)\\n            {\\n                if (dp[n][j] >= target)\\n                    return j;\\n            }\\n            return -1;\\n        }\\n};\\n```\n```\\nclass Solution\\n{\\n    public:\\n        int minRefuelStops(int target, int startFuel, vector<vector < int>> &a)\\n        {\\n            int i, j, n = a.size();\\n            vector < long long int > dp(n + 1, 0);\\n            dp[0] = startFuel;\\n            for (i = 1; i <= n; i++)\\n            {\\n                for (j = i; j >= 1; j--)\\n                {\\n                    int op1 = dp[j], op2 = 0;\\n                    if (dp[j - 1] >= a[i - 1][0])\\n                        op2 = dp[j - 1] + a[i - 1][1];\\n                    dp[j] = max(op1, op2);\\n                }\\n            }\\n            for (j = 0; j <= n; j++)\\n            {\\n                if (dp[j] >= target)\\n                    return j;\\n            }\\n            return -1;\\n        }\\n};\\n```\n```\\nclass Solution\\n{\\n    public:\\n        int minRefuelStops(int target, int fuel, vector<vector < int>> &a)\\n        {\\n            priority_queue < long long int > pq;\\n            long long int prev = 0, cur, diff, count = 0, i, n = a.size();\\n            for (i = 0; i < n; i++)\\n            {\\n                cur = a[i][0];\\n                diff = cur - prev;\\n                while (!pq.empty() && fuel < diff)\\n                {\\n                    fuel += pq.top();\\n                    pq.pop();\\n                    count++;\\n                }\\n                if (fuel < diff)\\n                    return -1;\\n                fuel -= diff;\\n                pq.push(a[i][1]);\\n                prev = cur;\\n            }\\n            cur = target;\\n            diff = cur - prev;\\n            while (!pq.empty() && fuel < diff)\\n            {\\n                fuel += pq.top();\\n                pq.pop();\\n                count++;\\n            }\\n            if (fuel < diff)\\n                return -1;\\n            else\\n                return count;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517725,
                "title": "java-using-priorityqueue",
                "content": "Using PriorityQueue or Max heap\\nJust check whether you can reach max distance or not otherwise refuel from the pump having maximum fuel value.\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startfuel, int[][] stations) {\\n        if(target==startfuel){\\n            return 0;\\n        }\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        int ans=0;\\n        int i=0;\\n        while(i<stations.length){\\n            int a=stations[i][0];\\n            int b=stations[i][1];\\n            if(startfuel>=a){\\n                pq.add(b);\\n                i++;\\n            }\\n            else{\\n                if(pq.size()!=0){\\n                    startfuel+=pq.remove();\\n                }\\n                else{\\n                    return -1;\\n                }\\n                ans++;\\n            }\\n        }\\n        while(startfuel<target){\\n            if(pq.size()!=0){\\n                startfuel+=pq.remove();\\n            }\\n            else{\\n                return -1;\\n            }\\n            ans++;\\n        }\\n        if(startfuel>=target){\\n            return ans;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startfuel, int[][] stations) {\\n        if(target==startfuel){\\n            return 0;\\n        }\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        int ans=0;\\n        int i=0;\\n        while(i<stations.length){\\n            int a=stations[i][0];\\n            int b=stations[i][1];\\n            if(startfuel>=a){\\n                pq.add(b);\\n                i++;\\n            }\\n            else{\\n                if(pq.size()!=0){\\n                    startfuel+=pq.remove();\\n                }\\n                else{\\n                    return -1;\\n                }\\n                ans++;\\n            }\\n        }\\n        while(startfuel<target){\\n            if(pq.size()!=0){\\n                startfuel+=pq.remove();\\n            }\\n            else{\\n                return -1;\\n            }\\n            ans++;\\n        }\\n        if(startfuel>=target){\\n            return ans;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476123,
                "title": "20-ms-faster-than-95-40-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int> pq;  // We\\'re trying to store the maximum value of fuel where we can reach by just startfuel\\n\\t\\t// Like if we have startfuel =10  and given stations are [[2,10],[4,10],[8,20]] \\n\\t\\t// then pq will be like this 20 10 10 and will add 20 in startfuel for next time and will iterate it till pq becomes empty or startfuel<target\\n\\t\\t// otherwise -1 will be returned\\n        pq.push(startFuel);\\n        int count=0;\\n        int i=0;\\n        startFuel=0;\\n        int n=stations.size();\\n        while(!pq.empty()){\\n            int fuel=pq.top();\\n            startFuel+=fuel;\\n            if(startFuel>=target){\\n                return count;\\n            }\\n            pq.pop();\\n            while(i<n and stations[i][0]<=startFuel){\\n                pq.push(stations[i][1]);\\n                i++;\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int> pq;  // We\\'re trying to store the maximum value of fuel where we can reach by just startfuel\\n\\t\\t// Like if we have startfuel =10  and given stations are [[2,10],[4,10],[8,20]] \\n\\t\\t// then pq will be like this 20 10 10 and will add 20 in startfuel for next time and will iterate it till pq becomes empty or startfuel<target\\n\\t\\t// otherwise -1 will be returned\\n        pq.push(startFuel);\\n        int count=0;\\n        int i=0;\\n        startFuel=0;\\n        int n=stations.size();\\n        while(!pq.empty()){\\n            int fuel=pq.top();\\n            startFuel+=fuel;\\n            if(startFuel>=target){\\n                return count;\\n            }\\n            pq.pop();\\n            while(i<n and stations[i][0]<=startFuel){\\n                pq.push(stations[i][1]);\\n                i++;\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279779,
                "title": "java-dp-and-greedy-solution",
                "content": "1. DP state : in the ith stop, use n fill, what is the maximum it can go\\n\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] A) {\\n        if(startFuel>=target)return 0;\\n        Arrays.sort(A,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        \\n        int res=Integer.MAX_VALUE;\\n        \\n        int dp[][]=new int[A.length+1][A.length+1];//at ith stop, use n fill\\n        dp[0][0]=startFuel;\\n        \\n        for(int i=1;i<dp.length;i++){\\n            int least=A[i-1][0];\\n            int add=A[i-1][1];\\n            dp[i][A.length]=dp[i-1][A.length];\\n            for(int j=0;j<dp[0].length-1;j++){\\n                dp[i][j]=Math.max(dp[i-1][j],dp[i][j]);\\n                if(dp[i-1][j]>=least){\\n                    dp[i][j+1]=Math.max(dp[i][j+1],add+dp[i-1][j]);\\n                    if(dp[i][j+1]>=target){\\n                        res=Math.min(res,j+1);\\n                    }\\n                }\\n            }\\n        }\\n    \\n        return res==Integer.MAX_VALUE?-1:res;\\n    }\\n}\\n```\\n\\n2. Greedy : once you do not have enough gas, take the maximum one that you store in your heap,stop as you can get into this station\\n\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] A) {\\n        int cur=startFuel;\\n        int res=0;\\n        Arrays.sort(A,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        PriorityQueue<Integer>pq=new PriorityQueue<>((a,b)->{\\n            return b-a;\\n        });\\n        for(int i=0;i<A.length;i++){\\n            int ith=A[i][0];\\n            int gas=A[i][1];\\n            while(pq.size()>0&&cur<ith){\\n                cur+=pq.poll();\\n                res++;\\n            }\\n            if(cur<ith)return -1;//non-reachble\\n            pq.add(gas);\\n        }\\n        while(pq.size()>0&&cur<target){\\n            cur+=pq.poll();\\n            res++;\\n        }\\n        if(cur<target)return -1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] A) {\\n        if(startFuel>=target)return 0;\\n        Arrays.sort(A,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        \\n        int res=Integer.MAX_VALUE;\\n        \\n        int dp[][]=new int[A.length+1][A.length+1];//at ith stop, use n fill\\n        dp[0][0]=startFuel;\\n        \\n        for(int i=1;i<dp.length;i++){\\n            int least=A[i-1][0];\\n            int add=A[i-1][1];\\n            dp[i][A.length]=dp[i-1][A.length];\\n            for(int j=0;j<dp[0].length-1;j++){\\n                dp[i][j]=Math.max(dp[i-1][j],dp[i][j]);\\n                if(dp[i-1][j]>=least){\\n                    dp[i][j+1]=Math.max(dp[i][j+1],add+dp[i-1][j]);\\n                    if(dp[i][j+1]>=target){\\n                        res=Math.min(res,j+1);\\n                    }\\n                }\\n            }\\n        }\\n    \\n        return res==Integer.MAX_VALUE?-1:res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] A) {\\n        int cur=startFuel;\\n        int res=0;\\n        Arrays.sort(A,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        PriorityQueue<Integer>pq=new PriorityQueue<>((a,b)->{\\n            return b-a;\\n        });\\n        for(int i=0;i<A.length;i++){\\n            int ith=A[i][0];\\n            int gas=A[i][1];\\n            while(pq.size()>0&&cur<ith){\\n                cur+=pq.poll();\\n                res++;\\n            }\\n            if(cur<ith)return -1;//non-reachble\\n            pq.add(gas);\\n        }\\n        while(pq.size()>0&&cur<target){\\n            cur+=pq.poll();\\n            res++;\\n        }\\n        if(cur<target)return -1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267064,
                "title": "rust-max-heap-greedy-solution",
                "content": "``` rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn min_refuel_stops(target: i32, mut fuel: i32, mut stations: Vec<Vec<i32>>) -> i32 {\\n        stations.push(vec![target, 0]);\\n        let mut heap : BinaryHeap<i32> = BinaryHeap::new(); // unused stations seen so far\\n        let mut k = 0; // number of refuels so far\\n        for s in stations.iter() {\\n            while fuel < s[0] { // can\\'t reach s\\n                match heap.pop() {\\n                    Some(f) => {  // we use the largest station to refuel\\n                        fuel = fuel + f; \\n                        k = k + 1\\n                    },\\n                    None => return -1  // no usable station: can\\'t reach target\\n                }\\n            }\\n            heap.push(s[1]);\\n        }\\n        k\\n    }\\n}\\n```\\n\\nLet n be the number of stations.\\nThe max-heap has size at most n, hence any push/pop operation has complexity O(log(n)).\\nSince we are doing these operations at most n times each, the total complexity is O(nlog(n)).",
                "solutionTags": [],
                "code": "``` rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn min_refuel_stops(target: i32, mut fuel: i32, mut stations: Vec<Vec<i32>>) -> i32 {\\n        stations.push(vec![target, 0]);\\n        let mut heap : BinaryHeap<i32> = BinaryHeap::new(); // unused stations seen so far\\n        let mut k = 0; // number of refuels so far\\n        for s in stations.iter() {\\n            while fuel < s[0] { // can\\'t reach s\\n                match heap.pop() {\\n                    Some(f) => {  // we use the largest station to refuel\\n                        fuel = fuel + f; \\n                        k = k + 1\\n                    },\\n                    None => return -1  // no usable station: can\\'t reach target\\n                }\\n            }\\n            heap.push(s[1]);\\n        }\\n        k\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119421,
                "title": "priority-queue-easy-understand",
                "content": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n\\t\\t// the position we can achieve without any fuel\\n        int curr = startFuel;\\n\\t\\t// total number of fueling \\n        int res = 0;\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> b[1] - a[1]);\\n        int index = 0;\\n\\t\\t// The will not stop until we achieve the target\\n        while(curr < target) {\\n\\t\\t\\t// if we don\\'t achieve the target, we need to get fuel. Which one station should we  fuel? That depenses on the maximun fuel we can get by one stop. (Greedy)\\n            while(index < stations.length && stations[index][0] <= curr) {\\n                queue.offer(stations[index]);\\n                index++;\\n            }\\n            if(!queue.isEmpty()) {\\n                int[] station = queue.poll();\\n                res++;\\n                curr += station[1];\\n            }else {\\n                res = -1;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n\\t\\t// the position we can achieve without any fuel\\n        int curr = startFuel;\\n\\t\\t// total number of fueling \\n        int res = 0;\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> b[1] - a[1]);\\n        int index = 0;\\n\\t\\t// The will not stop until we achieve the target\\n        while(curr < target) {\\n\\t\\t\\t// if we don\\'t achieve the target, we need to get fuel. Which one station should we  fuel? That depenses on the maximun fuel we can get by one stop. (Greedy)\\n            while(index < stations.length && stations[index][0] <= curr) {\\n                queue.offer(stations[index]);\\n                index++;\\n            }\\n            if(!queue.isEmpty()) {\\n                int[] station = queue.poll();\\n                res++;\\n                curr += station[1];\\n            }else {\\n                res = -1;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027599,
                "title": "n-logn-solution-c-and-java",
                "content": "Java\\n```\\n/* Solution comments - very clear and concise\\n\\nWhen driving past a gas station, let\\'s remember the amount of fuel it contained. We don\\'t need to decide yet whether to fuel up here or not - for example, there could be a bigger gas station up ahead that we would rather refuel at.\\n\\nWhen we run out of fuel before reaching the next station, we\\'ll retroactively fuel up: greedily choosing the largest gas stations first.\\n\\nThis is guaranteed to succeed because we drive the largest distance possible before each refueling stop, and therefore have the largest choice of gas stations to (retroactively) stop at.\\n*/\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if(startFuel >= target) return 0;\\n        if(stations.length == 0 && (startFuel < target)) return -1;\\n        if(startFuel < stations[0][0]) return -1;\\n        \\n        // Max-heap\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        // consider each station provides a jump of remainingfuel + station[i][0] + station[i][1]\\n        int jumps = 0, prevLoc = 0, currentFuel = startFuel;\\n        \\n        for(int loc[] : stations){\\n            currentFuel -= (loc[0]-prevLoc);\\n            \\n            // let initial = 30\\n            // [[10,50],[20,5],[40,13],[97,1],[100,0]]\\n            // we need a loop to keep refueling until either we are out of fuel or tank gets enough fuel\\n            // In this case when we reach at 97, we have (5,2) in pq and we would need to fill all\\n            while(!pq.isEmpty() && currentFuel < 0){\\n                currentFuel += pq.poll();\\n                jumps++;\\n            }\\n            \\n            // if by refueling at all prev stations, the tank was < 0, we will never reach dest\\n            if(currentFuel < 0) return -1;\\n            \\n            pq.add(loc[1]);\\n            prevLoc = loc[0];\\n        }\\n        \\n\\t\\t//*************************************************\\n        // repeating for cases like\\n        // 100\\n        // 50\\n        // [[40,50]]\\n        // alternatively we could also check if (stations[stations.length-1][0] < target) we may add [target, 0] in stations\\n        {\\n            currentFuel -= (target-prevLoc);\\n            \\n            while(!pq.isEmpty() && currentFuel < 0){\\n                currentFuel += pq.poll();\\n                jumps++;\\n            }\\n\\t\\t\\t\\n            if(currentFuel < 0) return -1;\\n        }\\n        \\n        return jumps;\\n    }\\n}\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        if(startFuel >= target) return 0;\\n        if(stations.size() == 0 && (startFuel < target)) return -1;\\n        if(startFuel < stations[0][0]) return -1;\\n        \\n        // see java sol comments below //************************************************* for need of adding below lines\\n        if(stations[stations.size()-1][0] < target)\\n            stations.push_back({target, 0});\\n        \\n        // Max-heap\\n        priority_queue<int> pq;\\n        // consider each station provides a jump of remainingfuel + station[i][0] + station[i][1]\\n        int jumps = 0, prevLoc = 0, currentFuel = startFuel;\\n        \\n        for(vector<int> loc : stations){\\n            currentFuel -= (loc[0]-prevLoc);\\n            \\n            while(pq.size() > 0 && currentFuel < 0){\\n                currentFuel += pq.top();\\n                pq.pop();\\n                jumps++;\\n            }\\n            \\n            if(currentFuel < 0) return -1;\\n            \\n            pq.push(loc[1]);\\n            prevLoc = loc[0];\\n        }\\n        \\n        return jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/* Solution comments - very clear and concise\\n\\nWhen driving past a gas station, let\\'s remember the amount of fuel it contained. We don\\'t need to decide yet whether to fuel up here or not - for example, there could be a bigger gas station up ahead that we would rather refuel at.\\n\\nWhen we run out of fuel before reaching the next station, we\\'ll retroactively fuel up: greedily choosing the largest gas stations first.\\n\\nThis is guaranteed to succeed because we drive the largest distance possible before each refueling stop, and therefore have the largest choice of gas stations to (retroactively) stop at.\\n*/\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if(startFuel >= target) return 0;\\n        if(stations.length == 0 && (startFuel < target)) return -1;\\n        if(startFuel < stations[0][0]) return -1;\\n        \\n        // Max-heap\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        // consider each station provides a jump of remainingfuel + station[i][0] + station[i][1]\\n        int jumps = 0, prevLoc = 0, currentFuel = startFuel;\\n        \\n        for(int loc[] : stations){\\n            currentFuel -= (loc[0]-prevLoc);\\n            \\n            // let initial = 30\\n            // [[10,50],[20,5],[40,13],[97,1],[100,0]]\\n            // we need a loop to keep refueling until either we are out of fuel or tank gets enough fuel\\n            // In this case when we reach at 97, we have (5,2) in pq and we would need to fill all\\n            while(!pq.isEmpty() && currentFuel < 0){\\n                currentFuel += pq.poll();\\n                jumps++;\\n            }\\n            \\n            // if by refueling at all prev stations, the tank was < 0, we will never reach dest\\n            if(currentFuel < 0) return -1;\\n            \\n            pq.add(loc[1]);\\n            prevLoc = loc[0];\\n        }\\n        \\n\\t\\t//*************************************************\\n        // repeating for cases like\\n        // 100\\n        // 50\\n        // [[40,50]]\\n        // alternatively we could also check if (stations[stations.length-1][0] < target) we may add [target, 0] in stations\\n        {\\n            currentFuel -= (target-prevLoc);\\n            \\n            while(!pq.isEmpty() && currentFuel < 0){\\n                currentFuel += pq.poll();\\n                jumps++;\\n            }\\n\\t\\t\\t\\n            if(currentFuel < 0) return -1;\\n        }\\n        \\n        return jumps;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        if(startFuel >= target) return 0;\\n        if(stations.size() == 0 && (startFuel < target)) return -1;\\n        if(startFuel < stations[0][0]) return -1;\\n        \\n        // see java sol comments below //************************************************* for need of adding below lines\\n        if(stations[stations.size()-1][0] < target)\\n            stations.push_back({target, 0});\\n        \\n        // Max-heap\\n        priority_queue<int> pq;\\n        // consider each station provides a jump of remainingfuel + station[i][0] + station[i][1]\\n        int jumps = 0, prevLoc = 0, currentFuel = startFuel;\\n        \\n        for(vector<int> loc : stations){\\n            currentFuel -= (loc[0]-prevLoc);\\n            \\n            while(pq.size() > 0 && currentFuel < 0){\\n                currentFuel += pq.top();\\n                pq.pop();\\n                jumps++;\\n            }\\n            \\n            if(currentFuel < 0) return -1;\\n            \\n            pq.push(loc[1]);\\n            prevLoc = loc[0];\\n        }\\n        \\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908154,
                "title": "java-c-solution-priority-queue",
                "content": "java\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer>pq=new PriorityQueue<>( (a,b)-> (b-a) );\\n        int res=0;\\n        int currreach=startFuel;\\n        int i=0;\\n        while(currreach<target)\\n        {\\n            while(i<stations.length && stations[i][0]<=currreach)\\n                pq.add(stations[i++][1]);\\n            if(pq.isEmpty())\\n                return -1;\\n            currreach+=pq.poll();\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```\\ncpp\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int>pq;\\n        int res=0;\\n        int reach=startFuel;\\n        int i=0;\\n        while(reach<target)\\n        {\\n            while(i<stations.size() && stations[i][0]<=reach)\\n                pq.push(stations[i++][1]);\\n            if(pq.empty())\\n                return -1;\\n            reach+=pq.top();\\n            pq.pop();\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer>pq=new PriorityQueue<>( (a,b)-> (b-a) );\\n        int res=0;\\n        int currreach=startFuel;\\n        int i=0;\\n        while(currreach<target)\\n        {\\n            while(i<stations.length && stations[i][0]<=currreach)\\n                pq.add(stations[i++][1]);\\n            if(pq.isEmpty())\\n                return -1;\\n            currreach+=pq.poll();\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int>pq;\\n        int res=0;\\n        int reach=startFuel;\\n        int i=0;\\n        while(reach<target)\\n        {\\n            while(i<stations.size() && stations[i][0]<=reach)\\n                pq.push(stations[i++][1]);\\n            if(pq.empty())\\n                return -1;\\n            reach+=pq.top();\\n            pq.pop();\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905316,
                "title": "c-step-by-step-approaches-with-detailed-comments-beats-100",
                "content": "```\\n// Intuitive: Use Dfs and for each stop, check based on the current fuel info, all the stations we can reach\\n// Try out each station and follow the same process\\n// Optimized DP:\\n// For each station, check out the farthest station we could reach. This could be found by iterating through all previous stations\\n// and getting the max distance amoung them\\n// Complexity: O(n2)\\n// Further Optimization:\\n// In each loop we are trying to find the max range/distance we can find using all the stations before the current index\\n// This looks like application of Heap where we store all the stations reachable from the current fuel status and get the max distance possible using the fuel \\n// from the stations within reachable distance\\npublic class Solution {\\n    public int MinRefuelStops(int target, int startFuel, int[][] stations) {\\n        var maxHeap = new MaxHeap(stations.Length);\\n        var curRange = startFuel;\\n        var stationIndex = 0;\\n        var fillUps = 0;\\n        while(curRange < target)\\n        {\\n            // Find all fuel stations within the range of curRange\\n            while(stationIndex < stations.Length && stations[stationIndex][0] <= curRange)\\n            {\\n                maxHeap.Add(stations[stationIndex][1]);\\n                stationIndex++;\\n            }\\n            \\n            // if we cant find any stations within the range and curRange < target, means the target is not reachable\\n            if(maxHeap.Count() == 0) return -1;\\n            \\n            // Add the max range possible\\n            curRange += maxHeap.GetMax();\\n            fillUps++;\\n        }\\n        \\n        return fillUps;\\n    }\\n    \\n    public int MinRefuelStops_On2(int target, int startFuel, int[][] stations) {\\n        if(stations.Length == 0 && target > startFuel)\\n            return -1;\\n        // var cache = new Dictionary<string, int>();\\n        // var minStationCount = Dfs_Memo(target, startFuel, stations, 0, cache);\\n        // return minStationCount == int.MaxValue ? -1 : minStationCount;\\n        \\n        var len = stations.Length;\\n        var dp = new long[len + 1]; // DP[i] is the max distance we can travel after refuelling from i number of stations\\n        dp[0] = startFuel;\\n        for(var i = 0 ; i < len; i++)\\n        {\\n            for(var j = i; j >=0 ; j--)\\n            {\\n                // if we can reach the current station\\n                if(dp[j] < stations[i][0])\\n                    continue;\\n                \\n                dp[j+1] = Math.Max(dp[j+1], dp[j] + (long)stations[i][1]);\\n            }\\n        }\\n        \\n        // At this point, we have the max distance we can travel from each fueling stations including the fuels that we can get from the previous gas stations\\n        // At any time, if we reach target, then we have to refuel from all those stations\\n        for(var i = 0 ; i < dp.Length; i++)\\n        {\\n            if(dp[i] >= target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    \\n    private int Dfs_Memo(int target, int currentFuel, int[][] stations, int lastStationIndex, Dictionary<string, int> cache)\\n    {\\n        if(currentFuel >= target)\\n            return 0;\\n        \\n        // variables during each call: currentFuel, lastStationIndex\\n        var key = $\"{currentFuel}:{lastStationIndex}\";\\n        if(cache.ContainsKey(key))\\n            return cache[key];\\n        \\n        // Find all stations within the range from current fuel\\n        var minStationCount = int.MaxValue;\\n        for(var i = lastStationIndex; i < stations.Length; i++)\\n        {\\n            var station = stations[i];\\n            \\n            // can\\'t reach this station\\n            if(currentFuel < station[0])\\n                continue;\\n            \\n            // Take the fuel from this station and proceed\\n            var updatedFuel = currentFuel + station[1];\\n            \\n            // Can only try the station next to the current one\\n            var curStationCount = Dfs_Memo(target, updatedFuel, stations, i + 1, cache);\\n            \\n            // we cant reach the end by picking the current gas station\\n            if(curStationCount == int.MaxValue)\\n                continue;\\n            \\n            minStationCount = Math.Min(minStationCount, curStationCount + 1);\\n        }\\n        \\n        cache[key] = minStationCount;\\n        return minStationCount;\\n    }\\n    \\n     private class MaxHeap{\\n        \\n        List<int> heap;\\n        public MaxHeap(int capacity)\\n        {\\n            heap = new List<int>(capacity);\\n        }\\n         \\n        public int Count()\\n        {\\n            return heap.Count;\\n        }\\n        \\n        public int GetMax()\\n        {\\n            if(heap.Count == 0) return int.MinValue;\\n            \\n            int max = heap[0];\\n            heap[0] = heap[heap.Count - 1];\\n            heap.RemoveAt(heap.Count - 1);\\n            HeapifyDown(0);\\n            return max;\\n        }\\n        \\n        public void Add(int val)\\n        {\\n            heap.Add(val);\\n            HeapifyUp(heap.Count - 1);\\n        }\\n        \\n        public int Peek()\\n        {\\n            return heap[0];\\n        }\\n        \\n        public void Remove(int val)\\n        {\\n            int index = heap.IndexOf(val);\\n            if (index == -1) return;\\n\\n            if(index  == heap.Count - 1)\\n            {\\n                heap.RemoveAt(heap.Count - 1);    \\n                return;\\n            }\\n            \\n            heap[index] = heap[heap.Count - 1];\\n            heap.RemoveAt(heap.Count - 1);\\n            \\n            if (heap.Count <= 1) return;\\n            \\n            var parent = GetParent(index);\\n            \\n            // Either the deleted index is the root or the parent is smaller\\n            if(index == 0 || heap[parent] > heap[index])\\n                HeapifyDown(index);\\n            else\\n                HeapifyUp(index);\\n        }\\n        \\n        private void HeapifyDown(int index)\\n        {\\n            while(index < heap.Count)\\n            {\\n                var leftChild = GetLeftChild(index);\\n                var rightChild = GetRightChild(index);\\n                \\n                var newIndex = rightChild < heap.Count && heap[leftChild] < heap[rightChild] ? rightChild : leftChild;\\n                \\n                if(newIndex >= heap.Count)\\n                    break;\\n                \\n                if(heap[newIndex] < heap[index])\\n                    break;\\n                \\n                Swap(index, newIndex);\\n                index = newIndex;                \\n            }\\n        }\\n        \\n        private void HeapifyUp(int index)\\n        {\\n            while(index > 0)\\n            {\\n                var parent = GetParent(index);\\n                if(heap[parent] > heap[index])\\n                    break;\\n                \\n                Swap(parent, index);\\n                index = parent;                \\n            }\\n        }\\n        \\n        private int GetParent(int i) => (i-1)/2;\\n        \\n        private int GetLeftChild(int i) => 2*i+1;\\n        \\n        private int GetRightChild(int i) => 2*i+2;\\n        \\n        private void Swap(int i, int j)\\n        {\\n            int temp = heap[i];\\n            heap[i] = heap[j];\\n            heap[j] = temp;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Intuitive: Use Dfs and for each stop, check based on the current fuel info, all the stations we can reach\\n// Try out each station and follow the same process\\n// Optimized DP:\\n// For each station, check out the farthest station we could reach. This could be found by iterating through all previous stations\\n// and getting the max distance amoung them\\n// Complexity: O(n2)\\n// Further Optimization:\\n// In each loop we are trying to find the max range/distance we can find using all the stations before the current index\\n// This looks like application of Heap where we store all the stations reachable from the current fuel status and get the max distance possible using the fuel \\n// from the stations within reachable distance\\npublic class Solution {\\n    public int MinRefuelStops(int target, int startFuel, int[][] stations) {\\n        var maxHeap = new MaxHeap(stations.Length);\\n        var curRange = startFuel;\\n        var stationIndex = 0;\\n        var fillUps = 0;\\n        while(curRange < target)\\n        {\\n            // Find all fuel stations within the range of curRange\\n            while(stationIndex < stations.Length && stations[stationIndex][0] <= curRange)\\n            {\\n                maxHeap.Add(stations[stationIndex][1]);\\n                stationIndex++;\\n            }\\n            \\n            // if we cant find any stations within the range and curRange < target, means the target is not reachable\\n            if(maxHeap.Count() == 0) return -1;\\n            \\n            // Add the max range possible\\n            curRange += maxHeap.GetMax();\\n            fillUps++;\\n        }\\n        \\n        return fillUps;\\n    }\\n    \\n    public int MinRefuelStops_On2(int target, int startFuel, int[][] stations) {\\n        if(stations.Length == 0 && target > startFuel)\\n            return -1;\\n        // var cache = new Dictionary<string, int>();\\n        // var minStationCount = Dfs_Memo(target, startFuel, stations, 0, cache);\\n        // return minStationCount == int.MaxValue ? -1 : minStationCount;\\n        \\n        var len = stations.Length;\\n        var dp = new long[len + 1]; // DP[i] is the max distance we can travel after refuelling from i number of stations\\n        dp[0] = startFuel;\\n        for(var i = 0 ; i < len; i++)\\n        {\\n            for(var j = i; j >=0 ; j--)\\n            {\\n                // if we can reach the current station\\n                if(dp[j] < stations[i][0])\\n                    continue;\\n                \\n                dp[j+1] = Math.Max(dp[j+1], dp[j] + (long)stations[i][1]);\\n            }\\n        }\\n        \\n        // At this point, we have the max distance we can travel from each fueling stations including the fuels that we can get from the previous gas stations\\n        // At any time, if we reach target, then we have to refuel from all those stations\\n        for(var i = 0 ; i < dp.Length; i++)\\n        {\\n            if(dp[i] >= target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    \\n    private int Dfs_Memo(int target, int currentFuel, int[][] stations, int lastStationIndex, Dictionary<string, int> cache)\\n    {\\n        if(currentFuel >= target)\\n            return 0;\\n        \\n        // variables during each call: currentFuel, lastStationIndex\\n        var key = $\"{currentFuel}:{lastStationIndex}\";\\n        if(cache.ContainsKey(key))\\n            return cache[key];\\n        \\n        // Find all stations within the range from current fuel\\n        var minStationCount = int.MaxValue;\\n        for(var i = lastStationIndex; i < stations.Length; i++)\\n        {\\n            var station = stations[i];\\n            \\n            // can\\'t reach this station\\n            if(currentFuel < station[0])\\n                continue;\\n            \\n            // Take the fuel from this station and proceed\\n            var updatedFuel = currentFuel + station[1];\\n            \\n            // Can only try the station next to the current one\\n            var curStationCount = Dfs_Memo(target, updatedFuel, stations, i + 1, cache);\\n            \\n            // we cant reach the end by picking the current gas station\\n            if(curStationCount == int.MaxValue)\\n                continue;\\n            \\n            minStationCount = Math.Min(minStationCount, curStationCount + 1);\\n        }\\n        \\n        cache[key] = minStationCount;\\n        return minStationCount;\\n    }\\n    \\n     private class MaxHeap{\\n        \\n        List<int> heap;\\n        public MaxHeap(int capacity)\\n        {\\n            heap = new List<int>(capacity);\\n        }\\n         \\n        public int Count()\\n        {\\n            return heap.Count;\\n        }\\n        \\n        public int GetMax()\\n        {\\n            if(heap.Count == 0) return int.MinValue;\\n            \\n            int max = heap[0];\\n            heap[0] = heap[heap.Count - 1];\\n            heap.RemoveAt(heap.Count - 1);\\n            HeapifyDown(0);\\n            return max;\\n        }\\n        \\n        public void Add(int val)\\n        {\\n            heap.Add(val);\\n            HeapifyUp(heap.Count - 1);\\n        }\\n        \\n        public int Peek()\\n        {\\n            return heap[0];\\n        }\\n        \\n        public void Remove(int val)\\n        {\\n            int index = heap.IndexOf(val);\\n            if (index == -1) return;\\n\\n            if(index  == heap.Count - 1)\\n            {\\n                heap.RemoveAt(heap.Count - 1);    \\n                return;\\n            }\\n            \\n            heap[index] = heap[heap.Count - 1];\\n            heap.RemoveAt(heap.Count - 1);\\n            \\n            if (heap.Count <= 1) return;\\n            \\n            var parent = GetParent(index);\\n            \\n            // Either the deleted index is the root or the parent is smaller\\n            if(index == 0 || heap[parent] > heap[index])\\n                HeapifyDown(index);\\n            else\\n                HeapifyUp(index);\\n        }\\n        \\n        private void HeapifyDown(int index)\\n        {\\n            while(index < heap.Count)\\n            {\\n                var leftChild = GetLeftChild(index);\\n                var rightChild = GetRightChild(index);\\n                \\n                var newIndex = rightChild < heap.Count && heap[leftChild] < heap[rightChild] ? rightChild : leftChild;\\n                \\n                if(newIndex >= heap.Count)\\n                    break;\\n                \\n                if(heap[newIndex] < heap[index])\\n                    break;\\n                \\n                Swap(index, newIndex);\\n                index = newIndex;                \\n            }\\n        }\\n        \\n        private void HeapifyUp(int index)\\n        {\\n            while(index > 0)\\n            {\\n                var parent = GetParent(index);\\n                if(heap[parent] > heap[index])\\n                    break;\\n                \\n                Swap(parent, index);\\n                index = parent;                \\n            }\\n        }\\n        \\n        private int GetParent(int i) => (i-1)/2;\\n        \\n        private int GetLeftChild(int i) => 2*i+1;\\n        \\n        private int GetRightChild(int i) => 2*i+2;\\n        \\n        private void Swap(int i, int j)\\n        {\\n            int temp = heap[i];\\n            heap[i] = heap[j];\\n            heap[j] = temp;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828163,
                "title": "rust-translated-4ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_refuel_stops(target: i32, mut start_fuel: i32, stations: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::BinaryHeap;\\n\\n        let mut heap = BinaryHeap::<i32>::new();\\n        let mut i = 0;\\n        let mut ans = 0;\\n        while start_fuel < target {\\n            while i < stations.len() && stations[i][0] <= start_fuel {\\n                heap.push(stations[i][1]);\\n                i += 1;\\n            }\\n            if heap.is_empty() {\\n                return -1;\\n            }\\n            start_fuel += heap.pop().unwrap();\\n            ans += 1;\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_refuel_stops() {\\n        assert_eq!(Solution::min_refuel_stops(1, 1, vec![]), 0)\\n    }\\n\\n    #[test]\\n    fn test_min_refuel_stops_02() {\\n        assert_eq!(Solution::min_refuel_stops(100, 1, vec![vec![10, 100]]), -1)\\n    }\\n\\n    #[test]\\n    fn test_min_refuel_stops_03() {\\n        assert_eq!(\\n            Solution::min_refuel_stops(\\n                100,\\n                10,\\n                vec![vec![10, 60], vec![20, 30], vec![30, 30], vec![60, 40]]\\n            ),\\n            2\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_refuel_stops(target: i32, mut start_fuel: i32, stations: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::BinaryHeap;\\n\\n        let mut heap = BinaryHeap::<i32>::new();\\n        let mut i = 0;\\n        let mut ans = 0;\\n        while start_fuel < target {\\n            while i < stations.len() && stations[i][0] <= start_fuel {\\n                heap.push(stations[i][1]);\\n                i += 1;\\n            }\\n            if heap.is_empty() {\\n                return -1;\\n            }\\n            start_fuel += heap.pop().unwrap();\\n            ans += 1;\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_refuel_stops() {\\n        assert_eq!(Solution::min_refuel_stops(1, 1, vec![]), 0)\\n    }\\n\\n    #[test]\\n    fn test_min_refuel_stops_02() {\\n        assert_eq!(Solution::min_refuel_stops(100, 1, vec![vec![10, 100]]), -1)\\n    }\\n\\n    #[test]\\n    fn test_min_refuel_stops_03() {\\n        assert_eq!(\\n            Solution::min_refuel_stops(\\n                100,\\n                10,\\n                vec![vec![10, 60], vec![20, 30], vec![30, 30], vec![60, 40]]\\n            ),\\n            2\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 824162,
                "title": "python-greedy-o-nlogn-98-89-from-intuition-to-actual-code",
                "content": "Intuition: the question asks the minimum number of refueling stops, and this implies we want to take as much from a single gas refuel as possible. Then the question comes to how do we keep track of the  gas stations in the descending order of refuel amount at current point? The data structure priority queue naturally comes to mind.\\n\\nWe sort the stations by their position in ascending order since it is the direction we are driving. Now as we proceeding along the road, there are two types of gas stations we can encounter: the ones that are reachable and the ones that are not.\\n- The reachable gas stations are those with pos <= current position + gas left in tank. We take this down into our priority queue.\\n- Vice versa, when current gas stations is out of reach, we will be looking for refuels from our priority queue and keep the number of refuels as less as possible. We first update our current position = position + gas left in tank and clear the tank. If we add all refuels possible and still can not reach the current gas stations, that means our target is not reachable. Otherwise, we update the refuel priority queue and continue.\\n\\n```\\n\\'\\'\\'\\nRuntime: 116 ms, faster than 98.89% of Python3 online submissions for Minimum Number of Refueling Stops.\\nMemory Usage: 14 MB, less than 89.72% of Python3 online submissions for Minimum Number of Refueling Stops\\n\\'\\'\\'\\nclass Solution:\\n    def minRefuelStops(self, target, startFuel, stations):\\n        stations.append([target, 0])\\n        stations.sort(reverse=True)\\n        curr, tank = 0, startFuel\\n        ans = 0\\n        refuels = []\\n        while curr + tank < target:\\n            pos, gas = stations.pop()\\n            if pos <= curr+tank:\\n                heapq.heappush(refuels, -gas)\\n            else:\\n                curr += tank\\n                tank = 0\\n                while curr+tank < pos and refuels:\\n                    ans += 1\\n                    tank -= heapq.heappop(refuels)\\n                if curr+tank < pos:\\n                    return -1\\n                heapq.heappush(refuels, -gas)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n\\'\\'\\'\\nRuntime: 116 ms, faster than 98.89% of Python3 online submissions for Minimum Number of Refueling Stops.\\nMemory Usage: 14 MB, less than 89.72% of Python3 online submissions for Minimum Number of Refueling Stops\\n\\'\\'\\'\\nclass Solution:\\n    def minRefuelStops(self, target, startFuel, stations):\\n        stations.append([target, 0])\\n        stations.sort(reverse=True)\\n        curr, tank = 0, startFuel\\n        ans = 0\\n        refuels = []\\n        while curr + tank < target:\\n            pos, gas = stations.pop()\\n            if pos <= curr+tank:\\n                heapq.heappush(refuels, -gas)\\n            else:\\n                curr += tank\\n                tank = 0\\n                while curr+tank < pos and refuels:\\n                    ans += 1\\n                    tank -= heapq.heappop(refuels)\\n                if curr+tank < pos:\\n                    return -1\\n                heapq.heappush(refuels, -gas)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643133,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        if(stations.size()==0){\\n            if(target<=startFuel) return 0;\\n            return -1;\\n        }\\n        priority_queue<int> pq;\\n        int curr_fuel = startFuel;\\n        int ans = 0;\\n        int prev = 0;\\n        for(int i=0;i<stations.size();i++){\\n            int capacity = stations[i][1];\\n            int location = stations[i][0];\\n            curr_fuel -= location-prev;\\n            while(!pq.empty() && curr_fuel<0){\\n                curr_fuel += pq.top();\\n                pq.pop();\\n                ans++;\\n            }\\n            if(curr_fuel<0) return -1;\\n            prev = location;\\n            pq.push(capacity);\\n        }\\n        curr_fuel -= target-prev;\\n        while(!pq.empty() && curr_fuel<0){\\n            curr_fuel += pq.top();\\n            pq.pop();\\n            ans++;\\n        }\\n        if(curr_fuel<0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        if(stations.size()==0){\\n            if(target<=startFuel) return 0;\\n            return -1;\\n        }\\n        priority_queue<int> pq;\\n        int curr_fuel = startFuel;\\n        int ans = 0;\\n        int prev = 0;\\n        for(int i=0;i<stations.size();i++){\\n            int capacity = stations[i][1];\\n            int location = stations[i][0];\\n            curr_fuel -= location-prev;\\n            while(!pq.empty() && curr_fuel<0){\\n                curr_fuel += pq.top();\\n                pq.pop();\\n                ans++;\\n            }\\n            if(curr_fuel<0) return -1;\\n            prev = location;\\n            pq.push(capacity);\\n        }\\n        curr_fuel -= target-prev;\\n        while(!pq.empty() && curr_fuel<0){\\n            curr_fuel += pq.top();\\n            pq.pop();\\n            ans++;\\n        }\\n        if(curr_fuel<0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554514,
                "title": "java-greedy-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int curFuel = startFuel, refuelTime = 0, station = 0;\\n        \\n        while(true){\\n            //track all reachable stations\\' gas from current location\\n            while(station < stations.length && stations[station][0] <= curFuel){\\n                pq.offer(stations[station][1]);\\n                ++station;\\n            }   \\n            //already enough to get to target\\n            if(curFuel >= target){\\n                return refuelTime;\\n            }\\n            //not have enough gas with all possible stations => cannot reach target\\n            if(pq.isEmpty()){\\n                return -1;\\n            }\\n            //refuel at station which is reachable and with maximum gas\\n            curFuel += pq.poll();\\n            ++refuelTime;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int curFuel = startFuel, refuelTime = 0, station = 0;\\n        \\n        while(true){\\n            //track all reachable stations\\' gas from current location\\n            while(station < stations.length && stations[station][0] <= curFuel){\\n                pq.offer(stations[station][1]);\\n                ++station;\\n            }   \\n            //already enough to get to target\\n            if(curFuel >= target){\\n                return refuelTime;\\n            }\\n            //not have enough gas with all possible stations => cannot reach target\\n            if(pq.isEmpty()){\\n                return -1;\\n            }\\n            //refuel at station which is reachable and with maximum gas\\n            curFuel += pq.poll();\\n            ++refuelTime;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418020,
                "title": "python-heapq-explained",
                "content": "Go as far as you can without stopping. Record all stations that you\\'ve passed, only record them but not use them. Now you have no fuel, you will pick up one of the previous passed station to re-fuel your car. Pick the one with most fuel. Then keep going until you have no fuel again.\\n\\n```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        que=[]\\n        pos=startFuel\\n        i=0\\n        res=0\\n        while True:\\n            if pos>=target:\\n                return res\\n            while i<len(stations) and stations[i][0]<=pos:\\n                heapq.heappush(que,-stations[i][1])\\n                i+=1\\n            if que:\\n                pos+=-heapq.heappop(que)\\n                res+=1\\n            else:\\n                return -1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        que=[]\\n        pos=startFuel\\n        i=0\\n        res=0\\n        while True:\\n            if pos>=target:\\n                return res\\n            while i<len(stations) and stations[i][0]<=pos:\\n                heapq.heappush(que,-stations[i][1])\\n                i+=1\\n            if que:\\n                pos+=-heapq.heappop(que)\\n                res+=1\\n            else:\\n                return -1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407927,
                "title": "simple-python-2d-dp",
                "content": "expanded the DP solution to a 2D version for clarity.\\n```\\nclass Solution(object):\\n    def minRefuelStops(self, target, startFuel, stations):\\n        \"\"\"\\n        :type target: int\\n        :type startFuel: int\\n        :type stations: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ls = len(stations)\\n        dp = [[0 for _ in range(ls+1)] for _ in range(ls+1)]\\n        \\n        for row in dp:\\n            row[0] = startFuel\\n            \\n        if startFuel >= target: return 0\\n            \\n        for refuels in range(1, ls+1):\\n            for stas in range(1, ls+1):\\n                station = stations[stas-1]\\n                dp[stas][refuels] = dp[stas-1][refuels]\\n                if dp[stas-1][refuels-1] >= station[0]:\\n                    dp[stas][refuels] = max(station[1] + dp[stas-1][refuels-1], dp[stas][refuels])\\n\\n            if dp[ls][refuels] >= target: return refuels\\n            \\n        return -1\\n```            \\n\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minRefuelStops(self, target, startFuel, stations):\\n        \"\"\"\\n        :type target: int\\n        :type startFuel: int\\n        :type stations: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ls = len(stations)\\n        dp = [[0 for _ in range(ls+1)] for _ in range(ls+1)]\\n        \\n        for row in dp:\\n            row[0] = startFuel\\n            \\n        if startFuel >= target: return 0\\n            \\n        for refuels in range(1, ls+1):\\n            for stas in range(1, ls+1):\\n                station = stations[stas-1]\\n                dp[stas][refuels] = dp[stas-1][refuels]\\n                if dp[stas-1][refuels-1] >= station[0]:\\n                    dp[stas][refuels] = max(station[1] + dp[stas-1][refuels-1], dp[stas][refuels])\\n\\n            if dp[ls][refuels] >= target: return refuels\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150489,
                "title": "a-not-very-elegant-dp-solution",
                "content": "Just for reference in case someone has the same thought process as I do.\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int N = stations.length;\\n        \\n        if (N == 0) {\\n            if (startFuel >= target) return 0;\\n            else return -1;\\n        }\\n\\n        int max = 1000000001; // impossible\\n        \\n        // If you want to get to the target from ith station with j times refueling (refueling at i, i+1, ...),\\n        // mat[i][j] means the min fuel you need to have in your tank as you reach the ith station.\\n        // we use 1000000001 as \"impossible\"\\n        int[][] mat = new int[N][N+1];\\n        for (int i = 0; i < N; i++) {\\n            Arrays.fill(mat[i], max);\\n        }\\n        int[] s = stations[N-1];\\n        mat[N-1][0] = target - s[0];\\n        mat[N-1][1] = Math.max(0, mat[N-1][0] - s[1]);\\n        for (int i = N-2; i >= 0; i--) {\\n            int[] prev = stations[i+1]; // \"prev\" as it\\'s the last station we processed.\\n            s = stations[i];\\n            mat[i][0] = target - s[0];\\n            for (int j = 0; j < N-i; j++) {\\n                // refuel at the current station\\n                int a = Math.max(0, mat[i+1][j]-s[1]+(prev[0]-s[0])); \\n                // DO NOT refuel at the current station;\\n                int b = mat[i+1][j+1] + (prev[0]-s[0]);\\n                mat[i][j+1] = Math.min(a, b);\\n            }\\n        }               \\n\\n        for (int i = 0; i < N+1; i++) {\\n            if (mat[0][i] <= startFuel-stations[0][0]) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int N = stations.length;\\n        \\n        if (N == 0) {\\n            if (startFuel >= target) return 0;\\n            else return -1;\\n        }\\n\\n        int max = 1000000001; // impossible\\n        \\n        // If you want to get to the target from ith station with j times refueling (refueling at i, i+1, ...),\\n        // mat[i][j] means the min fuel you need to have in your tank as you reach the ith station.\\n        // we use 1000000001 as \"impossible\"\\n        int[][] mat = new int[N][N+1];\\n        for (int i = 0; i < N; i++) {\\n            Arrays.fill(mat[i], max);\\n        }\\n        int[] s = stations[N-1];\\n        mat[N-1][0] = target - s[0];\\n        mat[N-1][1] = Math.max(0, mat[N-1][0] - s[1]);\\n        for (int i = N-2; i >= 0; i--) {\\n            int[] prev = stations[i+1]; // \"prev\" as it\\'s the last station we processed.\\n            s = stations[i];\\n            mat[i][0] = target - s[0];\\n            for (int j = 0; j < N-i; j++) {\\n                // refuel at the current station\\n                int a = Math.max(0, mat[i+1][j]-s[1]+(prev[0]-s[0])); \\n                // DO NOT refuel at the current station;\\n                int b = mat[i+1][j+1] + (prev[0]-s[0]);\\n                mat[i][j+1] = Math.min(a, b);\\n            }\\n        }               \\n\\n        for (int i = 0; i < N+1; i++) {\\n            if (mat[0][i] <= startFuel-stations[0][0]) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837313,
                "title": "7-lines-of-code-bottom-up-java-o-n2",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if(startFuel >= target) return 0;\\n        int[][] dp = new int[stations.length + 1][stations.length + 1];\\n        for (int i = 0; i < dp.length; i++) dp[i][0] = startFuel;\\n        for (int j = 1; j < dp.length; j++) {\\n            for (int i = j; i < dp.length; i++) {\\n                dp[i][j] = Math.max(dp[i-1][j], stations[i-1][0] > dp[i-1][j-1] ?\\n                        Integer.MIN_VALUE : dp[i-1][j-1] + stations[i-1][1]);\\n                if(dp[i][j] >= target) return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if(startFuel >= target) return 0;\\n        int[][] dp = new int[stations.length + 1][stations.length + 1];\\n        for (int i = 0; i < dp.length; i++) dp[i][0] = startFuel;\\n        for (int j = 1; j < dp.length; j++) {\\n            for (int i = j; i < dp.length; i++) {\\n                dp[i][j] = Math.max(dp[i-1][j], stations[i-1][0] > dp[i-1][j-1] ?\\n                        Integer.MIN_VALUE : dp[i-1][j-1] + stations[i-1][1]);\\n                if(dp[i][j] >= target) return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628031,
                "title": "greedy-solution-using-maxheap",
                "content": "# Intuition\\nLet\\'s assume that you keep on going as far as you can with the current fuel in your tank. You aim to reach every station in order. At a certain point on your journey, you realise that you can\\'t reach the next station because you don\\'t have enough fuel. Now you think \"Oh! no, I should have refueld earlier\". But since, this is a simulation, you can somehow rewind and refuel at some past station. \\n\\nBut which one of the past stations to choose? We are cheap people so we will choose the one which gives us the most fuel since the cost is same whether you refuel with 10 or 100, i.e \"1\". We keep on refueling from past stations until we have enough to reach the next station. The used up stations are marked or removed from consideration so that we don\\'t use them again. If we used up all past stations, and still we can\\'t reach the next station then there is no hope to reach the target.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.Length;\\n        // Add it for convenience\\n        Array.Resize(ref stations, n+1);\\n        stations[n] = new int[] {target,0}; \\n\\n        int pos = 0, fuel = startFuel, refuels = 0;\\n        PriorityQueue<int,int> heap = new(Comparer<int>.Create((a,b) => b-a));\\n\\n        for(int i=0;i<=n;i++) {\\n            int toReach = stations[i][0];\\n            // Make sure you get enough fuel to reach current \"toReach\".\\n            while(heap.Count > 0 && (pos+fuel) < toReach) {\\n                fuel+=heap.Dequeue();\\n                refuels++;\\n            }\\n            // If we couldn\\'t get enough fuel, then return -1\\n            if (pos+fuel < toReach) return -1;\\n\\n            // Update fuel and position\\n            fuel-=toReach-pos;\\n            pos = toReach;\\n\\n            // Put up current station as a potential refueling station.\\n            heap.Enqueue(stations[i][1], stations[i][1]);\\n        }\\n\\n        return refuels;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.Length;\\n        // Add it for convenience\\n        Array.Resize(ref stations, n+1);\\n        stations[n] = new int[] {target,0}; \\n\\n        int pos = 0, fuel = startFuel, refuels = 0;\\n        PriorityQueue<int,int> heap = new(Comparer<int>.Create((a,b) => b-a));\\n\\n        for(int i=0;i<=n;i++) {\\n            int toReach = stations[i][0];\\n            // Make sure you get enough fuel to reach current \"toReach\".\\n            while(heap.Count > 0 && (pos+fuel) < toReach) {\\n                fuel+=heap.Dequeue();\\n                refuels++;\\n            }\\n            // If we couldn\\'t get enough fuel, then return -1\\n            if (pos+fuel < toReach) return -1;\\n\\n            // Update fuel and position\\n            fuel-=toReach-pos;\\n            pos = toReach;\\n\\n            // Put up current station as a potential refueling station.\\n            heap.Enqueue(stations[i][1], stations[i][1]);\\n        }\\n\\n        return refuels;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499372,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& arr) {\\n        int sf = startFuel;\\n        int n = arr.size();\\n        int ans=0;\\n        int i=0;\\n        if(target<=startFuel)\\n            return 0;\\n        priority_queue<int> pq;\\n        while(sf<target)\\n        {\\n            while(i<n && arr[i][0]<=sf)\\n            {\\n                pq.push(arr[i][1]);\\n                i++;\\n            }\\n            if(pq.empty())\\n                return -1;\\n            int mx = pq.top();\\n            pq.pop();\\n            sf+= mx;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        if startFuel >= target: return 0\\n        h, f, count, xCar = [], startFuel, 0, 0\\n        for x, supply in stations + [[target,0]]:\\n            f -= x - xCar\\n            xCar = x\\n            while f < 0:\\n                    if not h: return -1\\n                    f -= heappop(h)\\n                    count += 1\\n            if x + f >= target: \\n                return count\\n            heappush(h, -supply)\\n        return -1\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int end = startFuel, maxDistance = startFuel;\\n\\n        int stops = 0, j = -1;\\n        int[] usedStations = new int[stations.length + 1];\\n        boolean change = true;\\n\\n        while(change && end < target) {\\n            change = false;\\n            j = 0;\\n            for (int i = 0; i < stations.length; i++) {\\n                if (stations[i][0] > end) {\\n                    break;\\n                }\\n                if (usedStations[i + 1] == 0 && maxDistance < (end + stations[i][1])) {\\n                    usedStations[j] = 0;\\n                    maxDistance = end + stations[i][1];\\n                    j = i + 1;\\n                    usedStations[i + 1] = 1;\\n                    change = true;\\n                }\\n            }\\n            stops++;\\n            end = maxDistance;\\n        }\\n        if (end >= target) {\\n            return stops;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& arr) {\\n        int sf = startFuel;\\n        int n = arr.size();\\n        int ans=0;\\n        int i=0;\\n        if(target<=startFuel)\\n            return 0;\\n        priority_queue<int> pq;\\n        while(sf<target)\\n        {\\n            while(i<n && arr[i][0]<=sf)\\n            {\\n                pq.push(arr[i][1]);\\n                i++;\\n            }\\n            if(pq.empty())\\n                return -1;\\n            int mx = pq.top();\\n            pq.pop();\\n            sf+= mx;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        if startFuel >= target: return 0\\n        h, f, count, xCar = [], startFuel, 0, 0\\n        for x, supply in stations + [[target,0]]:\\n            f -= x - xCar\\n            xCar = x\\n            while f < 0:\\n                    if not h: return -1\\n                    f -= heappop(h)\\n                    count += 1\\n            if x + f >= target: \\n                return count\\n            heappush(h, -supply)\\n        return -1\\n```\n```Java []\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int end = startFuel, maxDistance = startFuel;\\n\\n        int stops = 0, j = -1;\\n        int[] usedStations = new int[stations.length + 1];\\n        boolean change = true;\\n\\n        while(change && end < target) {\\n            change = false;\\n            j = 0;\\n            for (int i = 0; i < stations.length; i++) {\\n                if (stations[i][0] > end) {\\n                    break;\\n                }\\n                if (usedStations[i + 1] == 0 && maxDistance < (end + stations[i][1])) {\\n                    usedStations[j] = 0;\\n                    maxDistance = end + stations[i][1];\\n                    j = i + 1;\\n                    usedStations[i + 1] = 1;\\n                    change = true;\\n                }\\n            }\\n            stops++;\\n            end = maxDistance;\\n        }\\n        if (end >= target) {\\n            return stops;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922512,
                "title": "greedy-approach-using-set",
                "content": "# Intuition\\ngreedy approach ( using set)\\n\\n# Approach\\ncode is self explanatory\\n\\n# Complexity\\n- Time complexity:\\nnlogn where n is the length of the vector of stations.\\n\\n- Space complexity:\\nsize of the multiset\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n      int c=startFuel;\\n      sort(stations.begin(),stations.end());\\n      multiset<int> s;\\n      multiset<int>::iterator it;\\n      int i,j;\\n      int ans=0;\\n      if(c>=target){\\n          return ans;\\n      }\\n      for(i=0;i<stations.size();i++){\\n           while(stations[i][0]>c){\\n               if(s.empty()==1){\\n                   return -1;\\n               }\\n              it=s.end();\\n              it--;\\n              c=c+*(it);\\n              s.erase(it);\\n              ans++;\\n\\n           }\\n            s.insert(stations[i][1]);\\n            if(c>=target){\\n              return ans;\\n            }\\n      }\\n      if(c<target){\\n          while(s.empty()!=1){\\n              it=s.end();\\n              it--;\\n              c=c+*(it);\\n              ans++;\\n              if(c>=target){\\n                  return ans;\\n              }\\n              s.erase(it);\\n              if(s.empty()==1&&c<target){\\n                  return -1;\\n              }\\n          }\\n      }\\n      return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n      int c=startFuel;\\n      sort(stations.begin(),stations.end());\\n      multiset<int> s;\\n      multiset<int>::iterator it;\\n      int i,j;\\n      int ans=0;\\n      if(c>=target){\\n          return ans;\\n      }\\n      for(i=0;i<stations.size();i++){\\n           while(stations[i][0]>c){\\n               if(s.empty()==1){\\n                   return -1;\\n               }\\n              it=s.end();\\n              it--;\\n              c=c+*(it);\\n              s.erase(it);\\n              ans++;\\n\\n           }\\n            s.insert(stations[i][1]);\\n            if(c>=target){\\n              return ans;\\n            }\\n      }\\n      if(c<target){\\n          while(s.empty()!=1){\\n              it=s.end();\\n              it--;\\n              c=c+*(it);\\n              ans++;\\n              if(c>=target){\\n                  return ans;\\n              }\\n              s.erase(it);\\n              if(s.empty()==1&&c<target){\\n                  return -1;\\n              }\\n          }\\n      }\\n      return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551366,
                "title": "dp-greedy-easy-to-understand",
                "content": "Let ```dp[i][t]```  denotes max distance reachable using `stations[0...i]` with exactly `t` stations (so `t<=i+1`).\\nThen we could easily get the recurrence:\\n`dp[i][t] = max{dp[i-1][t-1] + fuel[i] if pos[i] <= dp[i-1][t-1], dp[i-1][t]}`, \\nWe want to get row `dp[n-1]` where `n` denotes number of stations.\\nNotice that each row `dp[i]` only depends on previous row, so we could only maintain a single row and fill next row with previous row. \\n```\\n def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        n = len(stations)\\n        dp = [startFuel] * (1 + n)     \\n        for i in range(0, n):\\n            for t in reversed(range(1, i + 2)):\\n                if dp[t - 1] >= stations[i][0]:\\n                    dp[t] = max(dp[t], dp[t - 1] + stations[i][1])\\n        for i in range(n + 1):\\n            if dp[i] >= target:\\n                return i\\n        return -1\\n```\\n\\t\\nAnother approach is to greedily add fuel (always add the greatest fuel collected)\\n```\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        backups, pos, res, i = [], startFuel, 0, 0\\n        while pos < target:\\n            if i < len(stations) and stations[i][0] <= pos:\\n                heapq.heappush(backups, -stations[i][1])\\n                i += 1\\n            else:\\n                if not backups:\\n                    res = -1\\n                    break\\n                pos += -heapq.heappop(backups)\\n                res += 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```dp[i][t]```\n```\\n def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        n = len(stations)\\n        dp = [startFuel] * (1 + n)     \\n        for i in range(0, n):\\n            for t in reversed(range(1, i + 2)):\\n                if dp[t - 1] >= stations[i][0]:\\n                    dp[t] = max(dp[t], dp[t - 1] + stations[i][1])\\n        for i in range(n + 1):\\n            if dp[i] >= target:\\n                return i\\n        return -1\\n```\n```\\ndef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        backups, pos, res, i = [], startFuel, 0, 0\\n        while pos < target:\\n            if i < len(stations) and stations[i][0] <= pos:\\n                heapq.heappush(backups, -stations[i][1])\\n                i += 1\\n            else:\\n                if not backups:\\n                    res = -1\\n                    break\\n                pos += -heapq.heappop(backups)\\n                res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2456295,
                "title": "java-greedy-algorithm-with-maxheap-beats-99",
                "content": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        //build the maxheap\\n        Queue<Integer> maxheap = new PriorityQueue<>((Integer a, Integer b) -> b - a);\\n        \\n        int currFuel = startFuel; //current fuel can be used\\n        int res = 0; //number of times that we refueling\\n        int currPos = 0; //the current position we at\\n        int n = stations.length; // number of gas stations we have\\n        \\n        //only get into the loop, when our currFuel is not enough to reach the target position\\n        while (currFuel < target) {\\n            //\\u56E0\\u4E3A\\u524D\\u9762while loop\\u7684\\u5224\\u65AD\\uFF0C\\u6211\\u4EEC\\u8F66\\u5B50\\u663E\\u7136\\u51ED\\u7740\\u81EA\\u8EAB\\u672C\\u6765\\u7684fuel\\u5DF2\\u7ECF\\u65E0\\u6CD5\\u5230\\u8FBE\\u91CD\\u70B9\\u4E86\\u3002\\n            //\\u90A3\\u6211\\u4EEC\\u5C31\\u5148\\u5230\\u8FBE\\u80FD\\u591F\\u6700\\u8FDC\\u7684\\u52A0\\u6CB9\\u7AD9\\uFF0C\\u7136\\u540E\\u628A\\u6240\\u6709\\u9014\\u5F84\\u7684\\uFF08\\u53EF\\u4EE5reach\\u7684\\u52A0\\u6CB9\\u7AD9\\uFF09\\u7684\\u6CB9\\u90FD\\u52A0\\u5230meaheap\\u91CC\\u9762\\n\\t\\t\\t//(\\u50CF\\u662F\\u5148\\u5B58\\u8D77\\u6765 \\u4F46\\u4E0D\\u52A0\\uFF0C\\u6CE8\\u610F\\uFF01\\u653E\\u5230heap\\u91CC\\u9762\\u5E76\\u4E0D\\u662F\\u52A0\\u6CB9\\uFF0C\\u5E76\\u4E0D\\u662F\\u52A0\\u6CB9\\u7684\\u64CD\\u4F5C\\uFF0C\\u4E0D\\u662F\\u5728\\u52A0\\u6CB9\\uFF01\\u91CD\\u8981\\u7684\\u4E8B\\u8BF4\\u4E09\\u904D~\\n            //currPos < n (number of gas stations) \\u662F\\u4E3A\\u4E86\\u786E\\u8BA4\\u8FD8\\u6709\\u52A0\\u6CB9\\u7AD9\\u7684\\u6CB9\\u53EF\\u52A0\\uFF0C\\u5F53\\u6211\\u4EEC\\u5DF2\\u7ECF\\u8D85\\u8FC7\\u4E86\\uFF0C\\u90A3\\u6211\\u4EEC\\u8FD9\\u4E2Aloop\\u91CC\\u6240\\u505A\\u7684\\u4E8B\\u60C5\\uFF0C\\n            //\\u4E5F\\u5C31\\u662F\\u5728heap\\u91CC\\u9762\\u653E\\u5165\\u4E4B\\u524D\\u9014\\u5F84\\u52A0\\u6CB9\\u7AD9\\u7684\\u6CB9\\u5DF2\\u7ECF\\u6CA1\\u6709\\u610F\\u4E49\\u4E86\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u4E4B\\u524D\\u90FD\\u5DF2\\u7ECF\\u52A0\\u8FC7\\u4E86\\uFF0C\\u73B0\\u5728\\u6CA1\\u6709\\u65B0\\u7684\\u9014\\u5F84\\u52A0\\u6CB9\\u7AD9\\u7684\\u6CB9\\u53EF\\u52A0\\n            while (currPos < n && stations[currPos][0] <= currFuel) {\\n                maxheap.add(stations[currPos][1]);\\n                currPos++;\\n            }\\n            \\n            //if there are no gas stations along the way we passed, then that means we could not reach the target\\n            if (maxheap.isEmpty()) {\\n                return -1;\\n            }\\n            //key: greedy alogirthm, we add the most / largest fuel we have in the heap\\n\\t\\t\\t//\\u8FD9\\u4E00\\u6B65\\u624D\\u662F\\u52A0\\u6CB9\\u7684\\u64CD\\u4F5C\\uFF0C\\u8FD9\\u65F6\\u5019\\u6211\\u4EEC\\u6CB9\\u4E0D\\u591F\\u4E86 \\u5BF9\\u5427\\uFF0C\\u6211\\u4EEC\\u628A\\u4E4B\\u524D\\u5B58\\u5728heap\\u91CC\\u7684\\u6CB9\\u62FF\\u51FA\\u6765 \\u3002\\u52A0\\uFF01\\u52A0\\u6EE1\\uFF01\\u52A0\\u5927\\u4E2A\\u7684\\uFF01\\n            currFuel += maxheap.poll();\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        //build the maxheap\\n        Queue<Integer> maxheap = new PriorityQueue<>((Integer a, Integer b) -> b - a);\\n        \\n        int currFuel = startFuel; //current fuel can be used\\n        int res = 0; //number of times that we refueling\\n        int currPos = 0; //the current position we at\\n        int n = stations.length; // number of gas stations we have\\n        \\n        //only get into the loop, when our currFuel is not enough to reach the target position\\n        while (currFuel < target) {\\n            //\\u56E0\\u4E3A\\u524D\\u9762while loop\\u7684\\u5224\\u65AD\\uFF0C\\u6211\\u4EEC\\u8F66\\u5B50\\u663E\\u7136\\u51ED\\u7740\\u81EA\\u8EAB\\u672C\\u6765\\u7684fuel\\u5DF2\\u7ECF\\u65E0\\u6CD5\\u5230\\u8FBE\\u91CD\\u70B9\\u4E86\\u3002\\n            //\\u90A3\\u6211\\u4EEC\\u5C31\\u5148\\u5230\\u8FBE\\u80FD\\u591F\\u6700\\u8FDC\\u7684\\u52A0\\u6CB9\\u7AD9\\uFF0C\\u7136\\u540E\\u628A\\u6240\\u6709\\u9014\\u5F84\\u7684\\uFF08\\u53EF\\u4EE5reach\\u7684\\u52A0\\u6CB9\\u7AD9\\uFF09\\u7684\\u6CB9\\u90FD\\u52A0\\u5230meaheap\\u91CC\\u9762\\n\\t\\t\\t//(\\u50CF\\u662F\\u5148\\u5B58\\u8D77\\u6765 \\u4F46\\u4E0D\\u52A0\\uFF0C\\u6CE8\\u610F\\uFF01\\u653E\\u5230heap\\u91CC\\u9762\\u5E76\\u4E0D\\u662F\\u52A0\\u6CB9\\uFF0C\\u5E76\\u4E0D\\u662F\\u52A0\\u6CB9\\u7684\\u64CD\\u4F5C\\uFF0C\\u4E0D\\u662F\\u5728\\u52A0\\u6CB9\\uFF01\\u91CD\\u8981\\u7684\\u4E8B\\u8BF4\\u4E09\\u904D~\\n            //currPos < n (number of gas stations) \\u662F\\u4E3A\\u4E86\\u786E\\u8BA4\\u8FD8\\u6709\\u52A0\\u6CB9\\u7AD9\\u7684\\u6CB9\\u53EF\\u52A0\\uFF0C\\u5F53\\u6211\\u4EEC\\u5DF2\\u7ECF\\u8D85\\u8FC7\\u4E86\\uFF0C\\u90A3\\u6211\\u4EEC\\u8FD9\\u4E2Aloop\\u91CC\\u6240\\u505A\\u7684\\u4E8B\\u60C5\\uFF0C\\n            //\\u4E5F\\u5C31\\u662F\\u5728heap\\u91CC\\u9762\\u653E\\u5165\\u4E4B\\u524D\\u9014\\u5F84\\u52A0\\u6CB9\\u7AD9\\u7684\\u6CB9\\u5DF2\\u7ECF\\u6CA1\\u6709\\u610F\\u4E49\\u4E86\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u4E4B\\u524D\\u90FD\\u5DF2\\u7ECF\\u52A0\\u8FC7\\u4E86\\uFF0C\\u73B0\\u5728\\u6CA1\\u6709\\u65B0\\u7684\\u9014\\u5F84\\u52A0\\u6CB9\\u7AD9\\u7684\\u6CB9\\u53EF\\u52A0\\n            while (currPos < n && stations[currPos][0] <= currFuel) {\\n                maxheap.add(stations[currPos][1]);\\n                currPos++;\\n            }\\n            \\n            //if there are no gas stations along the way we passed, then that means we could not reach the target\\n            if (maxheap.isEmpty()) {\\n                return -1;\\n            }\\n            //key: greedy alogirthm, we add the most / largest fuel we have in the heap\\n\\t\\t\\t//\\u8FD9\\u4E00\\u6B65\\u624D\\u662F\\u52A0\\u6CB9\\u7684\\u64CD\\u4F5C\\uFF0C\\u8FD9\\u65F6\\u5019\\u6211\\u4EEC\\u6CB9\\u4E0D\\u591F\\u4E86 \\u5BF9\\u5427\\uFF0C\\u6211\\u4EEC\\u628A\\u4E4B\\u524D\\u5B58\\u5728heap\\u91CC\\u7684\\u6CB9\\u62FF\\u51FA\\u6765 \\u3002\\u52A0\\uFF01\\u52A0\\u6EE1\\uFF01\\u52A0\\u5927\\u4E2A\\u7684\\uFF01\\n            currFuel += maxheap.poll();\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455897,
                "title": "ruby-100-100",
                "content": "Ruby:\\n```ruby\\n# Runtime: 528 ms, faster than 100.00% of Ruby online submissions for Minimum Number of Refueling Stops.\\n# Memory Usage: 211.2 MB, less than 100.00% of Ruby online submissions for Minimum Number of Refueling Stops.\\ndef min_refuel_stops(target, start_fuel, stations)\\n  dp = [start_fuel] + [0] * stations.size\\n  stations.each.with_index { |(location, capacity), i|\\n    i.downto(0) { |t| dp[t+1] = [dp[t+1], dp[t] + capacity].max if dp[t] >= location }\\n  }\\n  dp.each.with_index { |d, i| return i if d >= target }\\n  -1\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "```ruby\\n# Runtime: 528 ms, faster than 100.00% of Ruby online submissions for Minimum Number of Refueling Stops.\\n# Memory Usage: 211.2 MB, less than 100.00% of Ruby online submissions for Minimum Number of Refueling Stops.\\ndef min_refuel_stops(target, start_fuel, stations)\\n  dp = [start_fuel] + [0] * stations.size\\n  stations.each.with_index { |(location, capacity), i|\\n    i.downto(0) { |t| dp[t+1] = [dp[t+1], dp[t] + capacity].max if dp[t] >= location }\\n  }\\n  dp.each.with_index { |d, i| return i if d >= target }\\n  -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2455820,
                "title": "c-easy-and-short-code-98-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int max_go = startFuel;\\n        int answer = 0;\\n        int index = 0;\\n        priority_queue<int>pq;\\n        \\n        while(max_go<target){\\n            while(index<stations.size() && stations[index][0]<=max_go){\\n                pq.push(stations[index][1]); // push all the stations present in between where you started and till you reached.\\n                index++;\\n            }\\n            if(pq.empty())return -1;\\n            \\n            max_go = max_go+pq.top();\\n            pq.pop();\\n            answer++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int max_go = startFuel;\\n        int answer = 0;\\n        int index = 0;\\n        priority_queue<int>pq;\\n        \\n        while(max_go<target){\\n            while(index<stations.size() && stations[index][0]<=max_go){\\n                pq.push(stations[index][1]); // push all the stations present in between where you started and till you reached.\\n                index++;\\n            }\\n            if(pq.empty())return -1;\\n            \\n            max_go = max_go+pq.top();\\n            pq.pop();\\n            answer++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455711,
                "title": "c-priority-queue-with-detailed-explanation-t-c-o-nlogn-s-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    // T.C: O(nlogn) -> as we are using priority queue\\n    // S.C: O(n) -> max-to-max we might store all the station fuels into our priority queue \\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int currStation = startFuel;\\n        int refuelCnt = 0;\\n        \\n        // max-heap to get the maximum fuel whenever our fuel is exhausted\\n        priority_queue<int> pq; \\n        \\n        for(int i=0;i<stations.size();i++) {\\n            int nextStation = stations[i][0];\\n            int fuelQuantity = stations[i][1];\\n            \\n            // exhausted our fuel so refuel\\n            while(currStation < nextStation) {\\n                if(pq.empty()) return -1; // as we can\\'t refuel \\n                \\n                currStation += pq.top();\\n                pq.pop();\\n                refuelCnt++;\\n            }\\n            // as we have fuel to reach the next station\\n            // so we reach there and collect the fuel\\n            pq.push(fuelQuantity);\\n        }\\n        \\n        // check if we\\'ve reached our destination or not\\n        while(currStation < target) {\\n            if(pq.empty()) return -1; // as we can\\'t refuel \\n                \\n            currStation += pq.top();\\n            pq.pop();\\n            refuelCnt++;\\n        }\\n        \\n        return refuelCnt;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // T.C: O(nlogn) -> as we are using priority queue\\n    // S.C: O(n) -> max-to-max we might store all the station fuels into our priority queue \\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int currStation = startFuel;\\n        int refuelCnt = 0;\\n        \\n        // max-heap to get the maximum fuel whenever our fuel is exhausted\\n        priority_queue<int> pq; \\n        \\n        for(int i=0;i<stations.size();i++) {\\n            int nextStation = stations[i][0];\\n            int fuelQuantity = stations[i][1];\\n            \\n            // exhausted our fuel so refuel\\n            while(currStation < nextStation) {\\n                if(pq.empty()) return -1; // as we can\\'t refuel \\n                \\n                currStation += pq.top();\\n                pq.pop();\\n                refuelCnt++;\\n            }\\n            // as we have fuel to reach the next station\\n            // so we reach there and collect the fuel\\n            pq.push(fuelQuantity);\\n        }\\n        \\n        // check if we\\'ve reached our destination or not\\n        while(currStation < target) {\\n            if(pq.empty()) return -1; // as we can\\'t refuel \\n                \\n            currStation += pq.top();\\n            pq.pop();\\n            refuelCnt++;\\n        }\\n        \\n        return refuelCnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455582,
                "title": "ruby-translation-of-the-leetcode-solution",
                "content": "## Leetcode: 871. Minimum Number of Refueling Stops.\\n\\n\\n**Ruby: Translation of the Leetcode\\' solution.**\\n\\n\\nCode based on the [Leetcode\\'s solution](https://leetcode.com/problems/minimum-number-of-refueling-stops/solution/).\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 871. Minimum Number of Refueling Stops.\\n# https://leetcode.com/problems/minimum-number-of-refueling-stops/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 697 ms, faster than 100.00% of Ruby online submissions for Minimum Number of Refueling Stops.\\n# Memory Usage: 223.3 MB, less than 100.00% of Ruby online submissions for Minimum Number of Refueling Stops.\\n# @param {Integer} target\\n# @param {Integer} start_fuel\\n# @param {Integer[][]} stations\\n# @return {Integer}\\ndef min_refuel_stops(target, start_fuel, stations)\\n  # Based on:\\n  # https://leetcode.com/problems/minimum-number-of-refueling-stops/solution/\\n  dp = [start_fuel] + [0] * stations.size\\n  stations.each_with_index do |(location, capacity),i|\\n    (0..i).reverse_each do |t|\\n      dp[t+1] = max(dp[t+1], dp[t] + capacity) if dp[t] >= location\\n    end\\n  end\\n  dp.each_with_index do |d,i|\\n    return i if d >= target\\n  end\\n  return -1\\nend\\n\\ndef max(a,b)\\n  if a > b\\n    a\\n  else\\n    b\\n  end\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "```Ruby\\n# Leetcode: 871. Minimum Number of Refueling Stops.\\n# https://leetcode.com/problems/minimum-number-of-refueling-stops/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 697 ms, faster than 100.00% of Ruby online submissions for Minimum Number of Refueling Stops.\\n# Memory Usage: 223.3 MB, less than 100.00% of Ruby online submissions for Minimum Number of Refueling Stops.\\n# @param {Integer} target\\n# @param {Integer} start_fuel\\n# @param {Integer[][]} stations\\n# @return {Integer}\\ndef min_refuel_stops(target, start_fuel, stations)\\n  # Based on:\\n  # https://leetcode.com/problems/minimum-number-of-refueling-stops/solution/\\n  dp = [start_fuel] + [0] * stations.size\\n  stations.each_with_index do |(location, capacity),i|\\n    (0..i).reverse_each do |t|\\n      dp[t+1] = max(dp[t+1], dp[t] + capacity) if dp[t] >= location\\n    end\\n  end\\n  dp.each_with_index do |d,i|\\n    return i if d >= target\\n  end\\n  return -1\\nend\\n\\ndef max(a,b)\\n  if a > b\\n    a\\n  else\\n    b\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2455443,
                "title": "simple-java-solution-o-nlogn-time",
                "content": "Using BFS + greedy approch\\n**Time Complexity=O(nlogn)**\\n![image](https://assets.leetcode.com/users/images/8c9370ae-4146-49d8-9855-4600b307c77f_1661021570.4343047.png)\\n\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<int[]>((a,b)-> b[1]-a[1]);\\n        int count=0,i=0;\\n        int distance=startFuel;\\n        while(distance<target){\\n            while(i<stations.length&&distance>=stations[i][0]){ \\n                pq.offer(stations[i]);\\n                i++;\\n            }\\n            if(pq.isEmpty()) return -1;\\n            distance+=pq.remove()[1];\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<int[]>((a,b)-> b[1]-a[1]);\\n        int count=0,i=0;\\n        int distance=startFuel;\\n        while(distance<target){\\n            while(i<stations.length&&distance>=stations[i][0]){ \\n                pq.offer(stations[i]);\\n                i++;\\n            }\\n            if(pq.isEmpty()) return -1;\\n            distance+=pq.remove()[1];\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455442,
                "title": "dp-and-maxheap-approaches-with-explaination",
                "content": "## Approach 1 - DP\\n\\nThe idea is simple, we start at `i` th station and look back at each each station check point `j` in range of `[0,i]` and see if it is reachable from i\\'th station.\\n\\nIf so we add fuel of current station to the the previous station.\\n\\nIn the end we run a loop on dp array and see how much steps we\\'d have to take to make to reach the last stop. What\\'s interesting is that from each hotel we only add what\\'s possible after reaching next reachable station. but since out dp array has an extra insertion at begining we just can return `ret` without adding an addiotional `1` to it.\\n\\n```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        // DP Add stuff backward to all eligible stations\\n        int n=stations.length;\\n        long dp[] = new long[n+1]; // fuel at each station point\\n        \\n        dp[0]=startFuel; // start with starting fuel\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=i;j>=0 && dp[j]>=stations[i][0];--j){\\n                // for all stations points \\'j\\' from which there\\'s enough fuel to reach ith station point\\n                // update max distance\\n                dp[j+1] = Math.max(dp[j+1], dp[j]+stations[i][1]);\\n            }\\n        }\\n        \\n        // for each station check point check if we can return\\n        for(int ret=0;ret<n+1;ret++)\\n            if(dp[ret]>=target) return ret;\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\n## Approach 2 - Greedy MaxHeap\\n\\nThe idea is simple create a PQ with reverseOrder so that we can add and get the highest amout of fuel that\\'s available for us that\\'s behind us. \\n\\nwe start counting stops as long as `cur<target` and add every possible station beind us in a max heap and if we at any point find that heap is empty we can say that we haven\\'t reached the target yet heap is empty so return `-1`;\\n\\nelse if we exit loop after reaching target we simply return stops which gives us how many stations we had to stop\\n\\n```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        // Idea is to greadily pick the station with highest fuel at a given station check\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int n=stations.length, cur=startFuel, stops=0, i=0;\\n        for(stops=0;cur<target;stops++){\\n            // add all stations that are behind us\\n            while(i<stations.length && stations[i][0]<=cur)\\n                pq.offer(stations[i++][1]);\\n            if(pq.isEmpty()) return -1; // If no stations behind us and cur<target we didn\\'t and won\\'t reach target\\n            cur += pq.poll();\\n        }\\n        \\n        return stops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        // DP Add stuff backward to all eligible stations\\n        int n=stations.length;\\n        long dp[] = new long[n+1]; // fuel at each station point\\n        \\n        dp[0]=startFuel; // start with starting fuel\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=i;j>=0 && dp[j]>=stations[i][0];--j){\\n                // for all stations points \\'j\\' from which there\\'s enough fuel to reach ith station point\\n                // update max distance\\n                dp[j+1] = Math.max(dp[j+1], dp[j]+stations[i][1]);\\n            }\\n        }\\n        \\n        // for each station check point check if we can return\\n        for(int ret=0;ret<n+1;ret++)\\n            if(dp[ret]>=target) return ret;\\n        \\n        return -1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        // Idea is to greadily pick the station with highest fuel at a given station check\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int n=stations.length, cur=startFuel, stops=0, i=0;\\n        for(stops=0;cur<target;stops++){\\n            // add all stations that are behind us\\n            while(i<stations.length && stations[i][0]<=cur)\\n                pq.offer(stations[i++][1]);\\n            if(pq.isEmpty()) return -1; // If no stations behind us and cur<target we didn\\'t and won\\'t reach target\\n            cur += pq.poll();\\n        }\\n        \\n        return stops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455364,
                "title": "java-easy-greedy-sol-explained",
                "content": "* We will be first checking whether we can reach alll the stations by storing fuel whenever needed.\\n* once we are able to reach all the stations , we will examine our current pos , if our curr pos is less than target then we will use the left over fuel .\\n\\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startF, int[][] stations) {\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> b-a);\\n        \\n    \\n        \\n        int pos =startF;\\n        \\n        // ill check the farthest i can go\\n        for(int[] curr: stations){\\n            \\n            while(pos<curr[0]){\\n                if(pq.size()<=0) return -1;\\n                pos+=pq.remove();\\n            }\\n            pq.add(curr[1]);\\n        }\\n        \\n        while(pos<target){\\n            if(pq.size()<=0) return -1;\\n            pos+=pq.remove();\\n        }\\n        \\n        return (stations.length - pq.size());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startF, int[][] stations) {\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> b-a);\\n        \\n    \\n        \\n        int pos =startF;\\n        \\n        // ill check the farthest i can go\\n        for(int[] curr: stations){\\n            \\n            while(pos<curr[0]){\\n                if(pq.size()<=0) return -1;\\n                pos+=pq.remove();\\n            }\\n            pq.add(curr[1]);\\n        }\\n        \\n        while(pos<target){\\n            if(pq.size()<=0) return -1;\\n            pos+=pq.remove();\\n        }\\n        \\n        return (stations.length - pq.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454946,
                "title": "c-priority-queue-time-o-nlogn-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int n = stations.size();\\n        \\n        int count = 0;\\n        int distLimit = startFuel;\\n        int maxDist = 0;\\n        \\n        if(startFuel >= target)\\n            return 0;\\n        else if(!n)\\n            return -1;\\n        \\n        int k = 0;\\n\\n        priority_queue<int> max_pq;\\n        while(k < n)\\n        {\\n            while(k < n && stations[k][0] <= distLimit)\\n            {              \\n                max_pq.push(stations[k][1]);\\n                k++;\\n            }\\n            \\n            if(max_pq.empty())\\n               break;\\n        \\n            while(!max_pq.empty())\\n            {\\n                count++;\\n                distLimit += max_pq.top();\\n                max_pq.pop();\\n    \\n                if(distLimit >= target)\\n                    return count;\\n                \\n               if(k < n && distLimit >= stations[k][0])\\n                    break;                \\n            }\\n    \\n            if( k >= n)\\n                break;\\n        }\\n        \\n       return -1;\\n        \\n    }\\n    // Time O(NlogN)\\n    // Space O(N)\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int n = stations.size();\\n        \\n        int count = 0;\\n        int distLimit = startFuel;\\n        int maxDist = 0;\\n        \\n        if(startFuel >= target)\\n            return 0;\\n        else if(!n)\\n            return -1;\\n        \\n        int k = 0;\\n\\n        priority_queue<int> max_pq;\\n        while(k < n)\\n        {\\n            while(k < n && stations[k][0] <= distLimit)\\n            {              \\n                max_pq.push(stations[k][1]);\\n                k++;\\n            }\\n            \\n            if(max_pq.empty())\\n               break;\\n        \\n            while(!max_pq.empty())\\n            {\\n                count++;\\n                distLimit += max_pq.top();\\n                max_pq.pop();\\n    \\n                if(distLimit >= target)\\n                    return count;\\n                \\n               if(k < n && distLimit >= stations[k][0])\\n                    break;                \\n            }\\n    \\n            if( k >= n)\\n                break;\\n        }\\n        \\n       return -1;\\n        \\n    }\\n    // Time O(NlogN)\\n    // Space O(N)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454552,
                "title": "c-solution-easy-to-understand-greedy",
                "content": "**Please upvote if you find the solution useful.**\\n\\n**C++ Greedy Solution :-**\\n```\\nclass Solution {\\nprivate:\\n    static bool myCmp(vector<int> &a,vector<int> &b){\\n        return a[0]<b[0];\\n    }\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int stops = 0, currentFuel = startFuel;\\n        priority_queue<pair<int,int>> hypo;\\n        sort(stations.begin(),stations.end(),myCmp);\\n        int i = 0;\\n        while(currentFuel<target){\\n            while(stations.size()>i && stations[i][0]<=currentFuel){\\n                hypo.push({stations[i][1],stations[i][0]});\\n                i++;\\n            }\\n            if(currentFuel<target && !hypo.empty()){\\n                currentFuel += hypo.top().first;\\n                hypo.pop();\\n                stops ++;\\n            }else{\\n                stops = -1;\\n                break;\\n            }\\n        }\\n        return stops;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    static bool myCmp(vector<int> &a,vector<int> &b){\\n        return a[0]<b[0];\\n    }\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int stops = 0, currentFuel = startFuel;\\n        priority_queue<pair<int,int>> hypo;\\n        sort(stations.begin(),stations.end(),myCmp);\\n        int i = 0;\\n        while(currentFuel<target){\\n            while(stations.size()>i && stations[i][0]<=currentFuel){\\n                hypo.push({stations[i][1],stations[i][0]});\\n                i++;\\n            }\\n            if(currentFuel<target && !hypo.empty()){\\n                currentFuel += hypo.top().first;\\n                hypo.pop();\\n                stops ++;\\n            }else{\\n                stops = -1;\\n                break;\\n            }\\n        }\\n        return stops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454055,
                "title": "javascript-priority-queue-own-solution-100-faster",
                "content": "```\\n/**\\n * @param {number} target\\n * @param {number} startFuel\\n * @param {number[][]} stations\\n * @return {number}\\n */\\nvar minRefuelStops = function(target, startFuel, stations) {\\n    let stops = 0;\\n    let distCovered = startFuel;\\n    \\n    stations.sort((a, b) => b[1] - a[1]);\\n    \\n    while (distCovered < target) {\\n        let length = stations.length;\\n        for (let i = 0; i < stations.length; i++) {\\n            if (stations[i][0] <= distCovered) {\\n                distCovered += stations[i][1]\\n                stations.splice(i, 1);\\n                stops++;\\n                break;\\n            }\\n        }\\n        if (length === stations.length) {\\n            return -1;\\n        }\\n    }\\n    \\n    return stops;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number} target\\n * @param {number} startFuel\\n * @param {number[][]} stations\\n * @return {number}\\n */\\nvar minRefuelStops = function(target, startFuel, stations) {\\n    let stops = 0;\\n    let distCovered = startFuel;\\n    \\n    stations.sort((a, b) => b[1] - a[1]);\\n    \\n    while (distCovered < target) {\\n        let length = stations.length;\\n        for (let i = 0; i < stations.length; i++) {\\n            if (stations[i][0] <= distCovered) {\\n                distCovered += stations[i][1]\\n                stations.splice(i, 1);\\n                stops++;\\n                break;\\n            }\\n        }\\n        if (length === stations.length) {\\n            return -1;\\n        }\\n    }\\n    \\n    return stops;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453298,
                "title": "100-faster-and-100-takes-less-space-swift",
                "content": "```\\nclass Solution {\\n    func minRefuelStops(_ target: Int, _ startFuel: Int, _ stations: [[Int]]) -> Int {\\n        if stations.count == 0 {\\n            return startFuel >= target ? 0 : -1\\n        }\\n        if startFuel >= target {\\n            return 0\\n        }\\n        if startFuel < stations[0][0] {\\n            return -1\\n        }\\n        var dp = [Int](repeating: startFuel, count: stations.count + 1)\\n        for i in 0..<stations.count {\\n            for j in (0...i).reversed() {\\n                if dp[j] >= stations[i][0] {\\n                    dp[j + 1] = max(dp[j + 1], dp[j] + stations[i][1])\\n                }\\n            }\\n        }\\n        for i in 0...stations.count {\\n            if dp[i] >= target {\\n                return i\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\\nIf you like my solution please upvote)",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func minRefuelStops(_ target: Int, _ startFuel: Int, _ stations: [[Int]]) -> Int {\\n        if stations.count == 0 {\\n            return startFuel >= target ? 0 : -1\\n        }\\n        if startFuel >= target {\\n            return 0\\n        }\\n        if startFuel < stations[0][0] {\\n            return -1\\n        }\\n        var dp = [Int](repeating: startFuel, count: stations.count + 1)\\n        for i in 0..<stations.count {\\n            for j in (0...i).reversed() {\\n                if dp[j] >= stations[i][0] {\\n                    dp[j + 1] = max(dp[j + 1], dp[j] + stations[i][1])\\n                }\\n            }\\n        }\\n        for i in 0...stations.count {\\n            if dp[i] >= target {\\n                return i\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452800,
                "title": "c-max-heap-implementation-with-explanation",
                "content": "This problem is said to find out the minimum number of time we have to *re-fuel* our tank to visit while travelling from *0* to *target*. We will be given an initial amount of fuel *startFuel* and the location of fueling stops *stations* with amount of fuel available in each of those stations. How to come up with an idea that can minimize *re-fueling*?\\n\\n**Observation**: Take a look at the following line -\\n*Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived.* \\nThat simply means we have to re-fuel the car only when we have to move further for a distance say `X` and we do not have `X` amount of fuel available. In general, if something required whose is not available then it goes to the negative end. \\nLike, if we need `5` but we have `3`, then what we have is `-3 (deifict of 3)`. So, when my requirement goes negative I understand that I need some more amount to cover up the deficit.\\n\\n**Process**:\\nWe will use above understanding to solve this problem. That means after reaching each of the station we will be checking if we need some more fuel to cover the next stop or not? If we do not need to re-fuel we will go as-is, if we need to re-fuel then we will re-fuel the tank with the *largest amount of fuel* among stations we have passed behind. Let\\'s try to illustrate by the following example.\\n\\n``` python\\n// target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] \\n\\nSo we have 4 stations. And we need to move from 0 to 100.\\nOur current fuel, c_fuel = 10, our current location c_point = 0\\ncontainer = [] // container is something that stores the amount of fuel for the stops we have not used yet.\\n\\nNow, on i = 0th stop, distance is 10, and fuel = 60\\nWhile trying to access 0th stop we do not need more fuel. We can pass it with c_fuel=10 unit of fuel \\nand our remaining fuel is now c_fuel=0.\\nWe have not used 0th stop fuel so add it to the container. So,\\ncontainer = [60]\\nc_fuel = 0\\nc_point = 10\\n\\nNow, on i=1st stop, distance is 20, and fuel = 30\\nWe have 0 fuel in tank. We need 10 unit of fuel to pass this stop. We need to add some more fuel. We will be adding it from the container. So,\\nc_fuel = 0 + 60-10 = 50 ( from container 60 and we have to use 10 for travelling current distance )\\ncontainer = [30] (We have not used fuel of current stop yet)\\nc_point = 20\\n\\nNow, on i=2nd stop, distance is 30, and fuel = 30\\nWe have 50 fuel in tank. We need 10 unit of fuel to pass this stop. We do not need to add any more fuel.So,\\nc_fuel = 50 - 10 = 40 ( We have to use 10 for travelling current distance )\\ncontainer = [30, 30] (We have not used fuel of current stop yet)\\nc_point = 30\\n\\nNow, on i=3rd stop, distance is 60, and fuel = 40\\nWe have 40 fuel in tank. We need 30 unit of fuel to pass this stop. We don not need to add any more fuel. So,\\nc_fuel = 40 - 30 = 10 ( We have to use 30 for travelling current distance )\\ncontainer = [30, 30, 40] (We have not used fuel of current stop yet)\\nc_point = 60\\n\\nNow to approach the final distance 100 we need to travel 100-60 = 40 unit of distance. And 40 unit of fuel.\\nBut we have only 10 in car. We have to add some more fuel from container. Now for this we can add 30/30/40 unit from the container but we will be adding 40.\\nSo after adding 40, \\nc_fuel = 10 + 40 - 40= 10 ( We have to use 40 for travelling final distance )\\ncontainer = [30, 30] (We have not used fuel of current stop yet)\\nc_point = 100\\n\\nAs we have reached to the end we can say it is possible to reach from 0 to 100. And for this at, i = 0 and at i = 3 we had to re-fuel. So, we will be returning 2 as our answer.\\n```\\n**Now, why should we take the largest amount of fuel from container?**\\nNow imagine, if we had to reach the point `110` and if we re-fuel with `30` then to reach the destination we need to re-fuel again which will increase the `counter`. That\\'s why we are taking the largest from the unused fuels. Now which container stores the largest element at the top? `Max heap` or `Priority Queue`.\\nTry with rest of the examples.\\n\\n**Complete Code**: \\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int n = stations.size();\\n        priority_queue<int>available;\\n        int c_fuel = startFuel, c_point = 0, ans = 0;\\n        stations.push_back({target, 0});\\n        \\n        \\n        for(int i=0; i<stations.size(); i++){\\n            // cout<<stations.size()<<endl;\\n            int stop = stations[i][0];  \\n            int fuel = stations[i][1];  \\n            \\n            int to_dist = stop - c_point; \\n            c_fuel = c_fuel - to_dist; \\n            \\n            while(!available.empty() && c_fuel<0){\\n                c_fuel += available.top();  \\n                available.pop();\\n                ans++;  \\n            }\\n            if(c_fuel < 0) return -1;\\n            c_point = stop;  \\n            if(c_point >= target){\\n                break;\\n            }\\n            \\n            available.push(fuel);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote, If You Like it**.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "``` python\\n// target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] \\n\\nSo we have 4 stations. And we need to move from 0 to 100.\\nOur current fuel, c_fuel = 10, our current location c_point = 0\\ncontainer = [] // container is something that stores the amount of fuel for the stops we have not used yet.\\n\\nNow, on i = 0th stop, distance is 10, and fuel = 60\\nWhile trying to access 0th stop we do not need more fuel. We can pass it with c_fuel=10 unit of fuel \\nand our remaining fuel is now c_fuel=0.\\nWe have not used 0th stop fuel so add it to the container. So,\\ncontainer = [60]\\nc_fuel = 0\\nc_point = 10\\n\\nNow, on i=1st stop, distance is 20, and fuel = 30\\nWe have 0 fuel in tank. We need 10 unit of fuel to pass this stop. We need to add some more fuel. We will be adding it from the container. So,\\nc_fuel = 0 + 60-10 = 50 ( from container 60 and we have to use 10 for travelling current distance )\\ncontainer = [30] (We have not used fuel of current stop yet)\\nc_point = 20\\n\\nNow, on i=2nd stop, distance is 30, and fuel = 30\\nWe have 50 fuel in tank. We need 10 unit of fuel to pass this stop. We do not need to add any more fuel.So,\\nc_fuel = 50 - 10 = 40 ( We have to use 10 for travelling current distance )\\ncontainer = [30, 30] (We have not used fuel of current stop yet)\\nc_point = 30\\n\\nNow, on i=3rd stop, distance is 60, and fuel = 40\\nWe have 40 fuel in tank. We need 30 unit of fuel to pass this stop. We don not need to add any more fuel. So,\\nc_fuel = 40 - 30 = 10 ( We have to use 30 for travelling current distance )\\ncontainer = [30, 30, 40] (We have not used fuel of current stop yet)\\nc_point = 60\\n\\nNow to approach the final distance 100 we need to travel 100-60 = 40 unit of distance. And 40 unit of fuel.\\nBut we have only 10 in car. We have to add some more fuel from container. Now for this we can add 30/30/40 unit from the container but we will be adding 40.\\nSo after adding 40, \\nc_fuel = 10 + 40 - 40= 10 ( We have to use 40 for travelling final distance )\\ncontainer = [30, 30] (We have not used fuel of current stop yet)\\nc_point = 100\\n\\nAs we have reached to the end we can say it is possible to reach from 0 to 100. And for this at, i = 0 and at i = 3 we had to re-fuel. So, we will be returning 2 as our answer.\\n```\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        \\n        int n = stations.size();\\n        priority_queue<int>available;\\n        int c_fuel = startFuel, c_point = 0, ans = 0;\\n        stations.push_back({target, 0});\\n        \\n        \\n        for(int i=0; i<stations.size(); i++){\\n            // cout<<stations.size()<<endl;\\n            int stop = stations[i][0];  \\n            int fuel = stations[i][1];  \\n            \\n            int to_dist = stop - c_point; \\n            c_fuel = c_fuel - to_dist; \\n            \\n            while(!available.empty() && c_fuel<0){\\n                c_fuel += available.top();  \\n                available.pop();\\n                ans++;  \\n            }\\n            if(c_fuel < 0) return -1;\\n            c_point = stop;  \\n            if(c_point >= target){\\n                break;\\n            }\\n            \\n            available.push(fuel);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2452733,
                "title": "ruby-2-liner",
                "content": "priority queue\\n```\\ndef min_refuel_stops(target, start, list)\\n  [].tap{|q| 500.times.reduce(start){|max,i| q<<list.shift[1] until list.empty? or list[0][0]>max\\n    max>=target ? (return i) : q.empty? ? (return -1) : max+q.sort!.pop } }\\nend\\n```\\n\\nbacktracking\\n```\\ndef min_refuel_stops(target, start, list)\\n  [[0,0], *list, [target,0]].reverse.each_cons(2).reduce([0]){|res,segm| e,_,s,fuel=segm.flatten\\n    [2e9, *res, 2e9].each_cons(2).map{ [[e-s+_1-fuel,0].max, e-s+_2].min } }.index{start>=_1} or -1\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef min_refuel_stops(target, start, list)\\n  [].tap{|q| 500.times.reduce(start){|max,i| q<<list.shift[1] until list.empty? or list[0][0]>max\\n    max>=target ? (return i) : q.empty? ? (return -1) : max+q.sort!.pop } }\\nend\\n```\n```\\ndef min_refuel_stops(target, start, list)\\n  [[0,0], *list, [target,0]].reverse.each_cons(2).reduce([0]){|res,segm| e,_,s,fuel=segm.flatten\\n    [2e9, *res, 2e9].each_cons(2).map{ [[e-s+_1-fuel,0].max, e-s+_2].min } }.index{start>=_1} or -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2452563,
                "title": "c-dp-solution-with-explanation",
                "content": "```\\n /*Try to visualize the problem , as a traditional \\n    Knapsack problem. Now in case of K.S Problems , our \\n    goal is to maximize the profit , within the given \\n    capacity.\\n    \\n    In these problem , our goal is to Minimize the number\\n    of stations picked in our journey to reach the \\n    destination from \\'0\\'.\\n    \\n    So our recursion state would look like something\\n    these, dp[i] --> denotes the Minimum number of \\n    stations we need to stop at to reach target.\\n    \\n    Now , our \\'i\\' value ranges from \\'0\\' to \\'target\\'\\n    \\n    But wait!!! , let\\'s have a look at the constraints ,\\n    target <= 10^9 , we can\\'t consider the \\'station_dist\\'\\n    as our recursion state , as it will eventually give \\n    us MLE,\\n    \\n    \\n    So , what ......\\n    \\n    Let\\'s use the same approach , but now from a \\n    different perspective. Instead of finding the minimum\\n    number of refueling stations to reach i-th station \\n    (\\'target\\') , we just need to find out the maximum \\n    amount of fuel we can get by refuelling at \\'i\\' number\\n    of stations.\\n    \\n    \\n    Now , dp[i] --> Maximum amount of fuel , we can \\n    achieve by refueling our car exactly at \\'i\\' number of \\n    stations. \\n    \\n    */\\n    \\n     /*\\n     \\n     Time Complexity  : O(N*N)\\n     Space Complexity : O(N)\\n     \\n     */\\n\\n\\n\\n//dp[i] stores the maximum reach \\n// dp[j]>=(long long)stations[i][0] means\\n// suppose 70 tk k reach p pahuch gae bt target 100 h then we need more fuel to reach till target to uske lie jitne piche jo stations chut gae h unme hm dekhege wo maximum fuel wala station lege\\n//agr kahi dp[i] m jo reach h uski value target s >= ho gai to i return kr dege\\n\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n=stations.size();\\n        vector<long long> dp(n+1,0);\\n        \\n        dp[0]=startFuel;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                if(dp[j]>=(long long)stations[i][0])\\n                {\\n                    dp[j+1]=max(dp[j+1],dp[j]+stations[i][1]);\\n                }\\n            }\\n        }\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(dp[i]>=target) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n /*Try to visualize the problem , as a traditional \\n    Knapsack problem. Now in case of K.S Problems , our \\n    goal is to maximize the profit , within the given \\n    capacity.\\n    \\n    In these problem , our goal is to Minimize the number\\n    of stations picked in our journey to reach the \\n    destination from \\'0\\'.\\n    \\n    So our recursion state would look like something\\n    these, dp[i] --> denotes the Minimum number of \\n    stations we need to stop at to reach target.\\n    \\n    Now , our \\'i\\' value ranges from \\'0\\' to \\'target\\'\\n    \\n    But wait!!! , let\\'s have a look at the constraints ,\\n    target <= 10^9 , we can\\'t consider the \\'station_dist\\'\\n    as our recursion state , as it will eventually give \\n    us MLE,\\n    \\n    \\n    So , what ......\\n    \\n    Let\\'s use the same approach , but now from a \\n    different perspective. Instead of finding the minimum\\n    number of refueling stations to reach i-th station \\n    (\\'target\\') , we just need to find out the maximum \\n    amount of fuel we can get by refuelling at \\'i\\' number\\n    of stations.\\n    \\n    \\n    Now , dp[i] --> Maximum amount of fuel , we can \\n    achieve by refueling our car exactly at \\'i\\' number of \\n    stations. \\n    \\n    */\\n    \\n     /*\\n     \\n     Time Complexity  : O(N*N)\\n     Space Complexity : O(N)\\n     \\n     */\\n\\n\\n\\n//dp[i] stores the maximum reach \\n// dp[j]>=(long long)stations[i][0] means\\n// suppose 70 tk k reach p pahuch gae bt target 100 h then we need more fuel to reach till target to uske lie jitne piche jo stations chut gae h unme hm dekhege wo maximum fuel wala station lege\\n//agr kahi dp[i] m jo reach h uski value target s >= ho gai to i return kr dege\\n\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int n=stations.size();\\n        vector<long long> dp(n+1,0);\\n        \\n        dp[0]=startFuel;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                if(dp[j]>=(long long)stations[i][0])\\n                {\\n                    dp[j+1]=max(dp[j+1],dp[j]+stations[i][1]);\\n                }\\n            }\\n        }\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(dp[i]>=target) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452351,
                "title": "rust-heap-solution",
                "content": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn min_refuel_stops(target: i32, start_fuel: i32, mut stations: Vec<Vec<i32>>) -> i32 {       \\n        stations.push(vec![target, 0]);\\n        \\n        let mut min_number_of_stops = 0i32;\\n        let mut heap = BinaryHeap::with_capacity(stations.len());\\n        \\n        let mut current_fuel = start_fuel;\\n        \\n        for station in stations {\\n            let (position, fuel) = (station[0], station[1]);\\n            \\n            // if there is not enough fuel to keep going, then try to refuel from the biggest stations we have seen before\\n            while current_fuel < position {\\n                if let Some(refuel) = heap.pop() {\\n                    current_fuel += refuel;\\n                    min_number_of_stops += 1;\\n                } else {\\n                    // not enough fuel\\n                    return -1;\\n                }\\n            }\\n            // memorizing stations to refuel later if needed\\n            heap.push(fuel);\\n        }\\n        \\n        return min_number_of_stops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn min_refuel_stops(target: i32, start_fuel: i32, mut stations: Vec<Vec<i32>>) -> i32 {       \\n        stations.push(vec![target, 0]);\\n        \\n        let mut min_number_of_stops = 0i32;\\n        let mut heap = BinaryHeap::with_capacity(stations.len());\\n        \\n        let mut current_fuel = start_fuel;\\n        \\n        for station in stations {\\n            let (position, fuel) = (station[0], station[1]);\\n            \\n            // if there is not enough fuel to keep going, then try to refuel from the biggest stations we have seen before\\n            while current_fuel < position {\\n                if let Some(refuel) = heap.pop() {\\n                    current_fuel += refuel;\\n                    min_number_of_stops += 1;\\n                } else {\\n                    // not enough fuel\\n                    return -1;\\n                }\\n            }\\n            // memorizing stations to refuel later if needed\\n            heap.push(fuel);\\n        }\\n        \\n        return min_number_of_stops;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2452347,
                "title": "short-and-simple-solution-cpp",
                "content": "class Solution {\\npublic:\\n\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int i=0,res;\\n        priority_queue<int>pq;\\n        for(res=0;startFuel<target;res++){\\n            while(i<stations.size() && stations[i][0]<=startFuel)\\n                pq.push(stations[i++][1]);\\n            if(pq.empty())\\n                return -1;\\n            startFuel+=pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int i=0,res;\\n        priority_queue<int>pq;\\n        for(res=0;startFuel<target;res++){\\n            while(i<stations.size() && stations[i][0]<=startFuel)\\n                pq.push(stations[i++][1]);\\n            if(pq.empty())\\n                return -1;\\n            startFuel+=pq.top();\\n            pq.pop();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2452331,
                "title": "simple-java-better-approach-o-nlogn-time",
                "content": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        int fueled=0,start=0,dist=startFuel;\\n        \\n        while(dist<target){\\n            while(start<n && dist>=stations[start][0])\\n            {\\n                pq.offer(stations[start]);\\n                start++;\\n            }\\n            \\n            if(pq.isEmpty()) return -1;\\n            \\n            dist += pq.remove()[1];\\n            fueled++;\\n        }\\n        \\n        return fueled;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n = stations.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        int fueled=0,start=0,dist=startFuel;\\n        \\n        while(dist<target){\\n            while(start<n && dist>=stations[start][0])\\n            {\\n                pq.offer(stations[start]);\\n                start++;\\n            }\\n            \\n            if(pq.isEmpty()) return -1;\\n            \\n            dist += pq.remove()[1];\\n            fueled++;\\n        }\\n        \\n        return fueled;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452168,
                "title": "java-easy-explanation-using-priority-queue-90-faster-code",
                "content": "\\n\\n\\n\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        \\n\\t\\tPriorityQueue<Integer>pq=new PriorityQueue<>((a,b) -> stations[b][1]-stations[a][1]);\\n        int curr=startFuel,ans=0,idx=0;\\n        \\n        while(curr<target){\\n            while(idx<stations.length && stations[idx][0]<=curr){\\n                pq.add(idx);\\n                idx++;\\n            }\\n            if(pq.size()==0 && curr<target){\\n                return -1;\\n            }\\n            \\n            curr+=stations[pq.poll()][1];\\n            ans+=1;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        \\n\\t\\tPriorityQueue<Integer>pq=new PriorityQueue<>((a,b) -> stations[b][1]-stations[a][1]);\\n        int curr=startFuel,ans=0,idx=0;\\n        \\n        while(curr<target){\\n            while(idx<stations.length && stations[idx][0]<=curr){\\n                pq.add(idx);\\n                idx++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2452002,
                "title": "python-heap",
                "content": "This is an implmentation of a solution provided [here](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/294025/Java-Simple-Code-Greedy).\\n\\n**Solution**:\\nSince our car is started at position 0, the maximum travelable distance is depending on its fuel. However, we can only refuel at stations between 0 and max travelable distance. If we refuel at such station, it will increase our maximum travelable distance. Thus, we can be greedily refuel only at stations that contain maximum amount of fuel until we can reach the target. \\n\\nUse to heap to quickly find a station with a maximum amount of fuel\\n\\n**Complexity**:\\n    Time: O(nlogn)\\n    Space: O(n)\\n\\t\\n```\\nimport heapq\\n\\nclass Solution:\\n    def minRefuelStops(\\n        self, target: int, startFuel: int, stations: list[list[int]]\\n    ) -> int:\\n\\n        # Intialize the step and max travelable distance\\n        step, maxDist = 0, startFuel\\n\\n        # Initialize the index and bound of stations\\n        i, n = 0, len(stations)\\n\\n        # Initialize the heap\\n        heap = []\\n\\n        # Iterate until the car reaches the target\\n        while maxDist < target:\\n\\n            # Add all available stations to the heap\\n            while i < n and stations[i][0] <= maxDist:\\n                heapq.heappush(heap, -stations[i][1])\\n                i += 1\\n\\n            # If there is a station that the car hasn\\'t refuel at\\n            if heap:\\n\\n                # Pop such station from the heap and add its fuel to the max travalable distance\\n                maxDist += -heapq.heappop(heap)\\n                step += 1\\n\\n            # Else, the car isn\\'t able to reach the next station or target\\n            else:\\n                return -1\\n\\n        # Return the number of refueled station\\n        return step\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def minRefuelStops(\\n        self, target: int, startFuel: int, stations: list[list[int]]\\n    ) -> int:\\n\\n        # Intialize the step and max travelable distance\\n        step, maxDist = 0, startFuel\\n\\n        # Initialize the index and bound of stations\\n        i, n = 0, len(stations)\\n\\n        # Initialize the heap\\n        heap = []\\n\\n        # Iterate until the car reaches the target\\n        while maxDist < target:\\n\\n            # Add all available stations to the heap\\n            while i < n and stations[i][0] <= maxDist:\\n                heapq.heappush(heap, -stations[i][1])\\n                i += 1\\n\\n            # If there is a station that the car hasn\\'t refuel at\\n            if heap:\\n\\n                # Pop such station from the heap and add its fuel to the max travalable distance\\n                maxDist += -heapq.heappop(heap)\\n                step += 1\\n\\n            # Else, the car isn\\'t able to reach the next station or target\\n            else:\\n                return -1\\n\\n        # Return the number of refueled station\\n        return step\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451788,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) \\n    {\\n        priority_queue<int> pq;\\n        int ans=0;\\n        int currInd=0;\\n        while(startFuel<target)\\n        {\\n            while(currInd<stations.size())\\n            {\\n                if(stations[currInd][0]<=startFuel)\\n                    pq.push(stations[currInd++][1]);\\n                else \\n                    break;\\n            }\\n            if(pq.size()==0)\\n                return -1;\\n            startFuel+=pq.top();\\n            pq.pop();\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) \\n    {\\n        priority_queue<int> pq;\\n        int ans=0;\\n        int currInd=0;\\n        while(startFuel<target)\\n        {\\n            while(currInd<stations.size())\\n            {\\n                if(stations[currInd][0]<=startFuel)\\n                    pq.push(stations[currInd++][1]);\\n                else \\n                    break;\\n            }\\n            if(pq.size()==0)\\n                return -1;\\n            startFuel+=pq.top();\\n            pq.pop();\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451668,
                "title": "java-priority-queue-simple-code-6-lines-of-core-logic",
                "content": "1. Keep pushing the array[i] till you get atleast the start value(the current distance travelled).\\n2. poll the max ans add it to the start. greedy method to get the max drive in min fueling \\n```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n=stations.length;\\n        \\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b) -> b[1]-a[1]);\\n        \\n        int start=startFuel,i=0;\\n        int ans=0;\\n        while(start<target){\\n            \\n            \\n            while(i<n && start>=stations[i][0]){\\n                pq.add(stations[i]);\\n                i++;\\n            }\\n            if(pq.isEmpty()) return -1;\\n            \\n            start=start+pq.poll()[1];\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        int n=stations.length;\\n        \\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b) -> b[1]-a[1]);\\n        \\n        int start=startFuel,i=0;\\n        int ans=0;\\n        while(start<target){\\n            \\n            \\n            while(i<n && start>=stations[i][0]){\\n                pq.add(stations[i]);\\n                i++;\\n            }\\n            if(pq.isEmpty()) return -1;\\n            \\n            start=start+pq.poll()[1];\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451667,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public int MinRefuelStops(int target, int tank, int[][] stations)\\n    {\\n        int result = 0, prev = 0;\\n        var queue = new PriorityQueue<int, int>();        \\n        for (int i = 0; i <= stations.Length; i++)\\n        {\\n            int location = i<stations.Length? stations[i][0]:target;\\n            int capacity = i < stations.Length ? stations[i][1]: 0;\\n            tank = tank - (location - prev);\\n            while (queue.Count > 0 && tank < 0)\\n            {\\n                result++; \\n                tank += queue.Dequeue();\\n            }\\n            if (tank < 0)\\n                return -1;\\n            if(i < stations.Length)\\n            {\\n                queue.Enqueue(capacity, -capacity);\\n                prev = location;\\n            }         \\n        } \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public int MinRefuelStops(int target, int tank, int[][] stations)\\n    {\\n        int result = 0, prev = 0;\\n        var queue = new PriorityQueue<int, int>();        \\n        for (int i = 0; i <= stations.Length; i++)\\n        {\\n            int location = i<stations.Length? stations[i][0]:target;\\n            int capacity = i < stations.Length ? stations[i][1]: 0;\\n            tank = tank - (location - prev);\\n            while (queue.Count > 0 && tank < 0)\\n            {\\n                result++; \\n                tank += queue.Dequeue();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2451649,
                "title": "simple-explanation-explain-greedy",
                "content": "**Intuition**:\\n\\n1) we need to keep track of all the stations where car can reach with current fuel.\\n2) And from all the stations, we need to stop at that station which can fill the car with maximum fuel.\\n\\n**Cases To Consider:**\\n1. What if the car is not having enogh fuel to reach at any station.\\n2. What if the car covers all the stations but still car is not having enough fuel to reach the target.\\n\\nIn both the above cases we need to return -1, as car cannot reach the target.\\n\\nNow, the main thing is to identify which Data Structure to use for this situation,\\nAs we have seen that , we need to keep track of all the stations that car can cover and from among them car can stop at the station which has maximum Fuel.\\n\\nSo, it is clear that we need to keep track of maximum Fuel among all the reachable stations.\\nAnd it can be achieved by using Max Heap.\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int> pq;\\n        int minStops=0;\\n        int currentStationIndex = 0;\\n        int totalStations = size(stations);\\n        while(startFuel<target)\\n        {\\n            while(currentStationIndex < totalStations and stations[currentStationIndex][0]<=startFuel)\\n            {\\n                pq.push(stations[currentStationIndex][1]);\\n                currentStationIndex++;\\n            }\\n            if(pq.empty())\\n                return -1;\\n            startFuel+=pq.top();\\n            pq.pop();\\n            minStops++;\\n        }\\n        return minStops;\\n    }\\n};\\n```\\nTime Complexity: **O(nlog(n))**\\nSpace Complexity: **O(n)**\\nwhere n--> Number of Fuel Stations.\\n\\n *If you find this post useful, then don\\'t forget to upvote this.\\nHappy Coding :) *",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        priority_queue<int> pq;\\n        int minStops=0;\\n        int currentStationIndex = 0;\\n        int totalStations = size(stations);\\n        while(startFuel<target)\\n        {\\n            while(currentStationIndex < totalStations and stations[currentStationIndex][0]<=startFuel)\\n            {\\n                pq.push(stations[currentStationIndex][1]);\\n                currentStationIndex++;\\n            }\\n            if(pq.empty())\\n                return -1;\\n            startFuel+=pq.top();\\n            pq.pop();\\n            minStops++;\\n        }\\n        return minStops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451638,
                "title": "c-solution-with-o-nlogn-time-complexity",
                "content": "\\n    class Solution {\\n    public:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& st) {\\n        int ans=0;   // here ans will store the number of refilling stations\\n        int k=0;\\n        priority_queue<int>p;\\n        \\n        for(int i=0;startFuel<target;i++){\\n            while(k<st.size() and st[k][0]<=startFuel){\\n                p.push(st[k][1]);  // we will push the maximum fuel  will be there in that pair\\n                k++;\\n            }\\n            if(p.empty())return -1;\\n            startFuel+=p.top();\\n            p.pop();\\n            ans++;\\n                        \\n        }\\n        return ans;\\n         \\n    }\\n     };\\n\\t \\n\\t// T.C:  O(NlogN);\\n\\t// S.C:  O(N) \"For priority queue\"",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& st) {\\n        int ans=0;   // here ans will store the number of refilling stations\\n        int k=0;\\n        priority_queue<int>p;\\n        \\n        for(int i=0;startFuel<target;i++){\\n            while(k<st.size() and st[k][0]<=startFuel){\\n                p.push(st[k][1]);  // we will push the maximum fuel  will be there in that pair\\n                k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2451572,
                "title": "java-simple-greedy-approach-w-video-explanation",
                "content": "*Please **Upvote** if you find the explanation helpful*\\n\\n**Video Explanation**\\n[Minimum Number of Refueling Stops | YouTube](https://www.youtube.com/watch?v=zfEGbb6PyKA&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//4ms\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if (startFuel >= target)\\n            return 0;\\n        \\n        Queue<Integer> pq = new PriorityQueue<>((a,b) -> (b-a));\\n        \\n        int i=0,n=stations.length,stops=0,maxDistance=startFuel;\\n        \\n        while(maxDistance < target){\\n            while(i<n && stations[i][0] <=maxDistance){\\n                pq.offer(stations[i][1]);\\n                i++;\\n            }\\n            \\n            if(pq.isEmpty())\\n                return -1;\\n            maxDistance += pq.poll();\\n            stops++;\\n        }\\n        \\n        return stops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//4ms\\nclass Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        if (startFuel >= target)\\n            return 0;\\n        \\n        Queue<Integer> pq = new PriorityQueue<>((a,b) -> (b-a));\\n        \\n        int i=0,n=stations.length,stops=0,maxDistance=startFuel;\\n        \\n        while(maxDistance < target){\\n            while(i<n && stations[i][0] <=maxDistance){\\n                pq.offer(stations[i][1]);\\n                i++;\\n            }\\n            \\n            if(pq.isEmpty())\\n                return -1;\\n            maxDistance += pq.poll();\\n            stops++;\\n        }\\n        \\n        return stops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451560,
                "title": "python-solution-queue",
                "content": "\\tclass Solution:\\n\\t\\tdef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n\\n\\t\\t\\tpq = []\\n\\t\\t\\tmax_reach = startFuel\\n\\t\\t\\tcount = 0\\n\\t\\t\\tindex = 0\\n\\n\\t\\t\\twhile max_reach<target:\\n\\n\\t\\t\\t\\twhile index < len(stations) and stations[index][0] <= max_reach:\\n\\n\\t\\t\\t\\t\\tpq.append(stations[index][1])\\n\\t\\t\\t\\t\\tindex += 1\\n\\n\\t\\t\\t\\tif len(pq) <= 0:return -1\\n\\t\\t\\t\\tpq.sort()\\n\\t\\t\\t\\tmax_reach += pq[-1]\\n\\t\\t\\t\\tpq.pop()\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n\\n\\t\\t\\tpq = []\\n\\t\\t\\tmax_reach = startFuel\\n\\t\\t\\tcount = 0\\n\\t\\t\\tindex = 0\\n\\n\\t\\t\\twhile max_reach<target:\\n\\n\\t\\t\\t\\twhile index < len(stations) and stations[index][0] <= max_reach:\\n\\n\\t\\t\\t\\t\\tpq.append(stations[index][1])\\n\\t\\t\\t\\t\\tindex += 1\\n\\n\\t\\t\\t\\tif len(pq) <= 0:return -1\\n\\t\\t\\t\\tpq.sort()\\n\\t\\t\\t\\tmax_reach += pq[-1]\\n\\t\\t\\t\\tpq.pop()\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 2451533,
                "title": "simple-c-solution-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int curPos = startFuel;\\n        int ans = 0,count = 0;\\n        priority_queue<int> pq;\\n        while(1){\\n            while(count<stations.size() and stations[count][0]<=curPos){\\n                pq.push(stations[count][1]);\\n                count++;\\n            }\\n            if(curPos>=target) return ans;\\n            if(pq.empty())return -1;\\n            curPos+=pq.top();\\n            pq.pop();\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        int curPos = startFuel;\\n        int ans = 0,count = 0;\\n        priority_queue<int> pq;\\n        while(1){\\n            while(count<stations.size() and stations[count][0]<=curPos){\\n                pq.push(stations[count][1]);\\n                count++;\\n            }\\n            if(curPos>=target) return ans;\\n            if(pq.empty())return -1;\\n            curPos+=pq.top();\\n            pq.pop();\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451520,
                "title": "easy-explanation-beats-100",
                "content": "To find the minimum number of refueling stops we need to choose the **highest** stop stations first, however, we\\'re limited with the number of stations that we can choose from (we can only choose from the stations that we can reach).\\n\\nTo solve that problem, we can add all stations that we can reach to a **Priority Queue** then we keep choosing the highest value from it. After each refueling stop, we need to see what other station we can reach after that stop. \\n\\nIf we can\\'t reach any and we didn\\'t reach the target we should return `-1`\\n\\n```python\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        N = len(stations)\\n        pq = []\\n        def push(n):\\n            heappush(pq, -n)\\n        def pop():\\n            return - heappop(pq)\\n        res = 0 # Number of refueling stops\\n        i = 0 # Next station index that\\'s not added to the queue\\n        while startFuel < target:\\n            while i < N and stations[i][0] <= startFuel:\\n                push(stations[i][1])\\n                i += 1\\n            if not pq:\\n                return -1\\n            startFuel += pop()\\n            res += 1\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/938c6270-ee4c-44ce-b701-df2473ffbc33_1660967383.1305857.png)\\n\\n**Time Complexity:** `O(NlogN)` Where `N` is the number of stations. Note that the nested loop will run `N` time in the worst case so we will ignore it. the `NlogN` part is coming from adding value to the queue.\\n**Space Complexity:** `O(N)` Where `N` is the number of stations.\\n\\nInspired by @lee215\\n___\\nIf there are any suggestions/questions/mistakes please comment below\\n___\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        N = len(stations)\\n        pq = []\\n        def push(n):\\n            heappush(pq, -n)\\n        def pop():\\n            return - heappop(pq)\\n        res = 0 # Number of refueling stops\\n        i = 0 # Next station index that\\'s not added to the queue\\n        while startFuel < target:\\n            while i < N and stations[i][0] <= startFuel:\\n                push(stations[i][1])\\n                i += 1\\n            if not pq:\\n                return -1\\n            startFuel += pop()\\n            res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451491,
                "title": "java-simple-and-easy-o-nlogn-priority-queue-proper-explanation-and-comments",
                "content": "Here is java code using a priority queue(max heap). The reason for using prioroty queue is that we are using greedy approach. Whenever fuel ends and we can\\'t reach next step, we add max fuel from till now visited pumps. In the last while block, we have checked that whether we have reached our target or not, in case target is not reached and heap has elements, we refuel again. If heap has no elements and target is still not reached, we simply return -1. Else we refuel.\\n\\nI hope its clear. If still any doubt, feel free to ask. :)\\nIf like the solution, consider to upvote.\\n ```\\n class Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        \\n        int fuelIhaveAtCurrent = startFuel;\\n        int refuelCounts = 0;\\n        \\n        //Building a maxheap to store fuel from stations visited so far.\\n        PriorityQueue<Integer> fuelFromVisited = new PriorityQueue<>((a, b)-> (b-a));\\n        \\n        for(int [] station : stations) {\\n            int nextStation = station[0]; //getting the next station position\\n            int fuelAtNextStation = station[1];\\n            \\n            while(fuelIhaveAtCurrent < nextStation) { //I have less fuel than the next position\\n                if(fuelFromVisited.isEmpty()) {\\n                    return -1;\\n                }\\n                \\n                int getMaxFromPQ = fuelFromVisited.poll();\\n                fuelIhaveAtCurrent += getMaxFromPQ;\\n                \\n                refuelCounts++;\\n            }\\n            \\n            fuelFromVisited.offer(station[1]); //Keep adding fuel to maxHeap at each step\\n        }\\n        \\n        //This is a corner case when we still have elements in our PQ.\\n        while(fuelIhaveAtCurrent < target) { //I have less fuel than the next position\\n            if(fuelFromVisited.isEmpty()) {\\n                return -1;\\n            }\\n\\n            int getMaxFromPQ = fuelFromVisited.poll();\\n            fuelIhaveAtCurrent += getMaxFromPQ;\\n\\n            refuelCounts++;\\n        }\\n        return refuelCounts;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\\n        \\n        int fuelIhaveAtCurrent = startFuel;\\n        int refuelCounts = 0;\\n        \\n        //Building a maxheap to store fuel from stations visited so far.\\n        PriorityQueue<Integer> fuelFromVisited = new PriorityQueue<>((a, b)-> (b-a));\\n        \\n        for(int [] station : stations) {\\n            int nextStation = station[0]; //getting the next station position\\n            int fuelAtNextStation = station[1];\\n            \\n            while(fuelIhaveAtCurrent < nextStation) { //I have less fuel than the next position\\n                if(fuelFromVisited.isEmpty()) {\\n                    return -1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2451448,
                "title": "c-solution-time-o-n-2-memory-o-n-2-dynamic-programming-with-optimal-memory",
                "content": "```C#\\npublic class Solution {\\n    public int MinRefuelStops(int target, int startFuel, int[][] stations) {\\n        int[][] dp = new int[stations.Length + 1][];\\n        for (int i = 0; i <= stations.Length; i++) dp[i] = new int[i + 1];\\n        \\n        dp[0][0] = startFuel;\\n        \\n        int maxDistance = startFuel, currentDistance;\\n        for (int i = 0; i < stations.Length; i++) {\\n            if (maxDistance < stations[i][0]) return -1;\\n            \\n            maxDistance = -1;\\n            for (int j = 0; j <= i + 1; j++) {\\n                currentDistance = -1;\\n                if (j > 0 && dp[i][j - 1] >= stations[i][0]) currentDistance = Math.Max(currentDistance, dp[i][j - 1] + stations[i][1]);\\n                if (j <= i && dp[i][j] >= stations[i][0]) currentDistance = Math.Max(currentDistance, dp[i][j]);\\n                \\n                maxDistance = Math.Max(maxDistance, currentDistance);\\n                dp[i + 1][j] = currentDistance;\\n            }\\n        }\\n        \\n        if (maxDistance < target) return -1;\\n        for (int i = 0; i <= stations.Length; i++) {\\n            if (dp[stations.Length][i] >= target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int MinRefuelStops(int target, int startFuel, int[][] stations) {\\n        int[][] dp = new int[stations.Length + 1][];\\n        for (int i = 0; i <= stations.Length; i++) dp[i] = new int[i + 1];\\n        \\n        dp[0][0] = startFuel;\\n        \\n        int maxDistance = startFuel, currentDistance;\\n        for (int i = 0; i < stations.Length; i++) {\\n            if (maxDistance < stations[i][0]) return -1;\\n            \\n            maxDistance = -1;\\n            for (int j = 0; j <= i + 1; j++) {\\n                currentDistance = -1;\\n                if (j > 0 && dp[i][j - 1] >= stations[i][0]) currentDistance = Math.Max(currentDistance, dp[i][j - 1] + stations[i][1]);\\n                if (j <= i && dp[i][j] >= stations[i][0]) currentDistance = Math.Max(currentDistance, dp[i][j]);\\n                \\n                maxDistance = Math.Max(maxDistance, currentDistance);\\n                dp[i + 1][j] = currentDistance;\\n            }\\n        }\\n        \\n        if (maxDistance < target) return -1;\\n        for (int i = 0; i <= stations.Length; i++) {\\n            if (dp[stations.Length][i] >= target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451382,
                "title": "4-line-c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        vector<long long> dp(stations.size() + 1); dp[0] = startFuel;\\n        for (int i = 0; i < stations.size(); i++) for (int t = i; t >= 0; t--) if (dp[t] >= stations[i][0]) dp[t + 1] = max(dp[t + 1], dp[t] + stations[i][1]);\\n        for (int i = 0; i <= stations.size(); i++) if (dp[i] >= target) return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        vector<long long> dp(stations.size() + 1); dp[0] = startFuel;\\n        for (int i = 0; i < stations.size(); i++) for (int t = i; t >= 0; t--) if (dp[t] >= stations[i][0]) dp[t + 1] = max(dp[t + 1], dp[t] + stations[i][1]);\\n        for (int i = 0; i <= stations.size(); i++) if (dp[i] >= target) return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451305,
                "title": "c-simple-greedy-approach-tc-o-nlogn-sc-o-n",
                "content": "Hiii Everyone ,\\nThis question can be solved easily by greedy intution that we should take the station first that refuels our car with maximum fuel  .\\nto obtain this I will sort all tha stations pairs according to their fuel filling capacity and now iterate through the sorted array and take all required stations needed to reach destination .\\nTC: O(nlogn)\\nSC: O(n)\\n\\n```\\nbool comp(pair<int,int>a,pair<int,int>b)\\n{\\n    if(a.second==b.second)\\n        return a.first>b.first;\\n    return a.second>b.second;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        vector<pair<int,int>>s;\\n        int n=stations.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s.push_back({stations[i][0],stations[i][1]});\\n        }\\n        int count=0;\\n        sort(s.begin(),s.end(),comp);\\n        vector<bool>vis(n,false);\\n        while(target-startFuel>0)\\n        {\\n            bool flag=true;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(s[i].first<=startFuel and vis[i]==false and flag==true)\\n                {\\n                    vis[i]=true;\\n                    startFuel=startFuel+s[i].second;\\n                    count++;\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag==true)\\n                return -1;\\n        }\\n        return count;\\n    }\\n};\\n```\\nCode By : Priyansh Sharma\\n``` \\n**//Please leave a upvote if found useful.//**\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nbool comp(pair<int,int>a,pair<int,int>b)\\n{\\n    if(a.second==b.second)\\n        return a.first>b.first;\\n    return a.second>b.second;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\\n        vector<pair<int,int>>s;\\n        int n=stations.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s.push_back({stations[i][0],stations[i][1]});\\n        }\\n        int count=0;\\n        sort(s.begin(),s.end(),comp);\\n        vector<bool>vis(n,false);\\n        while(target-startFuel>0)\\n        {\\n            bool flag=true;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(s[i].first<=startFuel and vis[i]==false and flag==true)\\n                {\\n                    vis[i]=true;\\n                    startFuel=startFuel+s[i].second;\\n                    count++;\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag==true)\\n                return -1;\\n        }\\n        return count;\\n    }\\n};\\n```\n``` \\n**//Please leave a upvote if found useful.//**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451208,
                "title": "python-heap-o-nlogn",
                "content": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        que = []\\n        res, i, cur = 0, 0, startFuel\\n        while cur < target:\\n            while i < len(stations) and stations[i][0] <= cur:\\n                heappush(que, -stations[i][1])\\n                i += 1\\n            if not que: return -1\\n            cur += -heappop(que)\\n            res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\\n        que = []\\n        res, i, cur = 0, 0, startFuel\\n        while cur < target:\\n            while i < len(stations) and stations[i][0] <= cur:\\n                heappush(que, -stations[i][1])\\n                i += 1\\n            if not que: return -1\\n            cur += -heappop(que)\\n            res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2451201,
                "title": "python-use-time-machine-for-your-biggest-regrets",
                "content": "```python\\n        stations.append([target, inf])\\n        fuel, count, prev = startFuel, 0, 0\\n        regrets = []\\n        for pos, gas in stations:\\n            dist, prev = pos - prev, pos\\n            while regrets and fuel < dist:\\n                fuel += -heappop(regrets)\\n                count += 1\\n            if fuel < dist: return -1\\n            fuel -= dist\\n            heappush(regrets, -gas)\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        stations.append([target, inf])\\n        fuel, count, prev = startFuel, 0, 0\\n        regrets = []\\n        for pos, gas in stations:\\n            dist, prev = pos - prev, pos\\n            while regrets and fuel < dist:\\n                fuel += -heappop(regrets)\\n                count += 1\\n            if fuel < dist: return -1\\n            fuel -= dist\\n            heappush(regrets, -gas)\\n        return count\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1569802,
                "content": [
                    {
                        "username": "dengzq078",
                        "content": "similar with [JumpGame2](https://leetcode.com/problems/jump-game-ii/)"
                    },
                    {
                        "username": "michaellargent",
                        "content": "Please correct me if I\\'m misinterpreting the problem.\\nI\\'m provided a target, startFuel, and stations.\\nTarget, startFuel, and stations[i][0] all represent the distance from the origin.\\nIf the startFuel can reach the target without stopping at a station, then we return 0, however if it can\\'t we return -1.\\n\\nGiven this situation:\\ntarget: 1,\\nstartFuel: 1,\\nstations: [ [10,10] ]\\n\\nShouldn\\'t the stations along the way be irrelevant since we can reach the target without stopping?\\nThe expected result in the test is -1 with those variables, but shouldn\\'t it be 0.\\n\\nI\\'m guessing the way the tests are modeled, is the startFuel is suppose to be able to reach each station recursively first and not go directly to the target."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Google interview variation**: https://leetcode.com/discuss/interview-experience/609015/Google-or-L3-or-Warsaw-or-May-2020-Offer\\n\\n**Some discussions** that thelped me understand the **greedy** approach:\\n - [[Python] Time travel](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/911923/Python-Time-travel)\\n - [[Java] Simple Code - Greedy](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/294025/Java-Simple-Code-Greedy)\\n\\n**Problems that might be related**:\\n* https://leetcode.com/problems/jump-game-ii/\\n* https://leetcode.com/problems/gas-station/\\n* https://leetcode.com/problems/furthest-building-you-can-reach/\\n* https://leetcode.com/problems/ipo/"
                    },
                    {
                        "username": "pallavi_banerjee",
                        "content": "A few things to observe:\\n* The total fuel `F` collected (fuel collected from the stations we stopped + initial fuel in the tank) helps us reach a destination which is `F` miles east from the start and of course any station which is less than `F` miles east. Thus **\"maximum destination reachable = maximum total amount of fuel collected.\"** This arguably is the most crucial observation.\\n*  Now, with `k` turns or stops if we could maximize the amount of fuel we can collect, then it let\\'s us reach the maximum destination with `k` stops. Why? Maximum destination in k stops = maximum total fuel collected in k stops + start fuel (previous observation)\\n* Every time we increase `k`, total fuel increases, hence maximum destination reachable moves further east (increases). Why? because fuel is always positive.\\n* Now, if we increase `k` and for each `k` try to find the maximum destination reachable, the smallest value of `k` for which `total_fuel` (or equivalently `maximum_destination`) >= target, is the minimum no. of refuels.\\n* Now let\\'s try to solve the problem iteratively by increasing the value of `k`. \\n\\t* When `k=0`, what is the maximum destination we can reach? Obviously, `start_fuel`. But with `k = 0` stops we have made a certain number of stations (more specifically all stations with position <= `start_fuel` are now refuelling candidates)\\n\\t* So when `k=1`, what is the maximum destination we can reach? or equivalently what is the maximum total amount of fuel we can collect? The answer is maximum amount of fuel we can collect at `k=0` (which we have already solved) + maximum amount of fuel we can collect from all the refuelling candidates at `k=1`. Another important point to note here is that the refuelling candidates right now consists of the new refuelling candidates (which are now available after solving for `k=0`) as well as the initial set of candidates that were available when we were starting. At this point, you can probably guess that we can track the maximums in a max heap.\\n\\t* The logic for `k = 2, 3 ..` follows. And the first time we encounter `total_fuel >= target`, helps us identify the minimum `k`."
                    },
                    {
                        "username": "moodfire",
                        "content": "Here the main important thing to consider is `dp[i]` denotes the max target that can be reached with minimum of i fuel stops.\\n\\nIn the second loop, we have to start the t= i -> 0 because if we carefully observe what dp[i] denotes is minimum i stops and max distance.\\n\\nThe first loop denotes how many stops we are considering i = 0 -> N\\ni = 0 means that we are considering only 1 stop so maximum we can go is to dp[1].\\nI = 1 means we can are considering two stops and max we can go is to dp[2] but here we can see if we can reach to second station directly from startfuel i.e dp[0] and can still have max distance than the previous result which was dp[1] = dp[0] + station[0][1] \\n\\nSo, dp[1] = max(dp[0] + station[0][0], dp[0] + station[1][1]) \\n\\nMain thing to understand that outer loop means how many stations we are considering right now, and i denotes the max station we are consider which is current station.\\n\\nInner loop means minimum stops that we are updating taking into account the current station."
                    }
                ]
            },
            {
                "id": 1566304,
                "content": [
                    {
                        "username": "dengzq078",
                        "content": "similar with [JumpGame2](https://leetcode.com/problems/jump-game-ii/)"
                    },
                    {
                        "username": "michaellargent",
                        "content": "Please correct me if I\\'m misinterpreting the problem.\\nI\\'m provided a target, startFuel, and stations.\\nTarget, startFuel, and stations[i][0] all represent the distance from the origin.\\nIf the startFuel can reach the target without stopping at a station, then we return 0, however if it can\\'t we return -1.\\n\\nGiven this situation:\\ntarget: 1,\\nstartFuel: 1,\\nstations: [ [10,10] ]\\n\\nShouldn\\'t the stations along the way be irrelevant since we can reach the target without stopping?\\nThe expected result in the test is -1 with those variables, but shouldn\\'t it be 0.\\n\\nI\\'m guessing the way the tests are modeled, is the startFuel is suppose to be able to reach each station recursively first and not go directly to the target."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Google interview variation**: https://leetcode.com/discuss/interview-experience/609015/Google-or-L3-or-Warsaw-or-May-2020-Offer\\n\\n**Some discussions** that thelped me understand the **greedy** approach:\\n - [[Python] Time travel](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/911923/Python-Time-travel)\\n - [[Java] Simple Code - Greedy](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/294025/Java-Simple-Code-Greedy)\\n\\n**Problems that might be related**:\\n* https://leetcode.com/problems/jump-game-ii/\\n* https://leetcode.com/problems/gas-station/\\n* https://leetcode.com/problems/furthest-building-you-can-reach/\\n* https://leetcode.com/problems/ipo/"
                    },
                    {
                        "username": "pallavi_banerjee",
                        "content": "A few things to observe:\\n* The total fuel `F` collected (fuel collected from the stations we stopped + initial fuel in the tank) helps us reach a destination which is `F` miles east from the start and of course any station which is less than `F` miles east. Thus **\"maximum destination reachable = maximum total amount of fuel collected.\"** This arguably is the most crucial observation.\\n*  Now, with `k` turns or stops if we could maximize the amount of fuel we can collect, then it let\\'s us reach the maximum destination with `k` stops. Why? Maximum destination in k stops = maximum total fuel collected in k stops + start fuel (previous observation)\\n* Every time we increase `k`, total fuel increases, hence maximum destination reachable moves further east (increases). Why? because fuel is always positive.\\n* Now, if we increase `k` and for each `k` try to find the maximum destination reachable, the smallest value of `k` for which `total_fuel` (or equivalently `maximum_destination`) >= target, is the minimum no. of refuels.\\n* Now let\\'s try to solve the problem iteratively by increasing the value of `k`. \\n\\t* When `k=0`, what is the maximum destination we can reach? Obviously, `start_fuel`. But with `k = 0` stops we have made a certain number of stations (more specifically all stations with position <= `start_fuel` are now refuelling candidates)\\n\\t* So when `k=1`, what is the maximum destination we can reach? or equivalently what is the maximum total amount of fuel we can collect? The answer is maximum amount of fuel we can collect at `k=0` (which we have already solved) + maximum amount of fuel we can collect from all the refuelling candidates at `k=1`. Another important point to note here is that the refuelling candidates right now consists of the new refuelling candidates (which are now available after solving for `k=0`) as well as the initial set of candidates that were available when we were starting. At this point, you can probably guess that we can track the maximums in a max heap.\\n\\t* The logic for `k = 2, 3 ..` follows. And the first time we encounter `total_fuel >= target`, helps us identify the minimum `k`."
                    },
                    {
                        "username": "moodfire",
                        "content": "Here the main important thing to consider is `dp[i]` denotes the max target that can be reached with minimum of i fuel stops.\\n\\nIn the second loop, we have to start the t= i -> 0 because if we carefully observe what dp[i] denotes is minimum i stops and max distance.\\n\\nThe first loop denotes how many stops we are considering i = 0 -> N\\ni = 0 means that we are considering only 1 stop so maximum we can go is to dp[1].\\nI = 1 means we can are considering two stops and max we can go is to dp[2] but here we can see if we can reach to second station directly from startfuel i.e dp[0] and can still have max distance than the previous result which was dp[1] = dp[0] + station[0][1] \\n\\nSo, dp[1] = max(dp[0] + station[0][0], dp[0] + station[1][1]) \\n\\nMain thing to understand that outer loop means how many stations we are considering right now, and i denotes the max station we are consider which is current station.\\n\\nInner loop means minimum stops that we are updating taking into account the current station."
                    }
                ]
            },
            {
                "id": 1575847,
                "content": [
                    {
                        "username": "dengzq078",
                        "content": "similar with [JumpGame2](https://leetcode.com/problems/jump-game-ii/)"
                    },
                    {
                        "username": "michaellargent",
                        "content": "Please correct me if I\\'m misinterpreting the problem.\\nI\\'m provided a target, startFuel, and stations.\\nTarget, startFuel, and stations[i][0] all represent the distance from the origin.\\nIf the startFuel can reach the target without stopping at a station, then we return 0, however if it can\\'t we return -1.\\n\\nGiven this situation:\\ntarget: 1,\\nstartFuel: 1,\\nstations: [ [10,10] ]\\n\\nShouldn\\'t the stations along the way be irrelevant since we can reach the target without stopping?\\nThe expected result in the test is -1 with those variables, but shouldn\\'t it be 0.\\n\\nI\\'m guessing the way the tests are modeled, is the startFuel is suppose to be able to reach each station recursively first and not go directly to the target."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Google interview variation**: https://leetcode.com/discuss/interview-experience/609015/Google-or-L3-or-Warsaw-or-May-2020-Offer\\n\\n**Some discussions** that thelped me understand the **greedy** approach:\\n - [[Python] Time travel](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/911923/Python-Time-travel)\\n - [[Java] Simple Code - Greedy](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/294025/Java-Simple-Code-Greedy)\\n\\n**Problems that might be related**:\\n* https://leetcode.com/problems/jump-game-ii/\\n* https://leetcode.com/problems/gas-station/\\n* https://leetcode.com/problems/furthest-building-you-can-reach/\\n* https://leetcode.com/problems/ipo/"
                    },
                    {
                        "username": "pallavi_banerjee",
                        "content": "A few things to observe:\\n* The total fuel `F` collected (fuel collected from the stations we stopped + initial fuel in the tank) helps us reach a destination which is `F` miles east from the start and of course any station which is less than `F` miles east. Thus **\"maximum destination reachable = maximum total amount of fuel collected.\"** This arguably is the most crucial observation.\\n*  Now, with `k` turns or stops if we could maximize the amount of fuel we can collect, then it let\\'s us reach the maximum destination with `k` stops. Why? Maximum destination in k stops = maximum total fuel collected in k stops + start fuel (previous observation)\\n* Every time we increase `k`, total fuel increases, hence maximum destination reachable moves further east (increases). Why? because fuel is always positive.\\n* Now, if we increase `k` and for each `k` try to find the maximum destination reachable, the smallest value of `k` for which `total_fuel` (or equivalently `maximum_destination`) >= target, is the minimum no. of refuels.\\n* Now let\\'s try to solve the problem iteratively by increasing the value of `k`. \\n\\t* When `k=0`, what is the maximum destination we can reach? Obviously, `start_fuel`. But with `k = 0` stops we have made a certain number of stations (more specifically all stations with position <= `start_fuel` are now refuelling candidates)\\n\\t* So when `k=1`, what is the maximum destination we can reach? or equivalently what is the maximum total amount of fuel we can collect? The answer is maximum amount of fuel we can collect at `k=0` (which we have already solved) + maximum amount of fuel we can collect from all the refuelling candidates at `k=1`. Another important point to note here is that the refuelling candidates right now consists of the new refuelling candidates (which are now available after solving for `k=0`) as well as the initial set of candidates that were available when we were starting. At this point, you can probably guess that we can track the maximums in a max heap.\\n\\t* The logic for `k = 2, 3 ..` follows. And the first time we encounter `total_fuel >= target`, helps us identify the minimum `k`."
                    },
                    {
                        "username": "moodfire",
                        "content": "Here the main important thing to consider is `dp[i]` denotes the max target that can be reached with minimum of i fuel stops.\\n\\nIn the second loop, we have to start the t= i -> 0 because if we carefully observe what dp[i] denotes is minimum i stops and max distance.\\n\\nThe first loop denotes how many stops we are considering i = 0 -> N\\ni = 0 means that we are considering only 1 stop so maximum we can go is to dp[1].\\nI = 1 means we can are considering two stops and max we can go is to dp[2] but here we can see if we can reach to second station directly from startfuel i.e dp[0] and can still have max distance than the previous result which was dp[1] = dp[0] + station[0][1] \\n\\nSo, dp[1] = max(dp[0] + station[0][0], dp[0] + station[1][1]) \\n\\nMain thing to understand that outer loop means how many stations we are considering right now, and i denotes the max station we are consider which is current station.\\n\\nInner loop means minimum stops that we are updating taking into account the current station."
                    }
                ]
            },
            {
                "id": 1575592,
                "content": [
                    {
                        "username": "dengzq078",
                        "content": "similar with [JumpGame2](https://leetcode.com/problems/jump-game-ii/)"
                    },
                    {
                        "username": "michaellargent",
                        "content": "Please correct me if I\\'m misinterpreting the problem.\\nI\\'m provided a target, startFuel, and stations.\\nTarget, startFuel, and stations[i][0] all represent the distance from the origin.\\nIf the startFuel can reach the target without stopping at a station, then we return 0, however if it can\\'t we return -1.\\n\\nGiven this situation:\\ntarget: 1,\\nstartFuel: 1,\\nstations: [ [10,10] ]\\n\\nShouldn\\'t the stations along the way be irrelevant since we can reach the target without stopping?\\nThe expected result in the test is -1 with those variables, but shouldn\\'t it be 0.\\n\\nI\\'m guessing the way the tests are modeled, is the startFuel is suppose to be able to reach each station recursively first and not go directly to the target."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Google interview variation**: https://leetcode.com/discuss/interview-experience/609015/Google-or-L3-or-Warsaw-or-May-2020-Offer\\n\\n**Some discussions** that thelped me understand the **greedy** approach:\\n - [[Python] Time travel](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/911923/Python-Time-travel)\\n - [[Java] Simple Code - Greedy](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/294025/Java-Simple-Code-Greedy)\\n\\n**Problems that might be related**:\\n* https://leetcode.com/problems/jump-game-ii/\\n* https://leetcode.com/problems/gas-station/\\n* https://leetcode.com/problems/furthest-building-you-can-reach/\\n* https://leetcode.com/problems/ipo/"
                    },
                    {
                        "username": "pallavi_banerjee",
                        "content": "A few things to observe:\\n* The total fuel `F` collected (fuel collected from the stations we stopped + initial fuel in the tank) helps us reach a destination which is `F` miles east from the start and of course any station which is less than `F` miles east. Thus **\"maximum destination reachable = maximum total amount of fuel collected.\"** This arguably is the most crucial observation.\\n*  Now, with `k` turns or stops if we could maximize the amount of fuel we can collect, then it let\\'s us reach the maximum destination with `k` stops. Why? Maximum destination in k stops = maximum total fuel collected in k stops + start fuel (previous observation)\\n* Every time we increase `k`, total fuel increases, hence maximum destination reachable moves further east (increases). Why? because fuel is always positive.\\n* Now, if we increase `k` and for each `k` try to find the maximum destination reachable, the smallest value of `k` for which `total_fuel` (or equivalently `maximum_destination`) >= target, is the minimum no. of refuels.\\n* Now let\\'s try to solve the problem iteratively by increasing the value of `k`. \\n\\t* When `k=0`, what is the maximum destination we can reach? Obviously, `start_fuel`. But with `k = 0` stops we have made a certain number of stations (more specifically all stations with position <= `start_fuel` are now refuelling candidates)\\n\\t* So when `k=1`, what is the maximum destination we can reach? or equivalently what is the maximum total amount of fuel we can collect? The answer is maximum amount of fuel we can collect at `k=0` (which we have already solved) + maximum amount of fuel we can collect from all the refuelling candidates at `k=1`. Another important point to note here is that the refuelling candidates right now consists of the new refuelling candidates (which are now available after solving for `k=0`) as well as the initial set of candidates that were available when we were starting. At this point, you can probably guess that we can track the maximums in a max heap.\\n\\t* The logic for `k = 2, 3 ..` follows. And the first time we encounter `total_fuel >= target`, helps us identify the minimum `k`."
                    },
                    {
                        "username": "moodfire",
                        "content": "Here the main important thing to consider is `dp[i]` denotes the max target that can be reached with minimum of i fuel stops.\\n\\nIn the second loop, we have to start the t= i -> 0 because if we carefully observe what dp[i] denotes is minimum i stops and max distance.\\n\\nThe first loop denotes how many stops we are considering i = 0 -> N\\ni = 0 means that we are considering only 1 stop so maximum we can go is to dp[1].\\nI = 1 means we can are considering two stops and max we can go is to dp[2] but here we can see if we can reach to second station directly from startfuel i.e dp[0] and can still have max distance than the previous result which was dp[1] = dp[0] + station[0][1] \\n\\nSo, dp[1] = max(dp[0] + station[0][0], dp[0] + station[1][1]) \\n\\nMain thing to understand that outer loop means how many stations we are considering right now, and i denotes the max station we are consider which is current station.\\n\\nInner loop means minimum stops that we are updating taking into account the current station."
                    }
                ]
            },
            {
                "id": 1574643,
                "content": [
                    {
                        "username": "dengzq078",
                        "content": "similar with [JumpGame2](https://leetcode.com/problems/jump-game-ii/)"
                    },
                    {
                        "username": "michaellargent",
                        "content": "Please correct me if I\\'m misinterpreting the problem.\\nI\\'m provided a target, startFuel, and stations.\\nTarget, startFuel, and stations[i][0] all represent the distance from the origin.\\nIf the startFuel can reach the target without stopping at a station, then we return 0, however if it can\\'t we return -1.\\n\\nGiven this situation:\\ntarget: 1,\\nstartFuel: 1,\\nstations: [ [10,10] ]\\n\\nShouldn\\'t the stations along the way be irrelevant since we can reach the target without stopping?\\nThe expected result in the test is -1 with those variables, but shouldn\\'t it be 0.\\n\\nI\\'m guessing the way the tests are modeled, is the startFuel is suppose to be able to reach each station recursively first and not go directly to the target."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "**Google interview variation**: https://leetcode.com/discuss/interview-experience/609015/Google-or-L3-or-Warsaw-or-May-2020-Offer\\n\\n**Some discussions** that thelped me understand the **greedy** approach:\\n - [[Python] Time travel](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/911923/Python-Time-travel)\\n - [[Java] Simple Code - Greedy](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/294025/Java-Simple-Code-Greedy)\\n\\n**Problems that might be related**:\\n* https://leetcode.com/problems/jump-game-ii/\\n* https://leetcode.com/problems/gas-station/\\n* https://leetcode.com/problems/furthest-building-you-can-reach/\\n* https://leetcode.com/problems/ipo/"
                    },
                    {
                        "username": "pallavi_banerjee",
                        "content": "A few things to observe:\\n* The total fuel `F` collected (fuel collected from the stations we stopped + initial fuel in the tank) helps us reach a destination which is `F` miles east from the start and of course any station which is less than `F` miles east. Thus **\"maximum destination reachable = maximum total amount of fuel collected.\"** This arguably is the most crucial observation.\\n*  Now, with `k` turns or stops if we could maximize the amount of fuel we can collect, then it let\\'s us reach the maximum destination with `k` stops. Why? Maximum destination in k stops = maximum total fuel collected in k stops + start fuel (previous observation)\\n* Every time we increase `k`, total fuel increases, hence maximum destination reachable moves further east (increases). Why? because fuel is always positive.\\n* Now, if we increase `k` and for each `k` try to find the maximum destination reachable, the smallest value of `k` for which `total_fuel` (or equivalently `maximum_destination`) >= target, is the minimum no. of refuels.\\n* Now let\\'s try to solve the problem iteratively by increasing the value of `k`. \\n\\t* When `k=0`, what is the maximum destination we can reach? Obviously, `start_fuel`. But with `k = 0` stops we have made a certain number of stations (more specifically all stations with position <= `start_fuel` are now refuelling candidates)\\n\\t* So when `k=1`, what is the maximum destination we can reach? or equivalently what is the maximum total amount of fuel we can collect? The answer is maximum amount of fuel we can collect at `k=0` (which we have already solved) + maximum amount of fuel we can collect from all the refuelling candidates at `k=1`. Another important point to note here is that the refuelling candidates right now consists of the new refuelling candidates (which are now available after solving for `k=0`) as well as the initial set of candidates that were available when we were starting. At this point, you can probably guess that we can track the maximums in a max heap.\\n\\t* The logic for `k = 2, 3 ..` follows. And the first time we encounter `total_fuel >= target`, helps us identify the minimum `k`."
                    },
                    {
                        "username": "moodfire",
                        "content": "Here the main important thing to consider is `dp[i]` denotes the max target that can be reached with minimum of i fuel stops.\\n\\nIn the second loop, we have to start the t= i -> 0 because if we carefully observe what dp[i] denotes is minimum i stops and max distance.\\n\\nThe first loop denotes how many stops we are considering i = 0 -> N\\ni = 0 means that we are considering only 1 stop so maximum we can go is to dp[1].\\nI = 1 means we can are considering two stops and max we can go is to dp[2] but here we can see if we can reach to second station directly from startfuel i.e dp[0] and can still have max distance than the previous result which was dp[1] = dp[0] + station[0][1] \\n\\nSo, dp[1] = max(dp[0] + station[0][0], dp[0] + station[1][1]) \\n\\nMain thing to understand that outer loop means how many stations we are considering right now, and i denotes the max station we are consider which is current station.\\n\\nInner loop means minimum stops that we are updating taking into account the current station."
                    }
                ]
            }
        ]
    }
]