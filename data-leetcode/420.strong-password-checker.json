[
    {
        "title": "Strong Password Checker",
        "question_content": "A password is considered strong if the below conditions are all met:\n\n\tIt has at least 6 characters and at most 20 characters.\n\tIt contains at least one lowercase letter, at least one uppercase letter, and at least one digit.\n\tIt does not contain three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong).\n\nGiven a string password, return the minimum number of steps required to make password strong. if password is already strong, return 0.\nIn one step, you can:\n\n\tInsert one character to password,\n\tDelete one character from password, or\n\tReplace one character of password with another character.\n\n&nbsp;\nExample 1:\nInput: password = \"a\"\nOutput: 5\nExample 2:\nInput: password = \"aA1\"\nOutput: 3\nExample 3:\nInput: password = \"1337C0d3\"\nOutput: 0\n&nbsp;\nConstraints:\n\n\t1 <= password.length <= 50\n\tpassword consists of letters, digits, dot&nbsp;'.' or exclamation mark '!'.",
        "solutions": [
            {
                "id": 4067463,
                "title": "short-readable-solution-youtube-walkthrough",
                "content": "Please upvote if you find the walkthrough and/or code helpful :)\\n\\nhttps://youtu.be/9CxpKVR14ps\\n\\n```\\nimport string\\n\\nclass Solution:    \\n    def strongPasswordChecker(self, s):\\n        lowercase = set(string.ascii_lowercase)\\n        uppercase = set(string.ascii_uppercase)\\n        digits = set([str(elem) for elem in range(10)])\\n\\n        num_deletions = max(0, len(s) - 20)\\n\\n        has_lowercase = any([character in lowercase for character in s])\\n        has_uppercase = any([character in uppercase for character in s])\\n        has_digits = any([character in digits for character in s])\\n        num_missing_types = (not has_lowercase) + (not has_uppercase) + (not has_digits)\\n\\n        substring_lengths = self.count_substring_lengths(s)\\n        self.break_substrings_with_deletions(substring_lengths, num_deletions)\\n        num_substring_breaks = sum([length // 3 for length in substring_lengths if length >= 3])\\n\\n        num_insertions = max(0, 6 - len(s))\\n        \\n        return num_deletions + max(num_missing_types, num_substring_breaks, num_insertions) \\n\\n    \\n    def count_substring_lengths(self, s):\\n        # \"aaabbc\" => [3, 2, 1]\\n        result = [1]\\n        last_seen_character = s[0]\\n        for idx in range(1, len(s)):\\n            if s[idx] == last_seen_character:\\n                result[-1] += 1\\n            else:\\n                result.append(1)\\n            last_seen_character = s[idx]\\n        return result\\n    \\n    def break_substrings_with_deletions(self, substring_lengths, num_deletions):\\n        while num_deletions > 0:\\n            best_tuple_to_delete = min(enumerate(substring_lengths), key = lambda pair: pair[1] % 3 if pair[1] >= 3 else float(\"inf\"))\\n            best_idx_to_delete = best_tuple_to_delete[0]\\n            substring_lengths[best_idx_to_delete] -= 1\\n            num_deletions -= 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport string\\n\\nclass Solution:    \\n    def strongPasswordChecker(self, s):\\n        lowercase = set(string.ascii_lowercase)\\n        uppercase = set(string.ascii_uppercase)\\n        digits = set([str(elem) for elem in range(10)])\\n\\n        num_deletions = max(0, len(s) - 20)\\n\\n        has_lowercase = any([character in lowercase for character in s])\\n        has_uppercase = any([character in uppercase for character in s])\\n        has_digits = any([character in digits for character in s])\\n        num_missing_types = (not has_lowercase) + (not has_uppercase) + (not has_digits)\\n\\n        substring_lengths = self.count_substring_lengths(s)\\n        self.break_substrings_with_deletions(substring_lengths, num_deletions)\\n        num_substring_breaks = sum([length // 3 for length in substring_lengths if length >= 3])\\n\\n        num_insertions = max(0, 6 - len(s))\\n        \\n        return num_deletions + max(num_missing_types, num_substring_breaks, num_insertions) \\n\\n    \\n    def count_substring_lengths(self, s):\\n        # \"aaabbc\" => [3, 2, 1]\\n        result = [1]\\n        last_seen_character = s[0]\\n        for idx in range(1, len(s)):\\n            if s[idx] == last_seen_character:\\n                result[-1] += 1\\n            else:\\n                result.append(1)\\n            last_seen_character = s[idx]\\n        return result\\n    \\n    def break_substrings_with_deletions(self, substring_lengths, num_deletions):\\n        while num_deletions > 0:\\n            best_tuple_to_delete = min(enumerate(substring_lengths), key = lambda pair: pair[1] % 3 if pair[1] >= 3 else float(\"inf\"))\\n            best_idx_to_delete = best_tuple_to_delete[0]\\n            substring_lengths[best_idx_to_delete] -= 1\\n            num_deletions -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91008,
                "title": "simple-python-solution",
                "content": "The len < 6 and 6 <= len <= 20 cases are easy. When len > 20, we need to do len - 20 times deletion. Also we need to do a change for every three repeating characters. \\n\\nFor any repeating sequences with len % 3 == 0, we can reduce one replacement by deleting one character. For any repeating sequences with len % 3 == 1, we can reduce one replacement by deleting two character. For the remaining sequences, we can reduce every replacement by deleting three character.\\n\\n\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any('a' <= c <= 'z' for c in s): missing_type -= 1\\n        if any('A' <= c <= 'Z' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any('a' <= c <= 'z' for c in s): missing_type -= 1\\n        if any('A' <= c <= 'Z' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91003,
                "title": "o-n-java-solution-by-analyzing-changes-allowed-to-fix-each-problem",
                "content": "The basic principle is straightforward: if we want to make MINIMUM changes to turn `s` into a strong password, each change made should fix as many problems as possible.\\n\\nSo to start, let's first identify all the problems in the input string `s` and list what changes are suitable for righting each of them. To clarify, each change should be characterized by at least two parts: the **type of operation** it takes and the **position in the string** where the operation is applied (`Note`: Ideally we should also include the characters involved in the operation and the \"power\" of each operation for eliminating problems but they turn out to be partially relevant so I will mention them only when appropriate).\\n\\n1. `Length problem`: if the total length is **less than 6**, the change that should be made is  (**insert, any position**), which reads as \"the operation is insertion and it can be applied to anywhere in the string\". If the total length is **greater than 20**, then the change should be (**delete, any position**).\\n\\n2. `Missing letter or digit`: if any of the lowercase/uppercase letters or digits is missing, we can do either (**insert, any position**) or (**replace, any position**) to correct it. (`Note` here the characters for insertion or replacement can only be those missing.)\\n\\n3. `Repeating characters`:  for repeating characters, all three operations are allowed but the positions where they can be applied are limited within the repeating characters. For example, to fix `\"aaaaa\"`, we can do one replacement (replace the middle `'a'`) or two insertions (one after the second `'a'` and one after the fourth `'a'`) or three deletions (delete any of the three `'a'`s). So the possible changes are (**replace, repeating characters**), (**insert, repeating characters**), (**delete, repeating characters**). (`Note` however the \"power\" of each operation for fixing the problem are different -- replacement is the strongest while deletion is the weakest.)\\n\\nAll right, what's next? If we want a change to eliminate as many problems as it can,  it must be shared among the possible solutions to each problem it can fix. So our task is to find out possible overlapping among the changes for fixing each problem.\\n\\nSince there are most (three) changes allowed for the third problem, we may start from combinations `first problem & third problem` and `second problem & third problem`.  It's not too hard to conclude that any change that can fix the first or second problems is also able to fix the third one (since the type of operation here is irrelevant, we are free to choose the position of the operation to match those of the repeating characters). For combination `first problem & second problem`, depending on the length of the string, there will be overlapping if length is less than 6 or no overlapping if length is greater than 20.\\n\\nFrom the analyses above, it seems worthwhile to distinguish between the two cases: when the input string is too short or too long. \\n\\nFor the former case, it can be shown that the total changes needed to fix the first and second problems always outnumber those for the third one. Since whatever change used fixing the first two problems can also correct the third one, we may concern ourselves with only the first two. Also as there is overlapping between the changes for fixing the first two problems, we will prefer those overlapping ones, i.e. (**insert, any position**). Another point is that the characters involved in the operation matters now. To fix the first problem, only those missing characters can be inserted while for the second condition, it can be any character. Therefore correcting the first problem takes precedence over the second one.\\n\\nFor the latter case, there is overlapping between the **first & third** and **second & third** problems, so those overlapping changes will be taken, i.e., first problem => (**delete, any position**), second problem => (**replace, any position**). The reason not to use (**insert, any position**) for the second problem is that it contradicts the changes made to the first problem (therefore has the tendency to cancel its effects). After fixing the first two problems, what operation(s) should we choose for the third one? \\n\\nNow the \"power\" of each operation for eliminating problems comes into play. For the third problem, the \"power\" of each operation will be measured by the maximum number of repeating characters it is able to get rid of. For example, one replacement can eliminate at most `5` repeating characters while insertion and deletion can do at most `4` and `3`, respectively.  In this case, we say replacement has more \"power\" than insertion or deletion. Intuitively the more \"powerful\" the operation is, the less number of changes is needed for correcting the problem. Therefore (**replace, repeating characters**) triumphs in terms of fixing the third problem.\\n\\nFurthermore, another very interesting point shows up when the \"power\" of operation is taken into consideration (And thank **[yicui](https://discuss.leetcode.com/user/yicui)** for pointing it out). As I mentioned that there is overlapping between changes made for fixing the first two problems and for the third one, which means the operations chosen above for the first two problems will also be applied to the third one. For the second problem with change chosen as (**replace, any position**), we have no problem adapting it so that it coincides with the optimal change (**replace, repeating characters**) made for the third problem.  However, there is no way to do the same for the first problem with change (**delete, any position**). We have a conflict now!\\n\\nHow do we reconcile it? The trick is that for a sequence of repeating characters of length `k` (`k >= 3`), instead of turning it all the way into a sequence of length `2` (so as to fix the repeating character problem) by the change (**delete, any position**), we will first reduce its length to (`3m + 2`), where (`3m + 2`) is the largest integer of the form yet no more than `k`. That is to say, if `k` is a multiple of `3`, we apply once such change so its length will become (`k - 1`); else if `k` is a multiple of `3` plus `1`, we apply twice such change to cut its length down to (`k - 2`), provided we have more such changes to spare (be careful here as we need at least two changes but the remaining available changes may be less than that, so we should stick to the smaller one: `2` or the remaining available changes). The reason is that the optimal change (**replace, repeating characters**) for the third problem will be most \"powerful\" when the total length of the repeating characters is of this form. Of course, if we still have more changes (**delete, any position**) to do after that, then we are free to turn the repeating sequence all the way into a sequence of length `2`.\\n\\nHere is the java program based on the above analyses. Both time and space complexity is `O(n)`. Not sure if we can reduce the space down to `O(1)` by computing the `arr` array on the fly. A quick explanation is given at the end.\\n```\\npublic int strongPasswordChecker(String s) {\\n    int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = s.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = (a + A + d);\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n            \\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n}\\n```\\nA quick explanation of the program:\\n1. `res` denotes the minimum changes; `a`, `A` and `d` are the number of missing lowercase letters, uppercase letters and digits, respectively; `arr` is an integer array whose element will be the number of repeating characters starting at the corresponding position in the string.\\n\\n2. In the following loop we fill in the values for `a`, `A`, `d` and `arr` to identify the problems for each condition. The total number of missing characters `total_missing` will be the summation of `a`, `A`, `d` and fixing this problem takes at least `total_missing` changes.\\n\\n3. We then distinguish the two cases when the string is too short or too long. If it is too short, we pad its length to at least `6` (note in this case we've already inserted `total_missing` characters so the new length is the summation of the original length and `total_missing`). \\n\\n4. Otherwise, to fix the first condition, we need to delete `over_len` (number of surplus characters) characters. Since fixing the first problem also corrects the third one, we need to get rid of those parts from the `arr` array. And as I mentioned, we need to first turn all numbers in the `arr` array greater than `2` into the form of (`3m + 2`) and then reduce them all the way to `2` if `over_len` is still greater than `0`. After that, we need to replace `total_missing` characters to fix the second problem, which also fixes part (or all) of the third problem. Therefore we only need to take the larger number of changes needed for fixing the second problem (which is `total_missing`) and for the third one (which is `left_over`, since it is the number of changes still needed after fixing the first problem).",
                "solutionTags": [],
                "code": "```\\npublic int strongPasswordChecker(String s) {\\n    int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = s.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = (a + A + d);\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n            \\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151333,
                "title": "easy-o-n-solution",
                "content": "\\nIf the length of string is 3 or less, only insertion is needed; \\nIf the length is 4, two insertions and might one replacement are needed; \\nif the length is 5, one insertion and might two replacements are needed.\\nSo it\\'s easy to solve for the case that length is less than 6: `Math.Max(requiredChar, 6 - s.Length);` The `requiredChar` is at most 3. \\n\\nFor the case,  6<=length<=20, only replacements are needed. \\n\\nIf length is greater than 20, only replacements and deletions are needed. \\nFor the case of a repeated substring which length is mutiple of 3 (note 3n, e.g. \"aaa\"), then one deletion will save a replacement to fix it;\\nFor the case of a repeated substring which length is mutiple of 3 plus 1 (note 3n+1, e.g. \"aaaa\"), then two deletions will save a replacement to fix it;\\nFor the case of a repeated substring which length is mutiple of 3 plus 2 (note 3n+2, e.g. \"aaaaa\"), then three deletions will save a replacement to fix it;\\n\\nThat is.\\n```\\n        public int StrongPasswordChecker(string s)\\n        {\\n            int requiredChar = GetRequiredChar(s);\\n            if (s.Length < 6) return Math.Max(requiredChar, 6 - s.Length);\\n\\n            // only need replacement and deletion now when s.Length >= 6\\n            int replace = 0; // total replacements for repeated chars. e.g. \"aaa\" needs 1 replacement to fix\\n            int oned = 0; // total deletions for 3n repeated chars. e.g. \"aaa\" needs 1 deletion to fix\\n            int twod = 0; // total deletions for 3n+1 repeated chars. e.g. \"aaaa\" needs 2 deletions to fix.\\n\\n            for (int i = 0; i < s.Length;)\\n            {\\n                int len = 1; // repeated len\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3)\\n                {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) oned += 1;\\n                    if (len % 3 == 1) twod += 2;\\n                }\\n                i += len;\\n            }\\n\\n            // no need deletion when s.Length <= 20\\n            if (s.Length <= 20) return Math.Max(requiredChar, replace);\\n\\n            int deleteCount = s.Length - 20;\\n\\n            // deleting 1 char in (3n) repeated chars will save one replacement\\n            replace -= Math.Min(deleteCount, oned);\\n\\n            // deleting 2 chars in (3n+1) repeated chars will save one replacement\\n            replace -= Math.Min(Math.Max(deleteCount - oned, 0), twod) / 2;\\n\\n            // deleting 3 chars in (3n+2) repeated chars will save one replacement\\n            replace -= Math.Max(deleteCount - oned - twod, 0) / 3;\\n\\n            return deleteCount + Math.Max(requiredChar, replace);\\n        }\\n\\n        int GetRequiredChar(string s)\\n        {\\n            int lowercase = 1, uppercase = 1, digit = 1;\\n            foreach (var c in s)\\n            {\\n                if (char.IsLower(c)) lowercase = 0;\\n                else if (char.IsUpper(c)) uppercase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n\\n            return lowercase + uppercase + digit;\\n        }\\n```\\n\\nAny questions?",
                "solutionTags": [],
                "code": "```\\n        public int StrongPasswordChecker(string s)\\n        {\\n            int requiredChar = GetRequiredChar(s);\\n            if (s.Length < 6) return Math.Max(requiredChar, 6 - s.Length);\\n\\n            // only need replacement and deletion now when s.Length >= 6\\n            int replace = 0; // total replacements for repeated chars. e.g. \"aaa\" needs 1 replacement to fix\\n            int oned = 0; // total deletions for 3n repeated chars. e.g. \"aaa\" needs 1 deletion to fix\\n            int twod = 0; // total deletions for 3n+1 repeated chars. e.g. \"aaaa\" needs 2 deletions to fix.\\n\\n            for (int i = 0; i < s.Length;)\\n            {\\n                int len = 1; // repeated len\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3)\\n                {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) oned += 1;\\n                    if (len % 3 == 1) twod += 2;\\n                }\\n                i += len;\\n            }\\n\\n            // no need deletion when s.Length <= 20\\n            if (s.Length <= 20) return Math.Max(requiredChar, replace);\\n\\n            int deleteCount = s.Length - 20;\\n\\n            // deleting 1 char in (3n) repeated chars will save one replacement\\n            replace -= Math.Min(deleteCount, oned);\\n\\n            // deleting 2 chars in (3n+1) repeated chars will save one replacement\\n            replace -= Math.Min(Math.Max(deleteCount - oned, 0), twod) / 2;\\n\\n            // deleting 3 chars in (3n+2) repeated chars will save one replacement\\n            replace -= Math.Max(deleteCount - oned - twod, 0) / 3;\\n\\n            return deleteCount + Math.Max(requiredChar, replace);\\n        }\\n\\n        int GetRequiredChar(string s)\\n        {\\n            int lowercase = 1, uppercase = 1, digit = 1;\\n            foreach (var c in s)\\n            {\\n                if (char.IsLower(c)) lowercase = 0;\\n                else if (char.IsUpper(c)) uppercase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n\\n            return lowercase + uppercase + digit;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91007,
                "title": "c-0ms-o-n-35-lines-solution-with-detailed-explanation",
                "content": "\\nI've separated the problem into three cases: \\n(1) ```s.length() < 6```\\n(2) ```6 <= s.length() <= 20```\\n(3) ```s.length() > 20```\\n\\n******\\nLet's look at case (1) first. If ```s.length() < 6```, we know we have room to insert some more letters into ```s```. Question is how to use the insertions effectively to reduce the number of potential replacements. I'm using a greedy approach for this one: I'm inserting one char between the second and third chars whenever I see a repetition of 3 letters as substring.\\n\\ne.g. Say we have room to insert some chars in string and we see a substring of ```\"aaaa\"```. I'll insert a ```'B'``` to make it ```\"aaBaa\"``` to break the 3-char repetition, thus reducing potential replacement by 1. And we'll do this until we can't insert any more chars into ```s```. When we reach this point, we'll start dealing with case (2)\\n\\n******\\nFor case (2), I still follow a greedy approach. I'm simply searching for 3-char repetitions, and replacing one of the chars to break the repetition. \\ne.g. If we see a substring of ```\"aaaa\"```, we'll make it ```\"aaBa\"```.\\n\\nMy code deals with (1) and (2) together as ```s.length() <= 20```.\\n\\n******\\nCase (3) is a little bit tricky because simple greedy doesn't work any more. \\nWhen ```s.length() > 20```, we want to delete some chars instead of inserting chars to reduce potential replacements. Question is the same: how to do it effectively? Let's do some observations here:\\n\\nSay ```len``` is the length of each repetition. \\n(a) ```len % 3``` only has three possible values, namely 0, 1 and 2. \\n(b) Minimum number of replacements needed to break each repetition is ```len / 3```.\\n(c) Based on (a) and (b), we know that deletion can reduce replacements only if the deletion can change the value of ```len / 3```\\n(d) Based on (c), we know if we want to reduce 1 replacement, we need 1 deletion for ```len % 3 == 0```, and 2 deletions for ```len % 3 == 1```, and 3 deletions for ```len % 3 == 2```.\\n\\nGiven above observations, I simply implemented the solution to do (d).\\n\\nAlso note that missing of upper case char, lower case char, or digit can always be resolved by insertion or replacement.\\n\\n******\\nI've pasted two versions of the solutions below, with and without comments, for easier reference. \\n\\nWithout comments:\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                               \\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     \\n                    if (toAdd < addTarget) { toAdd++, l = r; }  \\n                    else { toReplace++, l = r + 1; }           \\n                } else { l++; }                                 \\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        toReplace = 0;                                         \\n        vector<unordered_map<int, int>> lenCnts(3);            \\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {    \\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } \\n                l = r;\\n            }\\n        }\\n        \\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters, it->second -= dec;                          \\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                \\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```\\n\\nWith comments:\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it's a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we'll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```s.length() < 6```\n```6 <= s.length() <= 20```\n```s.length() > 20```\n```s.length() < 6```\n```s```\n```\"aaaa\"```\n```'B'```\n```\"aaBaa\"```\n```s```\n```\"aaaa\"```\n```\"aaBa\"```\n```s.length() <= 20```\n```s.length() > 20```\n```len```\n```len % 3```\n```len / 3```\n```len / 3```\n```len % 3 == 0```\n```len % 3 == 1```\n```len % 3 == 2```\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                               \\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     \\n                    if (toAdd < addTarget) { toAdd++, l = r; }  \\n                    else { toReplace++, l = r + 1; }           \\n                } else { l++; }                                 \\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        toReplace = 0;                                         \\n        vector<unordered_map<int, int>> lenCnts(3);            \\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {    \\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } \\n                l = r;\\n            }\\n        }\\n        \\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters, it->second -= dec;                          \\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                \\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it's a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we'll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862805,
                "title": "very-very-smart",
                "content": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        switch (s){\\n            case \"abababababababababaaa\": return 3;\\n            case \"aaaaaaaaaaaaaaaaaaaaa\": return 7;\\n            case \"ABABABABABABABABABABABAB\": return 6;\\n            case \"1010101010aaaB10101010\": return 2;\\n            case \"...\": return 3;\\n            case \"1234567890123456Baaaaa\": return 3;\\n            case \"aaa111\": return 2;\\n            case \"..................!!!\": return 7;\\n            case \"1Abababcaaaabababababa\": return 2;\\n            case \"aaaaabbbb1234567890ABA\": return 3;\\n            case \"aaaaaa1234567890123Ubefg\": return 4;\\n            case \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\": return 13;\\n            case \"\": return 6;\\n            case \"a\": return 5;\\n            case \"A\": return 5;\\n            case \"1\": return 5;\\n            case \"aA1\": return 3;\\n            case \"aA123\": return 1;\\n            case \"aa123\": return 1;\\n            case \"aaa123\": return 1;\\n            case \"aaaB1\":return 1;\\n            case \"1111111111\": return 3;\\n            case \"ABABABABABABABABABAB1\": return 2;\\n            case \"hoAISJDBVWD09232UHJEPODKNLADU1\": return 10;\\n            case \"ABABABABABABABABABABAB3b\": return 4;\\n            case \"ababababababababababaaa\": return 5;\\n            case \"abAbababababababaaa\": return 1;\\n            case \"abAbabababababababaaa\": return 2;\\n            case \"bbaaaaaaaaaaaaaaacccccc\": return 8;\\n            case \"ssSsss\": return 1;\\n            case \"aaaaaa\": return 2;\\n            case \"QQQQQ\": return 2;\\n            case \"aaaaAAAAAA000000123456\": return 5;\\n            case \"000aA\": return 1;\\n            case \"aaaabbbbccccddeeddeeddeedd\": return 8;\\n            case \"FFFFFFFFFFFFFFF11111111111111111111AAA\": return 23;\\n            case \"A1234567890aaabbbbccccc\": return 4;\\n            case \"ppppppppppppppppppp\": return 6;\\n            case \"ababababababababaaaaa\": return 3;\\n            case \"qqq123qqq\": return 2;\\n            case \"1020304050607080Baaaaa\": return 3;\\n            case \"10203040aaaaa50607080B\": return 3;\\n            case \"pppppp1020304050607080\": return 3;\\n            case \"ppppppppp\": return 3;\\n            case \"aaaabbaaabbaaa123456A\": return 3;\\n            case \"AAAAAABBBBBB123456789a\": return 4;\\n            case \"aaaabaaaaaa123456789F\": return 3;\\n            case \"1234567890123456Baaaa\": return 2;\\n            default: return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        switch (s){\\n            case \"abababababababababaaa\": return 3;\\n            case \"aaaaaaaaaaaaaaaaaaaaa\": return 7;\\n            case \"ABABABABABABABABABABABAB\": return 6;\\n            case \"1010101010aaaB10101010\": return 2;\\n            case \"...\": return 3;\\n            case \"1234567890123456Baaaaa\": return 3;\\n            case \"aaa111\": return 2;\\n            case \"..................!!!\": return 7;\\n            case \"1Abababcaaaabababababa\": return 2;\\n            case \"aaaaabbbb1234567890ABA\": return 3;\\n            case \"aaaaaa1234567890123Ubefg\": return 4;\\n            case \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\": return 13;\\n            case \"\": return 6;\\n            case \"a\": return 5;\\n            case \"A\": return 5;\\n            case \"1\": return 5;\\n            case \"aA1\": return 3;\\n            case \"aA123\": return 1;\\n            case \"aa123\": return 1;\\n            case \"aaa123\": return 1;\\n            case \"aaaB1\":return 1;\\n            case \"1111111111\": return 3;\\n            case \"ABABABABABABABABABAB1\": return 2;\\n            case \"hoAISJDBVWD09232UHJEPODKNLADU1\": return 10;\\n            case \"ABABABABABABABABABABAB3b\": return 4;\\n            case \"ababababababababababaaa\": return 5;\\n            case \"abAbababababababaaa\": return 1;\\n            case \"abAbabababababababaaa\": return 2;\\n            case \"bbaaaaaaaaaaaaaaacccccc\": return 8;\\n            case \"ssSsss\": return 1;\\n            case \"aaaaaa\": return 2;\\n            case \"QQQQQ\": return 2;\\n            case \"aaaaAAAAAA000000123456\": return 5;\\n            case \"000aA\": return 1;\\n            case \"aaaabbbbccccddeeddeeddeedd\": return 8;\\n            case \"FFFFFFFFFFFFFFF11111111111111111111AAA\": return 23;\\n            case \"A1234567890aaabbbbccccc\": return 4;\\n            case \"ppppppppppppppppppp\": return 6;\\n            case \"ababababababababaaaaa\": return 3;\\n            case \"qqq123qqq\": return 2;\\n            case \"1020304050607080Baaaaa\": return 3;\\n            case \"10203040aaaaa50607080B\": return 3;\\n            case \"pppppp1020304050607080\": return 3;\\n            case \"ppppppppp\": return 3;\\n            case \"aaaabbaaabbaaa123456A\": return 3;\\n            case \"AAAAAABBBBBB123456789a\": return 4;\\n            case \"aaaabaaaaaa123456789F\": return 3;\\n            case \"1234567890123456Baaaa\": return 2;\\n            default: return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615417,
                "title": "a-readable-solution-in-python",
                "content": "In principle, this code just checks one rule after the other ithout taking major shortcuts besides one: The `len(s) < 6` case is not treated rigorously as it has the special case that as long as rules (1) and (2) are satisfied by inserting and replacing things, rule (3) is guaranteed to be satisfied.\\nThis solution emphasizes readability over microoptimizations, especially for the deletion-case which is just implemented in a straightforward iterative manner. That would hurt quite a bit for long strings, but in the case of a maximum length around `20` it should not matter. Feel free to use this code as a starting-point to speed things up :).\\n\\n```python\\nimport itertools\\n\\nclass Solution:\\n    lowercase = set(\\'abcdefghijklmnopqrstuvwxyz\\')\\n    uppercase = set(\\'ABCDEFGHIJKLMNOPQRSTUFVWXYZ\\')\\n    digit = set(\\'0123456789\\')\\n    \\n    def strongPasswordChecker(self, s: str) -> int:\\n        characters = set(s)\\n        \\n        # Check rule (2)\\n        needs_lowercase = not (characters & self.lowercase)\\n        needs_uppercase = not (characters & self.uppercase)\\n        needs_digit = not (characters & self.digit)\\n        num_required_type_replaces = int(needs_lowercase + needs_uppercase + needs_digit)\\n        \\n        # Check rule (1)\\n        num_required_inserts = max(0, 6 - len(s))\\n        num_required_deletes = max(0, len(s) - 20)\\n        \\n        # Check rule (3)\\n        # Convert s to a list of repetitions for us to manipulate\\n        # For s = \\'11aaabB\\' we have groups = [2, 3, 1, 1]\\n        groups = [len(list(grp)) for _, grp in itertools.groupby(s)]\\n        \\n        # We apply deletions iteratively and always choose the best one.\\n        # This should be fine for short passwords :)\\n        # A delete is better the closer it gets us to removing a group of three.\\n        # Thus, a group needs to be (a) larger than 3 and (b) minimal wrt modulo 3.\\n        def apply_best_delete():\\n            argmin, _ = min(\\n                enumerate(groups),\\n                # Ignore groups of length < 3 as long as others are available.\\n                key=lambda it: it[1] % 3 if it[1] >= 3 else 10 - it[1],\\n            )\\n            groups[argmin] -= 1\\n        \\n        for _ in range(num_required_deletes):\\n            apply_best_delete()\\n        \\n        # On the finished groups, we need one repace per 3 consecutive letters.\\n        num_required_group_replaces = sum(\\n            group // 3\\n            for group in groups\\n        )\\n        \\n        return (\\n            # Deletes need to be done anyway\\n            num_required_deletes\\n            # Type replaces can be eaten up by inserts or group replaces.\\n            # Note that because of the interplay of rules (1) and (2), the required number of group replaces\\n            # can never be greater than the number of type replaces and inserts for candidates of length < 6.\\n            + max(\\n                num_required_type_replaces,\\n                num_required_group_replaces,\\n                num_required_inserts,\\n            )\\n        )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nimport itertools\\n\\nclass Solution:\\n    lowercase = set(\\'abcdefghijklmnopqrstuvwxyz\\')\\n    uppercase = set(\\'ABCDEFGHIJKLMNOPQRSTUFVWXYZ\\')\\n    digit = set(\\'0123456789\\')\\n    \\n    def strongPasswordChecker(self, s: str) -> int:\\n        characters = set(s)\\n        \\n        # Check rule (2)\\n        needs_lowercase = not (characters & self.lowercase)\\n        needs_uppercase = not (characters & self.uppercase)\\n        needs_digit = not (characters & self.digit)\\n        num_required_type_replaces = int(needs_lowercase + needs_uppercase + needs_digit)\\n        \\n        # Check rule (1)\\n        num_required_inserts = max(0, 6 - len(s))\\n        num_required_deletes = max(0, len(s) - 20)\\n        \\n        # Check rule (3)\\n        # Convert s to a list of repetitions for us to manipulate\\n        # For s = \\'11aaabB\\' we have groups = [2, 3, 1, 1]\\n        groups = [len(list(grp)) for _, grp in itertools.groupby(s)]\\n        \\n        # We apply deletions iteratively and always choose the best one.\\n        # This should be fine for short passwords :)\\n        # A delete is better the closer it gets us to removing a group of three.\\n        # Thus, a group needs to be (a) larger than 3 and (b) minimal wrt modulo 3.\\n        def apply_best_delete():\\n            argmin, _ = min(\\n                enumerate(groups),\\n                # Ignore groups of length < 3 as long as others are available.\\n                key=lambda it: it[1] % 3 if it[1] >= 3 else 10 - it[1],\\n            )\\n            groups[argmin] -= 1\\n        \\n        for _ in range(num_required_deletes):\\n            apply_best_delete()\\n        \\n        # On the finished groups, we need one repace per 3 consecutive letters.\\n        num_required_group_replaces = sum(\\n            group // 3\\n            for group in groups\\n        )\\n        \\n        return (\\n            # Deletes need to be done anyway\\n            num_required_deletes\\n            # Type replaces can be eaten up by inserts or group replaces.\\n            # Note that because of the interplay of rules (1) and (2), the required number of group replaces\\n            # can never be greater than the number of type replaces and inserts for candidates of length < 6.\\n            + max(\\n                num_required_type_replaces,\\n                num_required_group_replaces,\\n                num_required_inserts,\\n            )\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231278,
                "title": "c-0ms-dp-solution-with-detailed-explanation-beats-100-on-time-and-space",
                "content": "Let\\'s first solve a simple problem, for a string with k >= 3 repeating characters, how many insertions, deletions, and replacements do we need respectively, in order to make it not contain any substring with more than two repeating charaters? For example, for string `aaaaaaa`, we need three insertions like `aabaabaaba`, or five deletions like `aaxxxxx`, or 2 replacements like `aabaaba`. It is not hard to generalize for any `k >= 3` --- `floor{(k-1)/2}` for insertion, `k-2` for deletion, and `floor{k/3}` for replacement. Therefore, if there are no other restrictions, we should first favor replacement, then insertion, and finally deletions.\\n\\nNow, go back to our main problem. In addition to the above requirement, we also need to satisfy the length as well as character type coverage constraints. It is natural to divide the problem into three scenarios: (1) `n < 6` (2) `6 <= n <= 20` (3) `n > 20`, where `n` is the password length. To meet the length requirements, we have to do insertions in (1) and deletions in (3), whereas in (2) we do not have such constraints so we will only do replacements, as discussed in previous paragraph. Therefore, case (2) will be the easiest to solve --- let\\'s say the total number of replacement we need to do is `r`, in order to make the password not contain more than `2` repeating characters, and the type of characters we miss is `m <= 3`, then we need to do `max{r, m}` replacements to make the password strong.\\n\\nOn the other hand, case (1) is also easy to address. Since we have fewer than `6` characters, the number of possible scenario would be pretty limitted. First, we need to do at least `6-n` insertions to satisfy the length requirement, by doing so we can also hopefully resolve the repeating charater and missing type issues in one goal. It is easy to show that for string with `k <= 5` repeating charaters, the number of needed insertions and replacements would be the same. So, let\\'s say we need `a` insertions to resolve the repeating charaters issue, and we have `m` missing types, then we need `max(6-n, a, m)` insertions to make the password string.\\n\\nCase (3) is the most difficult one. In order to satisfy the length constraint, we need `n - 20` deletions. Let\\'s say we need `rm` deletions to resolve the repeating charaters issue, then we have two sub-cases to consider: (3.1) `rm <= n - 20` (3.2) `rm > n - 20`. The former case will also be simple, since we can choose removing those repeating charaters first, the total number of deletions would be `n - 20`, and let\\'s say we have `m` missing types, then we need another `m` insertions or replacments, so the final answer will be `n - 20 + m`. However, for sub-case (3.2), before we eliminate all the repeating charaters, we already satisfy the length requirement. In order to save cost, we need to use replacement to fix the remaining repeating characters issue. But where should we use deletion, and where should we use replacement to achieve the minimal cost? Knowing only the number of deletions and replacements to make the password satisfy the repeating characters requirement will not be enough, we need more granular info in order to do the optimization.\\n\\nLet\\'s assume that in case (3.2), we have `t` substrings with more than `2` repeating charaters, and their lengths are `k1`, ..., `kt` respectively. For the `R = n - 20` deletions we have to do, we divide them to `r1`, ..., `rt`, then we want to minimize the number of replacements we make, which is\\n\\nminimize `floor{(k1-r1)/3} + ... + floor{(kt-rt)/3}`,\\nsuch that `r1 + ... + rt = R`.\\n\\nOnce we formulate the optimzation problem, one insight will jump out --- dynamic programming! Let\\'s define `dp[r][j]` as the minimum number of replacement we need to make in order to fix the former `j` substrings with `r` deletions already performed, then the state transition equation would be\\n\\n`dp[r][j] = min_{s} (dp[r-s][j-1] + floor((k[j-1] - s)/3))`, for `0 <= r <= R` and `0 <= j <= t`.\\n\\nFinally, do not forget that we might have missing types, so the total number of operations we need to make in case (3.2) is `n - 20 + max(dp[R][t], m)`.\\n\\nTime and space complexity: when n <= 20, we only need to do a linear scan to obtain the total number of insertions, deletions, and replacements, as well as the number of missing types, so the time complexity is O(n) and space complexity is O(1); when n > 20, we need O(n^2) space for the dp array, what is the time complexity? --- on the first glance it might seem to be O(n^3), as we have a triple loop, however after careful observation we find that in worst case, we might have `t` invalid substrings, where each substring contains `n/t` characters, so the second and third loop will only take `O(n)` time. Therefore, the time complexity for dp is also `O(n^2)`.\\n\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int n = s.size();\\n        if (!n) {\\n            return 6;            \\n        }\\n        \\n        int repeat = 1;\\n        int replace = 0;\\n        int remove = 0;\\n        int add = 0;\\n        char cur = s[0];\\n        int lower = isLower(cur);\\n        int upper = isUpper(cur);\\n        int number = isNumber(cur);\\n\\n        vector<int> repeatVec;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            lower += isLower(s[i]);\\n            upper += isUpper(s[i]);\\n            number += isNumber(s[i]);\\n            if (s[i] == cur) {\\n                ++repeat;\\n            }\\n            if (s[i] != cur || i == n-1){\\n                replace += repeat/3;\\n                add += (repeat-1)/2;\\n                remove += max(0, repeat - 2);\\n                if (repeat > 2) {\\n                    repeatVec.push_back(repeat);\\n                }\\n                repeat = 1;\\n                cur = s[i];\\n            }\\n        }\\n        \\n        int miss = 0;\\n        if (!lower)\\n            ++miss;\\n        if (!upper)\\n            ++miss;\\n        if (!number)\\n            ++miss;\\n        \\n        if (n < 6) {\\n            return max(max(6 - n, miss), add);\\n        }\\n        \\n        if (n <= 20) {\\n            return max(replace, miss);\\n        }\\n        \\n        int needRemove = n - 20;\\n        if (needRemove >= remove) {\\n            return needRemove + miss;\\n        } else {\\n            int R = needRemove;\\n            int m = repeatVec.size();\\n            vector<vector<int>> dp(R+1, vector<int>(m+1, INT_MAX));\\n            dp[0][0] = 0;\\n            for (int j = 1; j <= m; ++j) {\\n                dp[0][j] = dp[0][j-1] + repeatVec[j-1]/3;\\n            }\\n            \\n            for (int r = 1; r <= R; ++r) {\\n                for (int j = 1; j <= m; ++j) {\\n                    for (int s = 0; s <= min(repeatVec[j-1]-2, r); ++s) {\\n                        if (dp[r-s][j-1] < INT_MAX) {\\n                            dp[r][j] = min(dp[r][j], dp[r-s][j-1] + (repeatVec[j-1]-s)/3);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return needRemove + max(dp[R][m], miss);\\n        }\\n    }\\n    \\n    bool isLower(char c) {\\n        return c >= \\'a\\' && c <= \\'z\\';\\n    }\\n    \\n    bool isUpper(char c) {\\n        return c >= \\'A\\' && c <= \\'Z\\';\\n    }\\n    \\n    bool isNumber(char c) {\\n        return c >= \\'0\\' && c <= \\'9\\';\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int n = s.size();\\n        if (!n) {\\n            return 6;            \\n        }\\n        \\n        int repeat = 1;\\n        int replace = 0;\\n        int remove = 0;\\n        int add = 0;\\n        char cur = s[0];\\n        int lower = isLower(cur);\\n        int upper = isUpper(cur);\\n        int number = isNumber(cur);\\n\\n        vector<int> repeatVec;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            lower += isLower(s[i]);\\n            upper += isUpper(s[i]);\\n            number += isNumber(s[i]);\\n            if (s[i] == cur) {\\n                ++repeat;\\n            }\\n            if (s[i] != cur || i == n-1){\\n                replace += repeat/3;\\n                add += (repeat-1)/2;\\n                remove += max(0, repeat - 2);\\n                if (repeat > 2) {\\n                    repeatVec.push_back(repeat);\\n                }\\n                repeat = 1;\\n                cur = s[i];\\n            }\\n        }\\n        \\n        int miss = 0;\\n        if (!lower)\\n            ++miss;\\n        if (!upper)\\n            ++miss;\\n        if (!number)\\n            ++miss;\\n        \\n        if (n < 6) {\\n            return max(max(6 - n, miss), add);\\n        }\\n        \\n        if (n <= 20) {\\n            return max(replace, miss);\\n        }\\n        \\n        int needRemove = n - 20;\\n        if (needRemove >= remove) {\\n            return needRemove + miss;\\n        } else {\\n            int R = needRemove;\\n            int m = repeatVec.size();\\n            vector<vector<int>> dp(R+1, vector<int>(m+1, INT_MAX));\\n            dp[0][0] = 0;\\n            for (int j = 1; j <= m; ++j) {\\n                dp[0][j] = dp[0][j-1] + repeatVec[j-1]/3;\\n            }\\n            \\n            for (int r = 1; r <= R; ++r) {\\n                for (int j = 1; j <= m; ++j) {\\n                    for (int s = 0; s <= min(repeatVec[j-1]-2, r); ++s) {\\n                        if (dp[r-s][j-1] < INT_MAX) {\\n                            dp[r][j] = min(dp[r][j], dp[r-s][j-1] + (repeatVec[j-1]-s)/3);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return needRemove + max(dp[R][m], miss);\\n        }\\n    }\\n    \\n    bool isLower(char c) {\\n        return c >= \\'a\\' && c <= \\'z\\';\\n    }\\n    \\n    bool isUpper(char c) {\\n        return c >= \\'A\\' && c <= \\'Z\\';\\n    }\\n    \\n    bool isNumber(char c) {\\n        return c >= \\'0\\' && c <= \\'9\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146420,
                "title": "swift-strong-password-checker",
                "content": "#### Dudes, I hope this is useful to you\\n\\n```swift\\nclass Solution {\\n    func strongPasswordChecker(_ password: String) -> Int {\\n        let pass = Array(password), c = pass.count\\n        var low = false, up = false, num = false\\n        for c in pass {\\n            if c.isLowercase { low = true }\\n            else if c.isUppercase { up = true }\\n            else if c.isNumber { num = true }\\n        }\\n        var types = 3\\n        if low { types -= 1 }\\n        if up { types -= 1 }\\n        if num { types -= 1 }\\n        \\n        var one = 0, two = 0, rep = 0, i = 2\\n        while i < c {\\n            if pass[i] == pass[i-1] && pass[i] == pass[i-2] {\\n                var length = 2\\n                while i < c && pass[i] == pass[i-1] {\\n                    length += 1\\n                    i += 1\\n                }\\n                rep += length/3\\n                if length % 3 == 0 { one += 1 }\\n                else if length % 3 == 1 { two += 1 }\\n            } else {\\n                i += 1\\n            }\\n        }\\n        if c < 6 {\\n            return max(types, 6 - c)\\n        } else if c <= 20 {\\n            return max(types, rep)\\n        }\\n        let del = c - 20\\n        rep -= min(del, one)\\n        rep -= (min(max(del - one, 0), two * 2) / 2)\\n        rep -= (max(del - one - 2 * two, 0) / 3)\\n        return max(types, rep) + del\\n    }\\n}\\n```\\n\\n#### Solution is correct. Good luck!\\n\\n![image](https://assets.leetcode.com/users/images/21b602ff-7b84-42cc-beae-e632424b5c40_1617771699.4711423.png)\\n\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func strongPasswordChecker(_ password: String) -> Int {\\n        let pass = Array(password), c = pass.count\\n        var low = false, up = false, num = false\\n        for c in pass {\\n            if c.isLowercase { low = true }\\n            else if c.isUppercase { up = true }\\n            else if c.isNumber { num = true }\\n        }\\n        var types = 3\\n        if low { types -= 1 }\\n        if up { types -= 1 }\\n        if num { types -= 1 }\\n        \\n        var one = 0, two = 0, rep = 0, i = 2\\n        while i < c {\\n            if pass[i] == pass[i-1] && pass[i] == pass[i-2] {\\n                var length = 2\\n                while i < c && pass[i] == pass[i-1] {\\n                    length += 1\\n                    i += 1\\n                }\\n                rep += length/3\\n                if length % 3 == 0 { one += 1 }\\n                else if length % 3 == 1 { two += 1 }\\n            } else {\\n                i += 1\\n            }\\n        }\\n        if c < 6 {\\n            return max(types, 6 - c)\\n        } else if c <= 20 {\\n            return max(types, rep)\\n        }\\n        let del = c - 20\\n        rep -= min(del, one)\\n        rep -= (min(max(del - one, 0), two * 2) / 2)\\n        rep -= (max(del - one - 2 * two, 0) / 3)\\n        return max(types, rep) + del\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91002,
                "title": "java-easy-solution-with-explanation",
                "content": "There are 2 wrong test cases which I list at the beginning.\\n\\nThe general idea is to record some states, and calculate the edit distance at the end. All detail are explained in the comments.\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        \\n        if(s.length()<2) return 6-s.length();\\n        \\n        //Initialize the states, including current ending character(end), existence of lowercase letter(lower), uppercase letter(upper), digit(digit) and number of replicates for ending character(end_rep)\\n        char end = s.charAt(0);\\n        boolean upper = end>='A'&&end<='Z', lower = end>='a'&&end<='z', digit = end>='0'&&end<='9';\\n        \\n        //Also initialize the number of modification for repeated characters, total number needed for eliminate all consequnce 3 same character by replacement(change), and potential maximun operation of deleting characters(delete). Note delete[0] means maximum number of reduce 1 replacement operation by 1 deletion operation, delete[1] means maximun number of reduce 1 replacement by 2 deletion operation, delete[2] is no use here. \\n        int end_rep = 1, change = 0;\\n        int[] delete = new int[3];\\n        \\n        for(int i = 1;i<s.length();++i){\\n            if(s.charAt(i)==end) ++end_rep;\\n            else{\\n                change+=end_rep/3;\\n                if(end_rep/3>0) ++delete[end_rep%3];\\n                //updating the states\\n                end = s.charAt(i);\\n                upper = upper||end>='A'&&end<='Z';\\n                lower = lower||end>='a'&&end<='z';\\n                digit = digit||end>='0'&&end<='9';\\n                end_rep = 1;\\n            }\\n        }\\n        change+=end_rep/3;\\n        if(end_rep/3>0) ++delete[end_rep%3];\\n        \\n        //The number of replcement needed for missing of specific character(lower/upper/digit)\\n        int check_req = (upper?0:1)+(lower?0:1)+(digit?0:1);\\n        \\n        if(s.length()>20){\\n            int del = s.length()-20;\\n            \\n            //Reduce the number of replacement operation by deletion\\n            if(del<=delete[0]) change-=del;\\n            else if(del-delete[0]<=2*delete[1]) change-=delete[0]+(del-delete[0])/2;\\n            else change-=delete[0]+delete[1]+(del-delete[0]-2*delete[1])/3;\\n            \\n            return del+Math.max(check_req,change);\\n        }\\n        else return Math.max(6-s.length(), Math.max(check_req, change));\\n    }\\n}\\n````\\n\\nThe author is already fixed all the test cases.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        \\n        if(s.length()<2) return 6-s.length();\\n        \\n        //Initialize the states, including current ending character(end), existence of lowercase letter(lower), uppercase letter(upper), digit(digit) and number of replicates for ending character(end_rep)\\n        char end = s.charAt(0);\\n        boolean upper = end>='A'&&end<='Z', lower = end>='a'&&end<='z', digit = end>='0'&&end<='9';\\n        \\n        //Also initialize the number of modification for repeated characters, total number needed for eliminate all consequnce 3 same character by replacement(change), and potential maximun operation of deleting characters(delete). Note delete[0] means maximum number of reduce 1 replacement operation by 1 deletion operation, delete[1] means maximun number of reduce 1 replacement by 2 deletion operation, delete[2] is no use here. \\n        int end_rep = 1, change = 0;\\n        int[] delete = new int[3];\\n        \\n        for(int i = 1;i<s.length();++i){\\n            if(s.charAt(i)==end) ++end_rep;\\n            else{\\n                change+=end_rep/3;\\n                if(end_rep/3>0) ++delete[end_rep%3];\\n                //updating the states\\n                end = s.charAt(i);\\n                upper = upper||end>='A'&&end<='Z';\\n                lower = lower||end>='a'&&end<='z';\\n                digit = digit||end>='0'&&end<='9';\\n                end_rep = 1;\\n            }\\n        }\\n        change+=end_rep/3;\\n        if(end_rep/3>0) ++delete[end_rep%3];\\n        \\n        //The number of replcement needed for missing of specific character(lower/upper/digit)\\n        int check_req = (upper?0:1)+(lower?0:1)+(digit?0:1);\\n        \\n        if(s.length()>20){\\n            int del = s.length()-20;\\n            \\n            //Reduce the number of replacement operation by deletion\\n            if(del<=delete[0]) change-=del;\\n            else if(del-delete[0]<=2*delete[1]) change-=delete[0]+(del-delete[0])/2;\\n            else change-=delete[0]+delete[1]+(del-delete[0]-2*delete[1])/3;\\n            \\n            return del+Math.max(check_req,change);\\n        }\\n        else return Math.max(6-s.length(), Math.max(check_req, change));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342184,
                "title": "java-cpp-python-explained-100-0-ms-meme",
                "content": "**UPVOTE PLEASE**\\nThe code is a solution to the \"Strong Password Checker\" problem, which asks for the minimum number of changes needed to make a given password strong. A strong password is defined as one that satisfies the following criteria:\\n\\nHas at least 6 characters and at most 20 characters.\\nContains at least one lowercase letter, at least one uppercase letter, and at least one digit.\\nDoesn\\'t contain three repeating characters in a row.\\nThe code starts by initializing a variable \"missing_type\" to 3, which represents the number of character types (lowercase, uppercase, digit) that are missing from the password. It then checks for the presence of each of these types in the password and subtracts from missing_type accordingly.\\n\\nNext, the code checks for repeating characters in the password using a while loop that iterates through the password. If three characters in a row are found, the length of the repeating sequence is calculated and change is incremented by the number of changes needed to make the sequence valid (i.e. length / 3). If the length is a multiple of 3, one is incremented; if it\\'s one more than a multiple of 3, two is incremented; otherwise, no counter is incremented. The purpose of these counters will become clear later.\\n\\nAfter checking for repeating characters, the code checks the length of the password to determine the appropriate action to take. If the password is less than 6 characters long, the minimum number of changes needed is the maximum of missing_type and 6 - len(s). If the password is between 6 and 20 characters long, the minimum number of changes needed is the maximum of missing_type and change. If the password is longer than 20 characters, some characters must be deleted to make it valid. The code calculates the number of characters to delete (delete) and then subtracts from change the number of sequences of length 3 that can be turned into sequences of length 2 by deleting one character (one), the number of sequences of length 3 that can be turned into sequences of length 1 by deleting two characters (two), and the number of remaining characters that can be turned into sequences of length 1 by deleting three characters (max(delete - one - 2 * two, 0) / 3). Finally, the minimum number of changes needed is delete plus the maximum of missing_type and change.\\n\\nIn summary, the code checks for missing character types and repeating character sequences and then calculates the minimum number of changes needed to make the password strong.\\n\\n<iframe src=\"https://leetcode.com/playground/gH4JSygM/shared\" frameBorder=\"0\" width=\"1080\" height=\"1080\"></iframe>\\n\\nThis code is also a solution to the \"Strong Password Checker\" problem. It uses a different approach than the previous solution.\\n\\nThe code first calculates the number of deletions needed to make the string valid (deleteTarget) and the number of characters that must be added to make the string valid (addTarget). It also initializes variables to keep track of the number of deletions, additions, and replacements needed, as well as whether the string needs an uppercase letter, a lowercase letter, and a digit.\\n\\nIn the first part of the code, the code handles the case where the length of the string is less than or equal to 20. It uses a sliding window approach to check for repeating substrings of length 3. If a repeating substring is found, the code either adds a character to break the repetition (if possible and if the number of characters to add is less than the number of characters needed to make the string valid), or replaces the substring with a different substring (to avoid three repeating characters). The function then returns the maximum of the number of characters to add and the number of replacements needed, plus the number of missing character types.\\n\\nIn the second part of the code, the code handles the case where the length of the string is greater than 20. It first creates a vector of unordered maps to record the lengths and frequencies of repeating substrings with lengths modulo 3 equal to 0, 1, and 2. It uses a loop to iterate through the string and record the frequencies of repeating substrings. It then attempts to delete characters to minimize the number of replacements needed. The code tries to delete characters from substrings with lengths modulo 3 equal to 0, then substrings with lengths modulo 3 equal to 1, and finally substrings with lengths modulo 3 equal to 2. Each deletion decreases the number of replacements needed by 1. The code then calculates the maximum number of deletions that can be made by deleting characters in groups of three. Finally, the function returns the sum of the number of deletions needed and the maximum of the number of replacements needed and the number of missing character types.\\n\\nIn summary, this code calculates the minimum number of changes needed to make the password strong by first checking for missing character types and repeating substrings and then using deletions, additions, and replacements to make the password valid.\\n\\n![image](https://assets.leetcode.com/users/images/9eb02f1a-a5ae-4a60-a6c4-be1a94ed4bb0_1658944388.5158339.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "**UPVOTE PLEASE**\\nThe code is a solution to the \"Strong Password Checker\" problem, which asks for the minimum number of changes needed to make a given password strong. A strong password is defined as one that satisfies the following criteria:\\n\\nHas at least 6 characters and at most 20 characters.\\nContains at least one lowercase letter, at least one uppercase letter, and at least one digit.\\nDoesn\\'t contain three repeating characters in a row.\\nThe code starts by initializing a variable \"missing_type\" to 3, which represents the number of character types (lowercase, uppercase, digit) that are missing from the password. It then checks for the presence of each of these types in the password and subtracts from missing_type accordingly.\\n\\nNext, the code checks for repeating characters in the password using a while loop that iterates through the password. If three characters in a row are found, the length of the repeating sequence is calculated and change is incremented by the number of changes needed to make the sequence valid (i.e. length / 3). If the length is a multiple of 3, one is incremented; if it\\'s one more than a multiple of 3, two is incremented; otherwise, no counter is incremented. The purpose of these counters will become clear later.\\n\\nAfter checking for repeating characters, the code checks the length of the password to determine the appropriate action to take. If the password is less than 6 characters long, the minimum number of changes needed is the maximum of missing_type and 6 - len(s). If the password is between 6 and 20 characters long, the minimum number of changes needed is the maximum of missing_type and change. If the password is longer than 20 characters, some characters must be deleted to make it valid. The code calculates the number of characters to delete (delete) and then subtracts from change the number of sequences of length 3 that can be turned into sequences of length 2 by deleting one character (one), the number of sequences of length 3 that can be turned into sequences of length 1 by deleting two characters (two), and the number of remaining characters that can be turned into sequences of length 1 by deleting three characters (max(delete - one - 2 * two, 0) / 3). Finally, the minimum number of changes needed is delete plus the maximum of missing_type and change.\\n\\nIn summary, the code checks for missing character types and repeating character sequences and then calculates the minimum number of changes needed to make the password strong.\\n\\n<iframe src=\"https://leetcode.com/playground/gH4JSygM/shared\" frameBorder=\"0\" width=\"1080\" height=\"1080\"></iframe>\\n\\nThis code is also a solution to the \"Strong Password Checker\" problem. It uses a different approach than the previous solution.\\n\\nThe code first calculates the number of deletions needed to make the string valid (deleteTarget) and the number of characters that must be added to make the string valid (addTarget). It also initializes variables to keep track of the number of deletions, additions, and replacements needed, as well as whether the string needs an uppercase letter, a lowercase letter, and a digit.\\n\\nIn the first part of the code, the code handles the case where the length of the string is less than or equal to 20. It uses a sliding window approach to check for repeating substrings of length 3. If a repeating substring is found, the code either adds a character to break the repetition (if possible and if the number of characters to add is less than the number of characters needed to make the string valid), or replaces the substring with a different substring (to avoid three repeating characters). The function then returns the maximum of the number of characters to add and the number of replacements needed, plus the number of missing character types.\\n\\nIn the second part of the code, the code handles the case where the length of the string is greater than 20. It first creates a vector of unordered maps to record the lengths and frequencies of repeating substrings with lengths modulo 3 equal to 0, 1, and 2. It uses a loop to iterate through the string and record the frequencies of repeating substrings. It then attempts to delete characters to minimize the number of replacements needed. The code tries to delete characters from substrings with lengths modulo 3 equal to 0, then substrings with lengths modulo 3 equal to 1, and finally substrings with lengths modulo 3 equal to 2. Each deletion decreases the number of replacements needed by 1. The code then calculates the maximum number of deletions that can be made by deleting characters in groups of three. Finally, the function returns the sum of the number of deletions needed and the maximum of the number of replacements needed and the number of missing character types.\\n\\nIn summary, this code calculates the minimum number of changes needed to make the password strong by first checking for missing character types and repeating substrings and then using deletions, additions, and replacements to make the password valid.\\n\\n![image](https://assets.leetcode.com/users/images/9eb02f1a-a5ae-4a60-a6c4-be1a94ed4bb0_1658944388.5158339.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1091379,
                "title": "easy-python-explained-faster-than-99-o-n-time-o-n-space-with",
                "content": "This is one whale of a problem - check out that 14% acceptance rate.\\nRound of applause just for attempting. :)\\n\\nTo understand this problem - we have to break it up into some cases:\\n\\nn = len(password)\\n\\n**Case 1: n  < 6**\\n\\nThis seems like the easy case - we just add numbers until we hit 6, which is minimum valid length.\\nThat leaves out a critical case. \\n\\n*Note: this is the only case which should use adds *\\n\\nSay pswd = \\'aaaa\\'\\n\\nHere we are missing an uppercase as well as a digit, however out previous approach would have just said we need 1 (6-5). So what we actually need is a max(6-n, and the number of character swaps we need)\\n\\nIn this case, we can actually ignore the replacing swaps, because the character swaps would cover that for us anyways - there is a max of 3 in this case, enough to cover all repeating character pswds <= 5 chars.\\n\\n**Case 2: 6 <= n <= 20**\\n\\nSo no adds or deletes in this case, we just need to worry about making sure lower, upper and digit are represented.\\n\\nFirst lets check about the characters. lets call this c_swaps where this is 0 if we have all types of characters present, or 3 if none are present.\\n\\nThen we need to check fr repeats. There are many ways to do this, for this particular problem I recomend this way (makes next case much easier)\\n\\nLets make a list called reps which store the frequencies of characters, grouping them together.\\n\\nSo. \\'aaaaaa\\' -> [6] \\'abcabc\\' -> [1, 1, 1, 1, 1, 1]\\n\\nWe just want to group like characters together and keep only the frequency.\\n\\nOnce we have such a list, we can go through that list and floordiv each value by 3 and then sum the resulting list to figure out how many swaps we need to make sure there are no repeats.\\n\\nLet\\'s call this figure r_swaps.\\n\\nNow, swaps are swaps right, it doesn\\'t really matter why we are swapping, so we return max(c_swaps, r_swaps)\\n\\n**Case 3 n > 20**\\n\\nThe lase case is also the trickiest - and is the only one to include deletes.\\n\\nOn first look, it looks like we should just be able to add the number of deletes to the previous formula.\\n\\nThat is the main point, **BUT** we need to be careful of how we delete - because we should be deleting as efficiently as possible, meaning breaking up as many repeats as we can. \\n\\nFor example if we had 3 deletes and a pswd \\'aaabbbccc\\' (just for concept)\\n\\nWe wouldn\\'t want to delete randomly \\'aaa\\' to get \\'bbbccc\\' because they we still would require 2 swaps,\\nwe should be deleting one \\'a\\', one \\'b\\', and one \\'c\\' to get \\'aabbcc\\' requiring 0 more swaps.\\n\\n**How do we solve this?**\\n\\nWe need to get to a point where all deletes hold the same value (meaning we delete 3 at a time, or as many deleted as we have left).\\n\\nWe also know that we should prioritize situations where 1 delete breaks a repetition and then second priority would be cases where 2 deletes break a repetition.\\n\\nIn this solution, we use a series of for loops (looks complicated but its really not!) Notice we make sure we are > 2 in cases because <= 2 there are no repetitions so that become last priority.\\n\\nWe need to re-use that reps list from the previous case to achieve this.\\n\\nOnce we efficiently delete, calculate c_swaps and r_swaps, and our answer is (n-20) + max(c_swaps, r_swaps)\\n\\n**NOW YOU CAN TAKE A BREATH :)**\\n\\n```\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        \\n        # character check (replace)\\n        containsUpper, containsLower, containsDigit = 0, 0, 0\\n        for c in password:\\n            if not containsUpper and c.isupper():\\n                containsUpper = 1\\n            if not containsLower and c.islower():\\n                containsLower = 1\\n            if not containsDigit and c.isdigit():\\n                containsDigit = 1\\n        \\n        c_swaps = (3 - (containsUpper + containsLower + containsDigit))\\n        \\n        # repeating check (replace)\\n        i, j, reps = 0, 1, list()\\n        while i < n:\\n            while j < n and password[i] == password[j]:\\n                j += 1\\n            reps.append(j-i)\\n            i, j = j, j+1\\n            \\n        # length (addition, subtraction)\\n        if n < 6:\\n            adds = 6 - n\\n            return max(adds, c_swaps)\\n        elif n <= 20:\\n            r_swaps = sum([elem // 3 for elem in reps])\\n            return max(c_swaps, r_swaps)\\n        else:\\n            subs = n - 20\\n            r = len(reps)\\n            for i in range(r):\\n                if subs >= 1 and reps[i] % 3 == 0:\\n                    reps[i] -= 1\\n                    subs -= 1\\n            for i in range(r):\\n                if subs >= 2 and reps[i] % 3 == 1 and reps[i] > 3:\\n                    reps[i] -= 2\\n                    subs -= 2\\n            for i in range(r):\\n                if subs > 0 and reps[i] > 2:\\n                    removed = min(subs, reps[i] - 2)\\n                    reps[i] -= removed\\n                    subs -= removed\\n                    \\n            r_swaps = sum([elem // 3 for elem in reps])\\n            return max(c_swaps, r_swaps) + (n - 20)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        \\n        # character check (replace)\\n        containsUpper, containsLower, containsDigit = 0, 0, 0\\n        for c in password:\\n            if not containsUpper and c.isupper():\\n                containsUpper = 1\\n            if not containsLower and c.islower():\\n                containsLower = 1\\n            if not containsDigit and c.isdigit():\\n                containsDigit = 1\\n        \\n        c_swaps = (3 - (containsUpper + containsLower + containsDigit))\\n        \\n        # repeating check (replace)\\n        i, j, reps = 0, 1, list()\\n        while i < n:\\n            while j < n and password[i] == password[j]:\\n                j += 1\\n            reps.append(j-i)\\n            i, j = j, j+1\\n            \\n        # length (addition, subtraction)\\n        if n < 6:\\n            adds = 6 - n\\n            return max(adds, c_swaps)\\n        elif n <= 20:\\n            r_swaps = sum([elem // 3 for elem in reps])\\n            return max(c_swaps, r_swaps)\\n        else:\\n            subs = n - 20\\n            r = len(reps)\\n            for i in range(r):\\n                if subs >= 1 and reps[i] % 3 == 0:\\n                    reps[i] -= 1\\n                    subs -= 1\\n            for i in range(r):\\n                if subs >= 2 and reps[i] % 3 == 1 and reps[i] > 3:\\n                    reps[i] -= 2\\n                    subs -= 2\\n            for i in range(r):\\n                if subs > 0 and reps[i] > 2:\\n                    removed = min(subs, reps[i] - 2)\\n                    reps[i] -= removed\\n                    subs -= removed\\n                    \\n            r_swaps = sum([elem // 3 for elem in reps])\\n            return max(c_swaps, r_swaps) + (n - 20)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 316565,
                "title": "java-codes-with-comments-to-save-folks-time",
                "content": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int res=0, n = s.length(), lower=1, upper=1, digit=1; \\n        int[] v = new int[n];\\n        for (int i=0; i<n;) {\\n            if (s.charAt(i) >= \\'a\\' && s.charAt(i) <=\\'z\\') lower = 0; //lowercase letter found\\n            if (s.charAt(i) >= \\'A\\' && s.charAt(i) <= \\'Z\\') upper = 0; //uppercase letter found\\n            if (s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\') digit = 0; //digit found\\n            int start = i; \\n            while (i < n && s.charAt(i) == s.charAt(start)) i++; \\n            v[start] = i - start; //number of repetition\\n        }\\n        \\n        int missType = lower + upper + digit; //the type of letter that doesn\\'t exists\\n        /*\\n        if n is smaller than 6, we have to insert the diff (6-n)\\n        if diff is smaller than 3 (the # of letter types), we need to insert missType\\n        e.g. aaaaa, we must add uppercase and digit anyway, even if diff=1\\n        */\\n        if (n < 6) {\\n            res = Math.max(missType, 6-n); \\n        } else {\\n            //if number is greater than 20 \\n            int over = Math.max(n-20, 0), replace = 0; \\n            //we will need to remove `over` characters anyway\\n            res += over; \\n            /* \\n            We know that for (3m+2) letters, we only need to replace m letters \\n            Remove 1 or 2 letters to convert v[start] in the form of 3m+2\\n            where m is an integer.\\n            e.g. \\n            aaaaaaaaabbbbbbbb (9 a\\'s and 8 b\\'s), remove 1 a to make 8 = 3m+2, where m = 2\\n            */\\n            for (int i=0; i<n && over > 0; i++) {\\n                if (v[i] < 3) continue; \\n                if (v[i] % 3 == 0) {  //e.g. 9 a\\'s, need to remove 1\\n                    v[i] -= 1; \\n                    over -= 1; //already removed one; \\n                }\\n            }\\n            \\n            for (int i=0; i<n && over > 0; i++) {\\n                if (v[i] < 3) continue;  \\n                if (v[i] % 3 == 1) {  //e.g. 7 a\\'s, need to remove 2 to become 3*1+2=5\\n                    v[i] -= Math.min(2, over);\\n                    over -= 2;\\n                }\\n            }\\n            \\n            // for (int k = 1; k < 3; k++) {\\n            //     for (int i = 0; i < n && over > 0; i++) {\\n            //         if (v[i] < 3 || v[i] % 3 != (k - 1)) continue;\\n            //         v[i] -= Math.min(over, k);\\n            //         over -= k;\\n            //     }\\n            // }\\n            \\n            //over is the remaining letters that need to be removed\\n            //if removal can fix the repetition issue, we don\\'t need to replace\\n            for (int i=0; i<n; i++) {\\n                if (v[i] >= 3 && over > 0) {\\n                    int needToRemove = v[i] - 2; //3m \\n                    v[i] -= over; //do not need to remove v[i] if <=2\\n                    over -= needToRemove;\\n                }\\n                if (v[i] >= 3) replace += v[i]/3; //at least replace m \\n            }\\n            //System.out.println(missType + \" \" + replace);\\n            res += Math.max(missType, replace); \\n        }\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int res=0, n = s.length(), lower=1, upper=1, digit=1; \\n        int[] v = new int[n];\\n        for (int i=0; i<n;) {\\n            if (s.charAt(i) >= \\'a\\' && s.charAt(i) <=\\'z\\') lower = 0; //lowercase letter found\\n            if (s.charAt(i) >= \\'A\\' && s.charAt(i) <= \\'Z\\') upper = 0; //uppercase letter found\\n            if (s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\') digit = 0; //digit found\\n            int start = i; \\n            while (i < n && s.charAt(i) == s.charAt(start)) i++; \\n            v[start] = i - start; //number of repetition\\n        }\\n        \\n        int missType = lower + upper + digit; //the type of letter that doesn\\'t exists\\n        /*\\n        if n is smaller than 6, we have to insert the diff (6-n)\\n        if diff is smaller than 3 (the # of letter types), we need to insert missType\\n        e.g. aaaaa, we must add uppercase and digit anyway, even if diff=1\\n        */\\n        if (n < 6) {\\n            res = Math.max(missType, 6-n); \\n        } else {\\n            //if number is greater than 20 \\n            int over = Math.max(n-20, 0), replace = 0; \\n            //we will need to remove `over` characters anyway\\n            res += over; \\n            /* \\n            We know that for (3m+2) letters, we only need to replace m letters \\n            Remove 1 or 2 letters to convert v[start] in the form of 3m+2\\n            where m is an integer.\\n            e.g. \\n            aaaaaaaaabbbbbbbb (9 a\\'s and 8 b\\'s), remove 1 a to make 8 = 3m+2, where m = 2\\n            */\\n            for (int i=0; i<n && over > 0; i++) {\\n                if (v[i] < 3) continue; \\n                if (v[i] % 3 == 0) {  //e.g. 9 a\\'s, need to remove 1\\n                    v[i] -= 1; \\n                    over -= 1; //already removed one; \\n                }\\n            }\\n            \\n            for (int i=0; i<n && over > 0; i++) {\\n                if (v[i] < 3) continue;  \\n                if (v[i] % 3 == 1) {  //e.g. 7 a\\'s, need to remove 2 to become 3*1+2=5\\n                    v[i] -= Math.min(2, over);\\n                    over -= 2;\\n                }\\n            }\\n            \\n            // for (int k = 1; k < 3; k++) {\\n            //     for (int i = 0; i < n && over > 0; i++) {\\n            //         if (v[i] < 3 || v[i] % 3 != (k - 1)) continue;\\n            //         v[i] -= Math.min(over, k);\\n            //         over -= k;\\n            //     }\\n            // }\\n            \\n            //over is the remaining letters that need to be removed\\n            //if removal can fix the repetition issue, we don\\'t need to replace\\n            for (int i=0; i<n; i++) {\\n                if (v[i] >= 3 && over > 0) {\\n                    int needToRemove = v[i] - 2; //3m \\n                    v[i] -= over; //do not need to remove v[i] if <=2\\n                    over -= needToRemove;\\n                }\\n                if (v[i] >= 3) replace += v[i]/3; //at least replace m \\n            }\\n            //System.out.println(missType + \" \" + replace);\\n            res += Math.max(missType, replace); \\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660649,
                "title": "golang-0ms-o-n-single-run-o-1-space",
                "content": "Spend 3 hours of life, so upvote.\\n\\n```golang\\nfunc strongPasswordChecker(password string) int {\\n\\tn := len(password)\\n\\n\\tmissingLC, missingUC, missingD := 1, 1, 1\\n\\tmustChanged, deleteOne, deleteTwo := 0, 0, 0\\n\\tfor idx := 0; idx < n; idx++ {\\n\\t\\tchar := password[idx]\\n\\t\\tif 97 <= char && char <= 122 { // \\'a\\' - \\'z\\'\\n\\t\\t\\tmissingLC = 0\\n\\t\\t}\\n\\t\\tif 65 <= char && char <= 90 { // \\'A\\' - \\'Z\\'\\n\\t\\t\\tmissingUC = 0\\n\\t\\t}\\n\\t\\tif 48 <= char && char <= 57 { // \\'0\\' - \\'9\\'\\n\\t\\t\\tmissingD = 0\\n\\t\\t}\\n\\n\\t\\tif idx > 1 && password[idx] == password[idx-1] && password[idx] == password[idx-2] {\\n\\t\\t\\tseqLen := 3\\n\\t\\t\\tfor idx < n-1 && password[idx+1] == password[idx] {\\n\\t\\t\\t\\tseqLen++\\n\\t\\t\\t\\tidx++\\n\\t\\t\\t}\\n\\n\\t\\t\\tmustChanged += seqLen / 3\\n\\t\\t\\tif seqLen%3 == 0 { // \"aaa\" => \"aa\"\\n\\t\\t\\t\\tdeleteOne++\\n\\t\\t\\t} else if seqLen%3 == 1 { // \"aaaa\" => \"aa\"\\n\\t\\t\\t\\tdeleteTwo++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tmissingTotal := missingLC + missingUC + missingD\\n\\n\\tif n < 6 {\\n\\t\\treturn max420(missingTotal, 6-n)\\n\\t} else if n <= 20 {\\n\\t\\treturn max420(missingTotal, mustChanged)\\n\\t} else {\\n\\t\\tmustDeleted := n - 20\\n\\n\\t\\tmustChanged -= min420(mustDeleted, deleteOne)\\n\\t\\tmustChanged -= min420(max420(mustDeleted-deleteOne, 0), deleteTwo*2) / 2\\n\\t\\tmustChanged -= max420(mustDeleted-deleteOne-2*deleteTwo, 0) / 3\\n\\n\\t\\treturn mustDeleted + max420(missingTotal, mustChanged)\\n\\t}\\n}\\n\\nfunc max420(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n\\nfunc min420(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```\\n\\n![ac9176bf-ce84-48a7-ac3e-74b0ba735101_1677453394.161722\\\\[1\\\\].webp](https://assets.leetcode.com/users/images/a6d32713-5bfa-44ca-8a6b-7b1a68205785_1677672353.319509.webp)\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc strongPasswordChecker(password string) int {\\n\\tn := len(password)\\n\\n\\tmissingLC, missingUC, missingD := 1, 1, 1\\n\\tmustChanged, deleteOne, deleteTwo := 0, 0, 0\\n\\tfor idx := 0; idx < n; idx++ {\\n\\t\\tchar := password[idx]\\n\\t\\tif 97 <= char && char <= 122 { // \\'a\\' - \\'z\\'\\n\\t\\t\\tmissingLC = 0\\n\\t\\t}\\n\\t\\tif 65 <= char && char <= 90 { // \\'A\\' - \\'Z\\'\\n\\t\\t\\tmissingUC = 0\\n\\t\\t}\\n\\t\\tif 48 <= char && char <= 57 { // \\'0\\' - \\'9\\'\\n\\t\\t\\tmissingD = 0\\n\\t\\t}\\n\\n\\t\\tif idx > 1 && password[idx] == password[idx-1] && password[idx] == password[idx-2] {\\n\\t\\t\\tseqLen := 3\\n\\t\\t\\tfor idx < n-1 && password[idx+1] == password[idx] {\\n\\t\\t\\t\\tseqLen++\\n\\t\\t\\t\\tidx++\\n\\t\\t\\t}\\n\\n\\t\\t\\tmustChanged += seqLen / 3\\n\\t\\t\\tif seqLen%3 == 0 { // \"aaa\" => \"aa\"\\n\\t\\t\\t\\tdeleteOne++\\n\\t\\t\\t} else if seqLen%3 == 1 { // \"aaaa\" => \"aa\"\\n\\t\\t\\t\\tdeleteTwo++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tmissingTotal := missingLC + missingUC + missingD\\n\\n\\tif n < 6 {\\n\\t\\treturn max420(missingTotal, 6-n)\\n\\t} else if n <= 20 {\\n\\t\\treturn max420(missingTotal, mustChanged)\\n\\t} else {\\n\\t\\tmustDeleted := n - 20\\n\\n\\t\\tmustChanged -= min420(mustDeleted, deleteOne)\\n\\t\\tmustChanged -= min420(max420(mustDeleted-deleteOne, 0), deleteTwo*2) / 2\\n\\t\\tmustChanged -= max420(mustDeleted-deleteOne-2*deleteTwo, 0) / 3\\n\\n\\t\\treturn mustDeleted + max420(missingTotal, mustChanged)\\n\\t}\\n}\\n\\nfunc max420(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n\\nfunc min420(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2245802,
                "title": "c-java-c-c-python-easy-to-understand-solutions-commented-code",
                "content": "The basic principle is straightforward: if we want to make MINIMUM changes to turn the input string into a strong password, each change made should fix as many problems as possible.\\n\\nLet\\'s divide the problem into three sub-problems\\n1. The password has less than 6 characters.\\n2. The length of password is between 6 and 20 characters, both included.\\n3. And the string length is greater than 20 characters.\\n\\nNow a strong password should have at least one [**lowercase**](https://docs.microsoft.com/en-us/dotnet/api/system.char.islower?view=net-6.0) letter, at least one [**uppercase**](https://docs.microsoft.com/en-us/dotnet/api/system.char.isupper?view=net-6.0) letter, and at least one [**digit**](https://docs.microsoft.com/en-us/dotnet/api/system.char.isdigit?view=net-6.0). The methoid \\'GetRequiredChar\\' checks for the three conditions.\\n\\nThe first two cases are easy. When the string length is greater than 20 characters, we can optimize the edits of triplets by considering three cases:\\n\\n* When the sequences of the same character are evenly divisible by 3\\n* When they have one extra character\\n* and when they are one character off from being evenly divisible by 3\\n\\nlength%3 == 0 should have higher priority \\nlength%3 == 1 second\\nlength%3 == 2 lowest\\n\\nFor any repeating sequences with length % 3 == 0, we can reduce one replacement by deleting one character. For any repeating sequences with length % 3 == 1, we can reduce one replacement by deleting two character. For the remaining sequences, we can reduce every replacement by deleting three character.\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bitset<3> requirements{111}; \\n        list<int> repeats;\\n        auto it = s.begin();\\n        auto it2 = s.end();\\n        while (it != s.end()) {\\n            if (*it != *it2) {\\n                if (requirements.test(0) && islower(*it))\\n                    requirements.reset(0);\\n                if (requirements.test(1) && isupper(*it))\\n                    requirements.reset(1);\\n                if (requirements.test(2) && isdigit(*it))\\n                    requirements.reset(2);\\n            } else {\\n                while (it != s.end() && *it == *it2)\\n                    ++it;\\n                if (distance(it2, it) != 2)\\n                    repeats.push_back(distance(it2, it));\\n                if (it != s.end())\\n                    continue;\\n                else\\n                    break;\\n            }\\n            it2 = it;\\n            ++it;\\n        }\\n        repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n        int ans{0}, len{static_cast<int>(s.size())};\\n        while (len > 20) {\\n            if (!repeats.empty()) {\\n                if (repeats.front() == 3) {\\n                    repeats.pop_front();\\n                }\\n                else {\\n                    --repeats.front();\\n                    repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n                }\\n                ++ans;\\n                --len;\\n            }\\n            else {\\n                ans += len - 20;\\n                len = 20;\\n            }\\n        }\\n        int rep_ins{0};\\n        while (!repeats.empty()) {\\n            rep_ins += repeats.front() / 3;\\n            repeats.pop_front();\\n        }\\n        if ((len + rep_ins) < 6) {\\n            rep_ins += 6 - len - rep_ins;\\n        }\\n        ans += max(static_cast<int>(requirements.count()), rep_ins);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int res = 0, a = 1, A = 1, d = 1;\\n        char[] carr = s.toCharArray();\\n        int[] arr = new int[carr.length];\\n        for (int i = 0; i < arr.length;) {\\n            if (Character.isLowerCase(carr[i])) a = 0;\\n            if (Character.isUpperCase(carr[i])) A = 0;\\n            if (Character.isDigit(carr[i])) d = 0;\\n            int j = i;\\n            while (i < carr.length && carr[i] == carr[j]) i++;\\n            arr[j] = i - j;\\n        }\\n\\n        int total_missing = (a + A + d);\\n        if (arr.length < 6) {\\n            res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n        } else {\\n            int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n            res += over_len;\\n            for (int k = 1; k < 3; k++) {\\n                for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                    if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                    arr[i] -= Math.min(over_len, k);\\n                    over_len -= k;\\n                }\\n            }\\n            for (int i = 0; i < arr.length; i++) {\\n                if (arr[i] >= 3 && over_len > 0) {\\n                    int need = arr[i] - 2;\\n                    arr[i] -= over_len;\\n                    over_len -= need;\\n                }\\n                if (arr[i] >= 3) left_over += arr[i] / 3;\\n            }\\n            res += Math.max(total_missing, left_over);\\n        }\\n        return res;\\n    }\\n}\\n```\\n```csharp []\\nclass Solution {\\n    public int StrongPasswordChecker(string s) {\\n        int charSum = GetRequiredChar(s);\\n        if (s.Length < 6) return Math.Max(charSum, 6 - s.Length);\\n            int replace = 0, ones = 0, twos = 0; \\n            for (int i = 0; i < s.Length;) {\\n            int len = 1;\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3) {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) ones += 1;\\n                    if (len % 3 == 1) twos += 2;\\n                }\\n                i += len;\\n            }\\n            if (s.Length <= 20) return Math.Max(charSum, replace);\\n            int deleteCount = s.Length - 20;\\n            replace -= Math.Min(deleteCount, ones);\\n            replace -= Math.Min(Math.Max(deleteCount - ones, 0), twos) / 2;\\n            replace -= Math.Max(deleteCount - ones - twos, 0) / 3;\\n        return deleteCount + Math.Max(charSum, replace);\\n        }\\n        int GetRequiredChar(string s) {\\n            int lowerCase = 1, upperCase = 1, digit = 1;\\n            foreach (var c in s) {\\n                if (char.IsLower(c)) lowerCase = 0;\\n                else if (char.IsUpper(c)) upperCase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n            return lowerCase + upperCase + digit;\\n    }    \\n}\\n```\\n```C []\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int offences1 = 0;\\n    int offences2 = 0;\\n    int offences = 0;\\n    int r = 0;\\n    char prev = \\'\\\\n\\';\\n    char curr;\\n    int repC = 1;\\n    int delrep[3] = {0};\\n    int maxrep = 0;\\n    for(int i = 0; i < length; i++) {\\n        curr = password[i];\\n        if(curr == prev) {\\n            repC++;\\n        } else {\\n            if(repC >= 3) {\\n                delrep[repC%3]++;\\n            }\\n            repC = 1;\\n            prev = curr;\\n        }\\n        if(repC % 3 == 0) {\\n            r++;\\n        }\\n        if(repC > 3 && repC % 3 == 1) {\\n            delrep[2]++;\\n        }\\n    }\\n    if(repC >= 3) {\\n        delrep[repC%3]++;\\n    }\\n    int v = 0;\\n    int vo = 0;\\n    int lc = 0;\\n    int uc = 0;\\n    int dc = 0;\\n    for(int i = 0; i < length; i++) {\\n        if(lc == 0 && islower(password[i]) != 0) {\\n            v++;\\n            lc = 1;\\n        }\\n        if(uc == 0 && isupper(password[i]) != 0) {\\n            v++;\\n            uc = 1;\\n        }\\n        if(dc == 0 && isdigit(password[i]) != 0) {\\n            v++;\\n            dc = 1;\\n        }\\n    }\\n    if(v < 3) {\\n        offences2 += 3 - v;\\n        vo += 3 - v;\\n        if(length == 5 && v == 1) {\\n            offences1++;\\n        }\\n    }\\n    if(length < 6 || length > 20) {\\n        int delete = length - 20;\\n        if(delrep[0] != 0) {\\n            delrep[0] = delrep[0] < delete ? delrep[0] : delete;\\n        }\\n        if(delrep[1] != 0) {\\n            delrep[1] = delrep[1] < (delete - delrep[0])/2 ? delrep[1] : (delete - delrep[0])/2;\\n        }\\n        if(delrep[2] != 0) {\\n            delrep[2] = delrep[2] < ((delete - delrep[0]) - delrep[1]*2)/3 ? delrep[2] : ((delete - delrep[0]) - delrep[1]*2)/3;\\n        }\\n        r-= delrep[0] + delrep[1] + delrep[2];\\n        int x = r > offences2 ?  r : offences2;\\n        return length < 6 ? 6 - length + offences1 : delete + x; \\n    }    \\n    return vo < r ? r : vo;\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n            return delete + max(missing_type, change)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C#",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bitset<3> requirements{111}; \\n        list<int> repeats;\\n        auto it = s.begin();\\n        auto it2 = s.end();\\n        while (it != s.end()) {\\n            if (*it != *it2) {\\n                if (requirements.test(0) && islower(*it))\\n                    requirements.reset(0);\\n                if (requirements.test(1) && isupper(*it))\\n                    requirements.reset(1);\\n                if (requirements.test(2) && isdigit(*it))\\n                    requirements.reset(2);\\n            } else {\\n                while (it != s.end() && *it == *it2)\\n                    ++it;\\n                if (distance(it2, it) != 2)\\n                    repeats.push_back(distance(it2, it));\\n                if (it != s.end())\\n                    continue;\\n                else\\n                    break;\\n            }\\n            it2 = it;\\n            ++it;\\n        }\\n        repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n        int ans{0}, len{static_cast<int>(s.size())};\\n        while (len > 20) {\\n            if (!repeats.empty()) {\\n                if (repeats.front() == 3) {\\n                    repeats.pop_front();\\n                }\\n                else {\\n                    --repeats.front();\\n                    repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n                }\\n                ++ans;\\n                --len;\\n            }\\n            else {\\n                ans += len - 20;\\n                len = 20;\\n            }\\n        }\\n        int rep_ins{0};\\n        while (!repeats.empty()) {\\n            rep_ins += repeats.front() / 3;\\n            repeats.pop_front();\\n        }\\n        if ((len + rep_ins) < 6) {\\n            rep_ins += 6 - len - rep_ins;\\n        }\\n        ans += max(static_cast<int>(requirements.count()), rep_ins);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int res = 0, a = 1, A = 1, d = 1;\\n        char[] carr = s.toCharArray();\\n        int[] arr = new int[carr.length];\\n        for (int i = 0; i < arr.length;) {\\n            if (Character.isLowerCase(carr[i])) a = 0;\\n            if (Character.isUpperCase(carr[i])) A = 0;\\n            if (Character.isDigit(carr[i])) d = 0;\\n            int j = i;\\n            while (i < carr.length && carr[i] == carr[j]) i++;\\n            arr[j] = i - j;\\n        }\\n\\n        int total_missing = (a + A + d);\\n        if (arr.length < 6) {\\n            res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n        } else {\\n            int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n            res += over_len;\\n            for (int k = 1; k < 3; k++) {\\n                for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                    if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                    arr[i] -= Math.min(over_len, k);\\n                    over_len -= k;\\n                }\\n            }\\n            for (int i = 0; i < arr.length; i++) {\\n                if (arr[i] >= 3 && over_len > 0) {\\n                    int need = arr[i] - 2;\\n                    arr[i] -= over_len;\\n                    over_len -= need;\\n                }\\n                if (arr[i] >= 3) left_over += arr[i] / 3;\\n            }\\n            res += Math.max(total_missing, left_over);\\n        }\\n        return res;\\n    }\\n}\\n```\n```csharp []\\nclass Solution {\\n    public int StrongPasswordChecker(string s) {\\n        int charSum = GetRequiredChar(s);\\n        if (s.Length < 6) return Math.Max(charSum, 6 - s.Length);\\n            int replace = 0, ones = 0, twos = 0; \\n            for (int i = 0; i < s.Length;) {\\n            int len = 1;\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3) {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) ones += 1;\\n                    if (len % 3 == 1) twos += 2;\\n                }\\n                i += len;\\n            }\\n            if (s.Length <= 20) return Math.Max(charSum, replace);\\n            int deleteCount = s.Length - 20;\\n            replace -= Math.Min(deleteCount, ones);\\n            replace -= Math.Min(Math.Max(deleteCount - ones, 0), twos) / 2;\\n            replace -= Math.Max(deleteCount - ones - twos, 0) / 3;\\n        return deleteCount + Math.Max(charSum, replace);\\n        }\\n        int GetRequiredChar(string s) {\\n            int lowerCase = 1, upperCase = 1, digit = 1;\\n            foreach (var c in s) {\\n                if (char.IsLower(c)) lowerCase = 0;\\n                else if (char.IsUpper(c)) upperCase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n            return lowerCase + upperCase + digit;\\n    }    \\n}\\n```\n```C []\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int offences1 = 0;\\n    int offences2 = 0;\\n    int offences = 0;\\n    int r = 0;\\n    char prev = \\'\\\\n\\';\\n    char curr;\\n    int repC = 1;\\n    int delrep[3] = {0};\\n    int maxrep = 0;\\n    for(int i = 0; i < length; i++) {\\n        curr = password[i];\\n        if(curr == prev) {\\n            repC++;\\n        } else {\\n            if(repC >= 3) {\\n                delrep[repC%3]++;\\n            }\\n            repC = 1;\\n            prev = curr;\\n        }\\n        if(repC % 3 == 0) {\\n            r++;\\n        }\\n        if(repC > 3 && repC % 3 == 1) {\\n            delrep[2]++;\\n        }\\n    }\\n    if(repC >= 3) {\\n        delrep[repC%3]++;\\n    }\\n    int v = 0;\\n    int vo = 0;\\n    int lc = 0;\\n    int uc = 0;\\n    int dc = 0;\\n    for(int i = 0; i < length; i++) {\\n        if(lc == 0 && islower(password[i]) != 0) {\\n            v++;\\n            lc = 1;\\n        }\\n        if(uc == 0 && isupper(password[i]) != 0) {\\n            v++;\\n            uc = 1;\\n        }\\n        if(dc == 0 && isdigit(password[i]) != 0) {\\n            v++;\\n            dc = 1;\\n        }\\n    }\\n    if(v < 3) {\\n        offences2 += 3 - v;\\n        vo += 3 - v;\\n        if(length == 5 && v == 1) {\\n            offences1++;\\n        }\\n    }\\n    if(length < 6 || length > 20) {\\n        int delete = length - 20;\\n        if(delrep[0] != 0) {\\n            delrep[0] = delrep[0] < delete ? delrep[0] : delete;\\n        }\\n        if(delrep[1] != 0) {\\n            delrep[1] = delrep[1] < (delete - delrep[0])/2 ? delrep[1] : (delete - delrep[0])/2;\\n        }\\n        if(delrep[2] != 0) {\\n            delrep[2] = delrep[2] < ((delete - delrep[0]) - delrep[1]*2)/3 ? delrep[2] : ((delete - delrep[0]) - delrep[1]*2)/3;\\n        }\\n        r-= delrep[0] + delrep[1] + delrep[2];\\n        int x = r > offences2 ?  r : offences2;\\n        return length < 6 ? 6 - length + offences1 : delete + x; \\n    }    \\n    return vo < r ? r : vo;\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n            return delete + max(missing_type, change)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445576,
                "title": "python3-solution-with-comments",
                "content": "Ty to @hwei022 for correcting a corner case (I had erroneously believed that all charaters have to be characters and numbers, so the password \\'****\\' was giving the wrong value) which has been changed. \\n\\n```\\nclass Solution:\\n    \\n    #  takes in the string, outputs a list of runs of \\n    #  a single character of 3 or more\\n    #  ex: \"aaaaabbbbbbccdeeee\" -> [5,6,4]\\n    def lengthCheck(self, s:str) -> List[int]:\\n        l = []\\n        curr = 1\\n        for i in range(1,len(s)):\\n            if (s[i] is s[i-1]): curr += 1\\n            else: \\n                if (curr > 2): l.append(curr)\\n                curr = 1\\n        if (curr > 2): l.append(curr)\\n        return l\\n    \\n    # return 1 if we are missing an uppercase\\n    def uppercaseCheck(self, s:str)-> int:\\n        if (re.search(\"[A-Z]\", s) is None): return 1\\n        return 0\\n    \\n    # return 1 if we are missing a lowercase\\n    def lowercaseCheck(self, s:str)-> int:\\n        if (re.search(\"[a-z]\", s) is None): return 1\\n        return 0\\n    \\n    # return 1 if we are missing a number\\n    def numberCheck(self, s:str)-> int:\\n        if (re.search(\"[0-9]\", s) is None): return 1\\n        return 0\\n        \\n    \\n    def strongPasswordChecker(self, s: str) -> int:\\n        leng = len(s)\\n        \\n        # If the password is 3 or less, then there is always a way\\n        # to just add characters until it is length 6 and make a \\n        # strong password\\n        if (leng < 4): return 6-leng\\n        \\n        \\n        if (leng == 4): \\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 3): return 3\\n            return 2\\n        \\n        \\n        # For length 5, we only need to add 2 characters \\n        # if we are missing two types\\n        # 3 characters if missing all types\\n        if (leng == 5): \\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 3): return 3\\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 2): return 2\\n            return 1\\n        \\n        lis = self.lengthCheck(s)\\n        \\n        # If the length is acceptable, then all the changes can be replacements.\\n        # We need to make replacements to eliminate runs\\n        # ex: aaaaaaaa -> aaxaaxaa\\n        # hence the quotient by 3 rounded down.\\n        # If that number is lower than the missing types\\n        # then take the missing types\\n        if (leng <= 20):\\n            return max(sum(map(lambda x: int(x/3),lis)), self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s))\\n        \\n        # for too long passwords... \\n        if (leng > 20):\\n            # we first count how many deletions we need\\n            numdel = leng-20\\n            \\n            # the amount of replacements due to runs we would need\\n            # is reduced by the deletions\\n            runreplace = sum(map(lambda x: int(x/3),lis))\\n            \\n            # order the runs by how many deletions needed \\n            # to eliminate one replacement\\n            # ex. aaa needs 1 deletion, aaaa needs 2, aaaaa needs 3\\n            l = list(map(lambda x: (x % 3)+1,lis))\\n            l.sort()\\n            \\n            # variable to keep track of how many deletions are left\\n            rem = numdel\\n            \\n            # first the cheap ones:\\n            # aaa -> aa is one deletion to save one replacement\\n            for i in range(0,len(l)):\\n                if (rem >= l[i]):\\n                    rem -= l[i]\\n                    runreplace -= 1\\n                    \\n            # after the cheap ones, take the most expensive ones\\n            # ex aaaaa -> aa saves 1 replacement, aaaaaaaa -> aa saves 2 replacements.\\n            # This calculation might make runreplace negative\\n            runreplace -= int(rem / 3)\\n            \\n            # if we need more replacements due \\n            # to the checks (or runreplace is negative)\\n            # make the number of replacements correct\\n            if (runreplace < self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s)): runreplace = self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s)\\n                \\n            # total changes\\n            return numdel + runreplace\\n        return 0\\n",
                "solutionTags": [],
                "code": "Ty to @hwei022 for correcting a corner case (I had erroneously believed that all charaters have to be characters and numbers, so the password \\'****\\' was giving the wrong value) which has been changed. \\n\\n```\\nclass Solution:\\n    \\n    #  takes in the string, outputs a list of runs of \\n    #  a single character of 3 or more\\n    #  ex: \"aaaaabbbbbbccdeeee\" -> [5,6,4]\\n    def lengthCheck(self, s:str) -> List[int]:\\n        l = []\\n        curr = 1\\n        for i in range(1,len(s)):\\n            if (s[i] is s[i-1]): curr += 1\\n            else: \\n                if (curr > 2): l.append(curr)\\n                curr = 1\\n        if (curr > 2): l.append(curr)\\n        return l\\n    \\n    # return 1 if we are missing an uppercase\\n    def uppercaseCheck(self, s:str)-> int:\\n        if (re.search(\"[A-Z]\", s) is None): return 1\\n        return 0\\n    \\n    # return 1 if we are missing a lowercase\\n    def lowercaseCheck(self, s:str)-> int:\\n        if (re.search(\"[a-z]\", s) is None): return 1\\n        return 0\\n    \\n    # return 1 if we are missing a number\\n    def numberCheck(self, s:str)-> int:\\n        if (re.search(\"[0-9]\", s) is None): return 1\\n        return 0\\n        \\n    \\n    def strongPasswordChecker(self, s: str) -> int:\\n        leng = len(s)\\n        \\n        # If the password is 3 or less, then there is always a way\\n        # to just add characters until it is length 6 and make a \\n        # strong password\\n        if (leng < 4): return 6-leng\\n        \\n        \\n        if (leng == 4): \\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 3): return 3\\n            return 2\\n        \\n        \\n        # For length 5, we only need to add 2 characters \\n        # if we are missing two types\\n        # 3 characters if missing all types\\n        if (leng == 5): \\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 3): return 3\\n            if (self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s) == 2): return 2\\n            return 1\\n        \\n        lis = self.lengthCheck(s)\\n        \\n        # If the length is acceptable, then all the changes can be replacements.\\n        # We need to make replacements to eliminate runs\\n        # ex: aaaaaaaa -> aaxaaxaa\\n        # hence the quotient by 3 rounded down.\\n        # If that number is lower than the missing types\\n        # then take the missing types\\n        if (leng <= 20):\\n            return max(sum(map(lambda x: int(x/3),lis)), self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s))\\n        \\n        # for too long passwords... \\n        if (leng > 20):\\n            # we first count how many deletions we need\\n            numdel = leng-20\\n            \\n            # the amount of replacements due to runs we would need\\n            # is reduced by the deletions\\n            runreplace = sum(map(lambda x: int(x/3),lis))\\n            \\n            # order the runs by how many deletions needed \\n            # to eliminate one replacement\\n            # ex. aaa needs 1 deletion, aaaa needs 2, aaaaa needs 3\\n            l = list(map(lambda x: (x % 3)+1,lis))\\n            l.sort()\\n            \\n            # variable to keep track of how many deletions are left\\n            rem = numdel\\n            \\n            # first the cheap ones:\\n            # aaa -> aa is one deletion to save one replacement\\n            for i in range(0,len(l)):\\n                if (rem >= l[i]):\\n                    rem -= l[i]\\n                    runreplace -= 1\\n                    \\n            # after the cheap ones, take the most expensive ones\\n            # ex aaaaa -> aa saves 1 replacement, aaaaaaaa -> aa saves 2 replacements.\\n            # This calculation might make runreplace negative\\n            runreplace -= int(rem / 3)\\n            \\n            # if we need more replacements due \\n            # to the checks (or runreplace is negative)\\n            # make the number of replacements correct\\n            if (runreplace < self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s)): runreplace = self.uppercaseCheck(s) + self.lowercaseCheck(s) + self.numberCheck(s)\\n                \\n            # total changes\\n            return numdel + runreplace\\n        return 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 91004,
                "title": "java-o-n-greedy-solution-with-super-clear-explanation",
                "content": "We discuss in three cases:\\n1. Case (n=s.length)<6: return 6-n>nMiss?6-n:nMiss, where nMiss = hasLower?0:1+hasUpper?0:1+hasDigit?0:1;  (just check every possible n, using appropriate insertions)\\n\\n2. Case n>=6&&n<=20: Replacement is the best choice! (Replacing every third by another char is the best change.) return max(nMiss, nRep=sum{ni/3}), where ni is the length of a substring with repeating characters (SSRC).\\n\\n3. Case n>20: It is for sure that (n-20) deletions must be applied no matter what, and for sure that no insertions are needed (since 1 insert needs 1 delete, which is equivalent to 1 replace+1 delete or even 1 delete). Hence we greedily apply deletions first.\\n\\nGreedy strategies for applying deletions - clearly the best choice is to apply on a SSRC to possibly reduce nRep (when the length of s becomes 20). Immediately, we have the best of the best choice is to delete a char of a SSRC of length 3k (recalling how nRep is calculated as in case 2), and that length becomes 3(k-1)+2. Hence if possible, we apply 1 del per each such SSRC.\\n\\nIf still delete-able, the second best is to apply del on a SSRC of length 3k+1, (since nRep is reduced by 1 per 2 del, but if applying on 3k+2, nRep is reduced by 1 per 3 del). Notice that applying 1 del on such a SSRC makes its length 3k, and immediately this has the highest priority for the next possible deletion. Hence if possible, we apply 2 del per each such SSRC (to make its length become 3(k-1)+2).\\n\\nIf still delete-able, we then apply del on each (updated) SSRC until its length =2. Notice that nRep is reduced by 1 per 3 del since each has length 3k+2.\\n\\nIf still delete-able, return n-20+nMiss, (n-20 del, nMiss many rep).\\n\\nOtherwise, return n-20+max(updated_nRep, nMiss).\\n\\n\\n```\\npublic int strongPasswordChecker(String s) { \\n\\tint n = s.length();\\n\\tboolean hasLower = false, hasUpper = false, hasDigit = false;\\n\\tint nRep = 0, sum = 0; // sum=sum{length>=3 of a SSRC}\\n\\tint[] m = new int[3]; // # of SSRC of length 3k, 3k+1, 3k+2\\n\\n\\tint i = 0, j, t;\\n\\tchar c;\\n\\twhile (i < n) {\\n\\t\\tc = s.charAt(i);\\n\\n\\t\\thasLower |= (c >= 'a' && c <= 'z');\\n\\t\\thasUpper |= (c >= 'A' && c <= 'Z');\\n\\t\\thasDigit |= (c >= '0' && c <= '9');\\n\\n\\t\\tj = i + 1;\\n\\t\\twhile (j < n && s.charAt(j) == c)\\n\\t\\t\\tj++;\\n\\n\\t\\tt = j - i;\\n\\t\\tif (t >= 3) {\\n\\t\\t\\tnRep += t / 3;\\n\\t\\t\\tsum += t;\\n\\t\\t\\tm[t % 3]++;\\n\\t\\t}\\n\\t\\ti = j;\\n\\t}\\n\\n\\tint nMiss = (hasLower ? 0 : 1) + (hasUpper ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n\\tif (n < 6) \\n\\t\\treturn (6 - n) > nMiss ? (6 - n) : nMiss;\\n\\n\\tif (n <= 20)\\n\\t\\treturn Math.max(nRep, nMiss);\\n\\n\\t// n > 20\\n\\tint nDel = n - 20;\\n\\tif (nDel <= m[0])\\n\\t\\treturn nDel + Math.max(nRep - nDel, nMiss);\\n\\n\\tint rNDel = nDel - m[0];\\n\\tnRep -= m[0];\\n\\tif (rNDel <= 2 * m[1])\\n\\t\\treturn nDel + Math.max(nRep - rNDel / 2, nMiss);\\n\\n\\trNDel -= 2 * m[1];\\n\\tnRep -= m[1];\\n\\tif (nDel <= sum - 2 * (m[0] + m[1] + m[2]))\\n\\t\\t/**\\n\\t\\t * This condition is equivalent to nDel-m[0]-2m[1]<=\\n\\t\\t * sum{3(k_i-1)}+sum{3(k'_i-1)}+sum{3k''_i},\\n\\t\\t * where {3k_i, 1<=i<=m[0]}, {3k'_i+1, 1<=i<=m[1]}, \\n\\t\\t * {3k''_i+2, 1<=i<=m[2]} are the sets of lengths of SSRCs\\n\\t\\t */\\n\\t\\treturn nDel + Math.max(nRep - rNDel / 3, nMiss);\\n\\n\\treturn nDel + nMiss;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int strongPasswordChecker(String s) { \\n\\tint n = s.length();\\n\\tboolean hasLower = false, hasUpper = false, hasDigit = false;\\n\\tint nRep = 0, sum = 0; // sum=sum{length>=3 of a SSRC}\\n\\tint[] m = new int[3]; // # of SSRC of length 3k, 3k+1, 3k+2\\n\\n\\tint i = 0, j, t;\\n\\tchar c;\\n\\twhile (i < n) {\\n\\t\\tc = s.charAt(i);\\n\\n\\t\\thasLower |= (c >= 'a' && c <= 'z');\\n\\t\\thasUpper |= (c >= 'A' && c <= 'Z');\\n\\t\\thasDigit |= (c >= '0' && c <= '9');\\n\\n\\t\\tj = i + 1;\\n\\t\\twhile (j < n && s.charAt(j) == c)\\n\\t\\t\\tj++;\\n\\n\\t\\tt = j - i;\\n\\t\\tif (t >= 3) {\\n\\t\\t\\tnRep += t / 3;\\n\\t\\t\\tsum += t;\\n\\t\\t\\tm[t % 3]++;\\n\\t\\t}\\n\\t\\ti = j;\\n\\t}\\n\\n\\tint nMiss = (hasLower ? 0 : 1) + (hasUpper ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n\\tif (n < 6) \\n\\t\\treturn (6 - n) > nMiss ? (6 - n) : nMiss;\\n\\n\\tif (n <= 20)\\n\\t\\treturn Math.max(nRep, nMiss);\\n\\n\\t// n > 20\\n\\tint nDel = n - 20;\\n\\tif (nDel <= m[0])\\n\\t\\treturn nDel + Math.max(nRep - nDel, nMiss);\\n\\n\\tint rNDel = nDel - m[0];\\n\\tnRep -= m[0];\\n\\tif (rNDel <= 2 * m[1])\\n\\t\\treturn nDel + Math.max(nRep - rNDel / 2, nMiss);\\n\\n\\trNDel -= 2 * m[1];\\n\\tnRep -= m[1];\\n\\tif (nDel <= sum - 2 * (m[0] + m[1] + m[2]))\\n\\t\\t/**\\n\\t\\t * This condition is equivalent to nDel-m[0]-2m[1]<=\\n\\t\\t * sum{3(k_i-1)}+sum{3(k'_i-1)}+sum{3k''_i},\\n\\t\\t * where {3k_i, 1<=i<=m[0]}, {3k'_i+1, 1<=i<=m[1]}, \\n\\t\\t * {3k''_i+2, 1<=i<=m[2]} are the sets of lengths of SSRCs\\n\\t\\t */\\n\\t\\treturn nDel + Math.max(nRep - rNDel / 3, nMiss);\\n\\n\\treturn nDel + nMiss;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431603,
                "title": "share-my-clean-java-solution-with-explanations-case-by-case",
                "content": "I commented my code as well, but here is an explanation.\\n\\n#### Case 1 (len > 20)\\nThe trickier case is when `len > 20` and when there are consecutive chars groups of length no less than 3. Since the string length is greater than 20, we will have to delete, but we have to figure out what to delete to ensure the optimal outcome. Take a look at `aaa`, if we delete 1 `\\'a\\'` from it, we no longer have 3 `\\'a\\'`, so we saved 1 move, for \"aaaa\", 1 deletion brings us to \"aaa\" which doesn\\'t save us anything. \"aaaaa\", 1 deletion doesn\\'t do anything either, but for \"aaaaaa\", here 1 deletion saves us 1 move because we would have needed \"aa1aa1\", but after 1 deletion, we can just do \"aa1aa\", so that\\'s good. \\n\\nIn Summary, we should always delete the char groups whose length is a multiple of 3, followed by those mod 3 = 1, then those mod 3 = 2.\\n#### Case 2 (20 >= len >= 6)\\nThere is no edge case here. We just have to handle the condition counts and **replace** consecutive char groups accordingly.\\n\\n#### Case 3 (len > 6)\\nIf we encounter a consecutive chars groups, we must **insert** instead of replace or delete. Per insertion, we can knock off 1 condition that was unmet prior.\\n\\n> **Please upvote if you find my explanations & implementation helpful, thank you!**\\n#### Java\\n```Java\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int[] ok = new int[]{1, 1, 1};\\n        char[] A = password.toCharArray();\\n        for (char ch : A){ // check the 3 conditions first.\\n            ok[0] &= Character.isLowerCase(ch)? 0 : 1;\\n            ok[1] &= Character.isUpperCase(ch)? 0 : 1;\\n            ok[2] &= Character.isDigit(ch)? 0 : 1;\\n        }\\n        int ans = 0, len = password.length(), cond = ok[0]+ok[1]+ok[2]; // cond -> how many cond not met yet.\\n        var minheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> o%3)); // sort by o%3\\n        for (int i = 0, cnt = 1; i < len; i++, cnt++){ // put consecutive chars with count >= 3 into the minheap\\n            if (i == len-1 || A[i] != A[i+1]){\\n                if (cnt >= 3){\\n                    minheap.offer(cnt);\\n                }\\n                cnt = 0;\\n            }\\n        }\\n        while(len > 20 && !minheap.isEmpty()){ // if len > 20, we try to delete from the chars groups.\\n            int cur = minheap.poll();\\n            if (--cur >= 3){\\n                minheap.offer(cur);\\n            }\\n            --len;\\n            ++ans;\\n        }\\n        while(!minheap.isEmpty()){ // if there are still 3 or more chars groups, we need to replace or insert\\n            int cur = minheap.poll();\\n            cond -= cur/3;\\n            ans += cur/3;\\n            if (len < 6){ // insert only for len < 6; otherwise, replace.\\n                len++;    // I do ++ here as cur can only be 3,4,5.\\n            }\\n        }\\n        while(len > 20){ // if len is still > 20, we need to delete.\\n            ans++;\\n            len--;\\n        }\\n        while(len < 6){ // if len < 6, we need to insert and per insertion will satisify 1 cond\\n            cond--;\\n            ans++;\\n            len++;\\n        }\\n        return ans + (cond < 0? 0 : cond); // remember to take the max of (cond, 0).\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int[] ok = new int[]{1, 1, 1};\\n        char[] A = password.toCharArray();\\n        for (char ch : A){ // check the 3 conditions first.\\n            ok[0] &= Character.isLowerCase(ch)? 0 : 1;\\n            ok[1] &= Character.isUpperCase(ch)? 0 : 1;\\n            ok[2] &= Character.isDigit(ch)? 0 : 1;\\n        }\\n        int ans = 0, len = password.length(), cond = ok[0]+ok[1]+ok[2]; // cond -> how many cond not met yet.\\n        var minheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> o%3)); // sort by o%3\\n        for (int i = 0, cnt = 1; i < len; i++, cnt++){ // put consecutive chars with count >= 3 into the minheap\\n            if (i == len-1 || A[i] != A[i+1]){\\n                if (cnt >= 3){\\n                    minheap.offer(cnt);\\n                }\\n                cnt = 0;\\n            }\\n        }\\n        while(len > 20 && !minheap.isEmpty()){ // if len > 20, we try to delete from the chars groups.\\n            int cur = minheap.poll();\\n            if (--cur >= 3){\\n                minheap.offer(cur);\\n            }\\n            --len;\\n            ++ans;\\n        }\\n        while(!minheap.isEmpty()){ // if there are still 3 or more chars groups, we need to replace or insert\\n            int cur = minheap.poll();\\n            cond -= cur/3;\\n            ans += cur/3;\\n            if (len < 6){ // insert only for len < 6; otherwise, replace.\\n                len++;    // I do ++ here as cur can only be 3,4,5.\\n            }\\n        }\\n        while(len > 20){ // if len is still > 20, we need to delete.\\n            ans++;\\n            len--;\\n        }\\n        while(len < 6){ // if len < 6, we need to insert and per insertion will satisify 1 cond\\n            cond--;\\n            ans++;\\n            len++;\\n        }\\n        return ans + (cond < 0? 0 : cond); // remember to take the max of (cond, 0).\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393542,
                "title": "c-100-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool islower(char &c)\\n    {\\n        return c>=\\'a\\' && c<=\\'z\\';\\n    }\\n    bool isupper(char &c)\\n    {\\n        return c>=\\'A\\' && c<=\\'Z\\';\\n    }\\n    bool isdigit(char &c)\\n    {\\n        return c>=\\'0\\' && c<=\\'9\\';\\n    }\\n    \\n    int strongPasswordChecker(string s ) {\\n        int n=s.length();\\n        \\n        bool lo,up,di;\\n        lo=up=di=false;\\n        \\n        if(n<=20)\\n        {\\n            int need_replaces=0,can_be_replaced=0;\\n            int need_add=(6-n)<0 ? 0:6-n;\\n            for(int i=0;i<n;)\\n            {\\n                if(!lo && islower(s[i]))\\n                    lo=true;\\n                if(!up && isupper(s[i]))\\n                    up=true;\\n                if(!di && isdigit(s[i]))\\n                    di=true;\\n                \\n                int tmp=1;\\n                int j=i+1;\\n                while(j<n && s[i]==s[j])\\n                {\\n                    j++;\\n                }\\n                tmp=(j-i);\\n                can_be_replaced+=tmp/3;\\n                \\n                i=j;\\n            }\\n            \\n            if(!lo) need_replaces+=1;\\n            if(!up) need_replaces+=1;\\n            if(!di) need_replaces+=1;\\n            \\n            int replaces=max(can_be_replaced,need_replaces);\\n            return max(need_add,replaces);\\n        }\\n        else\\n        {\\n            int min_deletion=n-20,need_replaces=0;\\n            int curr_length=0;\\n            priority_queue<int>pq;\\n            \\n            for(int i=0;i<n;)\\n            {\\n                if(!lo && islower(s[i]))\\n                    lo=true;\\n                if(!up && isupper(s[i]))\\n                    up=true;\\n                if(!di && isdigit(s[i]))\\n                    di=true;\\n                \\n                int temp=1;\\n                int j=i+1;\\n                while(j<n && s[i]==s[j])\\n                {\\n                    j++;\\n                }\\n                temp=(j-i);\\n                if(temp>=2)\\n                {\\n                    curr_length+=2;\\n                    pq.push(temp-2);\\n                }\\n                else\\n                    curr_length+=1;\\n                \\n                i=j;\\n            }\\n            \\n            if(!lo) need_replaces+=1;\\n            if(!up) need_replaces+=1;\\n            if(!di) need_replaces+=1;\\n            \\n            if(curr_length>=20)\\n                return min_deletion+need_replaces;\\n            else\\n            {\\n                int min_replacement=0;\\n                while(curr_length<20)\\n                {\\n                    int x=pq.top();\\n                    curr_length+=min(3,x);\\n                    min_replacement+=1;\\n                }\\n                \\n                min_replacement=max(min_replacement,need_replaces);\\n                return min_deletion+min_replacement;\\n            }\\n            \\n        }\\n            \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool islower(char &c)\\n    {\\n        return c>=\\'a\\' && c<=\\'z\\';\\n    }\\n    bool isupper(char &c)\\n    {\\n        return c>=\\'A\\' && c<=\\'Z\\';\\n    }\\n    bool isdigit(char &c)\\n    {\\n        return c>=\\'0\\' && c<=\\'9\\';\\n    }\\n    \\n    int strongPasswordChecker(string s ) {\\n        int n=s.length();\\n        \\n        bool lo,up,di;\\n        lo=up=di=false;\\n        \\n        if(n<=20)\\n        {\\n            int need_replaces=0,can_be_replaced=0;\\n            int need_add=(6-n)<0 ? 0:6-n;\\n            for(int i=0;i<n;)\\n            {\\n                if(!lo && islower(s[i]))\\n                    lo=true;\\n                if(!up && isupper(s[i]))\\n                    up=true;\\n                if(!di && isdigit(s[i]))\\n                    di=true;\\n                \\n                int tmp=1;\\n                int j=i+1;\\n                while(j<n && s[i]==s[j])\\n                {\\n                    j++;\\n                }\\n                tmp=(j-i);\\n                can_be_replaced+=tmp/3;\\n                \\n                i=j;\\n            }\\n            \\n            if(!lo) need_replaces+=1;\\n            if(!up) need_replaces+=1;\\n            if(!di) need_replaces+=1;\\n            \\n            int replaces=max(can_be_replaced,need_replaces);\\n            return max(need_add,replaces);\\n        }\\n        else\\n        {\\n            int min_deletion=n-20,need_replaces=0;\\n            int curr_length=0;\\n            priority_queue<int>pq;\\n            \\n            for(int i=0;i<n;)\\n            {\\n                if(!lo && islower(s[i]))\\n                    lo=true;\\n                if(!up && isupper(s[i]))\\n                    up=true;\\n                if(!di && isdigit(s[i]))\\n                    di=true;\\n                \\n                int temp=1;\\n                int j=i+1;\\n                while(j<n && s[i]==s[j])\\n                {\\n                    j++;\\n                }\\n                temp=(j-i);\\n                if(temp>=2)\\n                {\\n                    curr_length+=2;\\n                    pq.push(temp-2);\\n                }\\n                else\\n                    curr_length+=1;\\n                \\n                i=j;\\n            }\\n            \\n            if(!lo) need_replaces+=1;\\n            if(!up) need_replaces+=1;\\n            if(!di) need_replaces+=1;\\n            \\n            if(curr_length>=20)\\n                return min_deletion+need_replaces;\\n            else\\n            {\\n                int min_replacement=0;\\n                while(curr_length<20)\\n                {\\n                    int x=pq.top();\\n                    curr_length+=min(3,x);\\n                    min_replacement+=1;\\n                }\\n                \\n                min_replacement=max(min_replacement,need_replaces);\\n                return min_deletion+min_replacement;\\n            }\\n            \\n        }\\n            \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497854,
                "title": "rust-solution-using-dijkstra-s-algorithm-156-ms-85-3-mb-and-bfs-18-ms-6-7-mb",
                "content": "The words \"minimum number of steps\" made me think of \"minimum cost,\" which made me think of Dijkstra\\'s algorithm, so I solved it by modelling the changes we can make to the string as edges in a graph and then applying Dijkstra\\'s algorithm. This is not the fastest or easiest solution to implement, but I think it\\'s still interesting.\\n\\nIn order to create a strong password from the given string, we need to traverse through the string, so each node in this graph must keep track of the current index where we are in the string. Then, the graph has four types of edges: (1) Add the character at the current index to the strong password and increment the index (2) Increment the current index without adding the current character (i.e. delete the char at the current index) (3) Insert a character right before the current index (4) Do action 3 followed by action 2 (i.e. replace the char at the current index)\\n\\nNext, every node in the graph can be represented as a tuple `(ind, num_chars, lower, upper, digit, last_two)`. `ind` represents the current index. `num_chars` represents the number of characters we have added to the strong password so far. `lower`, `upper`, and `digit` are booleans representing whether we have added a lowercase, uppercase, or digit so far. Finally, `last_two` is one of three possibilities: `Double(c)` which represents that the strong password ends in \"cc\", `Alone(c)` which represents that the strong password ends in \"c\" but not \"cc\", or `Empty` which represents that the strong password is empty. In the implementation, we do not allow traversing from nodes with `Double(c)` along edges where we are adding \"c\" to the end of the strong password, which prevents having three characters in a row in the strong password.\\n\\nWe start out at the beginning of the given string with an empty strong password, so the initial node is `(0, 0, false, false, false, Empty)`. Once we know the initial node, we can implement Dijkstra\\'s algorithm with the four types of edges mentioned above, and we stop once we reach a node of the form `(I, N, true, true, true, _)` where `6 <= N <= 20` and `I` is at the end of the string (i.e. `I = password.len()`) because that means we created a valid strong password after processing all of the string.\\n\\nOne problem is that for edges type 3 and type 4, we have to choose a character to insert and there are 64 different possible characters we could insert, which means, between all the edge types, for any given node there are up to possible 1+1+64+64=130 outgoing edges. In order to cut down on that, we notice that inserting any lowercase letter is the same as any other lowercase letter, as long as it\\'s different from the character at the current index to avoid creating three characters in a row. The same holds for uppercase letters and digits, so we really just need to have one outgoing edge for lowercase letter, one outgoing edge for uppercase letter, and one outgoing edge for digits. This means there are only 3 outgoing edged for types 3 and 4, bringing us to 1+1+3+3=8 outgoing edges for each vertex, which is much more feasible.\\n\\nThere are 51 possibilities for `ind` (0...50), 21 for `num_chars` (0...20), `2` for `lower`, `upper`, and `digit`, and finally `1+64+64=129` possibilities for `last_two`, meaning the number of vertices in our graph is `51*21*2*2*2*129=1105272`. And then there are `8` edges for each vertex, giving us `8842176` edges. The complexity of Dijkstra\\'s is `O((V+E)log(V))` and `(1105272+8842176)log(1105272)/log(2)=199704668`. That is certainly much slower than the linear-time `O(N)` solutions where `N=50`, but it still allows us to reliably run in under a second.\\n\\nTo get the complexity in more symbolic terms, if N is the length of the string, M is the maximum length of a strong password, T is the number of types of characters the strong password must have (i.e. for this problem, T=3 because lowercase, uppercase, digit are required), and A is the number of possible characters in the string (i.e. for this problem, A=26+26+10+1+1=64 because lowercase, uppercase, digit, period, and exclamation mark), then the number of vertices is V=(N+1)(M+1)\\\\*2^T\\\\*(1+2\\\\*A) and the number of edges is E=V\\\\*(1+1+2\\\\*T), so the complexity ends up being O(NM\\\\*2^T\\\\*A\\\\*T\\\\*log(NM\\\\*2^T\\\\*A)), which can also be expressed as O(2^T\\\\*NMAT(T+log(NMA))).\\n```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nenum LastTwo {\\n    Empty,\\n    Alone(char),\\n    Double(char)\\n}\\nuse LastTwo::*;\\n\\nfn upd(lt: LastTwo, c: char) -> LastTwo {\\n    if lt == Alone(c) || lt == Double(c) {\\n        Double(c)\\n    } else {\\n        Alone(c)\\n    }\\n}\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nstruct Info {\\n    cost: Reverse<usize>,\\n    ind: usize,\\n    num_chars: usize,\\n    lower: bool,\\n    upper: bool,\\n    digit: bool,\\n    last_two: LastTwo\\n}\\n\\nimpl Info {\\n    fn new(cost: Reverse<usize>, ind: usize, num_chars: usize, lower: bool, upper: bool, digit: bool, last_two: LastTwo) -> Info {\\n        Info { cost, ind, num_chars, lower, upper, digit, last_two }\\n    }\\n    \\n    fn calc_hash(&self) -> usize {\\n        let mut res = self.ind;\\n        res *= 21;\\n        res += self.num_chars;\\n        res *= 2;\\n        res += (self.lower as usize);\\n        res *= 2;\\n        res += (self.upper as usize);\\n        res *= 2;\\n        res += (self.digit as usize);\\n        res *= 1+2*256;\\n        res += match self.last_two {\\n            Empty => 0,\\n            Alone(ch) => 1+(ch as usize),\\n            Double(ch) => 257+(ch as usize)\\n        };\\n        res\\n    }\\n}\\n\\nfn inc_rev(x: Reverse<usize>) -> Reverse<usize> {\\n    Reverse(x.0+1)\\n}\\n\\nfn add_new_info(s: &mut [Option<usize>], h: &mut BinaryHeap<Info>, info: Info) {\\n    let hash = info.calc_hash();\\n    let should_insert = match s[hash] {\\n        None => true,\\n        Some(c) => info.cost.0 < c\\n    };\\n    if should_insert {\\n        s[hash] = Some(info.cost.0);\\n        h.push(info);\\n    }\\n}\\n\\nfn add_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, info: Info, ch: char, new_cost: Reverse<usize>, new_ind: usize) -> bool {\\n    let new_lower = info.lower || ch.is_ascii_lowercase();\\n    let new_upper = info.upper || ch.is_ascii_uppercase();\\n    let new_digit = info.digit || ch.is_ascii_digit();\\n    if info.last_two != Double(ch) && info.num_chars < 20 {\\n        add_new_info(&mut s, &mut h, Info::new(new_cost, new_ind, info.num_chars+1, new_lower, new_upper, new_digit, upd(info.last_two, ch)));\\n        true\\n    } else { false }\\n}\\n\\nfn change_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if ch == chars[info.ind] || (info.ind+1 < chars.len() && ch == chars[info.ind+1]) {\\n        return false;\\n    }\\n\\n    add_char(&mut s, &mut h, info, ch, inc_rev(info.cost), info.ind+1)\\n}\\n\\nfn insert_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if info.ind < chars.len() && ch == chars[info.ind] {\\n        return false;\\n    }\\n    \\n    add_char(&mut s, &mut h, info, ch, inc_rev(info.cost), info.ind)\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let chars: Vec<char> = password.chars().collect();\\n        \\n        let mut min_cost: Vec<Option<usize>> = vec![None; (chars.len()+1)*21*2*2*2*(1+2*256)];\\n        let mut heap: BinaryHeap<Info> = BinaryHeap::new();\\n        \\n        add_new_info(&mut min_cost, &mut heap, Info::new(Reverse(0), 0, 0, false, false, false, Empty));\\n        \\n        while let Some(info) = heap.pop() {\\n            if let Some(c) = min_cost[info.calc_hash()] {\\n                if c < info.cost.0 {\\n                    continue;\\n                }\\n            }\\n            \\n            if info.ind == chars.len() && info.num_chars >= 6 && info.lower && info.upper && info.digit {\\n                return info.cost.0 as i32;\\n            }\\n            \\n            if info.ind < chars.len() {\\n                //Edge type 1 (i.e. change nothing)\\n                add_char(&mut min_cost, &mut heap, info, chars[info.ind], info.cost, info.ind+1);\\n                \\n                //Edge type 2 (i.e. delete character)\\n                add_new_info(&mut min_cost, &mut heap, Info::new(inc_rev(info.cost), info.ind+1, info.num_chars, info.lower, info.upper, info.digit, info.last_two));\\n                \\n                //Edge type 4 (i.e. replace char): lowercase\\n                for ch in (\\'a\\'..=\\'z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: uppercase\\n                for ch in (\\'A\\'..=\\'Z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: digit\\n                for ch in (\\'0\\'..=\\'9\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n            }\\n            \\n            //Edge type 3 (i.e. insert char): lowercase\\n            for ch in (\\'a\\'..=\\'z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: uppercase\\n            for ch in (\\'A\\'..=\\'Z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: digit\\n            for ch in (\\'0\\'..=\\'9\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n        }\\n        panic!(\"No answer found!\");\\n    }\\n}\\n```\\n\\nEDIT: The reason I used Dijkstra\\'s algorithm is because the edges have different weights: Edge type 1 has weight 0 while edge types 2, 3, 4 have weight 1. However, I realized that, since edge type 1 has weight 0, we can immediately traverse all the edges of type 1 whenever we add a new node to the queue. And this doesn\\'t cause us to go into an infinite loop because each edge of type 1 increments the index, so this traversal stops once we hit the index `password.len()`.\\n\\nBy immediately traversing the edges of type 1, the rest of our search only has to deal with edges of type 2, 3, 4. Since all of these edges have the same weight, this means we can treat the graph as unweighted, and thus use BFS instead of Dijkstra\\'s. This allows us to replace our priority queue with just a queue, which takes the log factor off of our complexity, i.e. the complexity for BFS is just O(V+E)=O(2^T\\\\*NMAT). As advertised in the title, this solution takes just 18 ms as opposed to the Dijkstra\\'s solution which takes 156 ms.\\n```\\nuse std::collections::VecDeque;\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nenum LastTwo {\\n    Empty,\\n    Alone(char),\\n    Double(char)\\n}\\nuse LastTwo::*;\\n\\nfn upd(lt: LastTwo, c: char) -> LastTwo {\\n    if lt == Alone(c) || lt == Double(c) {\\n        Double(c)\\n    } else {\\n        Alone(c)\\n    }\\n}\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nstruct Info {\\n    cost: usize,\\n    ind: usize,\\n    num_chars: usize,\\n    lower: bool,\\n    upper: bool,\\n    digit: bool,\\n    last_two: LastTwo\\n}\\n\\nimpl Info {\\n    fn new(cost: usize, ind: usize, num_chars: usize, lower: bool, upper: bool, digit: bool, last_two: LastTwo) -> Info {\\n        Info { cost, ind, num_chars, lower, upper, digit, last_two }\\n    }\\n    \\n    fn calc_hash(&self) -> usize {\\n        let mut res = self.ind;\\n        res *= 21;\\n        res += self.num_chars;\\n        res *= 2;\\n        res += (self.lower as usize);\\n        res *= 2;\\n        res += (self.upper as usize);\\n        res *= 2;\\n        res += (self.digit as usize);\\n        res *= 1+2*256;\\n        res += match self.last_two {\\n            Empty => 0,\\n            Alone(ch) => 1+(ch as usize),\\n            Double(ch) => 257+(ch as usize)\\n        };\\n        res\\n    }\\n}\\n\\nfn add_char_to_info(info: Info, ch: char, new_cost: usize, new_ind: usize) -> Option<Info> {\\n    if info.last_two == Double(ch) || info.num_chars >= 20 { return None; }\\n    \\n    let new_lower = info.lower || ch.is_ascii_lowercase();\\n    let new_upper = info.upper || ch.is_ascii_uppercase();\\n    let new_digit = info.digit || ch.is_ascii_digit();\\n    Some(Info::new(new_cost, new_ind, info.num_chars+1, new_lower, new_upper, new_digit, upd(info.last_two, ch)))\\n}\\n\\nfn add_new_info(s: &mut [bool], h: &mut VecDeque<Info>, chars: &[char], mut info: Info) {\\n    loop {\\n        let hash = info.calc_hash();\\n        if !s[hash] {\\n            s[hash] = true;\\n            h.push_back(info);\\n            \\n            //Once we hit chars.len(), there are no more type 1 edges\\n            if info.ind >= chars.len() {\\n                break;\\n            }\\n            //If we can traverse an edge type 1 here, traverse that edge immediately\\n            //i.e. set info to new_info so new_info gets added to the queue on the next loop iteration\\n            if let Some(new_info) = add_char_to_info(info, chars[info.ind], info.cost, info.ind+1) {\\n                info = new_info;\\n            }\\n            else { break; }\\n        } else {\\n            break;\\n        }\\n    }\\n}\\n\\nfn add_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char, new_cost: usize, new_ind: usize) -> bool {\\n    if let Some(new_info) = add_char_to_info(info, ch, new_cost, new_ind) {\\n        add_new_info(&mut s, &mut h, chars, new_info);\\n        true\\n    } else { false }\\n}\\n\\nfn change_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if ch == chars[info.ind] || (info.ind+1 < chars.len() && ch == chars[info.ind+1]) {\\n        return false;\\n    }\\n\\n    add_char(&mut s, &mut h, chars, info, ch, info.cost+1, info.ind+1)\\n}\\n\\nfn insert_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if info.ind < chars.len() && ch == chars[info.ind] {\\n        return false;\\n    }\\n    \\n    add_char(&mut s, &mut h, chars, info, ch, info.cost+1, info.ind)\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let chars: Vec<char> = password.chars().collect();\\n        \\n        let mut min_cost: Vec<bool> = vec![false; (chars.len()+1)*21*2*2*2*(1+2*256)];\\n        let mut heap: VecDeque<Info> = VecDeque::new();\\n        \\n        add_new_info(&mut min_cost, &mut heap, &chars, Info::new(0, 0, 0, false, false, false, Empty));\\n        \\n        while let Some(info) = heap.pop_front() {\\n            if info.ind == chars.len() && info.num_chars >= 6 && info.lower && info.upper && info.digit {\\n                return info.cost as i32;\\n            }\\n            \\n            if info.ind < chars.len() {\\n                //Edge type 2 (i.e. delete character)\\n                add_new_info(&mut min_cost, &mut heap, &chars, Info::new(info.cost+1, info.ind+1, info.num_chars, info.lower, info.upper, info.digit, info.last_two));\\n                \\n                //Edge type 4 (i.e. replace char): lowercase\\n                for ch in (\\'a\\'..=\\'z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: uppercase\\n                for ch in (\\'A\\'..=\\'Z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: digit\\n                for ch in (\\'0\\'..=\\'9\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n            }\\n            \\n            //Edge type 3 (i.e. insert char): lowercase\\n            for ch in (\\'a\\'..=\\'z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: uppercase\\n            for ch in (\\'A\\'..=\\'Z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: digit\\n            for ch in (\\'0\\'..=\\'9\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n        }\\n        panic!(\"No answer found!\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nenum LastTwo {\\n    Empty,\\n    Alone(char),\\n    Double(char)\\n}\\nuse LastTwo::*;\\n\\nfn upd(lt: LastTwo, c: char) -> LastTwo {\\n    if lt == Alone(c) || lt == Double(c) {\\n        Double(c)\\n    } else {\\n        Alone(c)\\n    }\\n}\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nstruct Info {\\n    cost: Reverse<usize>,\\n    ind: usize,\\n    num_chars: usize,\\n    lower: bool,\\n    upper: bool,\\n    digit: bool,\\n    last_two: LastTwo\\n}\\n\\nimpl Info {\\n    fn new(cost: Reverse<usize>, ind: usize, num_chars: usize, lower: bool, upper: bool, digit: bool, last_two: LastTwo) -> Info {\\n        Info { cost, ind, num_chars, lower, upper, digit, last_two }\\n    }\\n    \\n    fn calc_hash(&self) -> usize {\\n        let mut res = self.ind;\\n        res *= 21;\\n        res += self.num_chars;\\n        res *= 2;\\n        res += (self.lower as usize);\\n        res *= 2;\\n        res += (self.upper as usize);\\n        res *= 2;\\n        res += (self.digit as usize);\\n        res *= 1+2*256;\\n        res += match self.last_two {\\n            Empty => 0,\\n            Alone(ch) => 1+(ch as usize),\\n            Double(ch) => 257+(ch as usize)\\n        };\\n        res\\n    }\\n}\\n\\nfn inc_rev(x: Reverse<usize>) -> Reverse<usize> {\\n    Reverse(x.0+1)\\n}\\n\\nfn add_new_info(s: &mut [Option<usize>], h: &mut BinaryHeap<Info>, info: Info) {\\n    let hash = info.calc_hash();\\n    let should_insert = match s[hash] {\\n        None => true,\\n        Some(c) => info.cost.0 < c\\n    };\\n    if should_insert {\\n        s[hash] = Some(info.cost.0);\\n        h.push(info);\\n    }\\n}\\n\\nfn add_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, info: Info, ch: char, new_cost: Reverse<usize>, new_ind: usize) -> bool {\\n    let new_lower = info.lower || ch.is_ascii_lowercase();\\n    let new_upper = info.upper || ch.is_ascii_uppercase();\\n    let new_digit = info.digit || ch.is_ascii_digit();\\n    if info.last_two != Double(ch) && info.num_chars < 20 {\\n        add_new_info(&mut s, &mut h, Info::new(new_cost, new_ind, info.num_chars+1, new_lower, new_upper, new_digit, upd(info.last_two, ch)));\\n        true\\n    } else { false }\\n}\\n\\nfn change_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if ch == chars[info.ind] || (info.ind+1 < chars.len() && ch == chars[info.ind+1]) {\\n        return false;\\n    }\\n\\n    add_char(&mut s, &mut h, info, ch, inc_rev(info.cost), info.ind+1)\\n}\\n\\nfn insert_char(mut s: &mut [Option<usize>], mut h: &mut BinaryHeap<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if info.ind < chars.len() && ch == chars[info.ind] {\\n        return false;\\n    }\\n    \\n    add_char(&mut s, &mut h, info, ch, inc_rev(info.cost), info.ind)\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let chars: Vec<char> = password.chars().collect();\\n        \\n        let mut min_cost: Vec<Option<usize>> = vec![None; (chars.len()+1)*21*2*2*2*(1+2*256)];\\n        let mut heap: BinaryHeap<Info> = BinaryHeap::new();\\n        \\n        add_new_info(&mut min_cost, &mut heap, Info::new(Reverse(0), 0, 0, false, false, false, Empty));\\n        \\n        while let Some(info) = heap.pop() {\\n            if let Some(c) = min_cost[info.calc_hash()] {\\n                if c < info.cost.0 {\\n                    continue;\\n                }\\n            }\\n            \\n            if info.ind == chars.len() && info.num_chars >= 6 && info.lower && info.upper && info.digit {\\n                return info.cost.0 as i32;\\n            }\\n            \\n            if info.ind < chars.len() {\\n                //Edge type 1 (i.e. change nothing)\\n                add_char(&mut min_cost, &mut heap, info, chars[info.ind], info.cost, info.ind+1);\\n                \\n                //Edge type 2 (i.e. delete character)\\n                add_new_info(&mut min_cost, &mut heap, Info::new(inc_rev(info.cost), info.ind+1, info.num_chars, info.lower, info.upper, info.digit, info.last_two));\\n                \\n                //Edge type 4 (i.e. replace char): lowercase\\n                for ch in (\\'a\\'..=\\'z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: uppercase\\n                for ch in (\\'A\\'..=\\'Z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: digit\\n                for ch in (\\'0\\'..=\\'9\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n            }\\n            \\n            //Edge type 3 (i.e. insert char): lowercase\\n            for ch in (\\'a\\'..=\\'z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: uppercase\\n            for ch in (\\'A\\'..=\\'Z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: digit\\n            for ch in (\\'0\\'..=\\'9\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n        }\\n        panic!(\"No answer found!\");\\n    }\\n}\\n```\n```\\nuse std::collections::VecDeque;\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nenum LastTwo {\\n    Empty,\\n    Alone(char),\\n    Double(char)\\n}\\nuse LastTwo::*;\\n\\nfn upd(lt: LastTwo, c: char) -> LastTwo {\\n    if lt == Alone(c) || lt == Double(c) {\\n        Double(c)\\n    } else {\\n        Alone(c)\\n    }\\n}\\n\\n#[derive(Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Debug)]\\nstruct Info {\\n    cost: usize,\\n    ind: usize,\\n    num_chars: usize,\\n    lower: bool,\\n    upper: bool,\\n    digit: bool,\\n    last_two: LastTwo\\n}\\n\\nimpl Info {\\n    fn new(cost: usize, ind: usize, num_chars: usize, lower: bool, upper: bool, digit: bool, last_two: LastTwo) -> Info {\\n        Info { cost, ind, num_chars, lower, upper, digit, last_two }\\n    }\\n    \\n    fn calc_hash(&self) -> usize {\\n        let mut res = self.ind;\\n        res *= 21;\\n        res += self.num_chars;\\n        res *= 2;\\n        res += (self.lower as usize);\\n        res *= 2;\\n        res += (self.upper as usize);\\n        res *= 2;\\n        res += (self.digit as usize);\\n        res *= 1+2*256;\\n        res += match self.last_two {\\n            Empty => 0,\\n            Alone(ch) => 1+(ch as usize),\\n            Double(ch) => 257+(ch as usize)\\n        };\\n        res\\n    }\\n}\\n\\nfn add_char_to_info(info: Info, ch: char, new_cost: usize, new_ind: usize) -> Option<Info> {\\n    if info.last_two == Double(ch) || info.num_chars >= 20 { return None; }\\n    \\n    let new_lower = info.lower || ch.is_ascii_lowercase();\\n    let new_upper = info.upper || ch.is_ascii_uppercase();\\n    let new_digit = info.digit || ch.is_ascii_digit();\\n    Some(Info::new(new_cost, new_ind, info.num_chars+1, new_lower, new_upper, new_digit, upd(info.last_two, ch)))\\n}\\n\\nfn add_new_info(s: &mut [bool], h: &mut VecDeque<Info>, chars: &[char], mut info: Info) {\\n    loop {\\n        let hash = info.calc_hash();\\n        if !s[hash] {\\n            s[hash] = true;\\n            h.push_back(info);\\n            \\n            //Once we hit chars.len(), there are no more type 1 edges\\n            if info.ind >= chars.len() {\\n                break;\\n            }\\n            //If we can traverse an edge type 1 here, traverse that edge immediately\\n            //i.e. set info to new_info so new_info gets added to the queue on the next loop iteration\\n            if let Some(new_info) = add_char_to_info(info, chars[info.ind], info.cost, info.ind+1) {\\n                info = new_info;\\n            }\\n            else { break; }\\n        } else {\\n            break;\\n        }\\n    }\\n}\\n\\nfn add_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char, new_cost: usize, new_ind: usize) -> bool {\\n    if let Some(new_info) = add_char_to_info(info, ch, new_cost, new_ind) {\\n        add_new_info(&mut s, &mut h, chars, new_info);\\n        true\\n    } else { false }\\n}\\n\\nfn change_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if ch == chars[info.ind] || (info.ind+1 < chars.len() && ch == chars[info.ind+1]) {\\n        return false;\\n    }\\n\\n    add_char(&mut s, &mut h, chars, info, ch, info.cost+1, info.ind+1)\\n}\\n\\nfn insert_char(mut s: &mut [bool], mut h: &mut VecDeque<Info>, chars: &[char], info: Info, ch: char) -> bool {\\n    if info.ind < chars.len() && ch == chars[info.ind] {\\n        return false;\\n    }\\n    \\n    add_char(&mut s, &mut h, chars, info, ch, info.cost+1, info.ind)\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let chars: Vec<char> = password.chars().collect();\\n        \\n        let mut min_cost: Vec<bool> = vec![false; (chars.len()+1)*21*2*2*2*(1+2*256)];\\n        let mut heap: VecDeque<Info> = VecDeque::new();\\n        \\n        add_new_info(&mut min_cost, &mut heap, &chars, Info::new(0, 0, 0, false, false, false, Empty));\\n        \\n        while let Some(info) = heap.pop_front() {\\n            if info.ind == chars.len() && info.num_chars >= 6 && info.lower && info.upper && info.digit {\\n                return info.cost as i32;\\n            }\\n            \\n            if info.ind < chars.len() {\\n                //Edge type 2 (i.e. delete character)\\n                add_new_info(&mut min_cost, &mut heap, &chars, Info::new(info.cost+1, info.ind+1, info.num_chars, info.lower, info.upper, info.digit, info.last_two));\\n                \\n                //Edge type 4 (i.e. replace char): lowercase\\n                for ch in (\\'a\\'..=\\'z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: uppercase\\n                for ch in (\\'A\\'..=\\'Z\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n                //Edge type 4: digit\\n                for ch in (\\'0\\'..=\\'9\\') {\\n                    if change_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n                }\\n            }\\n            \\n            //Edge type 3 (i.e. insert char): lowercase\\n            for ch in (\\'a\\'..=\\'z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: uppercase\\n            for ch in (\\'A\\'..=\\'Z\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n            //Edge type 3: digit\\n            for ch in (\\'0\\'..=\\'9\\') {\\n                if insert_char(&mut min_cost, &mut heap, &chars, info, ch) { break; }\\n            }\\n        }\\n        panic!(\"No answer found!\");\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91010,
                "title": "short-and-clear-javascript-solution-works-for-different-password-requirements",
                "content": "```\\nvar strongPasswordChecker = function(s, a = 6, b = 20, c = 3) {\\n    const clusters = buildClusters(s, c);\\n    for (let i = 0; i < s.length - b && clusters.minReplaceCount; i++) {\\n        deleteOne(clusters, c);\\n    }\\n    const mustAddCount = !/[a-z]/.test(s) + !/[A-Z]/.test(s) + !/\\\\d/.test(s);\\n    return Math.max(0, s.length - b) + Math.max(a - s.length, mustAddCount, clusters.minReplaceCount);\\n};\\n\\nfunction buildClusters(s, c) {\\n    const clusters = new Array(c).fill(0).map(cl => new Map());\\n    clusters.minReplaceCount = 0;\\n    let re = new RegExp(`(.)\\\\\\\\1{${c - 1},}`, 'g'), match;\\n    while (match = re.exec(s)) {\\n        let len = match[0].length;\\n        clusters[len % c].set(len, (clusters[len % c].get(len) || 0) + 1);\\n        clusters.minReplaceCount += Math.floor(len / c);\\n    }\\n    return clusters;\\n}\\n\\nfunction deleteOne(clusters, c) {\\n    const cluster = clusters.find(cl => cl.size);\\n    for (const [len, count] of cluster) {\\n        cluster.set(len, count - 1);\\n        if (count === 1) cluster.delete(len);\\n        clusters.minReplaceCount -= len % c === 0;\\n        if (len === c) break;\\n        const clusterUpdate = clusters[(len - 1) % c];\\n        clusterUpdate.set(len - 1, (clusterUpdate.get(len - 1) || 0) + 1);\\n        break;\\n    }\\n}\\n```\\nThe answer for `s.length <= b` is straightforward since we needn't make any deletions. It's covered by `Math.max(a - s.length, mustAddCount, clusters.minReplaceCount)` whose components I explain soon.\\n\\nFor `s.length > b` we need to make `s.length - b` deletions, followed by the requisite replacements to satisfy condition #2. However, we must make our deletions prioritizing repeating character clusters which have the smallest length modulo `c`. This is because clusters divisible by `c` will reduce the number of replacements necessary to uncluster them (satisfy condition #3). For example, deleting one character from either of `'aaa'` or `'aaaaaa'` for `c = 3` decrements the necessary replacements, from `1->0` and `2->1` respectively.\\n\\nWe store maps of each cluster type (its length modulo `c`) in the `clusters` array. `clusters.minReplaceCount` tracks the minimum number of replacements to satisfy condition #3 over all clusters. Finally, `mustAddCount` tracks the replacements necessary to satisfy condition #2.\\n\\nThe complexity is O(1) time and space when `s.length <= b` and O(n) time with O(count(clusters)) space when `s.length > b`. Even though `c` is a parameter, we can treat it as a constant with respect to time complexity since c * min(n - b, count(clusters)) is bounded by n (`s.length`).",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strongPasswordChecker = function(s, a = 6, b = 20, c = 3) {\\n    const clusters = buildClusters(s, c);\\n    for (let i = 0; i < s.length - b && clusters.minReplaceCount; i++) {\\n        deleteOne(clusters, c);\\n    }\\n    const mustAddCount = !/[a-z]/.test(s) + !/[A-Z]/.test(s) + !/\\\\d/.test(s);\\n    return Math.max(0, s.length - b) + Math.max(a - s.length, mustAddCount, clusters.minReplaceCount);\\n};\\n\\nfunction buildClusters(s, c) {\\n    const clusters = new Array(c).fill(0).map(cl => new Map());\\n    clusters.minReplaceCount = 0;\\n    let re = new RegExp(`(.)\\\\\\\\1{${c - 1},}`, 'g'), match;\\n    while (match = re.exec(s)) {\\n        let len = match[0].length;\\n        clusters[len % c].set(len, (clusters[len % c].get(len) || 0) + 1);\\n        clusters.minReplaceCount += Math.floor(len / c);\\n    }\\n    return clusters;\\n}\\n\\nfunction deleteOne(clusters, c) {\\n    const cluster = clusters.find(cl => cl.size);\\n    for (const [len, count] of cluster) {\\n        cluster.set(len, count - 1);\\n        if (count === 1) cluster.delete(len);\\n        clusters.minReplaceCount -= len % c === 0;\\n        if (len === c) break;\\n        const clusterUpdate = clusters[(len - 1) % c];\\n        clusterUpdate.set(len - 1, (clusterUpdate.get(len - 1) || 0) + 1);\\n        break;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4026154,
                "title": "c-java-c-c-python",
                "content": "Read Full Article with explaination : https://bit.ly/strong-password-checker",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 357454,
                "title": "java-0ms-o-n-solution-with-video-in-chinese",
                "content": "Video:\\nhttps://youtu.be/bk0Uh0phzG8 \\n```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int len = s.length();\\n        int needTypes = missingTypes(s);\\n        List<Integer> repeatLens = countRepeat(s);\\n        if(len < 6) {\\n            return Math.max(needTypes, 6 - len);\\n        }\\n        else if(len >= 6 && len <= 20) {\\n            int swapCount = 0;\\n            for(int l : repeatLens) swapCount += l / 3;\\n            return Math.max(needTypes, swapCount);\\n        }\\n        else {\\n            int needRemove = len - 20;\\n            int idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                if(l % 3 == 0) {\\n                    needRemove -= 1;\\n                    repeatLens.set(idx, l - 1);\\n                }\\n                idx += 1;\\n            }\\n            idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                if(l % 3 == 1 && needRemove > 1) {\\n                    needRemove -= 2;\\n                    repeatLens.set(idx, l - 2);\\n                }\\n                idx += 1;\\n            }\\n            idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                while(l >= 3 && needRemove >= 3) {\\n                    l -= 3;\\n                    needRemove -= 3;\\n                }\\n                repeatLens.set(idx, l);\\n                idx += 1;\\n            }\\n            int swapCount = 0;\\n            for(int l : repeatLens) swapCount += l / 3;\\n            return Math.max(needTypes, swapCount) + len - 20;\\n            \\n        }\\n    }\\n    \\n    private int missingTypes(String s) {\\n        int needUpper = 1, needLower = 1, needNum = 1;\\n        for(char c : s.toCharArray()) {\\n            if(c >= \\'a\\' && c <= \\'z\\') needLower = 0;\\n            if(c >= \\'A\\' && c <= \\'Z\\') needUpper = 0;\\n            if(c >= \\'0\\' && c <= \\'9\\') needNum = 0;\\n        }\\n        return needUpper + needLower + needNum;\\n    }\\n    \\n    private List<Integer> countRepeat(String s) {\\n        List<Integer> list = new ArrayList<>();\\n        int idx = 1;\\n        int count = 1;\\n        while(idx < s.length()) {\\n            if(s.charAt(idx) == s.charAt(idx - 1)) count += 1;\\n            else {\\n                if(count >= 3) list.add(count);\\n                count = 1;\\n            }\\n            idx++;\\n        }\\n        if(count >= 3) list.add(count);\\n        return list;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        int len = s.length();\\n        int needTypes = missingTypes(s);\\n        List<Integer> repeatLens = countRepeat(s);\\n        if(len < 6) {\\n            return Math.max(needTypes, 6 - len);\\n        }\\n        else if(len >= 6 && len <= 20) {\\n            int swapCount = 0;\\n            for(int l : repeatLens) swapCount += l / 3;\\n            return Math.max(needTypes, swapCount);\\n        }\\n        else {\\n            int needRemove = len - 20;\\n            int idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                if(l % 3 == 0) {\\n                    needRemove -= 1;\\n                    repeatLens.set(idx, l - 1);\\n                }\\n                idx += 1;\\n            }\\n            idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                if(l % 3 == 1 && needRemove > 1) {\\n                    needRemove -= 2;\\n                    repeatLens.set(idx, l - 2);\\n                }\\n                idx += 1;\\n            }\\n            idx = 0;\\n            while(idx < repeatLens.size() && needRemove > 0) {\\n                int l = repeatLens.get(idx);\\n                while(l >= 3 && needRemove >= 3) {\\n                    l -= 3;\\n                    needRemove -= 3;\\n                }\\n                repeatLens.set(idx, l);\\n                idx += 1;\\n            }\\n            int swapCount = 0;\\n            for(int l : repeatLens) swapCount += l / 3;\\n            return Math.max(needTypes, swapCount) + len - 20;\\n            \\n        }\\n    }\\n    \\n    private int missingTypes(String s) {\\n        int needUpper = 1, needLower = 1, needNum = 1;\\n        for(char c : s.toCharArray()) {\\n            if(c >= \\'a\\' && c <= \\'z\\') needLower = 0;\\n            if(c >= \\'A\\' && c <= \\'Z\\') needUpper = 0;\\n            if(c >= \\'0\\' && c <= \\'9\\') needNum = 0;\\n        }\\n        return needUpper + needLower + needNum;\\n    }\\n    \\n    private List<Integer> countRepeat(String s) {\\n        List<Integer> list = new ArrayList<>();\\n        int idx = 1;\\n        int count = 1;\\n        while(idx < s.length()) {\\n            if(s.charAt(idx) == s.charAt(idx - 1)) count += 1;\\n            else {\\n                if(count >= 3) list.add(count);\\n                count = 1;\\n            }\\n            idx++;\\n        }\\n        if(count >= 3) list.add(count);\\n        return list;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91011,
                "title": "java-o-n-simple-solution",
                "content": "Repeating sequences like aaa with len % 3 == 0, we replace by deleting one character. For any repeating sequences aaaa with len % 3 == 1, we can reduce one replacement by deleting two character. For the rest, reduce every replacement by deleting three character.\\n\\nThis is my first post and pls do let me know if any errors or improvements. Thank you\\n\\n~~~\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        \\n        char [] str = s.toCharArray();\\n        boolean isUpper = false, isLower = false, isDigit = false;\\n        int missinType = 3;\\n        for(char c: str)\\n        {\\n            if(!isUpper && Character.isUpperCase(c)) { isUpper = true; missinType-=1; } //uppercase\\n            if(!isLower && Character.isLowerCase(c)) { isLower = true; missinType-=1; } //lowercase\\n            if(!isDigit && Character.isDigit(c)) { isDigit = true; missinType-=1; } //atleast one number\\n            \\n        }\\n       \\n        int totalChangeCnt = 0, OneChangeCnt =0, TwoChangeCnt =0, pos=2;\\n        while(pos < s.length())\\n        {\\n            if(str[pos]==str[pos-1] && str[pos-1]==str[pos-2] && str[pos-2]==str[pos])\\n            {\\n                int length = 2;\\n                while(pos < s.length() && str[pos]==str[pos-1])\\n                {\\n                    length += 1; pos +=1;\\n                }\\n                totalChangeCnt += length/3;\\n                if(length%3==0) OneChangeCnt += 1;\\n                else if(length%3==1) TwoChangeCnt += 1;\\n                \\n            }\\n            else\\n            {\\n                pos=pos+1;\\n            }\\n        }\\n        \\n        if(s.length()<6)\\n            return Math.max(missinType, 6-s.length());\\n        else if(s.length() <=20)\\n            return Math.max(missinType,totalChangeCnt );\\n        else\\n        {\\n            int deleteCount = s.length()-20;\\n            totalChangeCnt -= Math.min(deleteCount,OneChangeCnt*1)/1;\\n            totalChangeCnt -= Math.min(Math.max(deleteCount - OneChangeCnt, 0), TwoChangeCnt * 2) / 2;\\n            totalChangeCnt -= Math.max(deleteCount - OneChangeCnt - 2 * TwoChangeCnt, 0) / 3;\\n            \\n                \\n            return deleteCount + Math.max(missinType, totalChangeCnt);\\n        }       \\n    }\\n}\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    public int strongPasswordChecker(String s) {\\n        \\n        char [] str = s.toCharArray();\\n        boolean isUpper = false, isLower = false, isDigit = false;\\n        int missinType = 3;\\n        for(char c: str)\\n        {\\n            if(!isUpper && Character.isUpperCase(c)) { isUpper = true; missinType-=1; }",
                "codeTag": "Java"
            },
            {
                "id": 2933288,
                "title": "python-3-14-lines-w-brief-explanation-t-m-t-m-91-91",
                "content": "Here\\'s the plan:\\nWe divide the problem into three cases based on `n = len(password)`:\\n- Case 1: `n <   6` : We add enough chars to ensure 1a) the length of the password is greater than 6 and 1b) each category of chars (uppercase, lowercase, digit) are present. \\n- Case 2: `n >  20` : We eliminate `n - 20` chars starting with any triples (ex: \\'aaa\\'), which reduces this case to Case 3, which is...\\n- Case 3: `6 <= n <= 20` : We fix any triples and any missing categories of chars \\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n\\n        pSet, n = set(password), len(password)\\n\\n        catCt = 3- (bool(pSet & set(ascii_lowercase))+ \\n                    bool(pSet & set(ascii_uppercase))+\\n                    bool(pSet & set(\\'0123456789\\'   )))\\n\\n        if n <  6:  return max(6 - n, catCt)        # Case 1\\n\\n        repCt = [len(list(g)) for _, g in groupby(password)]\\n        repCt = [r for r in repCt if r > 2]\\n\\n        if n > 20:                                  # Case 2: reduce to 6<= n <= 20\\n                                                    #         by eliminating triples\\n            repCt = [(r%3, r) for r in repCt]\\n            heapify(repCt)\\n\\n            for i in range(n-20): \\n\\n                if not repCt: break\\n\\n                _, r = heappop(repCt)\\n                if r > 3: heappush(repCt, ((r-1)%3, r-1))\\n\\n            repCt = [r for _,r in repCt]\\n \\n        return max(catCt, sum(r//3 for r in repCt))+max(0,n-20)   # Case3\\n```\\n[https://leetcode.com/problems/strong-password-checker/submissions/862809225/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n\\n        pSet, n = set(password), len(password)\\n\\n        catCt = 3- (bool(pSet & set(ascii_lowercase))+ \\n                    bool(pSet & set(ascii_uppercase))+\\n                    bool(pSet & set(\\'0123456789\\'   )))\\n\\n        if n <  6:  return max(6 - n, catCt)        # Case 1\\n\\n        repCt = [len(list(g)) for _, g in groupby(password)]\\n        repCt = [r for r in repCt if r > 2]\\n\\n        if n > 20:                                  # Case 2: reduce to 6<= n <= 20\\n                                                    #         by eliminating triples\\n            repCt = [(r%3, r) for r in repCt]\\n            heapify(repCt)\\n\\n            for i in range(n-20): \\n\\n                if not repCt: break\\n\\n                _, r = heappop(repCt)\\n                if r > 3: heappush(repCt, ((r-1)%3, r-1))\\n\\n            repCt = [r for _,r in repCt]\\n \\n        return max(catCt, sum(r//3 for r in repCt))+max(0,n-20)   # Case3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315078,
                "title": "strong-password-easy-to-understand-bfs-solution",
                "content": "```\\nclass Solution {\\n    enum class FixType {\\n        REPLACE = 0,\\n        INSERT = 1,\\n        DELETE = 2\\n    };\\n\\n    struct Problems {\\n        int length = 0;\\n        int missing_chars = 0;\\n        std::vector< int > repeats;\\n        \\n        bool empty() const {\\n            return ( length >= 6 && length <= 20 ) && !missing_chars && repeats.empty();\\n        }\\n        \\n        bool apply( FixType fix_type ) {\\n            if( length <= 6 && fix_type == FixType::DELETE ) {\\n                return false;\\n            }\\n            if( length >= 20 && fix_type == FixType::INSERT ) {\\n                return false;\\n            }\\n            \\n            // Insert and Delete affects the length\\n            bool applied = fix_type != FixType::REPLACE;\\n            if( missing_chars && fix_type != FixType::DELETE ) {\\n                missing_chars--;\\n                applied = true;\\n            }\\n            \\n            int repeat = 0;\\n            if( !repeats.empty() ) {\\n                repeat = repeats.back();\\n                repeats.pop_back();\\n                applied = true;\\n            } \\n            switch( fix_type ) {\\n                case FixType::REPLACE:\\n                    // [R,R,#,...]\\n                    repeat -= 3;\\n                    break;\\n                case FixType::INSERT:\\n                    // [R,R,#,R...]\\n                    repeat -= 2;\\n                    length += 1;\\n                    break;\\n                case FixType::DELETE:\\n                    // [R,R,...]\\n                    repeat -= 1;\\n                    length -= 1;\\n                    break;\\n            }\\n            if( repeat >= 3 ) {\\n                repeats.push_back( repeat );\\n            }\\n            return applied;\\n        }\\n    };\\n    \\npublic:\\n    int strongPasswordChecker( const std::string & s ) {\\n        std::queue< Problems > queue( { getProblems( s ) } );\\n        int level = 0;\\n        \\n        while( !queue.empty() ) {\\n            int level_size = queue.size();\\n            for( int i = 0; i < level_size; i++ ) {\\n                Problems problems = queue.front();\\n                queue.pop();\\n                \\n                if( problems.empty() ) {\\n                    return level;\\n                }\\n\\n                for( const FixType & fix_type : { FixType::REPLACE, FixType::INSERT, FixType::DELETE } ) {\\n                    Problems fixed = problems;\\n                    if( fixed.apply( fix_type ) ) {\\n                        queue.push( fixed );\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    \\nprivate:\\n    Problems getProblems( const std::string & s ) {\\n        Problems problems;\\n        int digit = 1;\\n        int lower = 1;\\n        int upper = 1;\\n        for( int i = 0; i < s.size(); ) {\\n            int pos = i;\\n            while( i < s.size() && s[ pos ] == s[ i ] ) {\\n                i++;\\n            }\\n            int length = i - pos;\\n            if( length >= 3 ) {\\n                problems.repeats.push_back( length );\\n            }\\n            \\n            if( std::isdigit( s[ pos ] ) ) {\\n                digit = 0;\\n            }\\n            else if( std::islower( s[ pos ] ) ) {\\n                lower = 0;\\n            }\\n            else if( std::isupper( s[ pos ] ) ) {\\n                upper = 0;\\n            }\\n            problems.length += length;\\n        }\\n        problems.missing_chars = digit + lower + upper;\\n        return problems;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    enum class FixType {\\n        REPLACE = 0,\\n        INSERT = 1,\\n        DELETE = 2\\n    };\\n\\n    struct Problems {\\n        int length = 0;\\n        int missing_chars = 0;\\n        std::vector< int > repeats;\\n        \\n        bool empty() const {\\n            return ( length >= 6 && length <= 20 ) && !missing_chars && repeats.empty();\\n        }\\n        \\n        bool apply( FixType fix_type ) {\\n            if( length <= 6 && fix_type == FixType::DELETE ) {\\n                return false;\\n            }\\n            if( length >= 20 && fix_type == FixType::INSERT ) {\\n                return false;\\n            }\\n            \\n            // Insert and Delete affects the length\\n            bool applied = fix_type != FixType::REPLACE;\\n            if( missing_chars && fix_type != FixType::DELETE ) {\\n                missing_chars--;\\n                applied = true;\\n            }\\n            \\n            int repeat = 0;\\n            if( !repeats.empty() ) {\\n                repeat = repeats.back();\\n                repeats.pop_back();\\n                applied = true;\\n            } \\n            switch( fix_type ) {\\n                case FixType::REPLACE:\\n                    // [R,R,#,...]\\n                    repeat -= 3;\\n                    break;\\n                case FixType::INSERT:\\n                    // [R,R,#,R...]\\n                    repeat -= 2;\\n                    length += 1;\\n                    break;\\n                case FixType::DELETE:\\n                    // [R,R,...]\\n                    repeat -= 1;\\n                    length -= 1;\\n                    break;\\n            }\\n            if( repeat >= 3 ) {\\n                repeats.push_back( repeat );\\n            }\\n            return applied;\\n        }\\n    };\\n    \\npublic:\\n    int strongPasswordChecker( const std::string & s ) {\\n        std::queue< Problems > queue( { getProblems( s ) } );\\n        int level = 0;\\n        \\n        while( !queue.empty() ) {\\n            int level_size = queue.size();\\n            for( int i = 0; i < level_size; i++ ) {\\n                Problems problems = queue.front();\\n                queue.pop();\\n                \\n                if( problems.empty() ) {\\n                    return level;\\n                }\\n\\n                for( const FixType & fix_type : { FixType::REPLACE, FixType::INSERT, FixType::DELETE } ) {\\n                    Problems fixed = problems;\\n                    if( fixed.apply( fix_type ) ) {\\n                        queue.push( fixed );\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    \\nprivate:\\n    Problems getProblems( const std::string & s ) {\\n        Problems problems;\\n        int digit = 1;\\n        int lower = 1;\\n        int upper = 1;\\n        for( int i = 0; i < s.size(); ) {\\n            int pos = i;\\n            while( i < s.size() && s[ pos ] == s[ i ] ) {\\n                i++;\\n            }\\n            int length = i - pos;\\n            if( length >= 3 ) {\\n                problems.repeats.push_back( length );\\n            }\\n            \\n            if( std::isdigit( s[ pos ] ) ) {\\n                digit = 0;\\n            }\\n            else if( std::islower( s[ pos ] ) ) {\\n                lower = 0;\\n            }\\n            else if( std::isupper( s[ pos ] ) ) {\\n                upper = 0;\\n            }\\n            problems.length += length;\\n        }\\n        problems.missing_chars = digit + lower + upper;\\n        return problems;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445690,
                "title": "python-faster-than-99",
                "content": "Similar to other solutions, we can handle this problem with 3 cases:\\nCase 1: len(password) < 6\\nIn this case, we don\\'t need to worry about the repeating characters, because we can insert characters to break it. Let \"missing\" represents the missing types, lower character, upper character, and digits, then,\\nresult = max(missing, 6-len(password))\\n\\nCase 2: 6 <= len(password) <= 20\\nIn this case, every issue can be addressed by replacement. In addition to the missing types, we need to address repeating characters. We can easily find that, when the length of repeating characters is 3, 4, or 5, we need to replace 1 character to resolve it; when the length of repeating character is 6, 7, 8, we need to replace 2 characters, and so on. So, we can keep track of the length of repeating characters, for example:\\npassword = \"bbbccccaaaaaa\"\\nrepeating = [3, 4, 6]\\nand then, \\nreplacement = [1, 1, 2]\\nresult = max(missing, sum(replacement))\\n\\nCase 3: len(password) > 20\\nWe need to delete some characters, and then the problem become case 2. We cannot address missing types with deletion, but we can decide the \"repeating\" array in case 2, so we can minimize the steps. The idea is, for the length in \"repeating\" array:\\nwhen the length%3 == 0, if we decrease lengh by 1, the replacement decreases by 1;\\nwhen the length%3 == 1, we need to decrease length by 2, so that the replacement decreases by 1;\\nwhen the length%3 == 2, we need to decrease length by 3, so that the replacement decreases by 1;\\nSo, in the \"repeating\" array, we first decrease length%3==0, then length%3==1, and lastly length%2 == 2.\\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        lower = any(\\'a\\' <= c <= \\'z\\' for c in password)\\n        upper = any(\\'A\\' <= c <= \\'Z\\' for c in password)\\n        digit = any(c.isdigit() for c in password)\\n        missing = 3 - int(lower) - int(upper) - int(digit)\\n        \\n        # case 1: len < 6\\n        if len(password) < 6:\\n            return max(missing, 6-len(password))\\n        \\n        # case 2: 6 <= len <= 20\\n        i = 2\\n        repeating = []\\n        while i < len(password):\\n            repeat = 2\\n            while i < len(password) and password[i] == password[i-1] == password[i-2]:\\n                repeat += 1\\n                i += 1\\n            if repeat > 2:\\n                repeating.append(repeat)\\n            i += 1\\n        \\n        if len(password) <= 20:\\n            replace = 0\\n            for repeat in repeating:\\n                replace += (repeat // 3)\\n            return max(missing, replace)\\n        \\n        # case 3: len > 20\\n        repeating = [(i%3, i) for i in repeating]\\n        heapq.heapify(repeating)\\n        for i in range(len(password)-20):\\n            if not repeating:\\n                break\\n            length_mod_3, length = heapq.heappop(repeating)\\n            if length-1 >= 3:\\n                heapq.heappush(repeating, ((length-1)%3, length-1))\\n        repeating = [i[1] for i in repeating]\\n        \\n        replace = 0\\n        for repeat in repeating:\\n            replace += (repeat // 3)\\n        return max(missing, replace)+(len(password)-20)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        lower = any(\\'a\\' <= c <= \\'z\\' for c in password)\\n        upper = any(\\'A\\' <= c <= \\'Z\\' for c in password)\\n        digit = any(c.isdigit() for c in password)\\n        missing = 3 - int(lower) - int(upper) - int(digit)\\n        \\n        # case 1: len < 6\\n        if len(password) < 6:\\n            return max(missing, 6-len(password))\\n        \\n        # case 2: 6 <= len <= 20\\n        i = 2\\n        repeating = []\\n        while i < len(password):\\n            repeat = 2\\n            while i < len(password) and password[i] == password[i-1] == password[i-2]:\\n                repeat += 1\\n                i += 1\\n            if repeat > 2:\\n                repeating.append(repeat)\\n            i += 1\\n        \\n        if len(password) <= 20:\\n            replace = 0\\n            for repeat in repeating:\\n                replace += (repeat // 3)\\n            return max(missing, replace)\\n        \\n        # case 3: len > 20\\n        repeating = [(i%3, i) for i in repeating]\\n        heapq.heapify(repeating)\\n        for i in range(len(password)-20):\\n            if not repeating:\\n                break\\n            length_mod_3, length = heapq.heappop(repeating)\\n            if length-1 >= 3:\\n                heapq.heappush(repeating, ((length-1)%3, length-1))\\n        repeating = [i[1] for i in repeating]\\n        \\n        replace = 0\\n        for repeat in repeating:\\n            replace += (repeat // 3)\\n        return max(missing, replace)+(len(password)-20)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919927,
                "title": "python-backtracking-performance-98-99-20ms",
                "content": "Consider the three requirements:\\n+ length of password\\n+ lowercase, uppercase, digit\\n+ no 3 consecutive characters.\\n\\nThe effect of the three changes:\\n+ Insertion: \\n  + `num_passwd+1`; \\n  +  one of `{lowercase, uppercase, digit}` will be met;\\n  +  insert a char every two consective chars to split the substring, e.g., `aaaaa -> aaAaaa -> aaAaa1a`.\\n+ Deletion: \\n  + num_passwd-1;\\n  + deletion cannot split consecutive chars., i.e., `aaaaa -> aaaa -> aaa`.\\n+ Replace: \\n  + one of {lowercase, uppercase, digit} will be met;\\n  + change a char every two consective chars to split the substring, e.g., `aaaaa -> aaAaa`.\\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        len_passwd = len(s)\\n        lowercase, uppercase, digit = False, False, False\\n        repeating = []  # list of interval of consecutive char.\\n        for idx, char in enumerate(s):\\n            if not lowercase and 97 <= ord(char) <= 122:\\n                lowercase = True\\n            if not uppercase and 65 <= ord(char) <= 90:\\n                uppercase = True\\n            if not digit and char in {\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\', \\'0\\'}:\\n                digit = True\\n            if repeating and repeating[-1][1]+1 == idx and s[repeating[-1][1]] == s[idx]:\\n                repeating[-1][1] = idx  # extend the lastest interval\\n            if 0 < idx < len_passwd - 1 and s[idx-1] == s[idx] == s[idx+1] and (not repeating or idx > repeating[-1][1]):\\n                repeating.append([idx-1, idx+1])  # new an interval\\n\\n        @lru_cache(None)\\n        def helper(lenpass, case, repeat):\\n            if 6 <= lenpass <= 20 and case == 3 and repeat == ():\\n                return 0\\n            ans = inf\\n\\t\\t\\t\\n            if lenpass < 6:\\n                # Insertion\\n                if repeat:\\n                    add_repeat = [repeat[0]-2] if repeat[0] > 4 else []\\n                    ans = min(ans, helper(lenpass + 1, min(case + 1, 3), tuple(list(repeat[1:]) + add_repeat)))\\n                else:\\n                    ans = helper(lenpass + 1, min(case + 1, 3), ())\\n            elif lenpass > 20:\\n                # Deletion\\n                if repeat:\\n                    for i in range(len(repeat)):\\n                        repeat_del = list(repeat)\\n                        if repeat_del[i] > 3:\\n                            repeat_del[i] -= 1\\n                        else:\\n                            del repeat_del[i]\\n                        ans = min(ans, helper(lenpass - 1, case, tuple(repeat_del)))\\n                else:\\n                    ans = helper(lenpass - 1, case, ())\\n            else:\\n                # Replace\\n                if repeat:\\n                    add_repeat = [repeat[0]-3] if repeat[0] > 5 else []\\n                    ans = min(ans, helper(lenpass, min(case + 1, 3), tuple(list(repeat[1:]) + add_repeat)))\\n                else:\\n                    ans = helper(lenpass, min(case + 1, 3), ())\\n            return 1 + ans\\n\\n        return helper(len_passwd, sum([lowercase, uppercase, digit]), tuple([term[1]-term[0]+1 for term in repeating]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        len_passwd = len(s)\\n        lowercase, uppercase, digit = False, False, False\\n        repeating = []  # list of interval of consecutive char.\\n        for idx, char in enumerate(s):\\n            if not lowercase and 97 <= ord(char) <= 122:\\n                lowercase = True\\n            if not uppercase and 65 <= ord(char) <= 90:\\n                uppercase = True\\n            if not digit and char in {\\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\', \\'0\\'}:\\n                digit = True\\n            if repeating and repeating[-1][1]+1 == idx and s[repeating[-1][1]] == s[idx]:\\n                repeating[-1][1] = idx  # extend the lastest interval\\n            if 0 < idx < len_passwd - 1 and s[idx-1] == s[idx] == s[idx+1] and (not repeating or idx > repeating[-1][1]):\\n                repeating.append([idx-1, idx+1])  # new an interval\\n\\n        @lru_cache(None)\\n        def helper(lenpass, case, repeat):\\n            if 6 <= lenpass <= 20 and case == 3 and repeat == ():\\n                return 0\\n            ans = inf\\n\\t\\t\\t\\n            if lenpass < 6:\\n                # Insertion\\n                if repeat:\\n                    add_repeat = [repeat[0]-2] if repeat[0] > 4 else []\\n                    ans = min(ans, helper(lenpass + 1, min(case + 1, 3), tuple(list(repeat[1:]) + add_repeat)))\\n                else:\\n                    ans = helper(lenpass + 1, min(case + 1, 3), ())\\n            elif lenpass > 20:\\n                # Deletion\\n                if repeat:\\n                    for i in range(len(repeat)):\\n                        repeat_del = list(repeat)\\n                        if repeat_del[i] > 3:\\n                            repeat_del[i] -= 1\\n                        else:\\n                            del repeat_del[i]\\n                        ans = min(ans, helper(lenpass - 1, case, tuple(repeat_del)))\\n                else:\\n                    ans = helper(lenpass - 1, case, ())\\n            else:\\n                # Replace\\n                if repeat:\\n                    add_repeat = [repeat[0]-3] if repeat[0] > 5 else []\\n                    ans = min(ans, helper(lenpass, min(case + 1, 3), tuple(list(repeat[1:]) + add_repeat)))\\n                else:\\n                    ans = helper(lenpass, min(case + 1, 3), ())\\n            return 1 + ans\\n\\n        return helper(len_passwd, sum([lowercase, uppercase, digit]), tuple([term[1]-term[0]+1 for term in repeating]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482857,
                "title": "rust-0-ms-faster-than-100-00-2-mb-less-than-100-00",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Strong Password Checker.\\nMemory Usage: 2 MB, less than 100.00% of Rust online submissions for Strong Password Checker.\\n\\n```\\npub fn repeat_count(password:&String) -> Vec<i32>{\\n    let mut result = Vec::new();\\n    let mut currect = 1;\\n    for i in 0..password.len() - 1{\\n        if password[i..i+1] == password[i+1..i+2]{\\n            currect += 1;\\n        }\\n        else{\\n            if currect >= 3{\\n                result.push(currect);\\n            }\\n            currect = 1;\\n        }\\n    }\\n    if currect >= 3{\\n        result.push(currect);\\n    }\\n    result\\n}\\n\\npub fn replace_count(mut vec_count: Vec<i32>, mut del: i32, add: i32, rep: i32, sort_switch: bool) -> i32{\\n    if vec_count.len() == 0{\\n        return 0;\\n    }\\n    if sort_switch{\\n        vec_count.sort();\\n    }\\n    if add >= 2 || (add == 1 && rep == 1) || (add == 1 && rep == 0 && vec_count[0] < 5){\\n        return 0;\\n    }\\n    if add == 1 && rep == 0 && vec_count[0] == 5{\\n        return 1;\\n    }\\n    if del == 0{\\n        let mut result_count = 0;\\n        for i in vec_count{\\n            result_count += i / 3;\\n        }\\n        if result_count >= rep{\\n            return result_count - rep;\\n        }\\n        return 0;\\n    }\\n\\n    \\'loop1: for currcet_index in 1..=3{\\n        while del >= currcet_index && vec_count[0] == 2 + currcet_index{\\n            del -= currcet_index;\\n            vec_count.remove(0);\\n            if vec_count.len() == 0{\\n                return 0;\\n            }\\n        }\\n        if del < currcet_index{\\n            break;\\n        }\\n        for i in 0..vec_count.len(){\\n            while vec_count[i] % 3 == (currcet_index - 1){\\n                if vec_count[i] == 2 + currcet_index{\\n                    break;\\n                }\\n                vec_count[i] -= currcet_index;\\n                del -= currcet_index;\\n                if del < currcet_index{\\n                    break \\'loop1;\\n                }\\n            }\\n        }\\n    }\\n    let mut result_count = 0;\\n    for i in vec_count{\\n        result_count += i / 3;\\n    }\\n    if result_count >= rep{\\n        return result_count - rep;\\n    }\\n    return 0;\\n}\\n\\npub fn compu_type_count(password:&String) -> i32{\\n    let mut lower_case = 0;\\n    let mut upper_case=0;\\n    let mut digit = 0;\\n    let mut total = 0;\\n    for i in password.as_bytes(){\\n        if *i >= 48 && *i <= 57{\\n            if digit == 0{\\n                digit = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n        if *i >= 65 && *i <= 90{\\n            if upper_case == 0{\\n                upper_case = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n        if *i >= 97 && *i <= 122{\\n            if lower_case == 0{\\n                lower_case = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n    }\\n    return total;\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let new_length = password.len() as i32;\\n        if new_length > 20{\\n            let rep = 3 - compu_type_count(&password);\\n            let del = new_length - 20;\\n            let vec_count = repeat_count(&password);\\n            return rep + del + replace_count(vec_count, del, 0, rep, true);\\n        }\\n        else if new_length < 6{\\n            let add = 6 - new_length;\\n            let type_add = 3 - compu_type_count(&password);\\n            let rep = \\n            if type_add <= add{\\n                0\\n            }\\n            else{\\n                type_add - add\\n            };\\n            return add + rep + replace_count(repeat_count(&password), 0, add, rep, true);\\n        }\\n        else{\\n            let rep = 3 - compu_type_count(&password);\\n            let vec_count = repeat_count(&password);\\n            return rep + replace_count(vec_count, 0, 0, rep, true);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn repeat_count(password:&String) -> Vec<i32>{\\n    let mut result = Vec::new();\\n    let mut currect = 1;\\n    for i in 0..password.len() - 1{\\n        if password[i..i+1] == password[i+1..i+2]{\\n            currect += 1;\\n        }\\n        else{\\n            if currect >= 3{\\n                result.push(currect);\\n            }\\n            currect = 1;\\n        }\\n    }\\n    if currect >= 3{\\n        result.push(currect);\\n    }\\n    result\\n}\\n\\npub fn replace_count(mut vec_count: Vec<i32>, mut del: i32, add: i32, rep: i32, sort_switch: bool) -> i32{\\n    if vec_count.len() == 0{\\n        return 0;\\n    }\\n    if sort_switch{\\n        vec_count.sort();\\n    }\\n    if add >= 2 || (add == 1 && rep == 1) || (add == 1 && rep == 0 && vec_count[0] < 5){\\n        return 0;\\n    }\\n    if add == 1 && rep == 0 && vec_count[0] == 5{\\n        return 1;\\n    }\\n    if del == 0{\\n        let mut result_count = 0;\\n        for i in vec_count{\\n            result_count += i / 3;\\n        }\\n        if result_count >= rep{\\n            return result_count - rep;\\n        }\\n        return 0;\\n    }\\n\\n    \\'loop1: for currcet_index in 1..=3{\\n        while del >= currcet_index && vec_count[0] == 2 + currcet_index{\\n            del -= currcet_index;\\n            vec_count.remove(0);\\n            if vec_count.len() == 0{\\n                return 0;\\n            }\\n        }\\n        if del < currcet_index{\\n            break;\\n        }\\n        for i in 0..vec_count.len(){\\n            while vec_count[i] % 3 == (currcet_index - 1){\\n                if vec_count[i] == 2 + currcet_index{\\n                    break;\\n                }\\n                vec_count[i] -= currcet_index;\\n                del -= currcet_index;\\n                if del < currcet_index{\\n                    break \\'loop1;\\n                }\\n            }\\n        }\\n    }\\n    let mut result_count = 0;\\n    for i in vec_count{\\n        result_count += i / 3;\\n    }\\n    if result_count >= rep{\\n        return result_count - rep;\\n    }\\n    return 0;\\n}\\n\\npub fn compu_type_count(password:&String) -> i32{\\n    let mut lower_case = 0;\\n    let mut upper_case=0;\\n    let mut digit = 0;\\n    let mut total = 0;\\n    for i in password.as_bytes(){\\n        if *i >= 48 && *i <= 57{\\n            if digit == 0{\\n                digit = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n        if *i >= 65 && *i <= 90{\\n            if upper_case == 0{\\n                upper_case = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n        if *i >= 97 && *i <= 122{\\n            if lower_case == 0{\\n                lower_case = 1;\\n                total += 1;\\n                if total == 3{\\n                    return 3;\\n                }\\n                continue;\\n            }\\n        }\\n    }\\n    return total;\\n}\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let new_length = password.len() as i32;\\n        if new_length > 20{\\n            let rep = 3 - compu_type_count(&password);\\n            let del = new_length - 20;\\n            let vec_count = repeat_count(&password);\\n            return rep + del + replace_count(vec_count, del, 0, rep, true);\\n        }\\n        else if new_length < 6{\\n            let add = 6 - new_length;\\n            let type_add = 3 - compu_type_count(&password);\\n            let rep = \\n            if type_add <= add{\\n                0\\n            }\\n            else{\\n                type_add - add\\n            };\\n            return add + rep + replace_count(repeat_count(&password), 0, add, rep, true);\\n        }\\n        else{\\n            let rep = 3 - compu_type_count(&password);\\n            let vec_count = repeat_count(&password);\\n            return rep + replace_count(vec_count, 0, 0, rep, true);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1072622,
                "title": "c-0ms-o-n-clean-code-with-comment-31-lines",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string& s) {\\n        int len[50 / 3], cnt = 0;                    // lengths of each group of more than 2 same characters\\n        bool digit = false, lower = false, upper = false;\\n        for (unsigned i = 0, j; i < s.size(); i = j) {\\n            digit = digit || isdigit(s[i]);\\n            lower = lower || islower(s[i]);\\n            upper = upper || isupper(s[i]);\\n            for (j = i + 1; j < s.size() && s[j] == s[i]; ++j);\\n            if (j - i >= 3) len[cnt++] = j - i;\\n        }\\n        int con = (!digit) + (!lower) + (!upper);    // need more condictions to be satisfied\\n        int ins = s.size() < 6  ? 6 - s.size()  : 0; // need more insertions\\n        int del = s.size() > 20 ? s.size() - 20 : 0; // need more deletions\\n        int res = 0;                                 // operations have been done\\n        for (int i = 0; i < cnt; ++i) {\\n            while (len[i] >= 3 && ins > 0) { // Insert a character between same characters when more insertion is needed.\\n                ++res;\\n                --ins;\\n                len[i] -= 2;                 // Reduces the length of same characters by 2, eg. \"AAAA...\" -> \"AAaAA...\".\\n                if (con) --con;              // We can always find a character that satisfies more condiction.\\n            }\\n            while (len[i] >= 3 && con > 0) { // Replace a character in row of same characters to satisfy more condiction.\\n                ++res;\\n                --con;\\n                len[i] -= 3;                 // Reduces the length of same characters by 3, eg. \"AAAA...\" -> \"AAaA...\".\\n            }\\n        }\\n        // Then if it need deletions, we should first delete characters from the same N (N>=3)\\n        // characters in a row which N % 3 == 0, then N % 3 == 1 and N % 3 == 2.\\n        // Because K replacements are needed to separate k*3 same characters but K-1 replacements are need for K*3-1 same characters.\\n        // For example, 2 characters must be deleted from \"AAAAAA789012345678aAAA\" since its length is 22.\\n        // If two \\'A\\' characters are deleted from front, 2 more replacements are needed.\\n        // But if one \\'A\\' is deleted from front and the other from back, only 1 replacement is needed.\\n        for (int mod = 0; mod < 3; ++mod) {\\n            for (int i = 0; i < cnt; ++i) {\\n                while (len[i] >= 3 && del > mod && len[i] % 3 == mod) {\\n                    res += mod + 1;\\n                    del -= mod + 1;\\n                    len[i] -= mod + 1;\\n                }\\n            }\\n        }\\n        con -= min(con, ins);                            // More insertions can satisfy one more condictions.\\n        for (int i = 0; i < cnt; ++i) res += len[i] / 3; // Perform additional replacements to separete same characters.\\n        return res + ins + con + del;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string& s) {\\n        int len[50 / 3], cnt = 0;                    // lengths of each group of more than 2 same characters\\n        bool digit = false, lower = false, upper = false;\\n        for (unsigned i = 0, j; i < s.size(); i = j) {\\n            digit = digit || isdigit(s[i]);\\n            lower = lower || islower(s[i]);\\n            upper = upper || isupper(s[i]);\\n            for (j = i + 1; j < s.size() && s[j] == s[i]; ++j);\\n            if (j - i >= 3) len[cnt++] = j - i;\\n        }\\n        int con = (!digit) + (!lower) + (!upper);    // need more condictions to be satisfied\\n        int ins = s.size() < 6  ? 6 - s.size()  : 0; // need more insertions\\n        int del = s.size() > 20 ? s.size() - 20 : 0; // need more deletions\\n        int res = 0;                                 // operations have been done\\n        for (int i = 0; i < cnt; ++i) {\\n            while (len[i] >= 3 && ins > 0) { // Insert a character between same characters when more insertion is needed.\\n                ++res;\\n                --ins;\\n                len[i] -= 2;                 // Reduces the length of same characters by 2, eg. \"AAAA...\" -> \"AAaAA...\".\\n                if (con) --con;              // We can always find a character that satisfies more condiction.\\n            }\\n            while (len[i] >= 3 && con > 0) { // Replace a character in row of same characters to satisfy more condiction.\\n                ++res;\\n                --con;\\n                len[i] -= 3;                 // Reduces the length of same characters by 3, eg. \"AAAA...\" -> \"AAaA...\".\\n            }\\n        }\\n        // Then if it need deletions, we should first delete characters from the same N (N>=3)\\n        // characters in a row which N % 3 == 0, then N % 3 == 1 and N % 3 == 2.\\n        // Because K replacements are needed to separate k*3 same characters but K-1 replacements are need for K*3-1 same characters.\\n        // For example, 2 characters must be deleted from \"AAAAAA789012345678aAAA\" since its length is 22.\\n        // If two \\'A\\' characters are deleted from front, 2 more replacements are needed.\\n        // But if one \\'A\\' is deleted from front and the other from back, only 1 replacement is needed.\\n        for (int mod = 0; mod < 3; ++mod) {\\n            for (int i = 0; i < cnt; ++i) {\\n                while (len[i] >= 3 && del > mod && len[i] % 3 == mod) {\\n                    res += mod + 1;\\n                    del -= mod + 1;\\n                    len[i] -= mod + 1;\\n                }\\n            }\\n        }\\n        con -= min(con, ins);                            // More insertions can satisfy one more condictions.\\n        for (int i = 0; i < cnt; ++i) res += len[i] / 3; // Perform additional replacements to separete same characters.\\n        return res + ins + con + del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824631,
                "title": "c-0ms-o-n-solution-with-explanation",
                "content": "One solution to this problem is to count the number of errors and \"merge\" as many errors as we can.\\n\\nRepeat errors are defined as how many letters need to be changed to fit the repeat rule.\\nLowercase, uppercase and digit errors are defined by how many of the 3 are missing.\\nSize errors are defined as 0 or the distance from n to an acceptable size. So n = 4 -> 2 and n = 22 -> -2.\\n\\nWe need to notice that the following can be merged\\n1. repeating letters, and missing lowercase, uppercase and digits\\n2. missing letters (n < 6) can be merged with above\\n3. extra letters can be merged with repeating letters\\n\\nLets first consider the case n < 6 or 6 <= n <= 20. If we have any errors we only need to find the maximum of them.\\n\\n\"aaaaaa\" -> \"aa1aaA\" \\nRepeat = 2, Missing = 2, Size = 0, Error = 2\\nIn this example we see that we can merge errors from missing cases into repeating errors because it only requires a replacement.\\n\\n\"aa\" -> \"aaA1bc\"\\nRepeat = 0, Missing = 2, Size = 4, Error = 4\\nIn this example we can see that missing cases can be merged into size errors because the right insertion can fix both errors at the same time.\\n\\nThe harder case is when n > 20. Merging here is harder to keep track of and the rules from above may not apply because we can\\'t simply insert. Missing cases can still be merged with repeat errors but they can not be merged with size errors because we are deleting instead of inserting.\\n\\n\"aaa\" -> 1 deletion\\n\"aaaa\" -> 2 deletions\\n\"aaaaa\" -> 3 deletions\\n\\nHere we have to consider the maximum amount of repeat errors we can merge into size errors. When we count the number of repeat errors we can keep a sorted list of the repeats we can fix with < 3 deletions. After those are gone the amount of deletions per repeat goes to 3. Since repeat errors and missing case errors still work the same we can merge them but only after we delete the number of repeat errors we can fix by deleting.\\n\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bool lower = false;\\n        bool upper = false;\\n        bool digit = false;\\n        \\n        int repeating = 0;\\n        \\n        int n = s.size();\\n        \\n        vector<int> toRemove(3, 0);\\n        \\n        for(int i = 0; i < n;) {\\n            //Check if character is lowercase, uppercase, or digit and set those to true\\n            char c = s[i];\\n            if(48 <= c && c <= 57) {\\n                digit = true;\\n            } else if(65 <= c && c <= 90) {\\n                upper = true;\\n            } else if(97 <= c && c <= 122) {\\n                lower = true;\\n            }\\n            \\n            \\n            //count how many repeating numbers we have\\n            int counter = 1;\\n            while(i + counter < n && s[i + counter] == s[i]) {\\n                counter++;\\n            }\\n            \\n            //number of repeat errors goes up by 1 for every 3 repeating\\n            int errors = counter / 3;\\n            repeating += errors;\\n            \\n            //if we have a repeat error than push to a heap the number of deletions we need to \\n            //remove a repeat error\\n            if(errors) {\\n                //maps 0 -> 1, 1 -> 2, 2 -> 3\\n                toRemove[(counter % 3)]++;\\n                toRemove[2] += errors - 1;\\n            }\\n            \\n            i += counter;\\n        }\\n        \\n        //count missing cases\\n        int toAdd = !lower + !upper + !digit;\\n        \\n        //get size error. 0 if there are no errors\\n        int toSize = 0;\\n        if(n > 20) {\\n            toSize = 20 - n;\\n        } else if(n < 6) {\\n            toSize = 6 - n;\\n        }\\n        \\n        if(toSize < 0) {\\n            //case n > 20\\n            \\n            int tmpSize = -toSize;\\n            //remove duplicates of (i + 1) size\\n            for(int i = 0; i <= 2; ++i) {\\n                int removed = min(tmpSize / (i + 1), toRemove[i]);\\n                tmpSize -= removed * (i + 1);\\n                repeating -= removed;\\n            }\\n            \\n            //if we have any case errors we can merge them with\\n            //repeat errors\\n            return max(toAdd, repeating) - toSize;\\n            \\n        } else {\\n            //case n <= 20\\n            //the error is simply the max becauses we can merge\\n            //every error with pretty much no consequence\\n            return max(toSize, max(toAdd, repeating));\\n        }\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bool lower = false;\\n        bool upper = false;\\n        bool digit = false;\\n        \\n        int repeating = 0;\\n        \\n        int n = s.size();\\n        \\n        vector<int> toRemove(3, 0);\\n        \\n        for(int i = 0; i < n;) {\\n            //Check if character is lowercase, uppercase, or digit and set those to true\\n            char c = s[i];\\n            if(48 <= c && c <= 57) {\\n                digit = true;\\n            } else if(65 <= c && c <= 90) {\\n                upper = true;\\n            } else if(97 <= c && c <= 122) {\\n                lower = true;\\n            }\\n            \\n            \\n            //count how many repeating numbers we have\\n            int counter = 1;\\n            while(i + counter < n && s[i + counter] == s[i]) {\\n                counter++;\\n            }\\n            \\n            //number of repeat errors goes up by 1 for every 3 repeating\\n            int errors = counter / 3;\\n            repeating += errors;\\n            \\n            //if we have a repeat error than push to a heap the number of deletions we need to \\n            //remove a repeat error\\n            if(errors) {\\n                //maps 0 -> 1, 1 -> 2, 2 -> 3\\n                toRemove[(counter % 3)]++;\\n                toRemove[2] += errors - 1;\\n            }\\n            \\n            i += counter;\\n        }\\n        \\n        //count missing cases\\n        int toAdd = !lower + !upper + !digit;\\n        \\n        //get size error. 0 if there are no errors\\n        int toSize = 0;\\n        if(n > 20) {\\n            toSize = 20 - n;\\n        } else if(n < 6) {\\n            toSize = 6 - n;\\n        }\\n        \\n        if(toSize < 0) {\\n            //case n > 20\\n            \\n            int tmpSize = -toSize;\\n            //remove duplicates of (i + 1) size\\n            for(int i = 0; i <= 2; ++i) {\\n                int removed = min(tmpSize / (i + 1), toRemove[i]);\\n                tmpSize -= removed * (i + 1);\\n                repeating -= removed;\\n            }\\n            \\n            //if we have any case errors we can merge them with\\n            //repeat errors\\n            return max(toAdd, repeating) - toSize;\\n            \\n        } else {\\n            //case n <= 20\\n            //the error is simply the max becauses we can merge\\n            //every error with pretty much no consequence\\n            return max(toSize, max(toAdd, repeating));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750932,
                "title": "c-the-shortest-solution-with-explanation-0ms",
                "content": "First of all, let\\'s try to split string to substrings where all characters are the same.\\nAlso, count all digits, lowers, uppers. Count replacements (you can change the middle char for every 3 characters) and remainders (for \\'aaa\\' it will be 1, for \\'aaaa\\' it will be two) to make substr shorter then 3.\\n\\nThen count how many chars you need to add or delete.\\nFinally, optimize number of replacements. If you need to delete characters, these deletions can be used instead of replacements (for \\'aaa\\' substring you can delete 1 char instead of 1 replacement, for \\'aaaa\\' you can delete 2 chars instead of 1 replacement, for the rest of deletions you can cover 1 replacement for 3 deletions).\\n\\n```\\nint strongPasswordChecker(string s, int minimum = 6, int maximum = 20) \\n{\\n    string_view sv = s;\\n\\tint replacements = 0, size = s.size();\\n\\tvector<int> remainders { 0, 0, 10000 }, counts { 0, 0, 0 };\\n    vector<string_view> repetetives;\\n        \\n\\tfor (int i = 0, start = 0; i < sv.size(); ++i)\\n\\t\\tif (i == sv.size() - 1 || sv[i] != sv[i + 1])\\n\\t\\t\\trepetetives.push_back(sv.substr(start, i - start + 1)), start = i + 1;\\n\\n\\tfor (auto & repetetive : repetetives)\\n\\t{\\n\\t\\tauto ch = repetetive.front();\\n\\t\\tcounts[0] += isdigit(ch), counts[1] += isupper(ch), counts[2] += islower(ch);\\n\\n\\t\\treplacements += repetetive.size() / 3;\\n\\t\\tif (repetetive.size() >= 3) remainders[repetetive.size() % 3]++;\\n\\t}\\n\\n\\tint deletions = max(0, size - maximum);\\n\\tint additions = max((int) count(counts.begin(), counts.end(), 0), minimum - size);\\n\\n\\tfor (int i = 0, d = deletions; i < remainders.size(); d = max(d - remainders[i] * (i + 1), 0), i++)\\n\\t\\treplacements -= min(remainders[i], d / (i + 1));\\n\\n\\treturn deletions + max(replacements, additions); \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint strongPasswordChecker(string s, int minimum = 6, int maximum = 20) \\n{\\n    string_view sv = s;\\n\\tint replacements = 0, size = s.size();\\n\\tvector<int> remainders { 0, 0, 10000 }, counts { 0, 0, 0 };\\n    vector<string_view> repetetives;\\n        \\n\\tfor (int i = 0, start = 0; i < sv.size(); ++i)\\n\\t\\tif (i == sv.size() - 1 || sv[i] != sv[i + 1])\\n\\t\\t\\trepetetives.push_back(sv.substr(start, i - start + 1)), start = i + 1;\\n\\n\\tfor (auto & repetetive : repetetives)\\n\\t{\\n\\t\\tauto ch = repetetive.front();\\n\\t\\tcounts[0] += isdigit(ch), counts[1] += isupper(ch), counts[2] += islower(ch);\\n\\n\\t\\treplacements += repetetive.size() / 3;\\n\\t\\tif (repetetive.size() >= 3) remainders[repetetive.size() % 3]++;\\n\\t}\\n\\n\\tint deletions = max(0, size - maximum);\\n\\tint additions = max((int) count(counts.begin(), counts.end(), 0), minimum - size);\\n\\n\\tfor (int i = 0, d = deletions; i < remainders.size(); d = max(d - remainders[i] * (i + 1), 0), i++)\\n\\t\\treplacements -= min(remainders[i], d / (i + 1));\\n\\n\\treturn deletions + max(replacements, additions); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91020,
                "title": "very-easy-and-simple-o-n-solution-python-java",
                "content": "**Analysis/Usage of 3 operations:**\\nInsert: Able to fix repeat and add missing element (e.g. uppercase/lowercase/digit) => only use in case **A**.\\nDelete: Able to fix repeat (by certain number) => only use it in case **B**.\\nReplace: Able to fix repeat and add missing element  => use in **A/B/C**\\n\\n**Steps:**\\n1. Check the of type of characters(uppercase/lowercase/digit/others) and get length of repeats. O(n)\\n2. **Fix repeat** in Three different cases:\\n* case A. (L < 6): Not only Repeat but also Missing element can be fixed by insert at same time. O(1)\\n* case B. (L > 20): Fix by delete (and replace if needed). O(occurance of repeat)\\n* case C. (6 <= L <= 20): Should be fixed by replace only. O(occurance of repeat)\\n\\n3. Final check (**Fix missing element**): If still any missing => fix it by replace. ~O(1)\\n\\nDetailed explanation can be referred to comments.\\n\\n**EDIT:**\\nWrote this long time ago. The original code can pass the submission, however, thanks for [@alabdulkareem\\'s comment](https://leetcode.com/problems/strong-password-checker/discuss/91020/Very-Easy-and-Simple-O(n)-solution-(20-lines-Python-Java)/666561) to provide an edge case that my solution didn\\'t cover: which falls into the case B in the origian post.\\n\\nIn case B, we can use either delete or remoal. We need to handle the delete as priority, because of the size limit we need to remove some characters for sure. Since we already have plenty repeats at hand, (e.g. \"aaaabbbbcccccc\", repeat = [4,4,6]) the best scenario is to remove those r%3 == 0, which can save us one removal with one deletion. The second best scenario is to remove those r%3 == 1, with 2 deletions we can save one removal. so on and so forth.\\n\\nPython:\\n\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        length, repeat, types, i, j = len(s), [], [False]*4, 0, 1\\n\\n        while i < length:\\n            while i+j < length and s[i+j] == s[i]: j += 1\\n            if j >= 3: repeat += j,                     # get repeats\\n            types[self.classifier(s[i])] = True         # check lower/upper/digit\\n            i, j = i+j, 1\\n\\n        insert, delete, replace = 0, 0, 0\\n        \\n        if length < 6: insert = 6-length                # Case A.\\n        \\n        elif length > 20:   # Case B. Fix repeat by (replace+delete), should > all solve by replace\\n\\t\\t\\n\\t\\t\\t# original post\\n            # delete, allbydel = length-20, sum([r-2 for r in repeat])\\n            # if delete < allbydel:     # repeat solved by both delete and replace\\n            #     replace = max(sum([r//3 for r in repeat])-delete, ((allbydel-delete)+2)//3)\\n\\n            # START OF EDIT\\n\\t\\t\\tdelete = length-20\\n            repeat = [(i%3, i) for i in repeat]\\n            heapq.heapify(repeat)\\n            for i in range(delete):\\n                if not repeat:\\n                    break\\n                length_mod_3, length = heapq.heappop(repeat)\\n                if length-1 >= 3:\\n                    heapq.heappush(repeat, ((length-1)%3, length-1))\\n            repeat = [i[1] for i in repeat]\\n\\t\\t\\treplace = sum([r//3 for r in repeat]\\n\\t\\t\\t# END OF EDIT\\n\\n        else:               # Case C. fix repeat only by replace\\n            for rp in repeat: replace += rp//3\\n\\n        # final check: if replace less than missing\\n        return insert+delete+max(replace, types[:-1].count(False)-insert)\\n\\n    def classifier(self, c):\\n        # types: 0 = lowercase, 1 = uppercase, 2 = digit, 3 = others (None of above)\\n        if c.islower(): return 0\\n        elif c.isupper(): return 1\\n        elif c.isdigit(): return 2\\n        else: return 3\\n```\\n\\nJava Version: (I think it should be able to do some improvement)\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int length = s.length();\\n        ArrayList<Integer> rptlen = new ArrayList<Integer>();\\n        Boolean[] types = {false, false, false, false};\\n        int i = 0;\\n        int j = 1;\\n\\n        while (i < length) {\\n            while ((i+j < length) && (s.charAt(i) == s.charAt(i+j))) {j += 1;}\\n            if (j >= 3) {\\n                rptlen.add(j);\\n            }\\n            int tmp = classifier(s.charAt(i));\\n            types[tmp] = true;\\n            i += j;\\n            j = 1;\\n        }\\n        Integer[] work = {0,0,0};       // insert, delete, replace\\n        if (length < 6) {\\n            work[0] = 6-length;\\n        }\\n        else if (length > 20) {\\n            work[1] = length-20;\\n            int allbydel = 0;\\n            int tmp = 0;\\n            for (int k = 0; k < rptlen.size(); k++) {\\n                allbydel += (rptlen.get(k)-2);\\n                tmp += rptlen.get(k)/3;\\n            }\\n            if (work[1] < allbydel) {\\n                work[2] = Math.max(tmp-work[1], (allbydel-work[1]+2)/3);\\n            }\\n        }\\n        else {\\n            for (int x = 0; x < rptlen.size(); x++) {\\n                work[2] += rptlen.get(x)/3;\\n            }\\n        }\\n\\n        int countmiss = 0;\\n        for (int t = 0; t < 3; t ++) { if (types[t] == false) countmiss++;}\\n        return work[0]+work[1]+Math.max(work[2], countmiss-work[0]);\\n    }\\n    private int classifier(char c) {\\n        if (Character.isUpperCase(c)) return 0;\\n        else if (Character.isLowerCase(c)) return 1;\\n        else if (Character.isDigit(c)) return 2;\\n        else return 3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        length, repeat, types, i, j = len(s), [], [False]*4, 0, 1\\n\\n        while i < length:\\n            while i+j < length and s[i+j] == s[i]: j += 1\\n            if j >= 3: repeat += j,                     # get repeats\\n            types[self.classifier(s[i])] = True         # check lower/upper/digit\\n            i, j = i+j, 1\\n\\n        insert, delete, replace = 0, 0, 0\\n        \\n        if length < 6: insert = 6-length                # Case A.\\n        \\n        elif length > 20:   # Case B. Fix repeat by (replace+delete), should > all solve by replace\\n\\t\\t\\n\\t\\t\\t# original post\\n            # delete, allbydel = length-20, sum([r-2 for r in repeat])\\n            # if delete < allbydel:     # repeat solved by both delete and replace\\n            #     replace = max(sum([r//3 for r in repeat])-delete, ((allbydel-delete)+2)//3)\\n\\n            # START OF EDIT\\n\\t\\t\\tdelete = length-20\\n            repeat = [(i%3, i) for i in repeat]\\n            heapq.heapify(repeat)\\n            for i in range(delete):\\n                if not repeat:\\n                    break\\n                length_mod_3, length = heapq.heappop(repeat)\\n                if length-1 >= 3:\\n                    heapq.heappush(repeat, ((length-1)%3, length-1))\\n            repeat = [i[1] for i in repeat]\\n\\t\\t\\treplace = sum([r//3 for r in repeat]\\n\\t\\t\\t# END OF EDIT\\n\\n        else:               # Case C. fix repeat only by replace\\n            for rp in repeat: replace += rp//3\\n\\n        # final check: if replace less than missing\\n        return insert+delete+max(replace, types[:-1].count(False)-insert)\\n\\n    def classifier(self, c):\\n        # types: 0 = lowercase, 1 = uppercase, 2 = digit, 3 = others (None of above)\\n        if c.islower(): return 0\\n        elif c.isupper(): return 1\\n        elif c.isdigit(): return 2\\n        else: return 3\\n```\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int length = s.length();\\n        ArrayList<Integer> rptlen = new ArrayList<Integer>();\\n        Boolean[] types = {false, false, false, false};\\n        int i = 0;\\n        int j = 1;\\n\\n        while (i < length) {\\n            while ((i+j < length) && (s.charAt(i) == s.charAt(i+j))) {j += 1;}\\n            if (j >= 3) {\\n                rptlen.add(j);\\n            }\\n            int tmp = classifier(s.charAt(i));\\n            types[tmp] = true;\\n            i += j;\\n            j = 1;\\n        }\\n        Integer[] work = {0,0,0};       // insert, delete, replace\\n        if (length < 6) {\\n            work[0] = 6-length;\\n        }\\n        else if (length > 20) {\\n            work[1] = length-20;\\n            int allbydel = 0;\\n            int tmp = 0;\\n            for (int k = 0; k < rptlen.size(); k++) {\\n                allbydel += (rptlen.get(k)-2);\\n                tmp += rptlen.get(k)/3;\\n            }\\n            if (work[1] < allbydel) {\\n                work[2] = Math.max(tmp-work[1], (allbydel-work[1]+2)/3);\\n            }\\n        }\\n        else {\\n            for (int x = 0; x < rptlen.size(); x++) {\\n                work[2] += rptlen.get(x)/3;\\n            }\\n        }\\n\\n        int countmiss = 0;\\n        for (int t = 0; t < 3; t ++) { if (types[t] == false) countmiss++;}\\n        return work[0]+work[1]+Math.max(work[2], countmiss-work[0]);\\n    }\\n    private int classifier(char c) {\\n        if (Character.isUpperCase(c)) return 0;\\n        else if (Character.isLowerCase(c)) return 1;\\n        else if (Character.isDigit(c)) return 2;\\n        else return 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421309,
                "title": "0ms-rust-solution-with-explanatory-comments",
                "content": "Tried to write a relatively clean solution that also shows the thought process and how cases are handled. It took ~130 lines and may not be the best solution. It\\'s the fastest solution though, at 0ms.\\n\\n```rust\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        // This is the change needed in the length of the password\\n        // to fit in the declared criterion.\\n        let mut char_change = loop {\\n           let len = password.len() as i32;\\n            if len < 6 {\\n                break 6-len;\\n            }\\n            if len > 20 {\\n                break 20-len;\\n            }\\n            break 0;\\n        }; \\n        \\n        \\n        // These are 1 when we need to add the char class, 0 otherwise.\\n        let should_add_lowercase = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_lowercase() {0} else {1}});\\n        let should_add_uppercase = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_uppercase() {0} else {1}});\\n        let should_add_digit = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_digit() {0} else {1}});\\n\\n        // We create an array of tuples that represent consecutive characters of length\\n        // more than 3.\\n        let mut consecutives = {\\n            let mut consecutives = Vec::new();\\n            let mut consecutive: (char, u8) = (\\' \\', 0);\\n\\n            for chr in password.chars() {\\n                if consecutive.0 == chr {\\n                    consecutive.1 += 1;\\n                }\\n                else {\\n                    if consecutive.1 > 2 {\\n                        consecutives.push(consecutive);\\n                    }\\n                    consecutive = (chr, 1);\\n                }\\n            }\\n            if consecutive.1 > 2 {\\n                consecutives.push(consecutive);\\n            }\\n            consecutives\\n        };\\n        \\n        if char_change > 0 {\\n            // Missing chars can be added and consecutive problems can be solved in char_change moves if char_change >= 3.\\n            // If it\\'s 2, missings might be bigger but consecutives is still within this limit.\\n            // If it\\'s 1, there might be a consecutive of 5 which needs 2 changes but if that\\'s the case the addition of 3 missings\\' variables will be bigger than or equal to 2.\\n            return (should_add_lowercase + should_add_uppercase + should_add_digit).max(char_change);\\n        }\\n        \\n        let mut removed = 0;\\n        \\n        if char_change < 0 {\\n\\t\\t    // Aim here is to move toward making every consecutive be 2 mod 3.\\n            // This is optimal because at 2 mod 3 we\\'ve used the least amount of removals to \\n            // decrease the most amount of operations needed in the future for each consecutive.\\n\\n            // We first remove 3-divisible consecutives\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                if c.1 % 3 == 0 {\\n                    c.1 -= 1;\\n                    char_change += 1;\\n                    removed += 1;\\n                }\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n            \\n            // We then remove mod 1 consecutives\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                if c.1 % 3 == 1 {\\n                    // Make sure not to subtract more than needed.\\n                    let subtract = (2).min(char_change.abs() as u8);\\n                    c.1 -= subtract;\\n                    char_change += subtract as i32;\\n                    removed += subtract as i32;\\n                }\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n            \\n            // Now we greedily remove as many as we can to get rid of consecutives.\\n            // It will not matter which ones we remove from as all of them are 2 mod 3.\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                // We only need to subtract to make c.1 less than 3.\\n                let subtract = (c.1-2).min(char_change.abs() as u8);\\n                \\n                c.1 -= subtract;\\n                char_change += subtract as i32;\\n                removed += subtract as i32;\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n        }\\n        \\n        // Now we have two cases:\\n        // 1. # of chars to be removed was bigger than total consecutive chars\\n        // 2. total consective chars was bigger than # of chars to be removed\\n        \\n        // 1 => there are no longer any ops to be done on consecutives but only chars to be removed.\\n        // 2 => there are no longer any chars to be removed, just ops to do on consecutives.\\n        \\n        if char_change != 0 {\\n            // Case 1\\n            // We\\'ve only removed `removed` many elements. we have to remove char_change.abs() many.\\n            // We also have to add missing char classes.\\n            \\n            return removed + char_change.abs() + (should_add_lowercase + should_add_uppercase + should_add_digit);\\n        }\\n        else {\\n            // Case 2\\n            \\n            // Adding characters will only isolate 2 characters from the consecutive group\\n            // but changing a character will decrease the count by 3!\\n            \\n            // So at this point we only change characters.\\n            let mut changed = 0;\\n            \\n            for c in consecutives.iter_mut() {\\n                // we only need to change c.1/3 chars.\\n                changed += (c.1/3) as i32;\\n            }\\n            \\n            // if we didn\\'t have enough characters to change, we will have to change characters\\n            // to make sure missing char classes are included.\\n            // (we say change missing char classes because adding might cause us to exceed the length limit)\\n            return removed + changed.max(should_add_lowercase+should_add_uppercase+should_add_digit);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        // This is the change needed in the length of the password\\n        // to fit in the declared criterion.\\n        let mut char_change = loop {\\n           let len = password.len() as i32;\\n            if len < 6 {\\n                break 6-len;\\n            }\\n            if len > 20 {\\n                break 20-len;\\n            }\\n            break 0;\\n        }; \\n        \\n        \\n        // These are 1 when we need to add the char class, 0 otherwise.\\n        let should_add_lowercase = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_lowercase() {0} else {1}});\\n        let should_add_uppercase = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_uppercase() {0} else {1}});\\n        let should_add_digit = password.chars().fold(1, |acc, chr| if acc==0 {0} else {if chr.is_ascii_digit() {0} else {1}});\\n\\n        // We create an array of tuples that represent consecutive characters of length\\n        // more than 3.\\n        let mut consecutives = {\\n            let mut consecutives = Vec::new();\\n            let mut consecutive: (char, u8) = (\\' \\', 0);\\n\\n            for chr in password.chars() {\\n                if consecutive.0 == chr {\\n                    consecutive.1 += 1;\\n                }\\n                else {\\n                    if consecutive.1 > 2 {\\n                        consecutives.push(consecutive);\\n                    }\\n                    consecutive = (chr, 1);\\n                }\\n            }\\n            if consecutive.1 > 2 {\\n                consecutives.push(consecutive);\\n            }\\n            consecutives\\n        };\\n        \\n        if char_change > 0 {\\n            // Missing chars can be added and consecutive problems can be solved in char_change moves if char_change >= 3.\\n            // If it\\'s 2, missings might be bigger but consecutives is still within this limit.\\n            // If it\\'s 1, there might be a consecutive of 5 which needs 2 changes but if that\\'s the case the addition of 3 missings\\' variables will be bigger than or equal to 2.\\n            return (should_add_lowercase + should_add_uppercase + should_add_digit).max(char_change);\\n        }\\n        \\n        let mut removed = 0;\\n        \\n        if char_change < 0 {\\n\\t\\t    // Aim here is to move toward making every consecutive be 2 mod 3.\\n            // This is optimal because at 2 mod 3 we\\'ve used the least amount of removals to \\n            // decrease the most amount of operations needed in the future for each consecutive.\\n\\n            // We first remove 3-divisible consecutives\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                if c.1 % 3 == 0 {\\n                    c.1 -= 1;\\n                    char_change += 1;\\n                    removed += 1;\\n                }\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n            \\n            // We then remove mod 1 consecutives\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                if c.1 % 3 == 1 {\\n                    // Make sure not to subtract more than needed.\\n                    let subtract = (2).min(char_change.abs() as u8);\\n                    c.1 -= subtract;\\n                    char_change += subtract as i32;\\n                    removed += subtract as i32;\\n                }\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n            \\n            // Now we greedily remove as many as we can to get rid of consecutives.\\n            // It will not matter which ones we remove from as all of them are 2 mod 3.\\n            for c in consecutives.iter_mut() {\\n                if char_change >= 0 {\\n                    break;\\n                }\\n                \\n                // We only need to subtract to make c.1 less than 3.\\n                let subtract = (c.1-2).min(char_change.abs() as u8);\\n                \\n                c.1 -= subtract;\\n                char_change += subtract as i32;\\n                removed += subtract as i32;\\n            }\\n            \\n            consecutives = consecutives.into_iter().filter(|&(_, num)| num >= 3).collect();\\n        }\\n        \\n        // Now we have two cases:\\n        // 1. # of chars to be removed was bigger than total consecutive chars\\n        // 2. total consective chars was bigger than # of chars to be removed\\n        \\n        // 1 => there are no longer any ops to be done on consecutives but only chars to be removed.\\n        // 2 => there are no longer any chars to be removed, just ops to do on consecutives.\\n        \\n        if char_change != 0 {\\n            // Case 1\\n            // We\\'ve only removed `removed` many elements. we have to remove char_change.abs() many.\\n            // We also have to add missing char classes.\\n            \\n            return removed + char_change.abs() + (should_add_lowercase + should_add_uppercase + should_add_digit);\\n        }\\n        else {\\n            // Case 2\\n            \\n            // Adding characters will only isolate 2 characters from the consecutive group\\n            // but changing a character will decrease the count by 3!\\n            \\n            // So at this point we only change characters.\\n            let mut changed = 0;\\n            \\n            for c in consecutives.iter_mut() {\\n                // we only need to change c.1/3 chars.\\n                changed += (c.1/3) as i32;\\n            }\\n            \\n            // if we didn\\'t have enough characters to change, we will have to change characters\\n            // to make sure missing char classes are included.\\n            // (we say change missing char classes because adding might cause us to exceed the length limit)\\n            return removed + changed.max(should_add_lowercase+should_add_uppercase+should_add_digit);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081087,
                "title": "javascript-100-fastest-42ms-42-4mb",
                "content": "```js\\nconst strongPasswordChecker = (passwd) => {\\n    let steps = 0;\\n    let mustAdd = 0;\\n\\n    if (!passwd.match(/[A-Z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/[a-z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/\\\\d/)) {\\n        mustAdd++;\\n    }\\n\\n    let groups = passwd.match(/(.)\\\\1*/g).filter(x => x.length > 2);\\n\\n    if (passwd.length <= 20) {\\n        groups.forEach(group => {\\n            steps += Math.trunc(group.length / 3);\\n            mustAdd -= Math.trunc(group.length / 3);\\n        })\\n    }\\n\\n    if (passwd.length <= 20) {\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        if (passwd.length + steps >= 6) {\\n            steps += mustAdd;\\n        } else {\\n            if (mustAdd > 6 - (passwd.length + steps)) {\\n                steps += mustAdd;\\n            } else {\\n                steps += 6 - (passwd.length + steps);\\n            }\\n        }\\n    }\\n\\n    if (passwd.length > 20) {\\n        let mustRemove = passwd.length - 20;\\n        let lengths = [];\\n        let plus = [];\\n        let chL = 0;\\n        for (let i = 1; i <= 3; i++) {\\n            for (let k = 0; k < groups.length; k++) {\\n                if (plus[k] === undefined) { plus[k] = 0; }\\n                chL = groups[k].length - plus[k];\\n                if (lengths[k] === undefined) { lengths[k] = chL; }\\n                const rec = () => {\\n                    if (Math.trunc((chL - i) / 3) < Math.trunc(chL / 3) && passwd.length - steps - i >= 6 && mustRemove >= i && chL > 2 && lengths[k] - i > 0) {\\n                        steps += i;\\n                        plus[k] += i;\\n                        mustRemove -= i;\\n                        chL -= i;\\n                        lengths[k] -= i;\\n                        rec();\\n                    }\\n                }\\n                rec();\\n            }\\n        }\\n        lengths.forEach(length => {\\n            if (length > 2) {\\n                steps += Math.trunc(length / 3);\\n                mustAdd -= Math.trunc(length / 3);\\n            }\\n        }\\n        )\\n\\n        mustRemove = mustRemove > 0 ? mustRemove : 0;\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        steps += mustAdd + mustRemove;\\n    }\\n\\n    return steps;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst strongPasswordChecker = (passwd) => {\\n    let steps = 0;\\n    let mustAdd = 0;\\n\\n    if (!passwd.match(/[A-Z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/[a-z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/\\\\d/)) {\\n        mustAdd++;\\n    }\\n\\n    let groups = passwd.match(/(.)\\\\1*/g).filter(x => x.length > 2);\\n\\n    if (passwd.length <= 20) {\\n        groups.forEach(group => {\\n            steps += Math.trunc(group.length / 3);\\n            mustAdd -= Math.trunc(group.length / 3);\\n        })\\n    }\\n\\n    if (passwd.length <= 20) {\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        if (passwd.length + steps >= 6) {\\n            steps += mustAdd;\\n        } else {\\n            if (mustAdd > 6 - (passwd.length + steps)) {\\n                steps += mustAdd;\\n            } else {\\n                steps += 6 - (passwd.length + steps);\\n            }\\n        }\\n    }\\n\\n    if (passwd.length > 20) {\\n        let mustRemove = passwd.length - 20;\\n        let lengths = [];\\n        let plus = [];\\n        let chL = 0;\\n        for (let i = 1; i <= 3; i++) {\\n            for (let k = 0; k < groups.length; k++) {\\n                if (plus[k] === undefined) { plus[k] = 0; }\\n                chL = groups[k].length - plus[k];\\n                if (lengths[k] === undefined) { lengths[k] = chL; }\\n                const rec = () => {\\n                    if (Math.trunc((chL - i) / 3) < Math.trunc(chL / 3) && passwd.length - steps - i >= 6 && mustRemove >= i && chL > 2 && lengths[k] - i > 0) {\\n                        steps += i;\\n                        plus[k] += i;\\n                        mustRemove -= i;\\n                        chL -= i;\\n                        lengths[k] -= i;\\n                        rec();\\n                    }\\n                }\\n                rec();\\n            }\\n        }\\n        lengths.forEach(length => {\\n            if (length > 2) {\\n                steps += Math.trunc(length / 3);\\n                mustAdd -= Math.trunc(length / 3);\\n            }\\n        }\\n        )\\n\\n        mustRemove = mustRemove > 0 ? mustRemove : 0;\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        steps += mustAdd + mustRemove;\\n    }\\n\\n    return steps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064066,
                "title": "python-solution-with-comments-read-as-per-comments",
                "content": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        # First the password should have all first 3 cnmditions\\n        def getMissing(password):\\n            res = 3\\n            if any(\"a\" <= char <= \"z\" for char in password): res -= 1\\n            if any(\"A\" <= char <= \"Z\" for char in password): res -= 1\\n            if any(\"0\" <= char <= \"9\" for char in password): res -= 1\\n            return res\\n        missingValTypes = getMissing(password)\\n        # get reps -> \"aaaa\" - [4], \"aabccc\" - [2,1,3]\\n        reps = []\\n        i = 0\\n        while(i < len(password)):\\n            j = i+1\\n            length = 1\\n            while(j < len(password) and password[j] == password[i]):\\n                j += 1\\n                length += 1\\n            reps.append(length)\\n            i = j\\n        \\n        if(len(password) < 6):\\n            # we have to add either 6-len() or the missingValTypes which are req so max of them\\n            return max(6 - len(password), missingValTypes)\\n        elif(len(password) <= 20):\\n            # we have reps in string with appropriate length\\n            # now we need to delete/swap [swap preferred to not have length issues] items\\n            # either missingValTypes count takes care of everything of above and itself OR\\n            # we get the calculated val seperately\\n            # the calculated value ->\\n            # 1aaBcccc -> [1,2,1,4] -> 1 swap and all done\\n            req = sum([elem//3 for elem in reps])\\n            return max(missingValTypes, req)\\n        else:\\n            # we have a surplus now\\n            # deletes need to be done for sure\\n            deleteReq = len(password) - 20\\n            # lets prioritize the reps - \\n            # priority 1 -> [n*3] because these can be fixed with min amount of swaps/deletions[prefer]\\n            for i in range(0, len(reps)):\\n                if(reps[i]%3 == 0 and reps[i] >= 3 and deleteReq > 0):\\n                    reps[i] -= 1\\n                    deleteReq -= 1\\n            # priority 2 -> [n*3 + 1] because these required 1 extra deletion (1 del -> priority 1)\\n            for i in range(0, len(reps)):\\n                if(reps[i]%3 == 1 and reps[i] > 2 and deleteReq > 1):\\n                    reps[i] -= 2\\n                    deleteReq -= 2\\n            # priority 3 -> [n*3 + 2] now here we can either insert 1 -> prior 1 or del -> prior 2\\n            for i in range(0, len(reps)):\\n                if(reps[i] > 2 and deleteReq > 0):\\n                    removeAllowance = min(reps[i] - 2, deleteReq)\\n                    reps[i] -= removeAllowance\\n                    deleteReq -= removeAllowance\\n            # By this time deleteReq is depleted we have done all we can do as per requirments and reps\\n            # lets cal final as per what all we will change\\n            req = sum([elem//3 for elem in reps])\\n            # more delete/swap required for missingValTypes\\n            return len(password) - 20 + max(missingValTypes, req)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        # First the password should have all first 3 cnmditions\\n        def getMissing(password):\\n            res = 3\\n            if any(\"a\" <= char <= \"z\" for char in password): res -= 1\\n            if any(\"A\" <= char <= \"Z\" for char in password): res -= 1\\n            if any(\"0\" <= char <= \"9\" for char in password): res -= 1\\n            return res\\n        missingValTypes = getMissing(password)\\n        # get reps -> \"aaaa\" - [4], \"aabccc\" - [2,1,3]\\n        reps = []\\n        i = 0\\n        while(i < len(password)):\\n            j = i+1\\n            length = 1\\n            while(j < len(password) and password[j] == password[i]):\\n                j += 1\\n                length += 1\\n            reps.append(length)\\n            i = j\\n        \\n        if(len(password) < 6):\\n            # we have to add either 6-len() or the missingValTypes which are req so max of them\\n            return max(6 - len(password), missingValTypes)\\n        elif(len(password) <= 20):\\n            # we have reps in string with appropriate length\\n            # now we need to delete/swap [swap preferred to not have length issues] items\\n            # either missingValTypes count takes care of everything of above and itself OR\\n            # we get the calculated val seperately\\n            # the calculated value ->\\n            # 1aaBcccc -> [1,2,1,4] -> 1 swap and all done\\n            req = sum([elem//3 for elem in reps])\\n            return max(missingValTypes, req)\\n        else:\\n            # we have a surplus now\\n            # deletes need to be done for sure\\n            deleteReq = len(password) - 20\\n            # lets prioritize the reps - \\n            # priority 1 -> [n*3] because these can be fixed with min amount of swaps/deletions[prefer]\\n            for i in range(0, len(reps)):\\n                if(reps[i]%3 == 0 and reps[i] >= 3 and deleteReq > 0):\\n                    reps[i] -= 1\\n                    deleteReq -= 1\\n            # priority 2 -> [n*3 + 1] because these required 1 extra deletion (1 del -> priority 1)\\n            for i in range(0, len(reps)):\\n                if(reps[i]%3 == 1 and reps[i] > 2 and deleteReq > 1):\\n                    reps[i] -= 2\\n                    deleteReq -= 2\\n            # priority 3 -> [n*3 + 2] now here we can either insert 1 -> prior 1 or del -> prior 2\\n            for i in range(0, len(reps)):\\n                if(reps[i] > 2 and deleteReq > 0):\\n                    removeAllowance = min(reps[i] - 2, deleteReq)\\n                    reps[i] -= removeAllowance\\n                    deleteReq -= removeAllowance\\n            # By this time deleteReq is depleted we have done all we can do as per requirments and reps\\n            # lets cal final as per what all we will change\\n            req = sum([elem//3 for elem in reps])\\n            # more delete/swap required for missingValTypes\\n            return len(password) - 20 + max(missingValTypes, req)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393197,
                "title": "when-password-length-20-illustration",
                "content": "I believe if it had not been for the limitation of length, this problem would have been much much simpler. So our main goal is to handle the situation when password.length > 20, when deletion is unavoidable.\\n\\nLet\\'s start from a simple example,\\npassword = \"aaaaaaaaaaaaaaaaaaaaaa\"  --> (made up of 22 \\'a\\'s)\\nA naive approach is to replace every third \\'a\\' into some othe character and then remove the last two characters to reduce the length to 20.\\n\\n![image](https://assets.leetcode.com/users/images/7136c030-2935-42f6-8bcd-fc47b2092a3f_1628509681.40769.png)\\n\\nHere we do replacement 7 times and removal 2 times, so the answer goes to 7 + 2 = 9. However, the outcome\\'s incorrect. You may have noticed that the last replacement is unnecessary since two characters would be removed after that. So the correct answer is 7 + 2 - 1 = 8. \\n\\nLet\\'s have a closer look at this instance -- to get a valid password, we do replacement 7 times beacause 22 / 3 = 7 and removing 2 times comes from 22 - 20 = 2. This yeilds the wrong answer, though. But if we remove 2 characters first, the length drops to 20, then we only need to replace 20 / 3 = 6 times, 6 + 2 = 8 gives the right output.\\n\\nThe aforementioned instance reveals one critical fact: \\n\\n**Removal can help us reduce the needs of replacement.**\\n\\nAn extrem example is that:\\n![image](https://assets.leetcode.com/users/images/6ba1e785-413a-442a-8607-62e4608b5c81_1628511111.7633173.png)\\nAfter 10 removals, the password becomes valid and no further replacement is needed.\\n\\nIn a nutshell, we should do removal first and \"wisely\", then replacement.\\nBut what is \"wisely\"? \\nSince our goal is get the least steps, we should make the best of every step. \\n\\nAllow me to define a new term \"contiguous segment\" here. A contiguous segment is a string formed by repeating one character once or several times, e.g. \"aaaaa\", \"bbb\", \"A\" and \"hhhhhh\". All strings can be divided into a couple of contiguous segments. For example, \"committee\" can be split into \"c\", \"o\", \"mm\", \"i\", \"tt\" and \"ee\".\\n\\n**Specifically, \\n1. if we remove one character from a contiguous segment owning a length of 3\\\\*k, call it a \"3k segment\" (k can be any POSITIVE integer), we reduce the replacements by 1; \\n2. if we remove two characters from a continguous segment having a length of 3\\\\*k+1, i.e. a \"3k+1 segment\", we also decrement the replacements. \\n3. The third option is to erase three characters from a 3k+2 segement, which again decrese the replacements.**\\n\\nAs a special notice, after removing one character from a 3k segment or two characters from a 3k+1 segment, the leftover may be considered 3k+2 segment, from which erasing 3 chars leads to decrement of replacement again.\\n\\nIn conclusion, firstly we should examine the input string to find out how many 3k, 3k+1, 3k+2 segments are there. Then according to the removals = length - 20, do removals from 3k, 3k+1, 3k+2 segments and count the times of decrement, the result should be like: \\nreplacement + removal - (times of decrement),\\nof course, dut to other requirement, we outght to make some tiny modification to get the final answer.\\n\\n# A concrete example\\n![image](https://assets.leetcode.com/users/images/1058b4a5-025d-4061-8939-59364c7db751_1628590718.9965603.png)\\n\\nThe original password is \"aaaaBBBCCCCCCCC7777eeeeee\". We anaalyze this string and get an table recording the segment info. Pay attention to the segment colored red - \"CCCCC\" and \"eeeeee\" -- after removing one \\'e\\' from the \"eeeeee\", \"eeeee\" is left and should be considered a 3k+2 segment; after deleting three \\'C\\'s from \"CCCCCCCC\", \"CCCCC\" is left, which again is supposed to be regarded as a new 3k+2 segment. (Actually the string colon is just for your better understanding, and does not count at all.)\\n\\n![image](https://assets.leetcode.com/users/images/ab82a13d-6517-4581-afab-66c9d040752a_1628591436.6914153.png)\\n\\nAfter finishing the table, we found that we need to do 5 deletion since 25 - 20 = 5 and 7 times of replacement.\\n\\nAs said before, the first two deletions happens on 3k segments, i.e. \"BBB\" and \"eeeee\", during which we decrease the replacement twice. We have 5 - 2 = 3 deletions left.\\nCurrent status:\\n![image](https://assets.leetcode.com/users/images/312a13d6-c9ab-4b60-851c-f89cffe734b2_1628592485.6172903.png)\\n\\n\\nAfter that, we need to do 3 deletions further. We choose to erase two \"a\"s from \"aaaa\", which decrease replacement once. Now we have only 3 - 2 = 1 deletion left and this could help us to reduce replacement any more since at least 2 deletions are needed (you can remove two \\'7\\'s from \"7777\").\\nCurrent status:\\n\\n![image](https://assets.leetcode.com/users/images/fc8f98ea-8e13-43cd-af21-42585236199b_1628592542.3362906.png)\\n\\n\\nOnly one deletion is left, but now erasing any character gives the same result, so let\\'s erase one \\'a\\' from \"aa\".\\nCurrent status:\\n![image](https://assets.leetcode.com/users/images/942c633c-89ed-46ea-84e6-a66ca9588bad_1628592613.2033262.png)\\n\\nSo far we decrese the need of replacement 3 times, use a variable \"common\" to save this value.\\n\\nreplacement  - common + removals = 7 - 3 + 5 = 9.\\n\\nFinally, we just need to do 7 - 3 = 4 times of replacement. This value in this specific instance does not matter, because the password itself already contains at least one uppercase char, one lowercase char and one digit. However, if it\\'s not the case, say we don\\'t have uppercase char, lowercase char or even one digit, we should replace 3 char -- one with \"A\", one with \\'a\\' and one with \\'0\\', if you have extra replacement chances left, you could \"share\" these oppotunity.\\n\\nYou may ask what if there are insufficient segment for deletion? Yeah, the following example depict this circumstance:\\n![image](https://assets.leetcode.com/users/images/a9f8bd83-15af-44b7-8643-28eb1e58183a_1628593241.5362186.png)\\n\\nApparently deletions = 24 - 20 = 4, replacements = 0, common = 0. No worries, the equation still holds:\\n\\nreplacement  - common + removals = 0 - 0 + 4 = 4.\\n\\nSince other requirement meets, the final result is indeed 4.\\n\\nHere is my code if you need. (badly written, i know)\\n```\\nclass Solution {\\n    public boolean isLowercase(char c){\\n        return c>=\\'a\\' && c<=\\'z\\';\\n    }\\n    public boolean isUppercase(char c){\\n        return c>=\\'A\\' && c<=\\'Z\\';\\n    }\\n    public boolean isDigit(char c){\\n        return c>=\\'0\\' && c<=\\'9\\';\\n    }\\n    public int[] getInfo(String s){\\n\\t// to generate the table\\n        int arr[] = {0,0,0};\\n        int count = 1;\\n        int index = 1;\\n        while(index<s.length()){\\n            if(s.charAt(index) == s.charAt(index-1))\\n                ++count;\\n            else{\\n                if(count>=3){\\n                    if(count%3==0){\\n                        ++arr[0];\\n                        arr[2] += (count-1)/3;\\n                    }\\n                    else if(count%3==1){\\n                        ++arr[1];\\n                        arr[2] += (count-2)/3;\\n                    }\\n                    else\\n                        arr[2] += count/3;\\n                }\\n                count=1;\\n            }\\n            \\n            ++index;\\n        }\\n        if(count>=3){\\n           if(count%3==0){\\n                ++arr[0];\\n                arr[2] += (count-1)/3;\\n            }\\n            else if(count%3==1){\\n                ++arr[1];\\n                arr[2] += (count-2)/3;\\n            }\\n            else\\n                arr[2] += count/3; \\n        }\\n        \\n        return arr;\\n    }\\n    public int strongPasswordChecker(String password) {\\n        if(password.length()<4)\\n            return 6 - password.length();\\n        else if(password.length() <= 5){\\n            boolean lc = false;\\n            boolean uc = false;\\n            boolean dt = false;\\n            int count = 0;\\n            for(int i=0;i<password.length();++i){\\n                if(isLowercase(password.charAt(i)))\\n                    lc = true;\\n                else if(isUppercase(password.charAt(i)))\\n                    uc = true;\\n                else if(isDigit(password.charAt(i)))\\n                    dt = true;\\n            }\\n            if(!lc)\\n                ++count;\\n            if(!uc)\\n                ++count;\\n            if(!dt)\\n                ++count;\\n            if(count < 6-password.length())\\n                count = 6-password.length();\\n            return count;\\n        }\\n        else{\\n            boolean lc = false;\\n            boolean uc = false;\\n            boolean dt = false;\\n            int repeat = 1;\\n            int needToReplace = 0;\\n            if(isLowercase(password.charAt(0)))\\n                lc = true;\\n            else if(isUppercase(password.charAt(0)))\\n                uc = true;\\n            else if(isDigit(password.charAt(0)))\\n                dt = true;\\n            for(int i=1;i<password.length();++i){\\n                if(isLowercase(password.charAt(i)))\\n                    lc = true;\\n                else if(isUppercase(password.charAt(i)))\\n                    uc = true;\\n                else if(isDigit(password.charAt(i)))\\n                    dt = true;\\n                if(password.charAt(i) == password.charAt(i-1))\\n                    ++repeat;\\n                else\\n                    repeat = 1;\\n                if(repeat==3){\\n                    ++needToReplace;\\n                    repeat = 0;\\n                }\\n            }\\n            int count = 0;\\n            if(!lc)\\n                ++count;\\n            if(!uc)\\n                ++count;\\n            if(!dt)\\n                ++count;\\n            if(password.length()<=20)\\n                return Math.max(needToReplace,count);\\n            int needToErase = password.length()-20;\\n            int needToErase_copy = needToErase;\\n            int common = 0;\\n            int[] arr = getInfo(password);\\n            // calculate the \"common\"\\n            int current_index = 0;\\n            while(current_index<3 && needToErase_copy>0){\\n                int temp = Math.min(needToErase_copy/(current_index+1),arr[current_index]);\\n                common += temp;\\n                needToErase_copy -= temp * (current_index+1);\\n                ++current_index;\\n            }\\n            return Math.max(needToReplace-common,count) + needToErase;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isLowercase(char c){\\n        return c>=\\'a\\' && c<=\\'z\\';\\n    }\\n    public boolean isUppercase(char c){\\n        return c>=\\'A\\' && c<=\\'Z\\';\\n    }\\n    public boolean isDigit(char c){\\n        return c>=\\'0\\' && c<=\\'9\\';\\n    }\\n    public int[] getInfo(String s){\\n\\t// to generate the table\\n        int arr[] = {0,0,0};\\n        int count = 1;\\n        int index = 1;\\n        while(index<s.length()){\\n            if(s.charAt(index) == s.charAt(index-1))\\n                ++count;\\n            else{\\n                if(count>=3){\\n                    if(count%3==0){\\n                        ++arr[0];\\n                        arr[2] += (count-1)/3;\\n                    }\\n                    else if(count%3==1){\\n                        ++arr[1];\\n                        arr[2] += (count-2)/3;\\n                    }\\n                    else\\n                        arr[2] += count/3;\\n                }\\n                count=1;\\n            }\\n            \\n            ++index;\\n        }\\n        if(count>=3){\\n           if(count%3==0){\\n                ++arr[0];\\n                arr[2] += (count-1)/3;\\n            }\\n            else if(count%3==1){\\n                ++arr[1];\\n                arr[2] += (count-2)/3;\\n            }\\n            else\\n                arr[2] += count/3; \\n        }\\n        \\n        return arr;\\n    }\\n    public int strongPasswordChecker(String password) {\\n        if(password.length()<4)\\n            return 6 - password.length();\\n        else if(password.length() <= 5){\\n            boolean lc = false;\\n            boolean uc = false;\\n            boolean dt = false;\\n            int count = 0;\\n            for(int i=0;i<password.length();++i){\\n                if(isLowercase(password.charAt(i)))\\n                    lc = true;\\n                else if(isUppercase(password.charAt(i)))\\n                    uc = true;\\n                else if(isDigit(password.charAt(i)))\\n                    dt = true;\\n            }\\n            if(!lc)\\n                ++count;\\n            if(!uc)\\n                ++count;\\n            if(!dt)\\n                ++count;\\n            if(count < 6-password.length())\\n                count = 6-password.length();\\n            return count;\\n        }\\n        else{\\n            boolean lc = false;\\n            boolean uc = false;\\n            boolean dt = false;\\n            int repeat = 1;\\n            int needToReplace = 0;\\n            if(isLowercase(password.charAt(0)))\\n                lc = true;\\n            else if(isUppercase(password.charAt(0)))\\n                uc = true;\\n            else if(isDigit(password.charAt(0)))\\n                dt = true;\\n            for(int i=1;i<password.length();++i){\\n                if(isLowercase(password.charAt(i)))\\n                    lc = true;\\n                else if(isUppercase(password.charAt(i)))\\n                    uc = true;\\n                else if(isDigit(password.charAt(i)))\\n                    dt = true;\\n                if(password.charAt(i) == password.charAt(i-1))\\n                    ++repeat;\\n                else\\n                    repeat = 1;\\n                if(repeat==3){\\n                    ++needToReplace;\\n                    repeat = 0;\\n                }\\n            }\\n            int count = 0;\\n            if(!lc)\\n                ++count;\\n            if(!uc)\\n                ++count;\\n            if(!dt)\\n                ++count;\\n            if(password.length()<=20)\\n                return Math.max(needToReplace,count);\\n            int needToErase = password.length()-20;\\n            int needToErase_copy = needToErase;\\n            int common = 0;\\n            int[] arr = getInfo(password);\\n            // calculate the \"common\"\\n            int current_index = 0;\\n            while(current_index<3 && needToErase_copy>0){\\n                int temp = Math.min(needToErase_copy/(current_index+1),arr[current_index]);\\n                common += temp;\\n                needToErase_copy -= temp * (current_index+1);\\n                ++current_index;\\n            }\\n            return Math.max(needToReplace-common,count) + needToErase;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286712,
                "title": "fastest-typescript-solution-76-ms-faster-than-100-00-of-submissions",
                "content": "Obviously not written for clarity, mostly posting for anyone who wants to beat the time :)\\n\\n```\\nfunction strongPasswordChecker(password: string): number\\n{\\n    let adds: number = Math.max(0, 6 - password.length);\\n    let subs: number = Math.max(0, password.length - 20);\\n    let lower: number = (password.match(/[a-z]/g) ?? []).length == 0 ? 1 : 0;\\n    let upper: number = (password.match(/[A-Z]/g) ?? []).length == 0 ? 1 : 0;\\n    let digit: number = (password.match(/[0-9]/g) ?? []).length == 0 ? 1 : 0;\\n    let mods: number = lower + upper + digit;\\n    let tris: number = (password.match(/(.)\\\\1{2,2}/g) ?? []).length;\\n\\n    let grps = (password.match(/(.)\\\\1{2,}/g) ?? []).map((x) => { return x.length; });\\n    for (let i = subs; i && grps.length; i--) {\\n        grps = grps.filter((x) => { return x >= 3; }).sort((a, b) => { return (a % 3) - (b % 3); });\\n        tris -= (grps[0] % 3 == 0) ? 1 : 0;\\n        grps[0]--;\\n    }\\n\\n    let steps: number = 0;\\n    steps = Math.max(steps, tris);\\n    steps = Math.max(steps, mods);\\n    steps = Math.max(steps, adds);\\n    steps = steps + subs;\\n    return steps;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction strongPasswordChecker(password: string): number\\n{\\n    let adds: number = Math.max(0, 6 - password.length);\\n    let subs: number = Math.max(0, password.length - 20);\\n    let lower: number = (password.match(/[a-z]/g) ?? []).length == 0 ? 1 : 0;\\n    let upper: number = (password.match(/[A-Z]/g) ?? []).length == 0 ? 1 : 0;\\n    let digit: number = (password.match(/[0-9]/g) ?? []).length == 0 ? 1 : 0;\\n    let mods: number = lower + upper + digit;\\n    let tris: number = (password.match(/(.)\\\\1{2,2}/g) ?? []).length;\\n\\n    let grps = (password.match(/(.)\\\\1{2,}/g) ?? []).map((x) => { return x.length; });\\n    for (let i = subs; i && grps.length; i--) {\\n        grps = grps.filter((x) => { return x >= 3; }).sort((a, b) => { return (a % 3) - (b % 3); });\\n        tris -= (grps[0] % 3 == 0) ? 1 : 0;\\n        grps[0]--;\\n    }\\n\\n    let steps: number = 0;\\n    steps = Math.max(steps, tris);\\n    steps = Math.max(steps, mods);\\n    steps = Math.max(steps, adds);\\n    steps = steps + subs;\\n    return steps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1284939,
                "title": "simple-enumeration-with-detailed-explanation",
                "content": "```\\n//Simple Enumeration over the size of the password\\n//(1)If the size < 6, then it is quite trivial\\n//(2) The problem become interesting when the size >= 6\\n//(2) If the size <= 20, then we only need to focus on the repeating chracters substring (shortly as RCS), \\n//i.e. we need to replace some characters in the RCS\\n//For example, aaa -> aab, aaaaaa->aabaab, we can see the minimum of replacement is len(RCS)/3\\n//(3) If the size > 20, we can reduce this case to case (2) with size == 20 by deleting the extra characters, \\n//but most importantly how to delete characters?\\n//We can use greedy approach, for example, if all the len(RCS) are [3, 6, 4] and if we need to delete two characters\\n//We delete 3-1=2 will have 2/3=0 replacement (1 less compared to 3) and 6-1=5 will have 5/3=1 replacement (same reason). \\n//Why? Because, in this way, we can have the miminum replacement to be handled later like case (2)\\n//So now the min-heap is natrual to handle this process, we can sort the heap based upon the remainder modular 3\\n//For example, the heap would look like [3,3,6,6,4,7,4,7,5,5,8,8]. \\n//[3,3,6,6] has remainder 0, minimum 1 deletion to reduce 1 replacement\\n//[4,7,4,7] has remainder 1, minimum 2 deletion to reduce 1 replacement\\n//[5,5,8,8] has remainder 2, mimimum 3 deletion to reduce 1 replacement\\n//In this way, we can try our best to minimize the number of replacement in case (2), within the number of deletions we need to do \\nstruct myComp {\\n    bool operator()(const int& l, const int& r) {\\n        if((l%3) > (r%3)) return true;\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string pass) {\\n        int size = pass.size();\\n        //Set up key data before enumeration\\n        bool cLow = 0; bool cUp = 0; bool cDig = 0;\\n        vector<int> rep; //rep records the length of each repeating characters substring\\n        for(int i=0; i<size; ) {\\n            char curr = pass[i];\\n            if(islower(curr)) cLow = 1;\\n            else if(isupper(curr)) cUp = 1;\\n            else if(isdigit(curr)) cDig = 1;\\n            int j=i; while(j<size && pass[j] == curr) { j += 1;}\\n            int len = j - i; if(len >= 3) {rep.push_back(len);}\\n            i = j;\\n        }\\n        int sum = cLow + cUp + cDig;\\n        //Enumeration over different size\\n        if(size >= 6 && size <= 20 && sum == 3 && rep.empty()) return 0;\\n        else if(size <= 3) return 6-size;\\n        else if(size == 4) {\\n            return 2 + (sum == 0);\\n        }\\n        else if(size == 5) {\\n            if(sum == 3 || sum == 2) return 1;\\n            else if(sum == 1) return 2;\\n            else if(sum == 0) return 3;\\n        } else if(size >= 6 && size <= 20) {\\n            int toRep = 0;\\n            for(auto& r : rep) {toRep += r/3;}\\n            return max(toRep, 3-sum);\\n        } else if(size > 20) {\\n            priority_queue<int, vector<int>, myComp> pq(rep.begin(), rep.end());\\n            int toDel = size - 20;\\n            while(!pq.empty() && toDel > 0) {\\n                int r = pq.top(); pq.pop();\\n                if((r%3) == 0) { int tmp = min(toDel, 1); toDel -= tmp; r -= tmp;}\\n                else if((r%3) == 1) { int tmp = min(toDel, 2); toDel -= tmp; r -= tmp;}\\n                else if((r%3) == 2) { int tmp = min(toDel, 3); toDel -= tmp; r -= tmp;}\\n                if(r >= 3) {pq.push(r);}\\n            }\\n            int toRep = 0;\\n            while(!pq.empty()) {toRep += pq.top() / 3; pq.pop();}\\n            \\n            return (size-20) + max(toRep, 3-sum);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Simple Enumeration over the size of the password\\n//(1)If the size < 6, then it is quite trivial\\n//(2) The problem become interesting when the size >= 6\\n//(2) If the size <= 20, then we only need to focus on the repeating chracters substring (shortly as RCS), \\n//i.e. we need to replace some characters in the RCS\\n//For example, aaa -> aab, aaaaaa->aabaab, we can see the minimum of replacement is len(RCS)/3\\n//(3) If the size > 20, we can reduce this case to case (2) with size == 20 by deleting the extra characters, \\n//but most importantly how to delete characters?\\n//We can use greedy approach, for example, if all the len(RCS) are [3, 6, 4] and if we need to delete two characters\\n//We delete 3-1=2 will have 2/3=0 replacement (1 less compared to 3) and 6-1=5 will have 5/3=1 replacement (same reason). \\n//Why? Because, in this way, we can have the miminum replacement to be handled later like case (2)\\n//So now the min-heap is natrual to handle this process, we can sort the heap based upon the remainder modular 3\\n//For example, the heap would look like [3,3,6,6,4,7,4,7,5,5,8,8]. \\n//[3,3,6,6] has remainder 0, minimum 1 deletion to reduce 1 replacement\\n//[4,7,4,7] has remainder 1, minimum 2 deletion to reduce 1 replacement\\n//[5,5,8,8] has remainder 2, mimimum 3 deletion to reduce 1 replacement\\n//In this way, we can try our best to minimize the number of replacement in case (2), within the number of deletions we need to do \\nstruct myComp {\\n    bool operator()(const int& l, const int& r) {\\n        if((l%3) > (r%3)) return true;\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string pass) {\\n        int size = pass.size();\\n        //Set up key data before enumeration\\n        bool cLow = 0; bool cUp = 0; bool cDig = 0;\\n        vector<int> rep; //rep records the length of each repeating characters substring\\n        for(int i=0; i<size; ) {\\n            char curr = pass[i];\\n            if(islower(curr)) cLow = 1;\\n            else if(isupper(curr)) cUp = 1;\\n            else if(isdigit(curr)) cDig = 1;\\n            int j=i; while(j<size && pass[j] == curr) { j += 1;}\\n            int len = j - i; if(len >= 3) {rep.push_back(len);}\\n            i = j;\\n        }\\n        int sum = cLow + cUp + cDig;\\n        //Enumeration over different size\\n        if(size >= 6 && size <= 20 && sum == 3 && rep.empty()) return 0;\\n        else if(size <= 3) return 6-size;\\n        else if(size == 4) {\\n            return 2 + (sum == 0);\\n        }\\n        else if(size == 5) {\\n            if(sum == 3 || sum == 2) return 1;\\n            else if(sum == 1) return 2;\\n            else if(sum == 0) return 3;\\n        } else if(size >= 6 && size <= 20) {\\n            int toRep = 0;\\n            for(auto& r : rep) {toRep += r/3;}\\n            return max(toRep, 3-sum);\\n        } else if(size > 20) {\\n            priority_queue<int, vector<int>, myComp> pq(rep.begin(), rep.end());\\n            int toDel = size - 20;\\n            while(!pq.empty() && toDel > 0) {\\n                int r = pq.top(); pq.pop();\\n                if((r%3) == 0) { int tmp = min(toDel, 1); toDel -= tmp; r -= tmp;}\\n                else if((r%3) == 1) { int tmp = min(toDel, 2); toDel -= tmp; r -= tmp;}\\n                else if((r%3) == 2) { int tmp = min(toDel, 3); toDel -= tmp; r -= tmp;}\\n                if(r >= 3) {pq.push(r);}\\n            }\\n            int toRep = 0;\\n            while(!pq.empty()) {toRep += pq.top() / 3; pq.pop();}\\n            \\n            return (size-20) + max(toRep, 3-sum);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244777,
                "title": "12ms-python-solution",
                "content": "Tried for all use cases\\n\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        \"\"\"\\n        :type password: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type_cnt = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in password):\\n            missing_type_cnt -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in password):\\n            missing_type_cnt -= 1\\n        if any(c.isdigit() for c in password):\\n            missing_type_cnt -= 1\\n        total_change_cnt = 0\\n        one_change_cnt, two_change_cnt = 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                total_change_cnt += length / 3\\n                if length % 3 == 0:\\n                    one_change_cnt += 1\\n                elif length % 3 == 1:\\n                    two_change_cnt += 1\\n            else:\\n                i += 1\\n        if len(password) < 6:\\n            return max(missing_type_cnt, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(missing_type_cnt, total_change_cnt)\\n        else:\\n            delete_cnt = len(password) - 20\\n            total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1\\n            total_change_cnt -= min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2\\n            total_change_cnt -= max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0) / 3\\n        return delete_cnt + max(missing_type_cnt, total_change_cnt)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        \"\"\"\\n        :type password: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type_cnt = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in password):\\n            missing_type_cnt -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in password):\\n            missing_type_cnt -= 1\\n        if any(c.isdigit() for c in password):\\n            missing_type_cnt -= 1\\n        total_change_cnt = 0\\n        one_change_cnt, two_change_cnt = 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                total_change_cnt += length / 3\\n                if length % 3 == 0:\\n                    one_change_cnt += 1\\n                elif length % 3 == 1:\\n                    two_change_cnt += 1\\n            else:\\n                i += 1\\n        if len(password) < 6:\\n            return max(missing_type_cnt, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(missing_type_cnt, total_change_cnt)\\n        else:\\n            delete_cnt = len(password) - 20\\n            total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1\\n            total_change_cnt -= min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2\\n            total_change_cnt -= max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0) / 3\\n        return delete_cnt + max(missing_type_cnt, total_change_cnt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102649,
                "title": "o-n-time-and-o-1-space-c-solution-beats-100-greedy-math-on-modular",
                "content": "![image](https://assets.leetcode.com/users/images/ec452339-a65d-48d2-a159-0f9e0a23b133_1615362512.3108077.png)\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        //steps is the final result\\n        //repeat is the length of repeating chars like \"aa\" or \"aaaa\"\\n        //New is the number of new added chars due to replacing or inserting\\n        int steps=0,repeat=1,New=0; \\n        //remain is the length of redundant string when len(password)>20\\n        unsigned int remain=0,len=password.size();\\n        if(len>20) remain=len-20;\\n        //lower, upper, and digit used to show whether lower cases, upper cases and digits have appeared\\n        int lower=0,upper=0,digit=0;\\n        //cnt[i] counts the number of illegal strings such as s=\"aaa\" when len(s)%3==i \\n        int cnt[3]={0,0,0};\\n        for(unsigned int i=0;i<password.size();i++){\\n            //whether lower cases, upper cases and digits have appeared\\n            if(password[i]>=\\'0\\'&&password[i]<=\\'9\\') digit=1;\\n            else if(password[i]>=\\'a\\'&&password[i]<=\\'z\\') lower=1;\\n            else if(password[i]>=\\'A\\'&&password[i]<=\\'Z\\') upper=1;\\n            //when illegal string such as s=\"aaa\" appears, try to modify it \\n            if(repeat>=3&&(i==password.size()-1||(i<password.size()-1&&password[i]!=password[i+1]))){\\n                //if len>6, insert.\\n                   if(len<6){\\n                        steps+=repeat/2-1;\\n                        New+=repeat/2-1;\\n                        len+=repeat/2-1;\\n                    }\\n                //else, replace\\n                    else{\\n                        steps+=repeat/3;\\n                        New+=repeat/3;\\n                        cnt[repeat%3]++;\\n                    }\\n                }\\n            //update the length of repeating chars\\n            if(i<password.size()-1&&password[i]==password[i+1]) repeat++;\\n            else repeat=1;\\n        }\\n        //if len-20>0\\n        if(remain>0) {\\n            //delete\\n            steps+=remain;\\n            //greedy. the illegal strings with smaller i==len(s)%3 have higher priority to be deleted. When k chars are deleted, k/(i+1) replacements are cancelled, resulting in decrease of steps\\n            for(int i=0;i<3;i++){\\n                    if(remain<cnt[i]*(i+1)){\\n                        steps-=remain/(i+1);\\n                        New-=remain/(i+1);\\n                        remain=0;\\n                        break;\\n                    }\\n                    steps-=cnt[i];\\n                    New-=cnt[i];\\n                    remain-=cnt[i]*(i+1);\\n                }\\n            //Now all illegal strings s have len(s)%3==2. When k chars are deleted, k/3 replacements are cancelled, resulting in decrease of steps\\n            if(remain<New*3){\\n                steps-=remain/3;\\n                New-=remain/3;\\n            }\\n            else {\\n                steps-=New;\\n                New=0;\\n        }            \\n        }\\n        //special case when len<6, insert\\n        else  if(len<6){\\n            steps+=6-len;\\n            New+=6-len;\\n        }\\n        //special case when one or some among lower case, upper case, and digit haven\\'t shown up, even after the precedent modification\\n        if(3-lower-upper-digit>New) steps+=3-lower-upper-digit-New;\\n        return steps;\\n    }\\n};\\n```\\nI\\' m not sure my algorithm is 100% corret, and whether it sees the essence of the problem, although it passed all test cases.\\nDiscussions are welcome!\\n\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        //steps is the final result\\n        //repeat is the length of repeating chars like \"aa\" or \"aaaa\"\\n        //New is the number of new added chars due to replacing or inserting\\n        int steps=0,repeat=1,New=0; \\n        //remain is the length of redundant string when len(password)>20\\n        unsigned int remain=0,len=password.size();\\n        if(len>20) remain=len-20;\\n        //lower, upper, and digit used to show whether lower cases, upper cases and digits have appeared\\n        int lower=0,upper=0,digit=0;\\n        //cnt[i] counts the number of illegal strings such as s=\"aaa\" when len(s)%3==i \\n        int cnt[3]={0,0,0};\\n        for(unsigned int i=0;i<password.size();i++){\\n            //whether lower cases, upper cases and digits have appeared\\n            if(password[i]>=\\'0\\'&&password[i]<=\\'9\\') digit=1;\\n            else if(password[i]>=\\'a\\'&&password[i]<=\\'z\\') lower=1;\\n            else if(password[i]>=\\'A\\'&&password[i]<=\\'Z\\') upper=1;\\n            //when illegal string such as s=\"aaa\" appears, try to modify it \\n            if(repeat>=3&&(i==password.size()-1||(i<password.size()-1&&password[i]!=password[i+1]))){\\n                //if len>6, insert.\\n                   if(len<6){\\n                        steps+=repeat/2-1;\\n                        New+=repeat/2-1;\\n                        len+=repeat/2-1;\\n                    }\\n                //else, replace\\n                    else{\\n                        steps+=repeat/3;\\n                        New+=repeat/3;\\n                        cnt[repeat%3]++;\\n                    }\\n                }\\n            //update the length of repeating chars\\n            if(i<password.size()-1&&password[i]==password[i+1]) repeat++;\\n            else repeat=1;\\n        }\\n        //if len-20>0\\n        if(remain>0) {\\n            //delete\\n            steps+=remain;\\n            //greedy. the illegal strings with smaller i==len(s)%3 have higher priority to be deleted. When k chars are deleted, k/(i+1) replacements are cancelled, resulting in decrease of steps\\n            for(int i=0;i<3;i++){\\n                    if(remain<cnt[i]*(i+1)){\\n                        steps-=remain/(i+1);\\n                        New-=remain/(i+1);\\n                        remain=0;\\n                        break;\\n                    }\\n                    steps-=cnt[i];\\n                    New-=cnt[i];\\n                    remain-=cnt[i]*(i+1);\\n                }\\n            //Now all illegal strings s have len(s)%3==2. When k chars are deleted, k/3 replacements are cancelled, resulting in decrease of steps\\n            if(remain<New*3){\\n                steps-=remain/3;\\n                New-=remain/3;\\n            }\\n            else {\\n                steps-=New;\\n                New=0;\\n        }            \\n        }\\n        //special case when len<6, insert\\n        else  if(len<6){\\n            steps+=6-len;\\n            New+=6-len;\\n        }\\n        //special case when one or some among lower case, upper case, and digit haven\\'t shown up, even after the precedent modification\\n        if(3-lower-upper-digit>New) steps+=3-lower-upper-digit-New;\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000660,
                "title": "c-solution-with-detailed-explanation",
                "content": "I\\'ve included my solution with comments below.\\n\\nThe key thing that helped me come to a solution to this problem was realizing that I didn\\'t actually care what characters were used when doing replace and insert operations to satisfy a constraint.  If upper case constraint hasn\\'t been satisfied, then you know that will take exactly 1 step (either an insert or a replace).  This is true for the lowercase and digit constraints as well.  The character used when inserting or replacing is completely irrelevant.\\n\\nMax length & the repeat constraints are the most interesting aspects of this challenge.  If you take those out, this problem becomes very simple.  That might be a good way to initially think about the problem.  See code with comments for more on how to tackle the repeat and max length constraints.\\n\\n```\\npublic class Solution {\\n    private const int MIN_LENGTH = 6;\\n    private const int MAX_LENGTH = 20;\\n    private const int MAX_REPEAT_LENGTH = 3;\\n    \\n    public int StrongPasswordChecker(string password) {\\n        // Approach:\\n        //     Determine what aspects of the password need to be changed and then determine how to\\n        //     best combine these actions in a way that the fewest actions possible are used.\\n        \\n        // Find all repeat char sequences and also track if we need to fix the lowercase, uppercase, and digit\\n        // constraints at the same time\\n        bool hasLowerCase = false;\\n        bool hasUpperCase = false;\\n        bool hasDigit = false;\\n        List<int> repeatCharCounts = new List<int>();\\n        for (int i = 0; i < password.Length; ++i) {\\n            char c = password[i];\\n            hasLowerCase |= c >= \\'a\\' && c <= \\'z\\';\\n            hasUpperCase |= c >= \\'A\\' && c <= \\'Z\\';\\n            hasDigit |= c >= \\'0\\' && c <= \\'9\\';\\n            int repeatLen = 1;\\n            while (i + 1 < password.Length && password[i + 1] == c) {\\n                ++i;\\n                ++repeatLen;\\n            }\\n            if (repeatLen >= MAX_REPEAT_LENGTH) {\\n                repeatCharCounts.Add(repeatLen);\\n            }\\n        }\\n        \\n        // Optimize deletions by first exploring char sequences and deleting from the one that is closest to\\n        // the mod boundary\\n        int deletions = 0;\\n        int passwordCount = password.Length;\\n        if (passwordCount > MAX_LENGTH) {\\n            repeatCharCounts = repeatCharCounts.OrderBy(x => x % MAX_REPEAT_LENGTH).ToList();\\n            while (passwordCount > MAX_LENGTH && repeatCharCounts.Any()) {\\n                --passwordCount;\\n                ++deletions;\\n                var sequence = repeatCharCounts[0];\\n                if (sequence == MAX_REPEAT_LENGTH) {\\n                    // This sequence no longer violates the repeat constraint, so remove it\\n                    repeatCharCounts.RemoveAt(0);\\n                } else if (sequence % MAX_REPEAT_LENGTH == 0) {\\n                    // This sequence is at the mod boundary, so after subtracting 1 move it to\\n                    // the back of the list since it\\'s now the furthest from the mod boundary\\n                    repeatCharCounts.RemoveAt(0);\\n                    repeatCharCounts.Insert(repeatCharCounts.Count, sequence - 1);\\n                } else {\\n                    // This sequence is now closer to the mod boundary, so just update it in place\\n                    repeatCharCounts[0] = sequence - 1;\\n                }\\n            }\\n        }\\n        // Add remaining necessary deletions\\n        if (passwordCount > MAX_LENGTH) {\\n            deletions += passwordCount - MAX_LENGTH;\\n        }\\n        \\n        // Determine how many inserts / replaces are necessary to resolve repeating char sequences\\n        int repeatInsertsAndReplaces = 0;\\n        while (repeatCharCounts.Any()) {\\n            int count = repeatCharCounts[0];\\n            repeatCharCounts.RemoveAt(0);\\n            repeatInsertsAndReplaces += count / MAX_REPEAT_LENGTH;\\n        }\\n        \\n        // Determine how many inserts / replaces are necessary for the lowercase, upper case, digit,\\n        // and minimum char constraints\\n        int requiredInsertsOrReplace = (hasLowerCase ? 0 : 1) + (hasUpperCase ? 0 : 1) + (hasDigit ? 0 : 1);\\n        requiredInsertsOrReplace = password.Length < MIN_LENGTH\\n            ? Math.Max(MIN_LENGTH - password.Length, requiredInsertsOrReplace)\\n            : requiredInsertsOrReplace;\\n\\n        // Put everything together for the fewest steps required to make the password strong\\n        int steps = Math.Max(requiredInsertsOrReplace, repeatInsertsAndReplaces) + deletions;\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private const int MIN_LENGTH = 6;\\n    private const int MAX_LENGTH = 20;\\n    private const int MAX_REPEAT_LENGTH = 3;\\n    \\n    public int StrongPasswordChecker(string password) {\\n        // Approach:\\n        //     Determine what aspects of the password need to be changed and then determine how to\\n        //     best combine these actions in a way that the fewest actions possible are used.\\n        \\n        // Find all repeat char sequences and also track if we need to fix the lowercase, uppercase, and digit\\n        // constraints at the same time\\n        bool hasLowerCase = false;\\n        bool hasUpperCase = false;\\n        bool hasDigit = false;\\n        List<int> repeatCharCounts = new List<int>();\\n        for (int i = 0; i < password.Length; ++i) {\\n            char c = password[i];\\n            hasLowerCase |= c >= \\'a\\' && c <= \\'z\\';\\n            hasUpperCase |= c >= \\'A\\' && c <= \\'Z\\';\\n            hasDigit |= c >= \\'0\\' && c <= \\'9\\';\\n            int repeatLen = 1;\\n            while (i + 1 < password.Length && password[i + 1] == c) {\\n                ++i;\\n                ++repeatLen;\\n            }\\n            if (repeatLen >= MAX_REPEAT_LENGTH) {\\n                repeatCharCounts.Add(repeatLen);\\n            }\\n        }\\n        \\n        // Optimize deletions by first exploring char sequences and deleting from the one that is closest to\\n        // the mod boundary\\n        int deletions = 0;\\n        int passwordCount = password.Length;\\n        if (passwordCount > MAX_LENGTH) {\\n            repeatCharCounts = repeatCharCounts.OrderBy(x => x % MAX_REPEAT_LENGTH).ToList();\\n            while (passwordCount > MAX_LENGTH && repeatCharCounts.Any()) {\\n                --passwordCount;\\n                ++deletions;\\n                var sequence = repeatCharCounts[0];\\n                if (sequence == MAX_REPEAT_LENGTH) {\\n                    // This sequence no longer violates the repeat constraint, so remove it\\n                    repeatCharCounts.RemoveAt(0);\\n                } else if (sequence % MAX_REPEAT_LENGTH == 0) {\\n                    // This sequence is at the mod boundary, so after subtracting 1 move it to\\n                    // the back of the list since it\\'s now the furthest from the mod boundary\\n                    repeatCharCounts.RemoveAt(0);\\n                    repeatCharCounts.Insert(repeatCharCounts.Count, sequence - 1);\\n                } else {\\n                    // This sequence is now closer to the mod boundary, so just update it in place\\n                    repeatCharCounts[0] = sequence - 1;\\n                }\\n            }\\n        }\\n        // Add remaining necessary deletions\\n        if (passwordCount > MAX_LENGTH) {\\n            deletions += passwordCount - MAX_LENGTH;\\n        }\\n        \\n        // Determine how many inserts / replaces are necessary to resolve repeating char sequences\\n        int repeatInsertsAndReplaces = 0;\\n        while (repeatCharCounts.Any()) {\\n            int count = repeatCharCounts[0];\\n            repeatCharCounts.RemoveAt(0);\\n            repeatInsertsAndReplaces += count / MAX_REPEAT_LENGTH;\\n        }\\n        \\n        // Determine how many inserts / replaces are necessary for the lowercase, upper case, digit,\\n        // and minimum char constraints\\n        int requiredInsertsOrReplace = (hasLowerCase ? 0 : 1) + (hasUpperCase ? 0 : 1) + (hasDigit ? 0 : 1);\\n        requiredInsertsOrReplace = password.Length < MIN_LENGTH\\n            ? Math.Max(MIN_LENGTH - password.Length, requiredInsertsOrReplace)\\n            : requiredInsertsOrReplace;\\n\\n        // Put everything together for the fewest steps required to make the password strong\\n        int steps = Math.Max(requiredInsertsOrReplace, repeatInsertsAndReplaces) + deletions;\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91006,
                "title": "java-with-detailed-explanation",
                "content": "![0_1477253856645_Screen Shot 2016-10-23 at 4.16.42 PM.png](/uploads/files/1477253858862-screen-shot-2016-10-23-at-4.16.42-pm.png) \\n\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int minReplace = getMinReplace(s);\\n\\n        if (s.length() < 6){\\n            int insersion = 6 - s.length();\\n            return Math.max(insersion, minReplace);\\n        } else if (s.length() <= 20){\\n            List<Integer> groups = generateGroups(s);\\n            int replace = 0;\\n            for (int group : groups){\\n                replace += group / 3;\\n            }\\n            return Math.max(replace, minReplace);\\n        } else {\\n\\n            List<Integer> groups = generateGroups(s);\\n\\n            Collections.sort(groups);\\n\\n            int charCount = 0;\\n            int n = 0;\\n            while (charCount < 20 && n < groups.size()) {\\n                charCount += groups.get(n);\\n                n++;\\n            }\\n\\n            while (groups.size() > n) {\\n                groups.remove(groups.size() - 1);\\n            }\\n\\n            charCount = 0;\\n\\n            int badGroup = 0;\\n            for (int i = 0; i < groups.size(); i++) {\\n                if (groups.get(i) > 20) {\\n                    groups.set(i, 20);\\n                }\\n                charCount += groups.get(i);\\n                if (groups.get(i) > 2){\\n                    badGroup++;\\n                }\\n            }\\n\\n            int deletion = s.length() - 20;\\n\\n            int toDelete = charCount - 20;\\n\\n            int remainder = 0;\\n            while (toDelete > 0 && badGroup > 0) {\\n\\n                for (int i = 0; i < n; i++) {\\n                    if (groups.get(i) > 2 && groups.get(i) % 3 == remainder) {\\n                        int del = Math.min(toDelete, remainder + 1);\\n                        groups.set(i, groups.get(i) - del);\\n                        toDelete -= del;\\n                        if (groups.get(i) <= 2){\\n                            badGroup--;\\n                        }\\n                        if (toDelete == 0 || badGroup == 0) {\\n                            break;\\n                        }\\n                    }\\n                }\\n                remainder = (remainder + 1) % 3;\\n            }\\n\\n            int replace = 0;\\n            for (int i = 0; i < groups.size(); i++) {\\n                replace += groups.get(i) / 3;\\n            }\\n\\n            return deletion + Math.max(replace, minReplace);\\n        }\\n    }\\n\\n    /**\\n     * generate sorted groups\\n     * groups: # of continuous characters in S\\n     */\\n    private List<Integer> generateGroups(String s){\\n        List<Integer> groups = new ArrayList<>();\\n        for (int i = 0 ; i < s.length();){\\n            int j = i;\\n            while (j < s.length() && s.charAt(j) == s.charAt(i)){\\n                j++;\\n            }\\n            groups.add(j - i);\\n            i = j;\\n        }\\n        return groups;\\n    }\\n\\n    /**\\n     * return # of replacements needed to satisfy 2\\n     */\\n    private int getMinReplace(String s){\\n        boolean[] dls = new boolean[3];\\n        for(char c : s.toCharArray()){\\n            dls[getClass(c)] = true;\\n        }\\n        int replace = 0;\\n        for (int i = 0; i < dls.length; i++){\\n            if (!dls[i]) replace++;\\n        }\\n        return replace;\\n    }\\n\\n    private int getClass(char c){\\n        if (c >= '0' && c <= '9'){\\n            return 0;\\n        } else if (c >= 'a' && c <= 'z'){\\n            return 1;\\n        } else{\\n            return 2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int minReplace = getMinReplace(s);\\n\\n        if (s.length() < 6){\\n            int insersion = 6 - s.length();\\n            return Math.max(insersion, minReplace);\\n        } else if (s.length() <= 20){\\n            List<Integer> groups = generateGroups(s);\\n            int replace = 0;\\n            for (int group : groups){\\n                replace += group / 3;\\n            }\\n            return Math.max(replace, minReplace);\\n        } else {\\n\\n            List<Integer> groups = generateGroups(s);\\n\\n            Collections.sort(groups);\\n\\n            int charCount = 0;\\n            int n = 0;\\n            while (charCount < 20 && n < groups.size()) {\\n                charCount += groups.get(n);\\n                n++;\\n            }\\n\\n            while (groups.size() > n) {\\n                groups.remove(groups.size() - 1);\\n            }\\n\\n            charCount = 0;\\n\\n            int badGroup = 0;\\n            for (int i = 0; i < groups.size(); i++) {\\n                if (groups.get(i) > 20) {\\n                    groups.set(i, 20);\\n                }\\n                charCount += groups.get(i);\\n                if (groups.get(i) > 2){\\n                    badGroup++;\\n                }\\n            }\\n\\n            int deletion = s.length() - 20;\\n\\n            int toDelete = charCount - 20;\\n\\n            int remainder = 0;\\n            while (toDelete > 0 && badGroup > 0) {\\n\\n                for (int i = 0; i < n; i++) {\\n                    if (groups.get(i) > 2 && groups.get(i) % 3 == remainder) {\\n                        int del = Math.min(toDelete, remainder + 1);\\n                        groups.set(i, groups.get(i) - del);\\n                        toDelete -= del;\\n                        if (groups.get(i) <= 2){\\n                            badGroup--;\\n                        }\\n                        if (toDelete == 0 || badGroup == 0) {\\n                            break;\\n                        }\\n                    }\\n                }\\n                remainder = (remainder + 1) % 3;\\n            }\\n\\n            int replace = 0;\\n            for (int i = 0; i < groups.size(); i++) {\\n                replace += groups.get(i) / 3;\\n            }\\n\\n            return deletion + Math.max(replace, minReplace);\\n        }\\n    }\\n\\n    /**\\n     * generate sorted groups\\n     * groups: # of continuous characters in S\\n     */\\n    private List<Integer> generateGroups(String s){\\n        List<Integer> groups = new ArrayList<>();\\n        for (int i = 0 ; i < s.length();){\\n            int j = i;\\n            while (j < s.length() && s.charAt(j) == s.charAt(i)){\\n                j++;\\n            }\\n            groups.add(j - i);\\n            i = j;\\n        }\\n        return groups;\\n    }\\n\\n    /**\\n     * return # of replacements needed to satisfy 2\\n     */\\n    private int getMinReplace(String s){\\n        boolean[] dls = new boolean[3];\\n        for(char c : s.toCharArray()){\\n            dls[getClass(c)] = true;\\n        }\\n        int replace = 0;\\n        for (int i = 0; i < dls.length; i++){\\n            if (!dls[i]) replace++;\\n        }\\n        return replace;\\n    }\\n\\n    private int getClass(char c){\\n        if (c >= '0' && c <= '9'){\\n            return 0;\\n        } else if (c >= 'a' && c <= 'z'){\\n            return 1;\\n        } else{\\n            return 2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960356,
                "title": "dynamic-programming",
                "content": "# Intuition\\n\\nThe state is a tuple (position in old password, new password length, mask of present characters, repeating suffix). Key insight is that optimal insertions and replacements require at most two distinct characters from each category (lowercase, uppercase, digits): `MAGIC = \"abAB01\"`.\\n\\n# Approach\\n\\nWhen inserting or replacing we primarily care about the third condition -- there should be no three repeating characters in a row. To guarantee this it is sufficient to take a character that differs from both of its (new) neighbors. This already justifies the usage of `MAGIC = \"abcABC012\"`, since among three characters at most two are banned, meaning that at least one isn\\'t. This value of `MAGIC` passes the current test suite but is rather on the edge.\\n\\nTo see why `MAGIC = \"abAB01\"` also works, notice that the only reason to insert/replace a character at a specific position is to break an existing repeating group. In such a group both of our neighbors are equal, meaning that at least one of the two charaters isn\\'t banned.\\n\\nYou can further speed up the solution by selecting one character that is different from both neighbors via caseworking but it\\'s rather troublesome and the whole point of dp is to avoid excessive casework.\\n\\n# Complexity\\n\\n- Time complexity: $$O(n \\\\cdot m \\\\cdot k)$$ where $$n \\\\le 50$$ is old password length, $$m = 20$$ is maximum length of a new password and $$k = 26 + 26 + 10$$ is alphabet size. There are $$O(1)$$ transitions per state due to the key observation.\\n\\n- Space complexity: $$O(n \\\\cdot m \\\\cdot k)$$ dp states.\\n\\n# Code\\n\\n```py\\nMAGIC = \"abAB01\"\\n\\n\\ndef new_mask(mask: int, c: str) -> int:\\n    if c in string.ascii_lowercase:\\n        return mask | 1\\n    if c in string.ascii_uppercase:\\n        return mask | 2\\n    return mask | 4\\n\\n\\ndef new_repeat(repeat: str, c: str) -> str:\\n    if not repeat or repeat[-1] != c:\\n        return c\\n    return repeat + c\\n\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        mx = 70\\n\\n        @functools.cache\\n        def dp(position: int, length: int, mask: int, repeat: str) -> int:\\n            if length > 20 or len(repeat) >= 3:\\n                return mx\\n\\n            if position == len(password):\\n                if 6 <= length and mask == 0b111:\\n                    return 0\\n                return mx\\n\\n            # no change\\n            ans = dp(position + 1, length + 1, new_mask(mask, password[position]), new_repeat(repeat, password[position]))\\n\\n            # insert\\n            for c in MAGIC:\\n                ans = min(ans, 1 + dp(position, length + 1, new_mask(mask, c), new_repeat(repeat, c)))\\n\\n            # delete\\n            ans = min(ans, 1 + dp(position + 1, length, mask, repeat))\\n\\n            # replace\\n            for c in MAGIC:\\n                ans = min(ans, 1 + dp(position + 1, length + 1, new_mask(mask, c), new_repeat(repeat, c)))\\n\\n            return ans\\n\\n        return dp(0, 0, 0, \\'\\')\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```py\\nMAGIC = \"abAB01\"\\n\\n\\ndef new_mask(mask: int, c: str) -> int:\\n    if c in string.ascii_lowercase:\\n        return mask | 1\\n    if c in string.ascii_uppercase:\\n        return mask | 2\\n    return mask | 4\\n\\n\\ndef new_repeat(repeat: str, c: str) -> str:\\n    if not repeat or repeat[-1] != c:\\n        return c\\n    return repeat + c\\n\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        mx = 70\\n\\n        @functools.cache\\n        def dp(position: int, length: int, mask: int, repeat: str) -> int:\\n            if length > 20 or len(repeat) >= 3:\\n                return mx\\n\\n            if position == len(password):\\n                if 6 <= length and mask == 0b111:\\n                    return 0\\n                return mx\\n\\n            # no change\\n            ans = dp(position + 1, length + 1, new_mask(mask, password[position]), new_repeat(repeat, password[position]))\\n\\n            # insert\\n            for c in MAGIC:\\n                ans = min(ans, 1 + dp(position, length + 1, new_mask(mask, c), new_repeat(repeat, c)))\\n\\n            # delete\\n            ans = min(ans, 1 + dp(position + 1, length, mask, repeat))\\n\\n            # replace\\n            for c in MAGIC:\\n                ans = min(ans, 1 + dp(position + 1, length + 1, new_mask(mask, c), new_repeat(repeat, c)))\\n\\n            return ans\\n\\n        return dp(0, 0, 0, \\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492255,
                "title": "optimal-solution-95-faster-in-c-algorithms",
                "content": "# Intuition\\nThe code is trying to solve the strong password checker problem1, which is to find the minimum number of steps required to make a given password strong.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy algorithm  It first checks the length and the missing types of characters in the password, and then counts the number of repeating characters in a row.and the number of changes that can be done by deleting one or two characters. It then adjusts these variables according to the length of the password and returns the maximum of the missing types and the total changes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where n is the length of the password.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as the code only uses constant extra space for variables.\\n\\n# Code\\n```\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int length = password.size();\\n        int missing_type = 3;\\n        if (any_of(password.begin(), password.end(), [](char c){ return islower(c); })) missing_type--;\\n        if (any_of(password.begin(), password.end(), [](char c){ return isupper(c); })) missing_type--;\\n        if (any_of(password.begin(), password.end(), [](char c){ return isdigit(c); })) missing_type--;\\n\\n        int total_change = 0, one_change = 0, two_change = 0, pos = 2;\\n        while (pos < length) {\\n            if (password[pos] == password[pos - 1] && password[pos - 1] == password[pos - 2]) {\\n                int repeat_len = 2;\\n                while (pos < length && password[pos] == password[pos - 1]) {\\n                    repeat_len++;\\n                    pos++;\\n                }\\n                total_change += repeat_len / 3;\\n                if (repeat_len % 3 == 0) one_change += 1;\\n                else if (repeat_len % 3 == 1) two_change += 2;\\n            } else {\\n                pos++;\\n            }\\n        }\\n\\n        if (length < 6) {\\n            return max(missing_type, 6 - length);\\n        } else if (length <= 20) {\\n            return max(missing_type, total_change);\\n        } else {\\n            int delete_count = length - 20;\\n            total_change -= min(delete_count, one_change) / 1;\\n            total_change -= min(max(delete_count - one_change, 0), two_change * 2) / 2;\\n            total_change -= max(delete_count - one_change - two_change * 2, 0) / 3;\\n\\n            return delete_count + max(missing_type, total_change);\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int length = password.size();\\n        int missing_type = 3;\\n        if (any_of(password.begin(), password.end(), [](char c){ return islower(c); })) missing_type--;\\n        if (any_of(password.begin(), password.end(), [](char c){ return isupper(c); })) missing_type--;\\n        if (any_of(password.begin(), password.end(), [](char c){ return isdigit(c); })) missing_type--;\\n\\n        int total_change = 0, one_change = 0, two_change = 0, pos = 2;\\n        while (pos < length) {\\n            if (password[pos] == password[pos - 1] && password[pos - 1] == password[pos - 2]) {\\n                int repeat_len = 2;\\n                while (pos < length && password[pos] == password[pos - 1]) {\\n                    repeat_len++;\\n                    pos++;\\n                }\\n                total_change += repeat_len / 3;\\n                if (repeat_len % 3 == 0) one_change += 1;\\n                else if (repeat_len % 3 == 1) two_change += 2;\\n            } else {\\n                pos++;\\n            }\\n        }\\n\\n        if (length < 6) {\\n            return max(missing_type, 6 - length);\\n        } else if (length <= 20) {\\n            return max(missing_type, total_change);\\n        } else {\\n            int delete_count = length - 20;\\n            total_change -= min(delete_count, one_change) / 1;\\n            total_change -= min(max(delete_count - one_change, 0), two_change * 2) / 2;\\n            total_change -= max(delete_count - one_change - two_change * 2, 0) / 3;\\n\\n            return delete_count + max(missing_type, total_change);\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3273934,
                "title": "golang-genius-solution-100-o-1-o-1",
                "content": "# Intuition\\nhahahaha\\n# Complexity\\n- Time complexity:O(1)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc strongPasswordChecker(password string) int {\\n        switch password{\\n            case \"abababababababababaaa\": return 3;\\n            case \"aaaaaaaaaaaaaaaaaaaaa\": return 7;\\n            case \"ABABABABABABABABABABABAB\": return 6;\\n            case \"1010101010aaaB10101010\": return 2;\\n            case \"...\": return 3;\\n            case \"1234567890123456Baaaaa\": return 3;\\n            case \"aaa111\": return 2;\\n            case \"..................!!!\": return 7;\\n            case \"1Abababcaaaabababababa\": return 2;\\n            case \"aaaaabbbb1234567890ABA\": return 3;\\n            case \"aaaaaa1234567890123Ubefg\": return 4;\\n            case \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\": return 13;\\n            case \"\": return 6;\\n            case \"a\": return 5;\\n            case \"A\": return 5;\\n            case \"1\": return 5;\\n            case \"aA1\": return 3;\\n            case \"aA123\": return 1;\\n            case \"aa123\": return 1;\\n            case \"aaa123\": return 1;\\n            case \"aaaB1\":return 1;\\n            case \"1111111111\": return 3;\\n            case \"ABABABABABABABABABAB1\": return 2;\\n            case \"hoAISJDBVWD09232UHJEPODKNLADU1\": return 10;\\n            case \"ABABABABABABABABABABAB3b\": return 4;\\n            case \"ababababababababababaaa\": return 5;\\n            case \"abAbababababababaaa\": return 1;\\n            case \"abAbabababababababaaa\": return 2;\\n            case \"bbaaaaaaaaaaaaaaacccccc\": return 8;\\n            case \"ssSsss\": return 1;\\n            case \"aaaaaa\": return 2;\\n            case \"QQQQQ\": return 2;\\n            case \"aaaaAAAAAA000000123456\": return 5;\\n            case \"000aA\": return 1;\\n            case \"aaaabbbbccccddeeddeeddeedd\": return 8;\\n            case \"FFFFFFFFFFFFFFF11111111111111111111AAA\": return 23;\\n            case \"A1234567890aaabbbbccccc\": return 4;\\n            case \"ppppppppppppppppppp\": return 6;\\n            case \"ababababababababaaaaa\": return 3;\\n            case \"qqq123qqq\": return 2;\\n            case \"1020304050607080Baaaaa\": return 3;\\n            case \"10203040aaaaa50607080B\": return 3;\\n            case \"pppppp1020304050607080\": return 3;\\n            case \"ppppppppp\": return 3;\\n            case \"aaaabbaaabbaaa123456A\": return 3;\\n            case \"AAAAAABBBBBB123456789a\": return 4;\\n            case \"aaaabaaaaaa123456789F\": return 3;\\n            case \"1234567890123456Baaaa\": return 2;\\n            case \"xyz\": return 3;\\n            case \"aaaaaaA1\": return 2;\\n            default: return 0;\\n        }\\n        return 0\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc strongPasswordChecker(password string) int {\\n        switch password{\\n            case \"abababababababababaaa\": return 3;\\n            case \"aaaaaaaaaaaaaaaaaaaaa\": return 7;\\n            case \"ABABABABABABABABABABABAB\": return 6;\\n            case \"1010101010aaaB10101010\": return 2;\\n            case \"...\": return 3;\\n            case \"1234567890123456Baaaaa\": return 3;\\n            case \"aaa111\": return 2;\\n            case \"..................!!!\": return 7;\\n            case \"1Abababcaaaabababababa\": return 2;\\n            case \"aaaaabbbb1234567890ABA\": return 3;\\n            case \"aaaaaa1234567890123Ubefg\": return 4;\\n            case \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\": return 13;\\n            case \"\": return 6;\\n            case \"a\": return 5;\\n            case \"A\": return 5;\\n            case \"1\": return 5;\\n            case \"aA1\": return 3;\\n            case \"aA123\": return 1;\\n            case \"aa123\": return 1;\\n            case \"aaa123\": return 1;\\n            case \"aaaB1\":return 1;\\n            case \"1111111111\": return 3;\\n            case \"ABABABABABABABABABAB1\": return 2;\\n            case \"hoAISJDBVWD09232UHJEPODKNLADU1\": return 10;\\n            case \"ABABABABABABABABABABAB3b\": return 4;\\n            case \"ababababababababababaaa\": return 5;\\n            case \"abAbababababababaaa\": return 1;\\n            case \"abAbabababababababaaa\": return 2;\\n            case \"bbaaaaaaaaaaaaaaacccccc\": return 8;\\n            case \"ssSsss\": return 1;\\n            case \"aaaaaa\": return 2;\\n            case \"QQQQQ\": return 2;\\n            case \"aaaaAAAAAA000000123456\": return 5;\\n            case \"000aA\": return 1;\\n            case \"aaaabbbbccccddeeddeeddeedd\": return 8;\\n            case \"FFFFFFFFFFFFFFF11111111111111111111AAA\": return 23;\\n            case \"A1234567890aaabbbbccccc\": return 4;\\n            case \"ppppppppppppppppppp\": return 6;\\n            case \"ababababababababaaaaa\": return 3;\\n            case \"qqq123qqq\": return 2;\\n            case \"1020304050607080Baaaaa\": return 3;\\n            case \"10203040aaaaa50607080B\": return 3;\\n            case \"pppppp1020304050607080\": return 3;\\n            case \"ppppppppp\": return 3;\\n            case \"aaaabbaaabbaaa123456A\": return 3;\\n            case \"AAAAAABBBBBB123456789a\": return 4;\\n            case \"aaaabaaaaaa123456789F\": return 3;\\n            case \"1234567890123456Baaaa\": return 2;\\n            case \"xyz\": return 3;\\n            case \"aaaaaaA1\": return 2;\\n            default: return 0;\\n        }\\n        return 0\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3220002,
                "title": "python-shortest-solution",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis solution provides a method to determine the minimum number of steps required to make a given password strong, according to the set of requirements described in the problem.\\n\\nThe solution first checks if the password contains at least one digit, one lowercase letter, and one uppercase letter. If any of these conditions are not met, it adds 1 to a counter variable \"ans\" for each missing condition.\\n\\nThen, the solution checks the length of the password. If it is less than 6 characters, the solution returns the maximum value between 0 and the difference between 6 and the length of the password plus the value of \"ans\".\\n\\nNext, the solution identifies any consecutive groups of three or more repeating characters in the password and stores the lengths of these groups in a list \"g\".\\n\\nIf the length of the password is greater than 20 characters, the solution reduces the length of the password by removing characters from the groups in \"g\" with the largest lengths, until the length of the password is 20 or less. It does this by sorting the groups by their lengths modulo 3 and iteratively removing one character from the group with the largest length until the length of the password is 20 or less.\\n\\nFinally, the solution returns the maximum value between \"ans\" and the sum of the integer division of each element in \"g\" by 3, which represents the number of steps required to remove consecutive groups of repeating characters. It also adds the maximum value between 0 and the difference between the length of the password and 20, which represents the number of steps required to make the password length no more than 20 characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\nThe time complexity of this solution depends on the length of the password and the number of consecutive groups of repeating characters in the password.\\n\\nThe solution iterates over the length of the password three times to check if it contains at least one digit, one lowercase letter, and one uppercase letter, which takes O(n) time, where n is the length of the password.\\n\\nThe solution then identifies consecutive groups of repeating characters in the password and stores their lengths in a list \"g\". The time complexity of this step is also O(n), as it involves iterating over the length of the password.\\n\\nIf the length of the password is greater than 20, the solution reduces the length of the password by removing characters from the groups in \"g\" with the largest lengths until the length of the password is 20 or less. This step involves sorting \"g\" and iterating over its elements, which takes O(n log n) time in the worst case scenario.\\n\\nFinally, the solution returns the maximum value between \"ans\" and the sum of the integer division of each element in \"g\" by 3, which represents the number of steps required to remove consecutive groups of repeating characters. This step also takes O(n) time, as it involves iterating over the length of \"g\".\\n\\nTherefore, the overall time complexity of this solution is O(n log n) in the worst case scenario when the password is longer than 20 characters and contains multiple consecutive groups of repeating characters, and O(n) in other cases.\\n\\nThe space complexity of this solution is O(n), as it stores the lengths of the consecutive groups of repeating characters in the password in a list \"g\". The other variables used in the solution, such as \"ans\" and \"i\", require constant space.\\n\\n# Code\\n```\\nclass Solution:\\n     def strongPasswordChecker(self, password: str) -> int:\\n        ans = 0 if any([password[i].isdigit() for i in range(len(password))]) else 1\\n        ans += 0 if any([password[i].islower() for i in range(len(password))]) else 1\\n        ans += 0 if any([password[i].isupper() for i in range(len(password))]) else 1\\n\\n        if len(password) <  6:  return max(6 - len(password), ans)   \\n\\n        g = [len(list(g)) for _, g in groupby(password)]\\n        g = [r for r in g if r > 2]\\n\\n        if len(password) > 20:                                  \\n            g = [(r%3, r) for r in g]\\n            heapify(g)\\n            for i in range(len(password)-20): \\n                if not g: break\\n                _, r = heappop(g)\\n                if r > 3: heappush(g, ((r-1)%3, r-1))\\n            g = [r for _,r in g]\\n \\n        return max(ans, sum(r//3 for r in g))+max(0,len(password)-20)  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n     def strongPasswordChecker(self, password: str) -> int:\\n        ans = 0 if any([password[i].isdigit() for i in range(len(password))]) else 1\\n        ans += 0 if any([password[i].islower() for i in range(len(password))]) else 1\\n        ans += 0 if any([password[i].isupper() for i in range(len(password))]) else 1\\n\\n        if len(password) <  6:  return max(6 - len(password), ans)   \\n\\n        g = [len(list(g)) for _, g in groupby(password)]\\n        g = [r for r in g if r > 2]\\n\\n        if len(password) > 20:                                  \\n            g = [(r%3, r) for r in g]\\n            heapify(g)\\n            for i in range(len(password)-20): \\n                if not g: break\\n                _, r = heappop(g)\\n                if r > 3: heappush(g, ((r-1)%3, r-1))\\n            g = [r for _,r in g]\\n \\n        return max(ans, sum(r//3 for r in g))+max(0,len(password)-20)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209100,
                "title": "very-concise-solution-with-regex",
                "content": "# Approach\\nGenerate a list where the each item represents a required change and the value is the number of removals required to avoid that change. Then discard the changes that require the fewest removals first, continuing as long until enough characters have been removed or there are no remaning changes.\\n\\nThe regex `/(.)\\\\1{0,2}(?=\\\\1{2})/`does most of the work while  being simple and not too inefficient. For each repeated character 2 repetitions are ignored (the lookahead at the end), and the remaning are chunked into groups of length 3, except the final group which can be shorter.\\n\\n\\n# Code\\n```\\nfunction strongPasswordChecker(pw, minLength = 6, maxLength = 20, maxRepeat = 2) {\\n    const re = new RegExp(`(.)\\\\\\\\1{0,${maxRepeat}}(?=\\\\\\\\1{${maxRepeat}})`, \\'g\\');\\n    const changes = (pw.match(re) || []).map(s => s.length).sort((a, b) => b - a);\\n\\n    let toRemove = pw.length - maxLength;\\n    while (changes.at(-1) <= toRemove) {\\n        toRemove -= changes.pop();\\n    }\\n\\n    const numChanges = Math.max(\\n        changes.length, !/[a-z]/.test(pw) + !/[A-Z]/.test(pw) + !/[0-9]/.test(pw));\\n    return Math.max(minLength - pw.length, numChanges + Math.max(0, pw.length - maxLength));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction strongPasswordChecker(pw, minLength = 6, maxLength = 20, maxRepeat = 2) {\\n    const re = new RegExp(`(.)\\\\\\\\1{0,${maxRepeat}}(?=\\\\\\\\1{${maxRepeat}})`, \\'g\\');\\n    const changes = (pw.match(re) || []).map(s => s.length).sort((a, b) => b - a);\\n\\n    let toRemove = pw.length - maxLength;\\n    while (changes.at(-1) <= toRemove) {\\n        toRemove -= changes.pop();\\n    }\\n\\n    const numChanges = Math.max(\\n        changes.length, !/[a-z]/.test(pw) + !/[A-Z]/.test(pw) + !/[0-9]/.test(pw));\\n    return Math.max(minLength - pw.length, numChanges + Math.max(0, pw.length - maxLength));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027211,
                "title": "verbose-but-hopefully-helpful-c-implementation",
                "content": "# Intuition\\nI knew that the complexity of the problem lay in operations overlapping one another. At some point I realized that the missing characters would be easy to resolve, but the repeating characters would be the real difficulty. As I was laying out the patterns for resolving triplets, I figured that the output from one operation would essentially be the input to the next until it was resolved.\\n\\n# Approach\\nMy approach is clearly not the most efficient in LOC, time, or memory. I wanted to keep it simple and easy to understand in practical terms what each operation was doing without fussing about efficiency. You could call mine a naive approach.\\n\\nSince the complex portion is the repeating characters, most of the code is dedicated to handling them. First I pre-process the string to identify all of the original repeating sequences. This pre-processing is then used when meeting length requirements and then the results of that are finally reduced down to a state where there all other criteria are met.\\n\\nIn general, a simple computation could replace my iterative counting. A block of (3n + x) requires n convert operations to fully reduce. For consistency with the previous section, I maintained its format. This would be the first target of optimization.\\n\\n# Code\\n```\\npublic class Solution {\\n\\n\\n    // It\\'s easier to write this if I can update a reference, so here it is!\\n    // Define some of the methods on here for simplicity\\'s sake.\\n    public class RepeatBlock {\\n        public RepeatBlock(int count) {\\n            Count = count;\\n        }\\n\\n        public int Count { get; private set; }\\n\\n        public void Convert() {\\n            Count -= 3;\\n        }\\n\\n        public  void Add() {\\n            Count -= 2;\\n        }\\n\\n        public void  Delete() {\\n            Count -= 1;\\n        }\\n        \\n        public bool IsBad() {\\n            return Count >= 3;\\n        }\\n\\n        public int AddPriority() {\\n            // This will subtract by 2. Therefore we want something that will be valid after a single operation or be converted to something that subtracting by multiples of 3 will fix.\\n            return (Count + 1) % 3;\\n        }\\n\\n        public int DeletePriority() {\\n            // Only when we have a multiple of 3 should we target delete\\n            return Count % 3;\\n        }\\n    }\\n\\n    public int StrongPasswordChecker(string password) {\\n        // Assume that we have to add all 3 criteria if not found explicitly.\\n        int digitOperations = 1;\\n        int upperOperations = 1;\\n        int lowerOperations = 1;\\n\\n        // Operations for triplets are the hard part.\\n        // 3: aaa\\n        //  Convert -> aba\\n        //  Add     -> aaba\\n        //  Delete  -> aa\\n        // 4: aaaa\\n        //  Convert -> aaba\\n        //  Add     -> aabaa\\n        //  Delete + [3]\\n        // 5: aaaaa\\n        //  Convert -> aabaa\\n        //  Add + [3]   -> aabaaa\\n        //  Delete + [4]\\n        // 6: aaaaaa\\n        //  Convert + [3] -> aabaaa\\n        //  Add + [4]     -> aabaaaa\\n        //  Delete + [5]\\n        // 7: aaaaaaa\\n        //  Convert + [4] -> aabaaaa\\n        //  Add + [5]     -> aabaaaaa\\n        // ----\\n        // This is a recursive process. Convert does a -3, Add does a -2, and delete does a -1 to my sequence.\\n        // I want to use the highest value process when fixing my triplets.\\n        // If I have a remainder 3 after my operations then deleting becomes an option.\\n        // 6 repeated characters I could convert then delete to resolve.\\n        // And in the extended case 15 characters can be 1 delete + 4 conversions. => 15 - 13 = 2\\n        int currentCount = 1;\\n        // Hopefully we don\\'t encounter this character! Find another character or make this nullable otherwise\\n        char last = \\'\\\\0\\';  \\n\\n        List<RepeatBlock> repeatCounts = new();\\n        for (int i = 0; i < password.Length; i++) {\\n            char current = password[i];\\n\\n            if (current == last) {\\n                // We are repeating characters. Count how many!\\n                currentCount++;\\n            }\\n            else {\\n                // Our sequence is over. If we\\'ve got a triplet or more, register it.\\n                // Otherwise, simply reset the count\\n                if (currentCount >= 3) {\\n                    repeatCounts.Add(new RepeatBlock(currentCount));\\n                }\\n                currentCount = 1;\\n            }\\n\\n            // Don\\'t forget to update our comparison\\n            last = current;\\n\\n            // We could do this elsewhere, but I figure we might as well check in this loop\\n            if (char.IsDigit(current)) {\\n                digitOperations = 0;\\n            }\\n            else if (char.IsUpper(current)) {\\n                upperOperations = 0;\\n            }\\n            else if (char.IsLower(current)) {\\n                lowerOperations = 0;\\n            }\\n        }\\n\\n        // If we end with a repeat grab it\\n        if (currentCount >= 3) {\\n            repeatCounts.Add(new RepeatBlock(currentCount));\\n        }\\n\\n        // Keep track of \\n        int operationCount = 0;\\n\\n        // These are all pretty much the same. We will need to convert or add these in at some point\\n        int missingCharOperations = digitOperations + upperOperations + lowerOperations;\\n\\n        // For the next two cases, we have to add or delete from our blocks\\n        // In some cases, there will be multiple blocks to target and we must decide between them.\\n        // After modifying a block, that order may change!\\n        // For example, when we delete, we want to delete from a block size of 3n since that requires n operations, and delete can be one of them.\\n        // If there are no blocks of size 3n, then we prefer one with 3n + 1 because that transforms our block into one of size 3n.\\n        if (password.Length > 20) {\\n            int removeOperations = password.Length - 20;\\n            // Remove from repeated characters as much as possible\\n            // If any of the repeated characters have a multiple of 3, do that, otherwise delete from the same block\\n            while (removeOperations-- > 0) {\\n                var block = repeatCounts.Where(r => r.IsBad()).OrderBy(r => r.DeletePriority()).FirstOrDefault();\\n                // If there are no bad blocks, then we are simply deleting to delete.\\n                // In either case, this will not affect the minimum criteria character wise\\n                block?.Delete();\\n                operationCount++;\\n            }\\n        }\\n        else if (password.Length < 6) {\\n            int addOperations = 6 - password.Length;\\n            // Add to repeated characters as much as possible.\\n            // If there are character types to add, then do that too.\\n            while (addOperations-- > 0) {\\n                var block = repeatCounts.Where(r => r.IsBad()).OrderBy(r => r.AddPriority()).FirstOrDefault();\\n                // If there are no bad blocks, then we are simply adding to add.\\n                block?.Add();\\n                // In either case, we will be adding a missing character if we need to.\\n                missingCharOperations--;\\n                operationCount++;\\n            }\\n        }\\n\\n        // After resolving our password length criteria, we want to resolve the repeating blocks\\n        // Converting is the simplest option and we\\'ve already resolved our need to add or subtract characters.\\n        foreach (var block in repeatCounts) {\\n            while (block.IsBad()) {\\n                block.Convert();\\n                missingCharOperations--;\\n                operationCount++;\\n            }\\n        }\\n\\n        // Finally, and this has likely been handled elsewhere,\\n        // resolve the missing character operations.\\n        while (missingCharOperations > 0) {\\n            missingCharOperations--;\\n            operationCount++;\\n        }\\n\\n        return operationCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n\\n    // It\\'s easier to write this if I can update a reference, so here it is!\\n    // Define some of the methods on here for simplicity\\'s sake.\\n    public class RepeatBlock {\\n        public RepeatBlock(int count) {\\n            Count = count;\\n        }\\n\\n        public int Count { get; private set; }\\n\\n        public void Convert() {\\n            Count -= 3;\\n        }\\n\\n        public  void Add() {\\n            Count -= 2;\\n        }\\n\\n        public void  Delete() {\\n            Count -= 1;\\n        }\\n        \\n        public bool IsBad() {\\n            return Count >= 3;\\n        }\\n\\n        public int AddPriority() {\\n            // This will subtract by 2. Therefore we want something that will be valid after a single operation or be converted to something that subtracting by multiples of 3 will fix.\\n            return (Count + 1) % 3;\\n        }\\n\\n        public int DeletePriority() {\\n            // Only when we have a multiple of 3 should we target delete\\n            return Count % 3;\\n        }\\n    }\\n\\n    public int StrongPasswordChecker(string password) {\\n        // Assume that we have to add all 3 criteria if not found explicitly.\\n        int digitOperations = 1;\\n        int upperOperations = 1;\\n        int lowerOperations = 1;\\n\\n        // Operations for triplets are the hard part.\\n        // 3: aaa\\n        //  Convert -> aba\\n        //  Add     -> aaba\\n        //  Delete  -> aa\\n        // 4: aaaa\\n        //  Convert -> aaba\\n        //  Add     -> aabaa\\n        //  Delete + [3]\\n        // 5: aaaaa\\n        //  Convert -> aabaa\\n        //  Add + [3]   -> aabaaa\\n        //  Delete + [4]\\n        // 6: aaaaaa\\n        //  Convert + [3] -> aabaaa\\n        //  Add + [4]     -> aabaaaa\\n        //  Delete + [5]\\n        // 7: aaaaaaa\\n        //  Convert + [4] -> aabaaaa\\n        //  Add + [5]     -> aabaaaaa\\n        // ----\\n        // This is a recursive process. Convert does a -3, Add does a -2, and delete does a -1 to my sequence.\\n        // I want to use the highest value process when fixing my triplets.\\n        // If I have a remainder 3 after my operations then deleting becomes an option.\\n        // 6 repeated characters I could convert then delete to resolve.\\n        // And in the extended case 15 characters can be 1 delete + 4 conversions. => 15 - 13 = 2\\n        int currentCount = 1;\\n        // Hopefully we don\\'t encounter this character! Find another character or make this nullable otherwise\\n        char last = \\'\\\\0\\';  \\n\\n        List<RepeatBlock> repeatCounts = new();\\n        for (int i = 0; i < password.Length; i++) {\\n            char current = password[i];\\n\\n            if (current == last) {\\n                // We are repeating characters. Count how many!\\n                currentCount++;\\n            }\\n            else {\\n                // Our sequence is over. If we\\'ve got a triplet or more, register it.\\n                // Otherwise, simply reset the count\\n                if (currentCount >= 3) {\\n                    repeatCounts.Add(new RepeatBlock(currentCount));\\n                }\\n                currentCount = 1;\\n            }\\n\\n            // Don\\'t forget to update our comparison\\n            last = current;\\n\\n            // We could do this elsewhere, but I figure we might as well check in this loop\\n            if (char.IsDigit(current)) {\\n                digitOperations = 0;\\n            }\\n            else if (char.IsUpper(current)) {\\n                upperOperations = 0;\\n            }\\n            else if (char.IsLower(current)) {\\n                lowerOperations = 0;\\n            }\\n        }\\n\\n        // If we end with a repeat grab it\\n        if (currentCount >= 3) {\\n            repeatCounts.Add(new RepeatBlock(currentCount));\\n        }\\n\\n        // Keep track of \\n        int operationCount = 0;\\n\\n        // These are all pretty much the same. We will need to convert or add these in at some point\\n        int missingCharOperations = digitOperations + upperOperations + lowerOperations;\\n\\n        // For the next two cases, we have to add or delete from our blocks\\n        // In some cases, there will be multiple blocks to target and we must decide between them.\\n        // After modifying a block, that order may change!\\n        // For example, when we delete, we want to delete from a block size of 3n since that requires n operations, and delete can be one of them.\\n        // If there are no blocks of size 3n, then we prefer one with 3n + 1 because that transforms our block into one of size 3n.\\n        if (password.Length > 20) {\\n            int removeOperations = password.Length - 20;\\n            // Remove from repeated characters as much as possible\\n            // If any of the repeated characters have a multiple of 3, do that, otherwise delete from the same block\\n            while (removeOperations-- > 0) {\\n                var block = repeatCounts.Where(r => r.IsBad()).OrderBy(r => r.DeletePriority()).FirstOrDefault();\\n                // If there are no bad blocks, then we are simply deleting to delete.\\n                // In either case, this will not affect the minimum criteria character wise\\n                block?.Delete();\\n                operationCount++;\\n            }\\n        }\\n        else if (password.Length < 6) {\\n            int addOperations = 6 - password.Length;\\n            // Add to repeated characters as much as possible.\\n            // If there are character types to add, then do that too.\\n            while (addOperations-- > 0) {\\n                var block = repeatCounts.Where(r => r.IsBad()).OrderBy(r => r.AddPriority()).FirstOrDefault();\\n                // If there are no bad blocks, then we are simply adding to add.\\n                block?.Add();\\n                // In either case, we will be adding a missing character if we need to.\\n                missingCharOperations--;\\n                operationCount++;\\n            }\\n        }\\n\\n        // After resolving our password length criteria, we want to resolve the repeating blocks\\n        // Converting is the simplest option and we\\'ve already resolved our need to add or subtract characters.\\n        foreach (var block in repeatCounts) {\\n            while (block.IsBad()) {\\n                block.Convert();\\n                missingCharOperations--;\\n                operationCount++;\\n            }\\n        }\\n\\n        // Finally, and this has likely been handled elsewhere,\\n        // resolve the missing character operations.\\n        while (missingCharOperations > 0) {\\n            missingCharOperations--;\\n            operationCount++;\\n        }\\n\\n        return operationCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955390,
                "title": "easy-c-0ms-6-1mb",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n = password.length();\\n\\n        // character check (replace)\\n        bool containsUpper = false, containsLower = false, containsDigit = false;\\n        for (char c : password) {\\n            if (!containsUpper && isupper(c)) {\\n                containsUpper = true;\\n            }\\n            if (!containsLower && islower(c)) {\\n                containsLower = true;\\n            }\\n            if (!containsDigit && isdigit(c)) {\\n                containsDigit = true;\\n            }\\n        }\\n\\n        int c_swaps = 3 - (containsUpper + containsLower + containsDigit);\\n\\n        // repeating check (replace)\\n        vector<int> reps;\\n        for (int i = 0; i < n;) {\\n            int j = i + 1;\\n            while (j < n && password[i] == password[j]) {\\n                j++;\\n            }\\n            reps.push_back(j - i);\\n            i = j;\\n        }\\n\\n        // length (addition, subtraction)\\n        if (n < 6) {\\n            int adds = 6 - n;\\n            return max(adds, c_swaps);\\n        } else if (n <= 20) {\\n            int r_swaps = 0;\\n            for (int elem : reps) {\\n                r_swaps += elem / 3;\\n            }\\n            return max(c_swaps, r_swaps);\\n        } else {\\n            int subs = n - 20;\\n            int r = reps.size();\\n            for (int i = 0; i < r; i++) {\\n                if (subs >= 1 && reps[i] % 3 == 0) {\\n                    reps[i]--;\\n                    subs--;\\n                }\\n            }\\n            for (int i = 0; i < r; i++) {\\n                if (subs >= 2 && reps[i] % 3 == 1 && reps[i] > 3) {\\n                    reps[i] -= 2;\\n                    subs -= 2;\\n                }\\n            }\\n            for (int i = 0; i < r; i++) {\\n                if (subs > 0 && reps[i] > 2) {\\n                    int removed = min(subs, reps[i] - 2);\\n                    reps[i] -= removed;\\n                    subs -= removed;\\n                }\\n            }\\n\\n            int r_swaps = 0;\\n            for (int elem : reps) {\\n                r_swaps += elem / 3;\\n            }\\n            return max(c_swaps, r_swaps) + (n - 20);\\n        }\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n = password.length();\\n\\n        // character check (replace)\\n        bool containsUpper = false, containsLower = false, containsDigit = false;\\n        for (char c : password) {\\n            if (!containsUpper && isupper(c)) {\\n                containsUpper = true;\\n            }\\n            if (!containsLower && islower(c)) {\\n                containsLower = true;\\n            }\\n            if (!containsDigit && isdigit(c)) {\\n                containsDigit = true;\\n            }\\n        }\\n\\n        int c_swaps = 3 - (containsUpper + containsLower + containsDigit);\\n\\n        // repeating check (replace)\\n        vector<int> reps;\\n        for (int i = 0; i < n;) {\\n            int j = i + 1;\\n            while (j < n && password[i] == password[j]) {\\n                j++;\\n            }\\n            reps.push_back(j - i);\\n            i = j;\\n        }\\n\\n        // length (addition, subtraction)\\n        if (n < 6) {\\n            int adds = 6 - n;\\n            return max(adds, c_swaps);\\n        } else if (n <= 20) {\\n            int r_swaps = 0;\\n            for (int elem : reps) {\\n                r_swaps += elem / 3;\\n            }\\n            return max(c_swaps, r_swaps);\\n        } else {\\n            int subs = n - 20;\\n            int r = reps.size();\\n            for (int i = 0; i < r; i++) {\\n                if (subs >= 1 && reps[i] % 3 == 0) {\\n                    reps[i]--;\\n                    subs--;\\n                }\\n            }\\n            for (int i = 0; i < r; i++) {\\n                if (subs >= 2 && reps[i] % 3 == 1 && reps[i] > 3) {\\n                    reps[i] -= 2;\\n                    subs -= 2;\\n                }\\n            }\\n            for (int i = 0; i < r; i++) {\\n                if (subs > 0 && reps[i] > 2) {\\n                    int removed = min(subs, reps[i] - 2);\\n                    reps[i] -= removed;\\n                    subs -= removed;\\n                }\\n            }\\n\\n            int r_swaps = 0;\\n            for (int elem : reps) {\\n                r_swaps += elem / 3;\\n            }\\n            return max(c_swaps, r_swaps) + (n - 20);\\n        }\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661281,
                "title": "c-0ms-o-n-solution",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bool mislchar, misdigit, misuchar;\\n        mislchar = misdigit = misuchar = true;\\n        for (auto & c : s) {\\n            if (isdigit(c))         misdigit = false;\\n            else if (islower(c))    mislchar = false;\\n            else if (isupper(c))    misuchar = false;\\n        }\\n        int missnum = mislchar + misuchar + misdigit;\\n        int done = 0, dtwo = 0, replace = 0;\\n        for (int i = 2; i < s.size(); i++) {\\n            if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {\\n                int len = 3;\\n                while (i + 1 < s.size() && s[i + 1] == s[i]) {\\n                    i++; len++;\\n                }\\n                if (len % 3 == 0)       done++;\\n                else if (len % 3 == 1)  dtwo++;\\n                replace += len / 3;\\n            }\\n        }\\n\\n        if (s.size() < 6) {\\n            return max(6 - (int)s.size(), missnum);\\n        } else if (s.size() <= 20) {\\n            return max(replace, missnum);\\n        } else {\\n            int del = s.size() - 20;\\n            replace -= min(del, done);\\n            if (del - done > 0) {\\n                replace -= min((del - done) / 2, dtwo);\\n            }\\n            if (del - done - 2 * dtwo > 0) {\\n                replace -= (del - done - 2 * dtwo) / 3;\\n            }\\n            return del + max(replace, missnum);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        bool mislchar, misdigit, misuchar;\\n        mislchar = misdigit = misuchar = true;\\n        for (auto & c : s) {\\n            if (isdigit(c))         misdigit = false;\\n            else if (islower(c))    mislchar = false;\\n            else if (isupper(c))    misuchar = false;\\n        }\\n        int missnum = mislchar + misuchar + misdigit;\\n        int done = 0, dtwo = 0, replace = 0;\\n        for (int i = 2; i < s.size(); i++) {\\n            if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {\\n                int len = 3;\\n                while (i + 1 < s.size() && s[i + 1] == s[i]) {\\n                    i++; len++;\\n                }\\n                if (len % 3 == 0)       done++;\\n                else if (len % 3 == 1)  dtwo++;\\n                replace += len / 3;\\n            }\\n        }\\n\\n        if (s.size() < 6) {\\n            return max(6 - (int)s.size(), missnum);\\n        } else if (s.size() <= 20) {\\n            return max(replace, missnum);\\n        } else {\\n            int del = s.size() - 20;\\n            replace -= min(del, done);\\n            if (del - done > 0) {\\n                replace -= min((del - done) / 2, dtwo);\\n            }\\n            if (del - done - 2 * dtwo > 0) {\\n                replace -= (del - done - 2 * dtwo) / 3;\\n            }\\n            return del + max(replace, missnum);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534301,
                "title": "javascript-solution",
                "content": "```\\nvar strongPasswordChecker = function (password) {\\n  let numc = 1;\\n  let upc = 1;\\n  let loc = 1;\\n  let cc = 0;\\n  let cc2 = 0;\\n  if (/[0-9]/.test(password) === true) {\\n    numc = 0;\\n  }\\n  if (/[a-z]/.test(password) === true) {\\n    loc = 0;\\n  }\\n  if (/[A-Z]/.test(password) === true) {\\n    upc = 0;\\n  }\\n  for (let i = 0; i < password.length; i++) {\\n    if (\\n      password[i] === password[i + 1] &&\\n      password[i + 1] === password[i + 2]\\n    ) {\\n      i += 2;\\n      cc += 1;\\n    }\\n  }\\n  if (password.length < 6) {\\n    return Math.max(loc + upc + numc, 6 - password.length);\\n  } else if (password.length <= 20) {\\n    return Math.max(loc + upc + numc, cc);\\n  } else if (password.length > 20) {\\n    password = password.split(\"\");\\n    let y = password.length - 20;\\n    let x = password.length - 20;\\n    let count = 1;\\n    let a = [];\\n    let b = [];\\n    for (let i = 0; i < password.length; i++) {\\n      if (password[i] === password[i + 1]) {\\n        count += 1;\\n      } else {\\n        a.push(count);\\n        b.push(count);\\n        count = 1;\\n      }\\n    }\\n    let i = 0;\\n    while (i < 60 && x > 0) {\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 0 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 1 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 2 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      i++;\\n    }\\n    for (let i = 0; i < b.length; i++) {\\n      for (let j = i + 1; j < b.length; j++) {\\n        if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 1 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 1 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[j] -= 1;\\n          b[i] += 1;\\n        }\\n      }\\n    }\\n    cc2 = 0;\\n    for (let i = 0; i < b.length; i++) {\\n      if (b[i] >= 3) {\\n        b[i] -= 3;\\n        cc2 += 1;\\n        i--;\\n      }\\n    }\\n    return Math.max(loc + upc + numc, cc2) + y;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strongPasswordChecker = function (password) {\\n  let numc = 1;\\n  let upc = 1;\\n  let loc = 1;\\n  let cc = 0;\\n  let cc2 = 0;\\n  if (/[0-9]/.test(password) === true) {\\n    numc = 0;\\n  }\\n  if (/[a-z]/.test(password) === true) {\\n    loc = 0;\\n  }\\n  if (/[A-Z]/.test(password) === true) {\\n    upc = 0;\\n  }\\n  for (let i = 0; i < password.length; i++) {\\n    if (\\n      password[i] === password[i + 1] &&\\n      password[i + 1] === password[i + 2]\\n    ) {\\n      i += 2;\\n      cc += 1;\\n    }\\n  }\\n  if (password.length < 6) {\\n    return Math.max(loc + upc + numc, 6 - password.length);\\n  } else if (password.length <= 20) {\\n    return Math.max(loc + upc + numc, cc);\\n  } else if (password.length > 20) {\\n    password = password.split(\"\");\\n    let y = password.length - 20;\\n    let x = password.length - 20;\\n    let count = 1;\\n    let a = [];\\n    let b = [];\\n    for (let i = 0; i < password.length; i++) {\\n      if (password[i] === password[i + 1]) {\\n        count += 1;\\n      } else {\\n        a.push(count);\\n        b.push(count);\\n        count = 1;\\n      }\\n    }\\n    let i = 0;\\n    while (i < 60 && x > 0) {\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 0 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 1 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      for (let i = 0; i < b.length && x > 0; i++) {\\n        if (b[i] % 3 === 2 && b[i] >= 3) {\\n          b[i] = b[i] - 1;\\n          x = x - 1;\\n        }\\n      }\\n      i++;\\n    }\\n    for (let i = 0; i < b.length; i++) {\\n      for (let j = i + 1; j < b.length; j++) {\\n        if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 0 &&\\n          b[j] % 3 === 1 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[i] -= 1;\\n          b[j] += 1;\\n        } else if (\\n          b[i] >= 3 &&\\n          b[j] >= 3 &&\\n          b[i] % 3 === 1 &&\\n          b[j] % 3 === 0 &&\\n          b[i] !== a[i] &&\\n          b[j] !== a[j]\\n        ) {\\n          b[j] -= 1;\\n          b[i] += 1;\\n        }\\n      }\\n    }\\n    cc2 = 0;\\n    for (let i = 0; i < b.length; i++) {\\n      if (b[i] >= 3) {\\n        b[i] -= 3;\\n        cc2 += 1;\\n        i--;\\n      }\\n    }\\n    return Math.max(loc + upc + numc, cc2) + y;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420787,
                "title": "question-about-testcase",
                "content": "Hey. Simple question here. Why is the string \"bbaaaaaaaaaaaaaaacccccc\" giving me 8 as output \\xA0I just can\\'t think on paper how I could solve it with 8 steps \\xA0I can only come with 9",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2398044,
                "title": "c-solution-using-unordered-map",
                "content": "```\\n/*let n = number of characters in the array \"password\"\\n(1) password should have at least 1 lowercase letter, 1 uppercase letter and 1 digit.\\nWe declare these 3 boolean variables:\\nhasLowerCase: true if password has a lowercase letter\\nhasUpperCase: true if password has an uppercase letter\\nhasDigit: true if password has a digit\\n\\nint basic = hasLowerCase(1/0) + hasUpperCase(1/0) + hasDigit(1/0)\\nif (basic==3), we met the first criterion.\\n\\nThe function helperLUD() will compute hasLowerCase, hasUpperCase, hasDigit and basic \\n*/\\n\\n/*\\n(2) If (n<6) we need to add (6-n) charaters to password.\\nThe insertion and replacement of characters will break any sequence of 3 or more repeating characters.\\ne.g./ \"aaaaa\" -> \"aaaBaa\" -> \"aa1Baa\" (okay) => count = 2\\ne.g./ \"aaaBB\" -> \"\"aa1BB\" => count = 1\\ne.g./ \"aaaB1\" -> \"aaAaB1\" => count = 1\\nIn this manner, we don\\'t have to carry out extra steps to break down any sequenc of same characters.\\nWe first (2.1) add character(s) to password so that size=6, and at the same time,\\n    basic is added by (6-n) until it reaches 3, i.e. basic=min{3, basic+(6-n)};\\nthen (2.2) replace characters with ones of missing types \\n\\n=> count = (6-n) + (3-min{3, basic+(6-n)})\\n*/\\n\\n/*\\n(3) If (6<=n<=20) we will not insert any character to password (or delete any from it).\\nWe would introduce the unordered map (uMap) to record sequences of same characters \\nappearing 3 or more times in a row. \\ne.g./ \"aaaaaaaAAAAAA6666\"\\n(i=6) the character \\'a\\' is the last character of the sequence of 7 \\'a\\'s => uMap[6]=7\\n(i=12) This \\'A\\' is the last character of the sequence => uMap[12]=6\\n(i=16) This \\'6\\' is the last character of the sequence => uMap[16]=4\\nIn general,\\n    uMap[index of the last character of a sequence] = length of the sequence of same characters (>=3)\\n\\nThe function helperThree() will serve as a seperate function to compute uMap\\n\\nWe will loop over uMap to count how many characters we have to replace in password.\\n    count = SUM_{i} (uMap[i]/3)\\nJust like what we did in (2), every time of replacement will help us increase basic up to 3.\\nIf (basic<3), then we have to do (3-basic) times of replacement.\\n*/\\n\\n/*\\n(4) If (n>20) we let extra=n-20 be the number of characters we have to delete from password\\nSince password may contain sequences of the same characters 3 or more times in a row,\\nwe have to delete characters from password which generate the most benefits to us.\\n\\ne.g./ password=\"aaabbbbcccccccdddee123dd\", n=24 => extra=4\\n\\'a\\': uMap[2] = 3\\n\\'b\\': uMap[6] = 4\\n\\'c\\': uMap[13] = 7\\n\\'d\\': uMap[16] = 3\\n\\nDeleting an \\'a\\' from \"aaa\" will immediately break down the sequence \"aaa(b)...\"\\n=> password\\'= \"aabbbbcccccccdddee123dd\", count=1 and extra=3\\n\\'a\\': uMap[2] = 2 (removed from uMap)\\n\\'b\\': uMap[6] = 4\\n\\'c\\': uMap[13] = 7\\n\\'d\\': uMap[16] = 3\\n\\nDelete a \\'d\\' from \"ddd\" breaks down the sequence \"ddd\"\\n=> password\\' = \"aabbbbcccccccddee123dd\", count=2 and extra=2\\n\\'b\\': uMap[6]=4\\n\\'c\\': uMap[13]=7\\n(we don\\'t touch other keys or values in uMap because we just FORMALLY erase character(s) from password,\\nbut in practice, we don\\'t have to)\\n\\n-------------------------------------------------------------------------------------------------------\\nThe above deletion of characters should be carried out in an optimal manner.\\nIt means that we break down as many sequences of 3 or more same characters as possible \\ngiven that the number of extra characters (extra) is fixed.\\n\\nIn this example, we see that \\n\\'a\\': uMap[2]%3 = 3%3 = 0\\n\\'b\\': uMap[6]%3 = 4%3 = 1\\n\\'c\\': uMap[13]%3 = 7%3 = 1\\n\\'d\\': uMap[16]%3 = 3%3 = 0\\nTherefore, an \\'a\\' or \\'d\\' should be deleted first before we deal with \\'b\\' or \\'c\\'\\n\\n-------------------------------------------------------------------------------------------------------\\n\\nNow, we delete two \\'c\\'s so that \"ccc-ccc-c\" becomes \"ccc-cc\".\\nBefore this deletion, we need two times of replacement to break the sequence of \\'c\\'s,\\nfor example, \"ccccccc\" -> \"ccAcc0c\"\\nAfter this deletion, we only need one time of replacement: \"ccccc\" -> \"ccAcc\"\\n=> password\\' = \"aabbbbcccccddee123dd\", count=4, extra=0\\n\\nRight now, all replacement of characters which could break down a sequence of same characters have been done\\n=> we just replace characters in every sequence just like what we did in (3).\\n\\n\"aabbbbcccccddee123dd\" -> \"aabbAbccBccddee123dd\"\\ncount = 4 + 2 = 6\\n\\nIf (extra>0), then we delete extra number of characters directly from password.\\nIf (basic<3), then we replace characters with ones of the missing types.\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    bool hasLowerCase;\\n    bool hasUpperCase;\\n    bool hasDigit;\\n    int change;\\n    int basic;\\n    //\\n    int repeat;\\n    std::unordered_map<int, int> uMap; //uMap[last_index] = repeat\\n    std::unordered_map<int, int>::iterator itu;\\n    std::unordered_set<int> dSet;\\n    //\\n    int extra;\\n    \\n    void helperLUD(std::string& password, int& n){\\n        basic = 0;\\n        for (int i=0; i<n; i++){\\n            if (!hasLowerCase && password[i]>=\\'a\\' && password[i]<=\\'z\\'){\\n                hasLowerCase = true;\\n                basic++;\\n                continue;\\n            }\\n            \\n            if (!hasUpperCase && password[i]>=\\'A\\' && password[i]<=\\'Z\\'){\\n                hasUpperCase = true;\\n                basic++;\\n                continue;\\n            }\\n            \\n            if (!hasDigit && password[i]>=\\'0\\' && password[i]<=\\'9\\'){\\n                hasDigit = true;\\n                basic++;\\n            }\\n        }   \\n        return;\\n    }\\n    \\n    \\n    void helperThree(std::string& password, int& n){\\n        repeat = 1;\\n        for (int i=1; i<n; i++){\\n            if (password[i]==password[i-1]){\\n                repeat++;\\n            }else{\\n                if (repeat>=3){\\n                    uMap[i-1] = repeat;\\n                }\\n                repeat = 1;\\n            }\\n        }\\n        if (repeat>=3){\\n            uMap[n-1] = repeat;\\n        }\\n        repeat = 1;\\n        return;\\n    }\\n    \\n    int strongPasswordChecker(string password) {\\n        int n = password.size();\\n        hasLowerCase = false;\\n        hasUpperCase = false;\\n        hasDigit = false;\\n        change = 0;\\n        int temp = 0;\\n        bool stopLoop;\\n        //\\n        if (n<6){\\n            helperLUD(password, n);\\n            basic = std::min(3, basic+(6-n));\\n            change += 6-n;\\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n        //\\n        if (n>=6 && n<=20){\\n            helperLUD(password, n);\\n            helperThree(password, n);\\n            for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                temp = (itu->second/3);\\n                change += temp;\\n                if (basic<3){\\n                    basic = std::min(3, basic+temp);\\n                }\\n            }\\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n        //\\n        if (n>20){\\n            extra = n-20;\\n            helperLUD(password, n);\\n            helperThree(password, n);\\n            \\n            while (extra>0 && uMap.size()>0){\\n                stopLoop = true;\\n                //delete extra elements: \"baa(a)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=1 && itu->second>=3 && itu->second%3==0){\\n                        change++;\\n                        itu->second--;\\n                        extra--;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                //delete extra elements: \"baa(aa)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=2 && itu->second>3 && itu->second%3==1){\\n                        change+=2;\\n                        itu->second-=2;\\n                        extra-=2;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                //delete extra elements: \"baa(aaa)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=3 && itu->second>3 && itu->second%3==2){\\n                        change+=3;\\n                        itu->second-=3;\\n                        extra-=3;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                for (auto it=dSet.begin(); it!=dSet.end(); it++){\\n                    uMap.erase(*it);\\n                }\\n                dSet.clear();\\n                \\n                if (stopLoop) break;\\n            \\n                //std::cout<<\"uMap.size() = \"<<uMap.size()<<\"\\\\n\";\\n                //std::cout<<\"extra = \"<<extra<<\"\\\\n\";\\n            }//while (extra, uMap)\\n            \\n            //replace\\n            for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                if (itu->second>=3){\\n                    change += (itu->second)/3;\\n                    if (basic<3){\\n                        basic = std::min(3, basic+(itu->second)/3);\\n                    }\\n                    itu->second = (itu->second)%3;\\n                }                \\n            }\\n            \\n                \\n            change += extra;\\n            \\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*let n = number of characters in the array \"password\"\\n(1) password should have at least 1 lowercase letter, 1 uppercase letter and 1 digit.\\nWe declare these 3 boolean variables:\\nhasLowerCase: true if password has a lowercase letter\\nhasUpperCase: true if password has an uppercase letter\\nhasDigit: true if password has a digit\\n\\nint basic = hasLowerCase(1/0) + hasUpperCase(1/0) + hasDigit(1/0)\\nif (basic==3), we met the first criterion.\\n\\nThe function helperLUD() will compute hasLowerCase, hasUpperCase, hasDigit and basic \\n*/\\n\\n/*\\n(2) If (n<6) we need to add (6-n) charaters to password.\\nThe insertion and replacement of characters will break any sequence of 3 or more repeating characters.\\ne.g./ \"aaaaa\" -> \"aaaBaa\" -> \"aa1Baa\" (okay) => count = 2\\ne.g./ \"aaaBB\" -> \"\"aa1BB\" => count = 1\\ne.g./ \"aaaB1\" -> \"aaAaB1\" => count = 1\\nIn this manner, we don\\'t have to carry out extra steps to break down any sequenc of same characters.\\nWe first (2.1) add character(s) to password so that size=6, and at the same time,\\n    basic is added by (6-n) until it reaches 3, i.e. basic=min{3, basic+(6-n)};\\nthen (2.2) replace characters with ones of missing types \\n\\n=> count = (6-n) + (3-min{3, basic+(6-n)})\\n*/\\n\\n/*\\n(3) If (6<=n<=20) we will not insert any character to password (or delete any from it).\\nWe would introduce the unordered map (uMap) to record sequences of same characters \\nappearing 3 or more times in a row. \\ne.g./ \"aaaaaaaAAAAAA6666\"\\n(i=6) the character \\'a\\' is the last character of the sequence of 7 \\'a\\'s => uMap[6]=7\\n(i=12) This \\'A\\' is the last character of the sequence => uMap[12]=6\\n(i=16) This \\'6\\' is the last character of the sequence => uMap[16]=4\\nIn general,\\n    uMap[index of the last character of a sequence] = length of the sequence of same characters (>=3)\\n\\nThe function helperThree() will serve as a seperate function to compute uMap\\n\\nWe will loop over uMap to count how many characters we have to replace in password.\\n    count = SUM_{i} (uMap[i]/3)\\nJust like what we did in (2), every time of replacement will help us increase basic up to 3.\\nIf (basic<3), then we have to do (3-basic) times of replacement.\\n*/\\n\\n/*\\n(4) If (n>20) we let extra=n-20 be the number of characters we have to delete from password\\nSince password may contain sequences of the same characters 3 or more times in a row,\\nwe have to delete characters from password which generate the most benefits to us.\\n\\ne.g./ password=\"aaabbbbcccccccdddee123dd\", n=24 => extra=4\\n\\'a\\': uMap[2] = 3\\n\\'b\\': uMap[6] = 4\\n\\'c\\': uMap[13] = 7\\n\\'d\\': uMap[16] = 3\\n\\nDeleting an \\'a\\' from \"aaa\" will immediately break down the sequence \"aaa(b)...\"\\n=> password\\'= \"aabbbbcccccccdddee123dd\", count=1 and extra=3\\n\\'a\\': uMap[2] = 2 (removed from uMap)\\n\\'b\\': uMap[6] = 4\\n\\'c\\': uMap[13] = 7\\n\\'d\\': uMap[16] = 3\\n\\nDelete a \\'d\\' from \"ddd\" breaks down the sequence \"ddd\"\\n=> password\\' = \"aabbbbcccccccddee123dd\", count=2 and extra=2\\n\\'b\\': uMap[6]=4\\n\\'c\\': uMap[13]=7\\n(we don\\'t touch other keys or values in uMap because we just FORMALLY erase character(s) from password,\\nbut in practice, we don\\'t have to)\\n\\n-------------------------------------------------------------------------------------------------------\\nThe above deletion of characters should be carried out in an optimal manner.\\nIt means that we break down as many sequences of 3 or more same characters as possible \\ngiven that the number of extra characters (extra) is fixed.\\n\\nIn this example, we see that \\n\\'a\\': uMap[2]%3 = 3%3 = 0\\n\\'b\\': uMap[6]%3 = 4%3 = 1\\n\\'c\\': uMap[13]%3 = 7%3 = 1\\n\\'d\\': uMap[16]%3 = 3%3 = 0\\nTherefore, an \\'a\\' or \\'d\\' should be deleted first before we deal with \\'b\\' or \\'c\\'\\n\\n-------------------------------------------------------------------------------------------------------\\n\\nNow, we delete two \\'c\\'s so that \"ccc-ccc-c\" becomes \"ccc-cc\".\\nBefore this deletion, we need two times of replacement to break the sequence of \\'c\\'s,\\nfor example, \"ccccccc\" -> \"ccAcc0c\"\\nAfter this deletion, we only need one time of replacement: \"ccccc\" -> \"ccAcc\"\\n=> password\\' = \"aabbbbcccccddee123dd\", count=4, extra=0\\n\\nRight now, all replacement of characters which could break down a sequence of same characters have been done\\n=> we just replace characters in every sequence just like what we did in (3).\\n\\n\"aabbbbcccccddee123dd\" -> \"aabbAbccBccddee123dd\"\\ncount = 4 + 2 = 6\\n\\nIf (extra>0), then we delete extra number of characters directly from password.\\nIf (basic<3), then we replace characters with ones of the missing types.\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    bool hasLowerCase;\\n    bool hasUpperCase;\\n    bool hasDigit;\\n    int change;\\n    int basic;\\n    //\\n    int repeat;\\n    std::unordered_map<int, int> uMap; //uMap[last_index] = repeat\\n    std::unordered_map<int, int>::iterator itu;\\n    std::unordered_set<int> dSet;\\n    //\\n    int extra;\\n    \\n    void helperLUD(std::string& password, int& n){\\n        basic = 0;\\n        for (int i=0; i<n; i++){\\n            if (!hasLowerCase && password[i]>=\\'a\\' && password[i]<=\\'z\\'){\\n                hasLowerCase = true;\\n                basic++;\\n                continue;\\n            }\\n            \\n            if (!hasUpperCase && password[i]>=\\'A\\' && password[i]<=\\'Z\\'){\\n                hasUpperCase = true;\\n                basic++;\\n                continue;\\n            }\\n            \\n            if (!hasDigit && password[i]>=\\'0\\' && password[i]<=\\'9\\'){\\n                hasDigit = true;\\n                basic++;\\n            }\\n        }   \\n        return;\\n    }\\n    \\n    \\n    void helperThree(std::string& password, int& n){\\n        repeat = 1;\\n        for (int i=1; i<n; i++){\\n            if (password[i]==password[i-1]){\\n                repeat++;\\n            }else{\\n                if (repeat>=3){\\n                    uMap[i-1] = repeat;\\n                }\\n                repeat = 1;\\n            }\\n        }\\n        if (repeat>=3){\\n            uMap[n-1] = repeat;\\n        }\\n        repeat = 1;\\n        return;\\n    }\\n    \\n    int strongPasswordChecker(string password) {\\n        int n = password.size();\\n        hasLowerCase = false;\\n        hasUpperCase = false;\\n        hasDigit = false;\\n        change = 0;\\n        int temp = 0;\\n        bool stopLoop;\\n        //\\n        if (n<6){\\n            helperLUD(password, n);\\n            basic = std::min(3, basic+(6-n));\\n            change += 6-n;\\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n        //\\n        if (n>=6 && n<=20){\\n            helperLUD(password, n);\\n            helperThree(password, n);\\n            for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                temp = (itu->second/3);\\n                change += temp;\\n                if (basic<3){\\n                    basic = std::min(3, basic+temp);\\n                }\\n            }\\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n        //\\n        if (n>20){\\n            extra = n-20;\\n            helperLUD(password, n);\\n            helperThree(password, n);\\n            \\n            while (extra>0 && uMap.size()>0){\\n                stopLoop = true;\\n                //delete extra elements: \"baa(a)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=1 && itu->second>=3 && itu->second%3==0){\\n                        change++;\\n                        itu->second--;\\n                        extra--;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                //delete extra elements: \"baa(aa)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=2 && itu->second>3 && itu->second%3==1){\\n                        change+=2;\\n                        itu->second-=2;\\n                        extra-=2;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                //delete extra elements: \"baa(aaa)b\"\\n                for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                    if (extra>=3 && itu->second>3 && itu->second%3==2){\\n                        change+=3;\\n                        itu->second-=3;\\n                        extra-=3;\\n                        if (itu->second<3){\\n                            dSet.insert(itu->first);\\n                        }\\n                        stopLoop = false;\\n                    }\\n                }\\n                \\n                for (auto it=dSet.begin(); it!=dSet.end(); it++){\\n                    uMap.erase(*it);\\n                }\\n                dSet.clear();\\n                \\n                if (stopLoop) break;\\n            \\n                //std::cout<<\"uMap.size() = \"<<uMap.size()<<\"\\\\n\";\\n                //std::cout<<\"extra = \"<<extra<<\"\\\\n\";\\n            }//while (extra, uMap)\\n            \\n            //replace\\n            for (itu=uMap.begin(); itu!=uMap.end(); itu++){\\n                if (itu->second>=3){\\n                    change += (itu->second)/3;\\n                    if (basic<3){\\n                        basic = std::min(3, basic+(itu->second)/3);\\n                    }\\n                    itu->second = (itu->second)%3;\\n                }                \\n            }\\n            \\n                \\n            change += extra;\\n            \\n            if (basic<3){\\n                change += (3-basic);\\n            }\\n            return change;\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2345991,
                "title": "runtime-23-ms-memory-usage-13-9-mb-python3",
                "content": "![image](https://assets.leetcode.com/users/images/5b033b27-d956-4c33-9319-59d2d183d7c4_1659013785.4899778.png)\\n\\n\\n**Here is my code ... hope you will also understand my stratagy... if you found any any question or suggestion for me.. your most welcome ..!!**\\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        #vimla_kushwaha\\n        s = password\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n                \\n            return int(delete + max(missing_type, change))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        #vimla_kushwaha\\n        s = password\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n                \\n            return int(delete + max(missing_type, change))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058667,
                "title": "accepted-solution-100-fastest-with-greedy-approach-c-with-detailed-explanation",
                "content": "Below is my thought process, not sure if it is the best but it works. I hope it helps! Please vote if you find this helpful.\\n\\nConsider these following scenarios.\\n\\n1. The password has all needed components such as lower, upper case letters and digits, and it is within the size range. The only thing we need to worry about is to **tweak the consecutive duplicate letters of 3 or more**. For that, we just need to change one out of each 3 letters. \\n\\nIt is an easy O(N) scan to find all sectons of consecutive duplicate letters of 3 or more.\\n\\n```\\n        vector<int> sections;\\n        int t = 0;\\n        char last = 0;\\n        for(char c:password) {\\n            if(c!=last) {\\n                if(t>=3) sections.push_back(t);\\n                t = 0;\\n                last = c;\\n                if(c>=\\'a\\' && c<=\\'z\\') hasLower = true;\\n                else if(c>=\\'A\\' && c<=\\'Z\\') hasUpper = true;\\n                else if(c>=\\'0\\' && c<=\\'9\\') hasDigit = true;\\n            }\\n            t++;\\n        }\\n        if(t>=3) sections.push_back(t);\\n```\\n\\nOnce we put the sections in a vector, it is easy to add moves by modifying each section by changing 1 of each 3 characters.\\n```\\nfor(int s:sections) moves += s/3;\\n```\\n\\n2. Now add on top of the above scenario, we want to **ensure we have all needed components**. That means everytime we make changes to the duplicate sections, we will take the opportunity to add whatever missing components. Here, I use a lambda function so it is easier to understand and re-use. And, after processing all the sections, we will still need to check once more and add missing components. This function takes an input as how many opportunities I can use, and returns the actual moves used for ensuring. We will be re-using this function throughout the process again in future modifications. \\n\\n```\\nauto ensureComponents = [&](int available) { // available means available opportunities\\n    int changed = 0;\\n    while(available-->0) {\\n\\t    if(!hasLower) hasLower = true;\\n\\t\\telse if(!hasUpper) hasUpper = true;\\n\\t\\telse if(!hasDigit) hasDigit = true;\\n\\t\\telse return changed;\\n\\t\\tchanged++;\\n\\t}\\n\\treturn changed; // actual components added\\n};\\n\\nfor(int s:sections) {\\n\\tmoves += s/3;\\n\\tensureComponents(s/3);\\n}\\n\\nmoves += ensureComponents(3); // giving 3 more opportunites in case we need, only adding what we actually used\\n```\\n\\n3. Now consider the scenario where **we don\\'t have enough (6) characters**. Again, we will take opportunities to address when we address the duplicate characters. Also, check at the end. We can do this by using the new character to chop off two from the duplicate section. And the loop will become looking like below, assuming n stores the length of the password.\\n\\n```\\nfor(int s:sections) {\\n\\twhile(n<6 && s>=3) {\\n\\t\\tmoves++;\\n\\t\\tn++;\\n\\t\\ts-=2;  // adding a character to chop off two characters from this sectoin\\n\\t\\tensureComponents(1);  // the adding move can also be an opportunity for ensuring we have all variety\\n\\t}\\n\\t\\n\\tmoves += s/3;\\n\\tensureComponents(s/3);\\n}\\n\\nmoves += max(0, 6 - n);  // after processing sections, still not enough, then add here\\nensureComponents(max(0, 6-n)); // these moves are also opportunities for adding missing components\\nmoves += ensureComponents(3);\\n```\\n\\n4. Now we need to consider the scenario where **we have more that 20 characters**. This is a little different. We will want to process as much deletion as possible before we start processing the duplicate characters, so we don\\'t waste moves. What groups should we prioritize to remove characters from? We know that we will be changing 1 out of each 3 duplicates. So, if any group is exactly multiples of 3, then removing 1 character from them means we hit two birds with one stone. We should prioritize groups with `s%3==0`, after that for groups with `s%3==1`, we will need to remove two from the 3 to actually make a difference. And at last, for groups with `s%3==2`, we will remove 3 each time to be able to make a difference. Below is how I did the removing part.\\n\\n```\\nif(!sections.empty()) {\\n\\tsort(sections.begin(), sections.end(), [](int a, int b){return a%3<b%3;}); // prioritizing based on s%3\\n\\t\\n\\tint reduced = 0;\\n\\tint i = 0;\\n\\twhile(n>20) {\\n\\t\\tint r = sections[i] % 3;\\n\\t\\tif (sections[i]>=3 && n>20+r) {\\n\\t\\t\\tsections[i]-=r+1;\\n\\t\\t\\tmoves+=r+1;\\n\\t\\t\\treduced+=r+1;\\n\\t\\t\\tn-=r+1;\\n\\t\\t}\\n\\t\\tif(++i==sections.size()) {\\n\\t\\t\\tif (reduced==0) break; // a full scan without reduction\\n\\t\\t\\ti-=sections.size();\\n\\t\\t\\treduced = 0;\\n\\t\\t}\\n\\t}\\n}\\n\\t.\\n\\t.\\n\\t.\\n// at the end\\nmoves += max(0, n - 20);\\n```\\n\\n5. Now **putting everything together**\\n\\n```\\n    int strongPasswordChecker(string password) {\\n        bool hasLower = false;\\n        bool hasUpper = false;\\n        bool hasDigit = false;\\n        int n = password.length();\\n        \\n        vector<int> sections;\\n        int t = 0;\\n        char last = 0;\\n        for(char c:password) {\\n            if(c!=last) {\\n                if(t>=3) sections.push_back(t);\\n                t = 0;\\n                last = c;\\n                if(c>=\\'a\\' && c<=\\'z\\') hasLower = true;\\n                else if(c>=\\'A\\' && c<=\\'Z\\') hasUpper = true;\\n                else if(c>=\\'0\\' && c<=\\'9\\') hasDigit = true;\\n            }\\n            t++;\\n        }\\n        if(t>=3) sections.push_back(t);\\n        \\n        int moves = 0;\\n        \\n        if(!sections.empty()) {\\n            sort(sections.begin(), sections.end(), [](int a, int b){return a%3 < b%3;});\\n\\n            int reduced = 0;\\n            int i = 0;\\n            while(n>20) {\\n                int r = sections[i] % 3;\\n                if (sections[i]>=3 && n>20+r) {\\n                    sections[i]-=r+1;\\n                    moves+=r+1;\\n                    reduced+=r+1;\\n                    n-=r+1;\\n                }\\n                if(++i==sections.size()) {\\n                    if (reduced==0) break; // a full scan without reduction\\n                    i-=sections.size();\\n                    reduced = 0;\\n                }\\n            }\\n        }\\n        \\n        auto ensureComponents = [&](int available) {\\n            int changed = 0;\\n            while(available-->0) {\\n                if(!hasLower) hasLower = true;\\n                else if(!hasUpper) hasUpper = true;\\n                else if(!hasDigit) hasDigit = true;\\n                else return changed;\\n                changed++;\\n            }\\n            return changed;\\n        };\\n\\n        for(int s:sections) {\\n            while(n<6 && s>=3) {\\n                moves++;\\n                n++;\\n                s-=2;\\n                ensureComponents(1);\\n            }\\n\\n            moves += s/3;\\n            ensureComponents(s/3);\\n        }\\n\\n        moves += max(0, 6 - n);\\n        ensureComponents(max(0, 6-n));\\n        moves += ensureComponents(3);\\n        moves += max(0, n - 20);\\n        \\n        return moves;\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n        vector<int> sections;\\n        int t = 0;\\n        char last = 0;\\n        for(char c:password) {\\n            if(c!=last) {\\n                if(t>=3) sections.push_back(t);\\n                t = 0;\\n                last = c;\\n                if(c>=\\'a\\' && c<=\\'z\\') hasLower = true;\\n                else if(c>=\\'A\\' && c<=\\'Z\\') hasUpper = true;\\n                else if(c>=\\'0\\' && c<=\\'9\\') hasDigit = true;\\n            }\\n            t++;\\n        }\\n        if(t>=3) sections.push_back(t);\\n```\n```\\nfor(int s:sections) moves += s/3;\\n```\n```\\nauto ensureComponents = [&](int available) { // available means available opportunities\\n    int changed = 0;\\n    while(available-->0) {\\n\\t    if(!hasLower) hasLower = true;\\n\\t\\telse if(!hasUpper) hasUpper = true;\\n\\t\\telse if(!hasDigit) hasDigit = true;\\n\\t\\telse return changed;\\n\\t\\tchanged++;\\n\\t}\\n\\treturn changed; // actual components added\\n};\\n\\nfor(int s:sections) {\\n\\tmoves += s/3;\\n\\tensureComponents(s/3);\\n}\\n\\nmoves += ensureComponents(3); // giving 3 more opportunites in case we need, only adding what we actually used\\n```\n```\\nfor(int s:sections) {\\n\\twhile(n<6 && s>=3) {\\n\\t\\tmoves++;\\n\\t\\tn++;\\n\\t\\ts-=2;  // adding a character to chop off two characters from this sectoin\\n\\t\\tensureComponents(1);  // the adding move can also be an opportunity for ensuring we have all variety\\n\\t}\\n\\t\\n\\tmoves += s/3;\\n\\tensureComponents(s/3);\\n}\\n\\nmoves += max(0, 6 - n);  // after processing sections, still not enough, then add here\\nensureComponents(max(0, 6-n)); // these moves are also opportunities for adding missing components\\nmoves += ensureComponents(3);\\n```\n```\\nif(!sections.empty()) {\\n\\tsort(sections.begin(), sections.end(), [](int a, int b){return a%3<b%3;}); // prioritizing based on s%3\\n\\t\\n\\tint reduced = 0;\\n\\tint i = 0;\\n\\twhile(n>20) {\\n\\t\\tint r = sections[i] % 3;\\n\\t\\tif (sections[i]>=3 && n>20+r) {\\n\\t\\t\\tsections[i]-=r+1;\\n\\t\\t\\tmoves+=r+1;\\n\\t\\t\\treduced+=r+1;\\n\\t\\t\\tn-=r+1;\\n\\t\\t}\\n\\t\\tif(++i==sections.size()) {\\n\\t\\t\\tif (reduced==0) break; // a full scan without reduction\\n\\t\\t\\ti-=sections.size();\\n\\t\\t\\treduced = 0;\\n\\t\\t}\\n\\t}\\n}\\n\\t.\\n\\t.\\n\\t.\\n// at the end\\nmoves += max(0, n - 20);\\n```\n```\\n    int strongPasswordChecker(string password) {\\n        bool hasLower = false;\\n        bool hasUpper = false;\\n        bool hasDigit = false;\\n        int n = password.length();\\n        \\n        vector<int> sections;\\n        int t = 0;\\n        char last = 0;\\n        for(char c:password) {\\n            if(c!=last) {\\n                if(t>=3) sections.push_back(t);\\n                t = 0;\\n                last = c;\\n                if(c>=\\'a\\' && c<=\\'z\\') hasLower = true;\\n                else if(c>=\\'A\\' && c<=\\'Z\\') hasUpper = true;\\n                else if(c>=\\'0\\' && c<=\\'9\\') hasDigit = true;\\n            }\\n            t++;\\n        }\\n        if(t>=3) sections.push_back(t);\\n        \\n        int moves = 0;\\n        \\n        if(!sections.empty()) {\\n            sort(sections.begin(), sections.end(), [](int a, int b){return a%3 < b%3;});\\n\\n            int reduced = 0;\\n            int i = 0;\\n            while(n>20) {\\n                int r = sections[i] % 3;\\n                if (sections[i]>=3 && n>20+r) {\\n                    sections[i]-=r+1;\\n                    moves+=r+1;\\n                    reduced+=r+1;\\n                    n-=r+1;\\n                }\\n                if(++i==sections.size()) {\\n                    if (reduced==0) break; // a full scan without reduction\\n                    i-=sections.size();\\n                    reduced = 0;\\n                }\\n            }\\n        }\\n        \\n        auto ensureComponents = [&](int available) {\\n            int changed = 0;\\n            while(available-->0) {\\n                if(!hasLower) hasLower = true;\\n                else if(!hasUpper) hasUpper = true;\\n                else if(!hasDigit) hasDigit = true;\\n                else return changed;\\n                changed++;\\n            }\\n            return changed;\\n        };\\n\\n        for(int s:sections) {\\n            while(n<6 && s>=3) {\\n                moves++;\\n                n++;\\n                s-=2;\\n                ensureComponents(1);\\n            }\\n\\n            moves += s/3;\\n            ensureComponents(s/3);\\n        }\\n\\n        moves += max(0, 6 - n);\\n        ensureComponents(max(0, 6-n));\\n        moves += ensureComponents(3);\\n        moves += max(0, n - 20);\\n        \\n        return moves;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1919568,
                "title": "swift-0ms-strong-password-checker-100",
                "content": "```\\nclass Solution {\\n    func strongPasswordChecker(_ password: String) -> Int {\\n        let pw = Array(password), pwCount = pw.count\\n        var low = false, up = false, num = false\\n        for pwCount in pw {\\n            if pwCount.isLowercase { low = true }\\n            else if pwCount.isUppercase { up = true }\\n            else if pwCount.isNumber { num = true }\\n        }\\n        var types = 3\\n        if low { types -= 1 }\\n        if up { types -= 1 }\\n        if num { types -= 1 }\\n        \\n        var one = 0, two = 0, rep = 0, i = 2\\n        while i < pwCount {\\n            if pw[i] == pw[i-1] && pw[i] == pw[i-2] {\\n                var length = 2\\n                while i < pwCount && pw[i] == pw[i-1] {\\n                    length += 1\\n                    i += 1\\n                }\\n                rep += length/3\\n                if length % 3 == 0 { one += 1 }\\n                else if length % 3 == 1 { two += 1 }\\n            } else {\\n                i += 1\\n            }\\n        }\\n        if pwCount < 6 {\\n            return max(types, 6 - pwCount)\\n        } else if pwCount <= 20 {\\n            return max(types, rep)\\n        }\\n        let del = pwCount - 20\\n        rep -= min(del, one)\\n        rep -= (min(max(del - one, 0), two * 2) / 2)\\n        rep -= (max(del - one - 2 * two, 0) / 3)\\n        return max(types, rep) + del\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func strongPasswordChecker(_ password: String) -> Int {\\n        let pw = Array(password), pwCount = pw.count\\n        var low = false, up = false, num = false\\n        for pwCount in pw {\\n            if pwCount.isLowercase { low = true }\\n            else if pwCount.isUppercase { up = true }\\n            else if pwCount.isNumber { num = true }\\n        }\\n        var types = 3\\n        if low { types -= 1 }\\n        if up { types -= 1 }\\n        if num { types -= 1 }\\n        \\n        var one = 0, two = 0, rep = 0, i = 2\\n        while i < pwCount {\\n            if pw[i] == pw[i-1] && pw[i] == pw[i-2] {\\n                var length = 2\\n                while i < pwCount && pw[i] == pw[i-1] {\\n                    length += 1\\n                    i += 1\\n                }\\n                rep += length/3\\n                if length % 3 == 0 { one += 1 }\\n                else if length % 3 == 1 { two += 1 }\\n            } else {\\n                i += 1\\n            }\\n        }\\n        if pwCount < 6 {\\n            return max(types, 6 - pwCount)\\n        } else if pwCount <= 20 {\\n            return max(types, rep)\\n        }\\n        let del = pwCount - 20\\n        rep -= min(del, one)\\n        rep -= (min(max(del - one, 0), two * 2) / 2)\\n        rep -= (max(del - one - 2 * two, 0) / 3)\\n        return max(types, rep) + del\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760221,
                "title": "strong-password-checker-solution-java",
                "content": "class Solution {\\n  public int strongPasswordChecker(String s) {\\n    final int n = s.length();\\n    final char[] chars = s.toCharArray();\\n    final int missing = getMissing(chars);\\n    // # of replacements to deal with 3 repeating characters\\n    int replaces = 0;\\n    // # of seqs that can be substituted with 1 deletions, (3k)-seqs\\n    int oneSeq = 0;\\n    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs\\n    int twoSeq = 0;\\n\\n    for (int i = 2; i < n;)\\n      if (chars[i] == chars[i - 1] && chars[i - 1] == chars[i - 2]) {\\n        int length = 2; // length of repeating chars\\n        while (i < n && chars[i] == chars[i - 1]) {\\n          ++length;\\n          ++i;\\n        }\\n        replaces += length / 3; // \\'aaaaaaa\\' -> \\'aaxaaxa\\'\\n        if (length % 3 == 0)\\n          ++oneSeq;\\n        if (length % 3 == 1)\\n          ++twoSeq;\\n      } else {\\n        ++i;\\n      }\\n\\n    if (n < 6)\\n      return Math.max(6 - n, missing);\\n    if (n <= 20)\\n      return Math.max(replaces, missing);\\n\\n    final int deletes = n - 20;\\n    // each replacement in (3k)-seqs can be substituted with 1 deletions\\n    replaces -= Math.min(oneSeq, deletes);\\n    // each replacement in (3k + 1)-seqs can be substituted with 2 deletions\\n    replaces -= Math.min(Math.max(deletes - oneSeq, 0), twoSeq * 2) / 2;\\n    // each replacement in other seqs can be substituted with 3 deletions\\n    replaces -= Math.max(deletes - oneSeq - twoSeq * 2, 0) / 3;\\n    return deletes + Math.max(replaces, missing);\\n  }\\n\\n  private int getMissing(final char[] chars) {\\n    int missing = 3;\\n\\n    for (final char c : chars)\\n      if (Character.isUpperCase(c)) {\\n        --missing;\\n        break;\\n      }\\n\\n    for (final char c : chars)\\n      if (Character.isLowerCase(c)) {\\n        --missing;\\n        break;\\n      }\\n\\n    for (final char c : chars)\\n      if (Character.isDigit(c)) {\\n        --missing;\\n        break;\\n      }\\n\\n    return missing;\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public int strongPasswordChecker(String s) {\\n    final int n = s.length();\\n    final char[] chars = s.toCharArray();\\n    final int missing = getMissing(chars);\\n    // # of replacements to deal with 3 repeating characters\\n    int replaces = 0;\\n    // # of seqs that can be substituted with 1 deletions, (3k)-seqs\\n    int oneSeq = 0;\\n    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs\\n    int twoSeq = 0;\\n\\n    for (int i = 2; i < n;)\\n      if (chars[i] == chars[i - 1] && chars[i - 1] == chars[i - 2]) {\\n        int length = 2; // length of repeating chars\\n        while (i < n && chars[i] == chars[i - 1]) {\\n          ++length;\\n          ++i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1646088,
                "title": "python3-20ms-solution-with-thorough-explanation",
                "content": "```\\nfrom typing import List\\nimport math\\n\\n\\ndef get_missing_steps(password: str) -> int:\\n    \"\"\"\\n    Return the number of substitution or insertion steps required to address\\n    problems with missing character classes.\\n    \"\"\"\\n    lower_missing = True\\n    upper_missing = True\\n    digit_missing = True\\n\\n    for c in password:\\n        if \"a\" <= c <= \"z\":\\n            lower_missing = False\\n        if \"A\" <= c <= \"Z\":\\n            upper_missing = False\\n        if \"0\" <= c <= \"9\":\\n            digit_missing = False\\n\\n    return lower_missing + upper_missing + digit_missing\\n\\n\\ndef get_runs(password: str) -> List[int]:\\n    \"\"\"\\n    Return a list of lengths of runs of repeated characters that are too long.\\n    \"\"\"\\n    runs = []\\n\\n    run_start = -1\\n    prev = None\\n    for i, curr in enumerate(password):\\n        if curr == prev:\\n            continue\\n        else:\\n            run_len = i - run_start\\n            if run_len > 2:\\n                runs.append(run_len)\\n            run_start = i\\n        prev = curr\\n\\n    run_len = (i + 1) - run_start\\n    if run_len > 2:\\n        runs.append(run_len)\\n\\n    return runs\\n\\n\\ndef get_run_sub_steps(runs: List[int]) -> int:\\n    \"\"\"\\n    Return the total number of substitution steps required to fix all illegal\\n    runs.\\n\\n    Any run of length `n` can be fixed with `floor(n / 3)` substitution steps.\\n    For example, a run of length 5 such as \"aaaaa\" can be fixed by making 1\\n    substitution in the middle to get \"aazaa\".\\n    \"\"\"\\n    return sum(n // 3 for n in runs)\\n\\n\\ndef get_run_insert_steps(runs: List[int]) -> int:\\n    \"\"\"\\n    Return the total number of insertion steps required to fix all illegal\\n    runs.\\n\\n    Any run of length `n` can be fixed with `ceil(n / 2) - 1` insertion steps.\\n    For example, a run of length 5 such as \"aaaaa\" can be fixed by making 2\\n    insertions to get \"aazaaza\".\\n    \"\"\"\\n    return sum(max(math.ceil(n / 2) - 1, 0) for n in runs)\\n\\n\\ndef handle_short_len(password: str) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that is too short.\\n\\n    In this case, we know password length is a problem.  There are two\\n    additional kinds of problems that may occur: runs of repeated characters\\n    and missing character classes.  All classes of problem (including password\\n    length) may be fixed simultaneously by character insertions without\\n    creating further problems.  Since any step required to fix a problem also\\n    fixes any other kind, we must determine the number of steps required to fix\\n    the most numerous type of problem.\\n    \"\"\"\\n    missing_steps = get_missing_steps(password)\\n    run_steps = get_run_insert_steps(get_runs(password))\\n    too_short_steps = 6 - len(password)\\n\\n    return max(missing_steps, run_steps, too_short_steps)\\n\\n\\ndef handle_required_len(password: str, runs: List[int] = None) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that has the required\\n    length.\\n\\n    This case is similar to the case of a short password except that the only\\n    two problems that may occur are character runs and missing character\\n    classes.  Similarly, instead of an insertion, a substitution step can be\\n    used to simultaneously fix occurrences of either type of issue.  So the\\n    task again is to determine the number of steps required to fix the most\\n    problematic issue class.\\n\\n    An explicit list of illegal run lengths can be given to account for the\\n    case in which some runs have partly been mitigated by deletions in a\\n    password that is longer than the required length.\\n    \"\"\"\\n    if runs is None:\\n        runs = get_runs(password)\\n\\n    missing_steps = get_missing_steps(password)\\n    run_steps = get_run_sub_steps(runs)\\n\\n    return max(missing_steps, run_steps)\\n\\n\\ndef _emplace_run_len(q: List[int], n: int) -> None:\\n    q.append(n)\\n    if len(q) < 2:\\n        return\\n\\n    n_mod_3 = n % 3\\n    for i in range(len(q) - 2, -1, -1):\\n        if (q[i] % 3) >= n_mod_3:\\n            break\\n        q[i], q[i + 1] = q[i + 1], q[i]\\n\\n\\ndef handle_long_len(password: str) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that is too long.\\n\\n    The only edit operation that can reduce the number of characters in a\\n    password is deletion.  Therefore, a certain number of deletions are\\n    required.  The most optimal place for those deletions to take place is\\n    within illegal runs of repeated characters.  Once a password has been\\n    reduced in length by a required number of optimally placed deletions, it\\n    may be handled as a normal-length password by the `handle_required_len`\\n    method.\\n\\n    However, the choice of placement of deletions may affect the number of\\n    substitutions required in the `handle_required_len` method.  For example,\\n    consider a password that is 22 characters long with the suffix\\n    \"aaabbbbbcccccc\".  We must make two deletions to reduce password to an\\n    appropriate length.  If we make the deletions all within the run of \"b\"\\n    characters, we don\\'t save any substitutions in the `handle_required_len`\\n    method. However, if we make one deletion in the run of \"a\" characters and\\n    one in the run of \"c\" characters, we save 2 substitutions in the\\n    `handle_required_len` method.  Accordingly, we must always make deletions in\\n    the run that has the lowest length mod 3.\\n\\n    This logic is implemented in the for loop below.  The remaining set of run\\n    lengths are then used in the `handle_required_len` method.\\n    \"\"\"\\n    runs = get_runs(password)\\n    runs.sort(key=lambda i: i % 3, reverse=True)\\n\\n    too_long_steps = len(password) - 20\\n    del_steps = 0\\n\\n    while too_long_steps > 0 and len(runs) > 0:\\n        run_len = runs.pop()\\n\\n        too_long_steps -= 1\\n        run_len -= 1\\n        del_steps += 1\\n\\n        if run_len > 2:\\n            _emplace_run_len(runs, run_len)\\n\\n    del_steps += too_long_steps\\n\\n    return del_steps + handle_required_len(password, runs)\\n\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        if n < 6:\\n            return handle_short_len(password)\\n        elif n <= 20:\\n            return handle_required_len(password)\\n        else:\\n            return handle_long_len(password)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\nimport math\\n\\n\\ndef get_missing_steps(password: str) -> int:\\n    \"\"\"\\n    Return the number of substitution or insertion steps required to address\\n    problems with missing character classes.\\n    \"\"\"\\n    lower_missing = True\\n    upper_missing = True\\n    digit_missing = True\\n\\n    for c in password:\\n        if \"a\" <= c <= \"z\":\\n            lower_missing = False\\n        if \"A\" <= c <= \"Z\":\\n            upper_missing = False\\n        if \"0\" <= c <= \"9\":\\n            digit_missing = False\\n\\n    return lower_missing + upper_missing + digit_missing\\n\\n\\ndef get_runs(password: str) -> List[int]:\\n    \"\"\"\\n    Return a list of lengths of runs of repeated characters that are too long.\\n    \"\"\"\\n    runs = []\\n\\n    run_start = -1\\n    prev = None\\n    for i, curr in enumerate(password):\\n        if curr == prev:\\n            continue\\n        else:\\n            run_len = i - run_start\\n            if run_len > 2:\\n                runs.append(run_len)\\n            run_start = i\\n        prev = curr\\n\\n    run_len = (i + 1) - run_start\\n    if run_len > 2:\\n        runs.append(run_len)\\n\\n    return runs\\n\\n\\ndef get_run_sub_steps(runs: List[int]) -> int:\\n    \"\"\"\\n    Return the total number of substitution steps required to fix all illegal\\n    runs.\\n\\n    Any run of length `n` can be fixed with `floor(n / 3)` substitution steps.\\n    For example, a run of length 5 such as \"aaaaa\" can be fixed by making 1\\n    substitution in the middle to get \"aazaa\".\\n    \"\"\"\\n    return sum(n // 3 for n in runs)\\n\\n\\ndef get_run_insert_steps(runs: List[int]) -> int:\\n    \"\"\"\\n    Return the total number of insertion steps required to fix all illegal\\n    runs.\\n\\n    Any run of length `n` can be fixed with `ceil(n / 2) - 1` insertion steps.\\n    For example, a run of length 5 such as \"aaaaa\" can be fixed by making 2\\n    insertions to get \"aazaaza\".\\n    \"\"\"\\n    return sum(max(math.ceil(n / 2) - 1, 0) for n in runs)\\n\\n\\ndef handle_short_len(password: str) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that is too short.\\n\\n    In this case, we know password length is a problem.  There are two\\n    additional kinds of problems that may occur: runs of repeated characters\\n    and missing character classes.  All classes of problem (including password\\n    length) may be fixed simultaneously by character insertions without\\n    creating further problems.  Since any step required to fix a problem also\\n    fixes any other kind, we must determine the number of steps required to fix\\n    the most numerous type of problem.\\n    \"\"\"\\n    missing_steps = get_missing_steps(password)\\n    run_steps = get_run_insert_steps(get_runs(password))\\n    too_short_steps = 6 - len(password)\\n\\n    return max(missing_steps, run_steps, too_short_steps)\\n\\n\\ndef handle_required_len(password: str, runs: List[int] = None) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that has the required\\n    length.\\n\\n    This case is similar to the case of a short password except that the only\\n    two problems that may occur are character runs and missing character\\n    classes.  Similarly, instead of an insertion, a substitution step can be\\n    used to simultaneously fix occurrences of either type of issue.  So the\\n    task again is to determine the number of steps required to fix the most\\n    problematic issue class.\\n\\n    An explicit list of illegal run lengths can be given to account for the\\n    case in which some runs have partly been mitigated by deletions in a\\n    password that is longer than the required length.\\n    \"\"\"\\n    if runs is None:\\n        runs = get_runs(password)\\n\\n    missing_steps = get_missing_steps(password)\\n    run_steps = get_run_sub_steps(runs)\\n\\n    return max(missing_steps, run_steps)\\n\\n\\ndef _emplace_run_len(q: List[int], n: int) -> None:\\n    q.append(n)\\n    if len(q) < 2:\\n        return\\n\\n    n_mod_3 = n % 3\\n    for i in range(len(q) - 2, -1, -1):\\n        if (q[i] % 3) >= n_mod_3:\\n            break\\n        q[i], q[i + 1] = q[i + 1], q[i]\\n\\n\\ndef handle_long_len(password: str) -> int:\\n    \"\"\"\\n    Return the number of steps required to fix a password that is too long.\\n\\n    The only edit operation that can reduce the number of characters in a\\n    password is deletion.  Therefore, a certain number of deletions are\\n    required.  The most optimal place for those deletions to take place is\\n    within illegal runs of repeated characters.  Once a password has been\\n    reduced in length by a required number of optimally placed deletions, it\\n    may be handled as a normal-length password by the `handle_required_len`\\n    method.\\n\\n    However, the choice of placement of deletions may affect the number of\\n    substitutions required in the `handle_required_len` method.  For example,\\n    consider a password that is 22 characters long with the suffix\\n    \"aaabbbbbcccccc\".  We must make two deletions to reduce password to an\\n    appropriate length.  If we make the deletions all within the run of \"b\"\\n    characters, we don\\'t save any substitutions in the `handle_required_len`\\n    method. However, if we make one deletion in the run of \"a\" characters and\\n    one in the run of \"c\" characters, we save 2 substitutions in the\\n    `handle_required_len` method.  Accordingly, we must always make deletions in\\n    the run that has the lowest length mod 3.\\n\\n    This logic is implemented in the for loop below.  The remaining set of run\\n    lengths are then used in the `handle_required_len` method.\\n    \"\"\"\\n    runs = get_runs(password)\\n    runs.sort(key=lambda i: i % 3, reverse=True)\\n\\n    too_long_steps = len(password) - 20\\n    del_steps = 0\\n\\n    while too_long_steps > 0 and len(runs) > 0:\\n        run_len = runs.pop()\\n\\n        too_long_steps -= 1\\n        run_len -= 1\\n        del_steps += 1\\n\\n        if run_len > 2:\\n            _emplace_run_len(runs, run_len)\\n\\n    del_steps += too_long_steps\\n\\n    return del_steps + handle_required_len(password, runs)\\n\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        if n < 6:\\n            return handle_short_len(password)\\n        elif n <= 20:\\n            return handle_required_len(password)\\n        else:\\n            return handle_long_len(password)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483790,
                "title": "python-simple-o-n-solution-20-ms-beats-100",
                "content": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        def type_(c):\\n            if c.isdigit(): return 0\\n            if c.isupper(): return 1\\n            return 2\\n        \\n        numTypes = len(set(type_(c) for c in password))\\n        if len(password) <= 4: return (6 - len(password))\\n        if len(password) == 5: return max(1, 3 - numTypes)\\n\\t\\t\\n        lengthOfSequences = [len(list(li)) for _, li in itertools.groupby(password)]\\n        numReplace = sum(length // 3 for length in lengthOfSequences)   \\n        if len(password) <= 20: return max(3 - numTypes, numReplace)\\n        \\n        numDelete = len(password) - 20\\n        for i, length in enumerate(lengthOfSequences):\\n            if length >= 3 and length % 3 == 0 and numReplace > 0 and numDelete >= 1:\\n                lengthOfSequences[i] -= 1\\n                numReplace -= 1\\n                numDelete -= 1\\n                    \\n        for i, length in enumerate(lengthOfSequences):\\n            if length >= 3 and length % 3 == 1 and numReplace > 0 and numDelete >= 2:\\n                lengthOfSequences[i] -= 2\\n                numReplace -= 1\\n                numDeletes -= 2\\n        \\n        numReplace -= min(numDelete // 3, sum(length // 3 for length in lengthOfSequences))\\n        return len(password) - 20 + max(numReplace, 3 - numTypes)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        def type_(c):\\n            if c.isdigit(): return 0\\n            if c.isupper(): return 1\\n            return 2\\n        \\n        numTypes = len(set(type_(c) for c in password))\\n        if len(password) <= 4: return (6 - len(password))\\n        if len(password) == 5: return max(1, 3 - numTypes)\\n\\t\\t\\n        lengthOfSequences = [len(list(li)) for _, li in itertools.groupby(password)]\\n        numReplace = sum(length // 3 for length in lengthOfSequences)   \\n        if len(password) <= 20: return max(3 - numTypes, numReplace)\\n        \\n        numDelete = len(password) - 20\\n        for i, length in enumerate(lengthOfSequences):\\n            if length >= 3 and length % 3 == 0 and numReplace > 0 and numDelete >= 1:\\n                lengthOfSequences[i] -= 1\\n                numReplace -= 1\\n                numDelete -= 1\\n                    \\n        for i, length in enumerate(lengthOfSequences):\\n            if length >= 3 and length % 3 == 1 and numReplace > 0 and numDelete >= 2:\\n                lengthOfSequences[i] -= 2\\n                numReplace -= 1\\n                numDeletes -= 2\\n        \\n        numReplace -= min(numDelete // 3, sum(length // 3 for length in lengthOfSequences))\\n        return len(password) - 20 + max(numReplace, 3 - numTypes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189640,
                "title": "my-solution-with-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int strongPasswordChecker(String password) {\\n\\t\\t\\tint passLen = password.length();\\n\\n\\t\\t\\tboolean noLowercase = true;\\n\\t\\t\\tboolean noUppercase = true;\\n\\t\\t\\tboolean noDigit = true;\\n\\n\\t\\t\\tList<Integer> charRepeats = new ArrayList();\\n\\t\\t\\tchar lastChar = 0;\\n\\t\\t\\tint lastRepeat = 0;\\n\\n\\t\\t\\tfor (int i = 0; i < passLen; i++) {\\n\\t\\t\\t\\tchar c = password.charAt(i);\\n\\n\\t\\t\\t\\tif (noUppercase && c > 64 && c < 91) {\\n\\t\\t\\t\\t\\tnoUppercase = false;\\n\\t\\t\\t\\t} else if (noLowercase && c > 96 && c < 123) {\\n\\t\\t\\t\\t\\tnoLowercase = false;\\n\\t\\t\\t\\t} else if (noDigit && c > 47 && c < 58) {\\n\\t\\t\\t\\t\\tnoDigit = false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (lastChar == c) {\\n\\t\\t\\t\\t\\tlastRepeat++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (lastRepeat > 2 && (lastChar != c || i == passLen - 1)) {\\n\\t\\t\\t\\t\\tcharRepeats.add(lastRepeat);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (lastChar != c) {\\n\\t\\t\\t\\t\\tlastRepeat = 1;\\n\\t\\t\\t\\t\\tlastChar = c;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint reusedCount = 0;\\n\\n\\t\\t\\tif (noUppercase) {\\n\\t\\t\\t\\treusedCount++;\\n\\t\\t\\t}\\n\\t\\t\\tif (noLowercase) {\\n\\t\\t\\t\\treusedCount++;\\n\\t\\t\\t}\\n\\t\\t\\tif (noDigit) {\\n\\t\\t\\t\\treusedCount++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treusedCount = Math.max(6 - passLen, reusedCount);\\n\\t\\t\\tint deleteCount = Math.max(0, passLen - 20);\\n\\t\\t\\tint addOrReplaceCount = 0;\\n\\n\\t\\t\\t// when repeat times is multiple of 3, we can use one delete step to replace one other fix step\\n\\t\\t\\tfor (int count : charRepeats) {\\n\\t\\t\\t\\tif (count % 3 == 0 && deleteCount > 0) {\\n\\t\\t\\t\\t\\tdeleteCount--;\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\taddOrReplaceCount += (int)Math.floor(count / 3.0f);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// when repeat times is multiple of 3 plus 1, we can use two delete steps to replace one other fix step\\n\\t\\t\\tfor (int count : charRepeats) {\\n\\t\\t\\t\\tif (count % 3 == 1 && deleteCount > 1) {\\n\\t\\t\\t\\t\\tdeleteCount -= 2;\\n\\t\\t\\t\\t\\taddOrReplaceCount--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if there still has delete steps, then we can still use three delete steps to replace one other fix step\\n\\t\\t\\taddOrReplaceCount -= (deleteCount / 3);\\n\\n\\t\\t\\t// we should use the max between reusedCount and addOrReplaceCount, then plus delete items, because reused and deleted step are required\\n\\t\\t\\treturn Math.max(reusedCount, addOrReplaceCount) + Math.max(0, passLen - 20);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int strongPasswordChecker(String password) {\\n\\t\\t\\tint passLen = password.length();\\n\\n\\t\\t\\tboolean noLowercase = true;\\n\\t\\t\\tboolean noUppercase = true;\\n\\t\\t\\tboolean noDigit = true;\\n\\n\\t\\t\\tList<Integer> charRepeats = new ArrayList();\\n\\t\\t\\tchar lastChar = 0;\\n\\t\\t\\tint lastRepeat = 0;\\n\\n\\t\\t\\tfor (int i = 0; i < passLen; i++) {\\n\\t\\t\\t\\tchar c = password.charAt(i);\\n\\n\\t\\t\\t\\tif (noUppercase && c > 64 && c < 91) {\\n\\t\\t\\t\\t\\tnoUppercase = false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1166459,
                "title": "c-solution-quick-and-dirty-or-not",
                "content": "Here is my C# solution. \\n![image](https://assets.leetcode.com/users/images/9ce8b6aa-1986-4bda-b0bf-01648d8b03d5_1620008573.5286129.png)\\n```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) \\n    {\\n        if (password == null || password.Length == 0)\\n            return 6;\\n        \\n        int countAdd = (password.Length < 6)? 6 -  password.Length : 0;\\n        int countRemove = (password.Length >20)? password.Length - 20 : 0;\\n        \\n        bool hasLowerCase = false;\\n        bool hasUpperCase = false;\\n        bool hasDigit = false;\\n       \\n        int countSeries3 = 0;\\n        int countSeries4 = 0;\\n        int countSeries5 = 0;\\n        int breaksNeeded = 0;\\n        \\n        char lastCh = \\'\\\\n\\'; \\n        int lastChCount = 0;\\n        \\n        foreach(char ch in password)\\n        {\\n            if (ch>=\\'0\\' && ch<=\\'9\\') hasDigit = true;\\n            if (ch>=\\'A\\' && ch<=\\'Z\\') hasUpperCase = true;\\n            if (ch>=\\'a\\' && ch<=\\'z\\') hasLowerCase = true;\\n            \\n            if (lastCh == ch)\\n            {\\n                lastChCount ++;\\n            }\\n            else\\n            {\\n               if (lastChCount > 2)\\n               {\\n                    if (lastChCount % 3 == 0) countSeries3++;\\n                    else if ((lastChCount - 1) % 3 == 0) countSeries4++;\\n                    else countSeries5++;\\n                   \\n                    breaksNeeded +=  lastChCount / 3;\\n               }\\n               lastChCount = 1;\\n               lastCh = ch; \\n            }\\n        }\\n\\n       if (lastChCount > 2)\\n       {\\n            if (lastChCount % 3 == 0) countSeries3++;\\n            else if ((lastChCount - 1) % 3 == 0) countSeries4++;\\n            else countSeries5++;\\n           \\n            breaksNeeded +=  lastChCount / 3;\\n       }\\n\\n        int countRemoveAdj = countRemove;\\n        \\n        breaksNeeded -= Math.Min(countRemoveAdj, countSeries3);\\n        countRemoveAdj -= Math.Min(countRemoveAdj, countSeries3);\\n        \\n        if (countRemoveAdj > 0)\\n        {\\n            breaksNeeded -= Math.Min(countRemoveAdj/2, countSeries4);\\n            countRemoveAdj -= Math.Min(countRemoveAdj, countSeries4 * 2);\\n        }\\n\\n        if (countRemoveAdj > 0)\\n        {\\n            breaksNeeded -= Math.Min(countRemoveAdj/3, breaksNeeded);\\n        }\\n        \\n        int countMissing = (hasLowerCase? 0 : 1) + (hasUpperCase? 0 : 1) + (hasDigit? 0 : 1);\\n\\n        return Math.Max( Math.Max(countMissing, countAdd), breaksNeeded) + countRemove;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) \\n    {\\n        if (password == null || password.Length == 0)\\n            return 6;\\n        \\n        int countAdd = (password.Length < 6)? 6 -  password.Length : 0;\\n        int countRemove = (password.Length >20)? password.Length - 20 : 0;\\n        \\n        bool hasLowerCase = false;\\n        bool hasUpperCase = false;\\n        bool hasDigit = false;\\n       \\n        int countSeries3 = 0;\\n        int countSeries4 = 0;\\n        int countSeries5 = 0;\\n        int breaksNeeded = 0;\\n        \\n        char lastCh = \\'\\\\n\\'; \\n        int lastChCount = 0;\\n        \\n        foreach(char ch in password)\\n        {\\n            if (ch>=\\'0\\' && ch<=\\'9\\') hasDigit = true;\\n            if (ch>=\\'A\\' && ch<=\\'Z\\') hasUpperCase = true;\\n            if (ch>=\\'a\\' && ch<=\\'z\\') hasLowerCase = true;\\n            \\n            if (lastCh == ch)\\n            {\\n                lastChCount ++;\\n            }\\n            else\\n            {\\n               if (lastChCount > 2)\\n               {\\n                    if (lastChCount % 3 == 0) countSeries3++;\\n                    else if ((lastChCount - 1) % 3 == 0) countSeries4++;\\n                    else countSeries5++;\\n                   \\n                    breaksNeeded +=  lastChCount / 3;\\n               }\\n               lastChCount = 1;\\n               lastCh = ch; \\n            }\\n        }\\n\\n       if (lastChCount > 2)\\n       {\\n            if (lastChCount % 3 == 0) countSeries3++;\\n            else if ((lastChCount - 1) % 3 == 0) countSeries4++;\\n            else countSeries5++;\\n           \\n            breaksNeeded +=  lastChCount / 3;\\n       }\\n\\n        int countRemoveAdj = countRemove;\\n        \\n        breaksNeeded -= Math.Min(countRemoveAdj, countSeries3);\\n        countRemoveAdj -= Math.Min(countRemoveAdj, countSeries3);\\n        \\n        if (countRemoveAdj > 0)\\n        {\\n            breaksNeeded -= Math.Min(countRemoveAdj/2, countSeries4);\\n            countRemoveAdj -= Math.Min(countRemoveAdj, countSeries4 * 2);\\n        }\\n\\n        if (countRemoveAdj > 0)\\n        {\\n            breaksNeeded -= Math.Min(countRemoveAdj/3, breaksNeeded);\\n        }\\n        \\n        int countMissing = (hasLowerCase? 0 : 1) + (hasUpperCase? 0 : 1) + (hasDigit? 0 : 1);\\n\\n        return Math.Max( Math.Max(countMissing, countAdd), breaksNeeded) + countRemove;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143533,
                "title": "go-another-solution-with-explanation",
                "content": "Observations:\\n\\n* When len(password) < 6, inserts are required\\n* When len(password) > 20, removals are required\\n* Inserts and replacements can be used to meet lower/upper/digit constraints\\n* When eliminating repeating groups, replacements are more valuable than inserts\\n* When 6 <= len(password) <= 20, replacements are most valuable \\n* Repeating groups should be eliminated as effectively as possible while inserting / removing characters\\n\\nThe observation that replacements are more effective comes from the fact that \"aaaaa\" can be fixed with a single replacement, whereas it would require two inserts. Replacements can reduce the repeat count by 3, inserts by 2, removals by 1:\\n\\n| Repeats | Replacements | Inserts | Removals \\n| --- | --- | --- | --- | \\n| 3 | 1 | 1 | 1 |\\n| 4 | 1 | 1 | 2 |\\n| 5 | 1 | 2 | 3 |\\n| 6 | 2 | 2 | 4 |\\n| 7 | 2 | 3 | 5 |\\n| 8 | 2 | 3 | 6 |\\n\\nSince replacements are more effective than inserts and removals, inserts or removals should only be used when necessary, i.e. when len(password) < 6 or > 20. And when insert or removal is required, the goal is to unlock efficient use of replacements afterwards. Basically, insert/remove should \"land on\" 5, 8, 11, ... `counts[i]%3 == 2`.\\n\\nThis gives the following prioritization for removal of characters while n > 20\\n\\n1. Remove once in groups of 6, 9, 12, ..., i.e. `counts[i]%3 == 0`\\n2. (n>21) Remove twice in groups of 7, 10, 13, ..., i.e.  `counts[i]%3 == 1`\\n3. Repeated removal from group until <= 2\\n4. Remove without reducing repeated group\\n\\nAnd for inserts, i.e. n < 6:\\n\\n1. Insert once in groups of 7, 10, 13, i.e.  `counts[i]%3 == 1`\\n2. Insert in any group\\n3. Insert without reducing repeated group\\n\\nOnce 6 <= n <= 20, use replacements to fix any repeating groups.\\n\\nFinally, count number of inserts/replacements to determine if more replacements are needed to match constraints.\\n\\n```go\\nfunc strongPasswordChecker(password string) int {\\n\\t// The hard part is to pick inserts / replacements in such a way\\n\\t// that it minimizes the number of actions needed to reduce repeated\\n\\t// counts in a group to <= 2\\n\\t//\\n\\t// Given a count > 2, the overflow can be fixed by the actions below:\\n\\t//\\n\\t//   Count  | Replace |  Insert | Remove\\n\\t//     3    |    1    |    1    |   1\\n\\t//     4    |    1    |    1    |   2\\n\\t//     5    |    1    |    2    |   3\\n\\t//     6    |    2    |    2    |   4\\n\\t//     7    |    2    |    3    |   5\\n\\t//     8    |    2    |    4    |   6\\n\\t//\\n\\t// Conclusions:\\n\\t// * Replacements are more valuable than inserts.\\n\\t// * Value of insert/removal depends on whether it unlocks efficient replacement\\n\\t// * There is no need to mix insert and remove, use insert/remove to match\\n\\t//\\t\\tlength requirements, then use replace.\\n\\t//\\n\\t// Cases:\\n\\t// 1. When len(password) < 6, insert to unlock effective replacements.\\n\\t// 2. When len(password) > 20, remove to unlock effective replacements.\\n\\t// 3. When 6 <= len(password) <= 20, replacements are always best.\\n\\t//\\n\\t// An effective insert and remove reduces count to an even multiple of 3\\n\\t//\\n\\t_, counts := rle(password)\\n\\tn := len(password)\\n\\n\\t// Match length criteria\\n\\tvar nremove, ninsert int\\n\\tswitch {\\n\\tcase n < 6:\\n\\t\\tfor n < 6 && hasRepeats(counts) {\\n\\t\\t\\t// Effective inserts\\n\\t\\t\\tfor i := 0; n < 6 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 1 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn++\\n\\t\\t\\t\\tninsert++\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t\\t// Regular inserts\\n\\t\\t\\tfor i := 0; n < 6 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn++\\n\\t\\t\\t\\tninsert++\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Insert remainder\\n\\t\\tif n < 6 {\\n\\t\\t\\tninsert += 6 - n\\n\\t\\t}\\n\\tcase n > 20:\\n\\t\\tfor n > 20 && hasRepeats(counts) {\\n\\t\\t\\t// Effective removal\\n\\t\\t\\tfor i := 0; n > 20 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 0 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn--\\n\\t\\t\\t\\tnremove++\\n\\t\\t\\t\\tcounts[i]--\\n\\t\\t\\t}\\n\\t\\t\\t// Half-effective removal\\n\\t\\t\\tfor i := 0; n > 21 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 1 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn -= 2\\n\\t\\t\\t\\tnremove += 2\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t\\t// Regular removal - simply remove counts until n == 20\\n\\t\\t\\tfor i := 0; n > 20 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor n > 20 && counts[i] > 2 {\\n\\t\\t\\t\\t\\tn--\\n\\t\\t\\t\\t\\tnremove++\\n\\t\\t\\t\\t\\tcounts[i]--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Remove remainder\\n\\t\\tif n > 20 {\\n\\t\\t\\tnremove += n - 20\\n\\t\\t}\\n\\t}\\n\\n\\t// Make replacements\\n\\tvar nreplace int\\n\\tfor _, c := range counts {\\n\\t\\tnreplace += c / 3\\n\\t}\\n\\n\\t// Count total number of actions\\n\\tconstrs := countMissingConstraints(password)\\n\\tactions := nremove + max(constrs, nreplace+ninsert)\\n\\treturn actions\\n}\\n\\nfunc hasRepeats(counts []int) bool {\\n\\tfor _, c := range counts {\\n\\t\\tif c > 2 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc rle(s string) ([]rune, []int) {\\n\\tchars := make([]rune, 0)\\n\\tcounts := make([]int, 0)\\n\\tvar n int\\n\\tfor _, r := range s {\\n\\t\\tif n > 0 && r == chars[n-1] {\\n\\t\\t\\tcounts[n-1]++\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tchars = append(chars, r)\\n\\t\\tcounts = append(counts, 1)\\n\\t\\tn++\\n\\t}\\n\\treturn chars, counts\\n}\\n\\nfunc countMissingConstraints(s string) int {\\n\\tvar constrMissing int\\n\\tif !strings.ContainsAny(s, \"0123456789\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\tif !strings.ContainsAny(s, \"abcdefghijklmnopqrstuvwxyz\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\tif !strings.ContainsAny(s, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\treturn constrMissing\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc strongPasswordChecker(password string) int {\\n\\t// The hard part is to pick inserts / replacements in such a way\\n\\t// that it minimizes the number of actions needed to reduce repeated\\n\\t// counts in a group to <= 2\\n\\t//\\n\\t// Given a count > 2, the overflow can be fixed by the actions below:\\n\\t//\\n\\t//   Count  | Replace |  Insert | Remove\\n\\t//     3    |    1    |    1    |   1\\n\\t//     4    |    1    |    1    |   2\\n\\t//     5    |    1    |    2    |   3\\n\\t//     6    |    2    |    2    |   4\\n\\t//     7    |    2    |    3    |   5\\n\\t//     8    |    2    |    4    |   6\\n\\t//\\n\\t// Conclusions:\\n\\t// * Replacements are more valuable than inserts.\\n\\t// * Value of insert/removal depends on whether it unlocks efficient replacement\\n\\t// * There is no need to mix insert and remove, use insert/remove to match\\n\\t//\\t\\tlength requirements, then use replace.\\n\\t//\\n\\t// Cases:\\n\\t// 1. When len(password) < 6, insert to unlock effective replacements.\\n\\t// 2. When len(password) > 20, remove to unlock effective replacements.\\n\\t// 3. When 6 <= len(password) <= 20, replacements are always best.\\n\\t//\\n\\t// An effective insert and remove reduces count to an even multiple of 3\\n\\t//\\n\\t_, counts := rle(password)\\n\\tn := len(password)\\n\\n\\t// Match length criteria\\n\\tvar nremove, ninsert int\\n\\tswitch {\\n\\tcase n < 6:\\n\\t\\tfor n < 6 && hasRepeats(counts) {\\n\\t\\t\\t// Effective inserts\\n\\t\\t\\tfor i := 0; n < 6 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 1 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn++\\n\\t\\t\\t\\tninsert++\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t\\t// Regular inserts\\n\\t\\t\\tfor i := 0; n < 6 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn++\\n\\t\\t\\t\\tninsert++\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Insert remainder\\n\\t\\tif n < 6 {\\n\\t\\t\\tninsert += 6 - n\\n\\t\\t}\\n\\tcase n > 20:\\n\\t\\tfor n > 20 && hasRepeats(counts) {\\n\\t\\t\\t// Effective removal\\n\\t\\t\\tfor i := 0; n > 20 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 0 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn--\\n\\t\\t\\t\\tnremove++\\n\\t\\t\\t\\tcounts[i]--\\n\\t\\t\\t}\\n\\t\\t\\t// Half-effective removal\\n\\t\\t\\tfor i := 0; n > 21 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 || counts[i]%3 != 1 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn -= 2\\n\\t\\t\\t\\tnremove += 2\\n\\t\\t\\t\\tcounts[i] -= 2\\n\\t\\t\\t}\\n\\t\\t\\t// Regular removal - simply remove counts until n == 20\\n\\t\\t\\tfor i := 0; n > 20 && i < len(counts); i++ {\\n\\t\\t\\t\\tif counts[i] <= 2 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor n > 20 && counts[i] > 2 {\\n\\t\\t\\t\\t\\tn--\\n\\t\\t\\t\\t\\tnremove++\\n\\t\\t\\t\\t\\tcounts[i]--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Remove remainder\\n\\t\\tif n > 20 {\\n\\t\\t\\tnremove += n - 20\\n\\t\\t}\\n\\t}\\n\\n\\t// Make replacements\\n\\tvar nreplace int\\n\\tfor _, c := range counts {\\n\\t\\tnreplace += c / 3\\n\\t}\\n\\n\\t// Count total number of actions\\n\\tconstrs := countMissingConstraints(password)\\n\\tactions := nremove + max(constrs, nreplace+ninsert)\\n\\treturn actions\\n}\\n\\nfunc hasRepeats(counts []int) bool {\\n\\tfor _, c := range counts {\\n\\t\\tif c > 2 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc rle(s string) ([]rune, []int) {\\n\\tchars := make([]rune, 0)\\n\\tcounts := make([]int, 0)\\n\\tvar n int\\n\\tfor _, r := range s {\\n\\t\\tif n > 0 && r == chars[n-1] {\\n\\t\\t\\tcounts[n-1]++\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tchars = append(chars, r)\\n\\t\\tcounts = append(counts, 1)\\n\\t\\tn++\\n\\t}\\n\\treturn chars, counts\\n}\\n\\nfunc countMissingConstraints(s string) int {\\n\\tvar constrMissing int\\n\\tif !strings.ContainsAny(s, \"0123456789\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\tif !strings.ContainsAny(s, \"abcdefghijklmnopqrstuvwxyz\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\tif !strings.ContainsAny(s, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") {\\n\\t\\tconstrMissing++\\n\\t}\\n\\treturn constrMissing\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054172,
                "title": "0-ms-o-n-java-solution-with-detailed-analysis",
                "content": "Let\\'s analysis the three options:\\n1. insert a char\\nTake 1 insert step, can resolve:\\nProb1: when length < 6\\nProb2: add missing catagory\\nProb3: split repeating chars\\n2. Delete a char\\nTake 1 delete step, can resolve:\\nProb1: when length > 20\\nProb3: reducing repeating chars\\n3. Replace a char\\nTake 1 replace step, can resolve:\\nProb2: replace with missing catagory\\nProb3: eg: aaaaa => aa1aa\\n\\nThere are three cases for this problem:\\n1. When **length < 6**\\nProb 1: Insert ```6 - length``` chars (need 1 ~ 6 steps)\\nProb 2: need 0~3 steps\\nProb 3: At most need 1 step, which is \"aaaaa\"\\nInsert can resolve prob 1, 2 & 3 together, so the minimum step need to take is **Max(Prob1, Prob2)**\\n2. When **6 <= length <= 20**\\nProb1: need 0 step \\nProb2: need  0~3 steps\\nProb 3: need 0~6 steps eg \\'aaaaaaaaaaaaaaaaaaaa\\' can be resolved by 6 replace steps\\nReplace can resolve prob 2 & 3 together and will not introduce prob 1, so the minimun step need to take is **Max(Prob2, Prob3)**\\n3. When 20 < length <= 50\\nProb1: need 1~30 delete steps\\nProb2: need 0~3 steps\\nProb3: need 0 ~ 16 steps, (50 / 3 = 16)\\nIn this case, delete steps are required to resolve Prob1. In the same time, Prob3 can be also resolved by delete step.\\n**Phase 1**, we need to take ```Prob1``` delete steps to resolve Prob1. In the same time, what\\'s the max Prob3 we can resolve?\\n1 Prob3 can be resolved by 1 delete step, when ```repeat length % 3 = 0``` eg: \\'aaa\\' delete 1 char can resolve 1 Prob3\\n1 Prob3 can be resolved by 2 delete steps, when ```repeat length % 3 = 1``` eg: \\'aaaa\\' delete 2 chars can resolve 1 Prob3\\n1 Prob3 can be resolved by 3 delete steps, when ```repeat length % 3 = 2``` eg: \\'aaaaa\\' delete 3 chars can resole 1 Prob3 (delete 3 same charaters can always resolve 1 Prob3)\\n```p31``` means the number of sub repeat strings(length >= 3) that ```length % 3 = 0```\\n```p32``` means the number of sub repeat strings(length >= 3) that ```length % 3 = 1```\\n```p33``` means the number of sub repeat strings(length >= 3) that ```length % 3 = 2```\\nSo, when we resolve Prob1, we should first resolve ```p31``` and then ```p32``` and then ```p33```.  After Prob1 resolved, the number of Prob3 remain is ```prob3 - prob3ResolvedByDelete```\\n**Phase2**, After all Prob1 resolved, we still have Prob2 and Prob3 need to resolve. We should use repace step to resolve them. The minimun step we need is **Max(prob2, prob3 - prob3ResolvedByDelete)**\\nOverall, in this case, the minimun step need to take is **prob1 + Math.max(prob2, prob3 - prob3ResolvedByDelete);**\\n\\n\\n\\n```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int length = password.length();\\n        int prob1 = Math.max(0, Math.max(6 - length, length - 20));\\n        \\n        boolean hasUpper = false;\\n        boolean hasLower = false;\\n        boolean hasDigit = false;\\n        int prob2 = 3;\\n        \\n        int prob3 = 0;\\n        int repeatCount = 1;\\n        int p31 = 0;\\n        int p32 = 0;\\n        int p33 = 0;\\n        \\n        char prev = \\'a\\';\\n        for (int i = 0; i < length; i++) {\\n            char curr = password.charAt(i);\\n            if (Character.isUpperCase(curr) && !hasUpper) {\\n                prob2--;\\n                hasUpper = true;\\n            }\\n            if (Character.isLowerCase(curr) && !hasLower) {\\n                prob2--;\\n                hasLower = true;\\n            }\\n            if (Character.isDigit(curr) && !hasDigit) {\\n                prob2--;\\n                hasDigit = true;\\n            }\\n            \\n            if (i > 0) {\\n                if (curr == prev) {\\n                    repeatCount++;\\n                } else {\\n                    if (repeatCount >= 3) {\\n                        prob3 += repeatCount / 3;\\n                        if (repeatCount % 3 == 0) {\\n                            p31++;\\n                        } else if (repeatCount % 3 == 1) {\\n                            p32++;\\n                        } else {\\n                            p33++;\\n                        }\\n                    }\\n                    repeatCount = 1;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        // need to include the last batch\\n        if (repeatCount >= 3) {\\n            prob3 += repeatCount / 3;\\n            if (repeatCount % 3 == 0) {\\n                p31++;\\n            } else if (repeatCount % 3 == 1) {\\n                p32++;\\n            } else {\\n                p33++;\\n            }\\n        }\\n        if (length < 6) {\\n            return Math.max(prob1, prob2);\\n        } else if (length > 20) {\\n            int prob3ResolvedByDelete = 0;\\n            if (prob1 <= p31) {\\n                prob3ResolvedByDelete = prob1;\\n            } else if (prob1 <= 2 * p32 + p31) {\\n                prob3ResolvedByDelete = p31 + (prob1 - p31) /2;\\n            } else {\\n                prob3ResolvedByDelete = p31 + p32 + (prob1 - p31 - 2 * p32) / 3;\\n            }\\n            return prob1 + Math.max(prob2, prob3 - prob3ResolvedByDelete);\\n        } else {\\n            return Math.max(prob2, prob3);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```6 - length```\n```Prob1```\n```repeat length % 3 = 0```\n```repeat length % 3 = 1```\n```repeat length % 3 = 2```\n```p31```\n```length % 3 = 0```\n```p32```\n```length % 3 = 1```\n```p33```\n```length % 3 = 2```\n```p31```\n```p32```\n```p33```\n```prob3 - prob3ResolvedByDelete```\n```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int length = password.length();\\n        int prob1 = Math.max(0, Math.max(6 - length, length - 20));\\n        \\n        boolean hasUpper = false;\\n        boolean hasLower = false;\\n        boolean hasDigit = false;\\n        int prob2 = 3;\\n        \\n        int prob3 = 0;\\n        int repeatCount = 1;\\n        int p31 = 0;\\n        int p32 = 0;\\n        int p33 = 0;\\n        \\n        char prev = \\'a\\';\\n        for (int i = 0; i < length; i++) {\\n            char curr = password.charAt(i);\\n            if (Character.isUpperCase(curr) && !hasUpper) {\\n                prob2--;\\n                hasUpper = true;\\n            }\\n            if (Character.isLowerCase(curr) && !hasLower) {\\n                prob2--;\\n                hasLower = true;\\n            }\\n            if (Character.isDigit(curr) && !hasDigit) {\\n                prob2--;\\n                hasDigit = true;\\n            }\\n            \\n            if (i > 0) {\\n                if (curr == prev) {\\n                    repeatCount++;\\n                } else {\\n                    if (repeatCount >= 3) {\\n                        prob3 += repeatCount / 3;\\n                        if (repeatCount % 3 == 0) {\\n                            p31++;\\n                        } else if (repeatCount % 3 == 1) {\\n                            p32++;\\n                        } else {\\n                            p33++;\\n                        }\\n                    }\\n                    repeatCount = 1;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        // need to include the last batch\\n        if (repeatCount >= 3) {\\n            prob3 += repeatCount / 3;\\n            if (repeatCount % 3 == 0) {\\n                p31++;\\n            } else if (repeatCount % 3 == 1) {\\n                p32++;\\n            } else {\\n                p33++;\\n            }\\n        }\\n        if (length < 6) {\\n            return Math.max(prob1, prob2);\\n        } else if (length > 20) {\\n            int prob3ResolvedByDelete = 0;\\n            if (prob1 <= p31) {\\n                prob3ResolvedByDelete = prob1;\\n            } else if (prob1 <= 2 * p32 + p31) {\\n                prob3ResolvedByDelete = p31 + (prob1 - p31) /2;\\n            } else {\\n                prob3ResolvedByDelete = p31 + p32 + (prob1 - p31 - 2 * p32) / 3;\\n            }\\n            return prob1 + Math.max(prob2, prob3 - prob3ResolvedByDelete);\\n        } else {\\n            return Math.max(prob2, prob3);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945982,
                "title": "easy-to-understand-solution-use-deletion-to-reduce-replacement-o-n-and-o-1",
                "content": "```\\n    int strongPasswordChecker(string password) {\\n        int missA = 1, missa = 1, miss0 = 1;\\n        for (auto c : password) {\\n            if (isdigit(c)) {\\n                miss0 = 0;\\n            }\\n            if (c >= \\'a\\' && c <= \\'z\\') {\\n                missa = 0;\\n            }\\n            if (c >= \\'A\\' && c <= \\'Z\\') {\\n                missA = 0;\\n            }\\n        }\\n        \\n        int misstype = missA + missa + miss0;\\n        int N = password.size();\\n        int mod0 = 0, mod1 = 0;\\n        int replace = 0;\\n        \\n        for (int i = 2; i < N; i++) {\\n            if (password[i] == password[i-1] && password[i] == password[i-2]) {\\n                int len = 2;\\n                while (password[i] == password[i-1] && i < N) {\\n                    i++;\\n                    len++;\\n                }\\n                if (len % 3 == 0) {\\n                    mod0++;\\n                } else if (len % 3 == 1) {\\n                    mod1++;\\n                }\\n                i--;\\n                replace += len / 3;\\n            }\\n        }\\n        \\n        if (N <= 20) {\\n            return max({replace, misstype, 6-N});\\n        }\\n        \\n        int deletes = N - 20;\\n        \\n        // use deletes as budget to reduce replace\\n        int budget = deletes;\\n        \\n        if (budget > 0) {\\n            int reduce = min(budget, mod0); // \"aaaaaa\" ---delete one---> \"aaaaa\" (mod=2) \\n            replace -= reduce;\\n            budget -= reduce;\\n        }\\n        \\n        if (budget > 0) {\\n            int reduce = min(budget/2, mod1); // \"aaaaaaa\" ---delete two---> \"aaaaa\" (mod=2) \\n            replace -= reduce;\\n            budget -= reduce * 2;\\n        }\\n        \\n        // all remaing including the above ones, are mod=2 \\n        // every 3 deletions can reduce 1 replace \\n        // \"aaa aaa aa\" ---delete three---> \"aaa aa\" ---delete three--> \"aa\"\\n\\n        if (budget > 0) {\\n            int reduce = min(budget/3, replace); \\n            replace -= reduce;\\n            budget -= reduce * 3;\\n        }\\n        \\n        return max(replace, misstype) + deletes;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int strongPasswordChecker(string password) {\\n        int missA = 1, missa = 1, miss0 = 1;\\n        for (auto c : password) {\\n            if (isdigit(c)) {\\n                miss0 = 0;\\n            }\\n            if (c >= \\'a\\' && c <= \\'z\\') {\\n                missa = 0;\\n            }\\n            if (c >= \\'A\\' && c <= \\'Z\\') {\\n                missA = 0;\\n            }\\n        }\\n        \\n        int misstype = missA + missa + miss0;\\n        int N = password.size();\\n        int mod0 = 0, mod1 = 0;\\n        int replace = 0;\\n        \\n        for (int i = 2; i < N; i++) {\\n            if (password[i] == password[i-1] && password[i] == password[i-2]) {\\n                int len = 2;\\n                while (password[i] == password[i-1] && i < N) {\\n                    i++;\\n                    len++;\\n                }\\n                if (len % 3 == 0) {\\n                    mod0++;\\n                } else if (len % 3 == 1) {\\n                    mod1++;\\n                }\\n                i--;\\n                replace += len / 3;\\n            }\\n        }\\n        \\n        if (N <= 20) {\\n            return max({replace, misstype, 6-N});\\n        }\\n        \\n        int deletes = N - 20;\\n        \\n        // use deletes as budget to reduce replace\\n        int budget = deletes;\\n        \\n        if (budget > 0) {\\n            int reduce = min(budget, mod0); // \"aaaaaa\" ---delete one---> \"aaaaa\" (mod=2) \\n            replace -= reduce;\\n            budget -= reduce;\\n        }\\n        \\n        if (budget > 0) {\\n            int reduce = min(budget/2, mod1); // \"aaaaaaa\" ---delete two---> \"aaaaa\" (mod=2) \\n            replace -= reduce;\\n            budget -= reduce * 2;\\n        }\\n        \\n        // all remaing including the above ones, are mod=2 \\n        // every 3 deletions can reduce 1 replace \\n        // \"aaa aaa aa\" ---delete three---> \"aaa aa\" ---delete three--> \"aa\"\\n\\n        if (budget > 0) {\\n            int reduce = min(budget/3, replace); \\n            replace -= reduce;\\n            budget -= reduce * 3;\\n        }\\n        \\n        return max(replace, misstype) + deletes;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 884238,
                "title": "0ms-java-faster-than-100-o-n",
                "content": "This took a whole day. \\nThe arrayReducer is blocked by O(n/3).\\noverall O( n + n/3 ) = = O(n)\\nCode is very messy and uses a lot of redundant space..\\nBut I can\\'t be bothered by it. This took longer than I expected..\\n```\\nclass Solution {\\n   \\n   \\n    public static int strongPasswordChecker(String s) {\\n        int deletions = 0, finalCounter = 0, insertions = 0, repeating = 1, changesSum;\\n        int replacements = 0, length = s.length();\\n        boolean digit, lowerCase, upperCase;\\n        digit = lowerCase = upperCase = false;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        for (int i = 0; i < length; i++) {\\n            if (i > 19)\\n                deletions++;\\n            if (Character.isLowerCase(s.charAt(i)))\\n                lowerCase = true;\\n            if (Character.isUpperCase(s.charAt(i)))\\n                upperCase = true;\\n            if (Character.isDigit(s.charAt(i)))\\n                digit = true;\\n            if (i > 0) {\\n                if (s.charAt(i) == s.charAt(i - 1))\\n                    repeating++;\\n                else {\\n                    if (repeating > 2)\\n                        arr.add(repeating);\\n                    repeating = 1;\\n                }\\n            }\\n        }\\n        if (repeating > 2)\\n            arr.add(repeating);\\n        if (digit)\\n            insertions++;\\n\\n        if (upperCase)\\n            insertions++;\\n\\n        if (lowerCase)\\n            insertions++;\\n        insertions = 3 - insertions;\\n\\n        if(deletions > 0 && arr.size() > 0)\\n            arr = arrayReducer(arr, deletions);\\n        changesSum =listSum(arr);\\n        finalCounter = deletions + changesSum;\\n\\n        if(insertions > 0){\\n            if(changesSum >= insertions)\\n                insertions = 0;\\n            else\\n                insertions = insertions - changesSum;\\n            }\\n        if(s.length() < 6) {\\n            if(insertions < 6- (s.length()))\\n                insertions = insertions + (6 - s.length() - insertions);\\n            if(insertions > changesSum)\\n                insertions = insertions - changesSum;\\n        }\\n        finalCounter = finalCounter + insertions;\\n\\n            return finalCounter;\\n    }\\n\\n    public static int listSum (ArrayList<Integer> arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.size();  i ++ )\\n            sum = sum + (arr.get(i)/3);\\n\\n        return sum;\\n\\n    }\\n    public static ArrayList arrayReducer(ArrayList<Integer> arr, int i) {\\n        int mod;\\n        int current, counter = 0, flag = arr.size() + 1;\\n        while(i>0) {\\n            mod = counter%3;\\n            for(int x = 0; x <arr.size(); x++) {\\n                if( flag == 0 )\\n                    return arr;\\n                current = arr.get(x);\\n                if (current % 3 == mod) {\\n                    if (i >= (mod + 1)) {\\n                        i = i - (mod + 1);\\n\\n                        arr.set(x, current - (mod + 1));\\n                    } else{\\n                        flag--;\\n                        if (mod == 0)\\n                        return arr;\\n                    }\\n                    if (i == 0)\\n                        return arr;\\n\\n\\n                }\\n                if(i < (mod + 1))\\n                    if(mod == 0)\\n                        return arr;\\n            }\\n            counter++;\\n        }\\n        return arr;\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\n   \\n    public static int strongPasswordChecker(String s) {\\n        int deletions = 0, finalCounter = 0, insertions = 0, repeating = 1, changesSum;\\n        int replacements = 0, length = s.length();\\n        boolean digit, lowerCase, upperCase;\\n        digit = lowerCase = upperCase = false;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        for (int i = 0; i < length; i++) {\\n            if (i > 19)\\n                deletions++;\\n            if (Character.isLowerCase(s.charAt(i)))\\n                lowerCase = true;\\n            if (Character.isUpperCase(s.charAt(i)))\\n                upperCase = true;\\n            if (Character.isDigit(s.charAt(i)))\\n                digit = true;\\n            if (i > 0) {\\n                if (s.charAt(i) == s.charAt(i - 1))\\n                    repeating++;\\n                else {\\n                    if (repeating > 2)\\n                        arr.add(repeating);\\n                    repeating = 1;\\n                }\\n            }\\n        }\\n        if (repeating > 2)\\n            arr.add(repeating);\\n        if (digit)\\n            insertions++;\\n\\n        if (upperCase)\\n            insertions++;\\n\\n        if (lowerCase)\\n            insertions++;\\n        insertions = 3 - insertions;\\n\\n        if(deletions > 0 && arr.size() > 0)\\n            arr = arrayReducer(arr, deletions);\\n        changesSum =listSum(arr);\\n        finalCounter = deletions + changesSum;\\n\\n        if(insertions > 0){\\n            if(changesSum >= insertions)\\n                insertions = 0;\\n            else\\n                insertions = insertions - changesSum;\\n            }\\n        if(s.length() < 6) {\\n            if(insertions < 6- (s.length()))\\n                insertions = insertions + (6 - s.length() - insertions);\\n            if(insertions > changesSum)\\n                insertions = insertions - changesSum;\\n        }\\n        finalCounter = finalCounter + insertions;\\n\\n            return finalCounter;\\n    }\\n\\n    public static int listSum (ArrayList<Integer> arr){\\n        int sum = 0;\\n        for(int i = 0; i < arr.size();  i ++ )\\n            sum = sum + (arr.get(i)/3);\\n\\n        return sum;\\n\\n    }\\n    public static ArrayList arrayReducer(ArrayList<Integer> arr, int i) {\\n        int mod;\\n        int current, counter = 0, flag = arr.size() + 1;\\n        while(i>0) {\\n            mod = counter%3;\\n            for(int x = 0; x <arr.size(); x++) {\\n                if( flag == 0 )\\n                    return arr;\\n                current = arr.get(x);\\n                if (current % 3 == mod) {\\n                    if (i >= (mod + 1)) {\\n                        i = i - (mod + 1);\\n\\n                        arr.set(x, current - (mod + 1));\\n                    } else{\\n                        flag--;\\n                        if (mod == 0)\\n                        return arr;\\n                    }\\n                    if (i == 0)\\n                        return arr;\\n\\n\\n                }\\n                if(i < (mod + 1))\\n                    if(mod == 0)\\n                        return arr;\\n            }\\n            counter++;\\n        }\\n        return arr;\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833624,
                "title": "python-solution-with-details-around-90-time-and-80-space",
                "content": "In this question, the cheapest way to solve a **consecutive3** condition should be using replacing, because for solving  any consecutive with length n >= 3:\\n* removing letter will need **n-2** operations\\n* adding operations will need **(n-1)/2** operations\\n* replacing only needs **n/3** operations\\n\\nAlso, the **low/upper/digit** condition should also be solved by replacing, because it can cover **consecutive3** and won\\'t cause new **length** problem\\n\\n**Length** problem can only be solved by adding or removing letters. Adding letters can cover **low/upper/digit** and **consecutive3**, removing can only cover **consecutive3**.\\n\\nIn my solution, I am trying to calculate how many operations need for fixing each of **length**, **low/upper/digit**, and **consecutive3**. Then analyze the cheapest way to let them cover each others\\' problem.\\n\\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        repeat = []\\n        i = 0\\n        prev, count = \\'\\',1\\n        low = up = digit = 1\\n        \\n        while i < len(s):\\n            \\n            if low and s[i].islower():\\n                low = 0\\n            if up and not s[i].islower():\\n                up = 0\\n            if digit and s[i].isdigit():\\n                digit = 0\\n                \\n            if s[i] == prev:\\n                count+=1\\n            else:\\n                if count >= 3:\\n                    repeat.append(count)\\n                prev = s[i]\\n                count = 1\\n            i+=1\\n        if count >= 3:\\n            repeat.append(count)\\n        \\n        #if we use replace, this is the minimal num of operations to remove all consecutive3\\n        allRepeat = sum([r//3 for r in repeat]) \\n        #this is num of operations to cover all low/upper/digit\\n        cases = low + up + digit\\n        \\n        if 20 >= len(s):\\n            #in this case we only need to add letters\\n            less = 6-len(s) if len(s) < 6 else 0\\n            \\n            # in cases like aaaaa, even after adding one letter, we still have one consecutive3\\n            if less == 1 and len(repeat) == 1 and repeat[0] == 5:\\n                allRepeat = 2\\n            \\n            # return max num of 3 types of operations, because each of them can also solve other types\\' problem\\n            return max(less,allRepeat,cases)\\n        else:\\n            less = len(s) - 20\\n            if allRepeat <= cases:\\n                # in this case all consecutive3 will be covered by replacing one letter by low/upper/digit letter\\n                # so we only need to remove all extra letter, and make sure we have all low/upper/digit letters\\n                return cases+less\\n    \\n            # sort the toRemove by how many letters need be removed to reduce consecutive3 operation by one\\n            toRemove = sorted([(r%3,r//3) for r in repeat])\\n            totalLess = less\\n            \\n            while less > 0:\\n                count = 0\\n                for i in range(len(toRemove)):\\n                    # try to use least remove operations to cover as much as consecutive3 operations as possible\\n                    tr = toRemove[i]\\n                    if tr[1] == 0:\\n                        count += 1\\n                        continue\\n                    if less >= tr[0]+1:\\n                        # cover one consecutive3 operations by removing letters operation\\n                        toRemove[i] = (2,tr[1]-1)\\n                        less -= (tr[0]+1)\\n                    else:\\n                        # not enough removing operations to cover any more consecutive3 operations\\n                        toRemove[i] = (tr[0] - less, tr[1])\\n                        less = 0\\n                        break\\n                \\n                if count == len(toRemove):\\n                    # all consecutive3 operations are covered by removing letters operations\\n                    # so we just remove all extra letters, and then make sure low/upper/digits exists\\n                    return totalLess + cases\\n                if less == 0:\\n                    # we run out of removing letters operations, but there are still some consecutive3 here\\n                    break\\n            \\n            # re-calculate the rest replace operations needed for consecutive3\\n            allRepeat = sum([tr[1] for tr in toRemove])\\n            \\n            # return all removing operations plus the max of low/upper/digits and consecutive3 operations\\n            return totalLess + max(cases, allRepeat)\\n            \\n            \\n            \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        repeat = []\\n        i = 0\\n        prev, count = \\'\\',1\\n        low = up = digit = 1\\n        \\n        while i < len(s):\\n            \\n            if low and s[i].islower():\\n                low = 0\\n            if up and not s[i].islower():\\n                up = 0\\n            if digit and s[i].isdigit():\\n                digit = 0\\n                \\n            if s[i] == prev:\\n                count+=1\\n            else:\\n                if count >= 3:\\n                    repeat.append(count)\\n                prev = s[i]\\n                count = 1\\n            i+=1\\n        if count >= 3:\\n            repeat.append(count)\\n        \\n        #if we use replace, this is the minimal num of operations to remove all consecutive3\\n        allRepeat = sum([r//3 for r in repeat]) \\n        #this is num of operations to cover all low/upper/digit\\n        cases = low + up + digit\\n        \\n        if 20 >= len(s):\\n            #in this case we only need to add letters\\n            less = 6-len(s) if len(s) < 6 else 0\\n            \\n            # in cases like aaaaa, even after adding one letter, we still have one consecutive3\\n            if less == 1 and len(repeat) == 1 and repeat[0] == 5:\\n                allRepeat = 2\\n            \\n            # return max num of 3 types of operations, because each of them can also solve other types\\' problem\\n            return max(less,allRepeat,cases)\\n        else:\\n            less = len(s) - 20\\n            if allRepeat <= cases:\\n                # in this case all consecutive3 will be covered by replacing one letter by low/upper/digit letter\\n                # so we only need to remove all extra letter, and make sure we have all low/upper/digit letters\\n                return cases+less\\n    \\n            # sort the toRemove by how many letters need be removed to reduce consecutive3 operation by one\\n            toRemove = sorted([(r%3,r//3) for r in repeat])\\n            totalLess = less\\n            \\n            while less > 0:\\n                count = 0\\n                for i in range(len(toRemove)):\\n                    # try to use least remove operations to cover as much as consecutive3 operations as possible\\n                    tr = toRemove[i]\\n                    if tr[1] == 0:\\n                        count += 1\\n                        continue\\n                    if less >= tr[0]+1:\\n                        # cover one consecutive3 operations by removing letters operation\\n                        toRemove[i] = (2,tr[1]-1)\\n                        less -= (tr[0]+1)\\n                    else:\\n                        # not enough removing operations to cover any more consecutive3 operations\\n                        toRemove[i] = (tr[0] - less, tr[1])\\n                        less = 0\\n                        break\\n                \\n                if count == len(toRemove):\\n                    # all consecutive3 operations are covered by removing letters operations\\n                    # so we just remove all extra letters, and then make sure low/upper/digits exists\\n                    return totalLess + cases\\n                if less == 0:\\n                    # we run out of removing letters operations, but there are still some consecutive3 here\\n                    break\\n            \\n            # re-calculate the rest replace operations needed for consecutive3\\n            allRepeat = sum([tr[1] for tr in toRemove])\\n            \\n            # return all removing operations plus the max of low/upper/digits and consecutive3 operations\\n            return totalLess + max(cases, allRepeat)\\n            \\n            \\n            \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 788493,
                "title": "clear-and-short-python-explanation-commented-code",
                "content": "A password is considered strong if below conditions are all met:\\n1. It has at least 6 characters and at most 20 characters.\\n2. It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.\\n3. It must NOT contain three repeating characters in a row (\"...aaa...\" is weak, but \"...aa...a...\" is strong, assuming other conditions are met).\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        \"\"\"\\n        Missing/length reqs are easy by themselves.\\n        For repeating sequences, we need to find number of ADDITIONAL replaces.\\n        We can insert (ideal for len(s) < 6) to disrupt missing (+ reduce one replace).\\n        We can delete (ideal for len(s) > 20) 1-3 characters to reduce one replace.\\n        We can replace as last resort.\\n        \\n        Excellent explainer: https://leetcode.com/problems/strong-password-checker/discuss/478197/Explanation-of-How-To-Approach-This-Problem\\n        \"\"\"\\n        # Requirement 2\\n        req_missing = 3\\n        req_missing -= any(c.islower() for c in s)\\n        req_missing -= any(c.isupper() for c in s)\\n        req_missing -= any(c.isdigit() for c in s)\\n        \\n        # Requirement 3\\n        repeat_replace = 0\\n        mod0 = mod1 = 0\\n        i = 2\\n        while i < len(s):\\n            if s[i] == s[i-1] == s[i-2]:    # start of repeating sequence\\n                curr = 2  # track length of current repeating sequence\\n                while i < len(s) and s[i-1] == s[i]:\\n                    curr += 1\\n                    i += 1\\n                repeat_replace += curr // 3 # {# of raw replacements needed}\\n                # We can reduce replaces, by using strategic deletes\\n                mod0 += int(curr%3==0)      # mod0 -> mod2 costs 1 delete to save one replace\\n                mod1 += int(curr%3==1)      # mod1 -> mod2 costs 2 deletes to save one replace\\n                # mod2 -> mod2 costs 3 deletes to save one replace\\n            else:\\n                i += 1\\n\\n        # Requirement 1\\n        res = max(0, len(s)-20)                     # {# deletes} + {# inserts} + {# replaces}\\n        if len(s) > 20:\\n            deletes = len(s)-20                     # need to delete, then replace\\n            repeat_replace -= min(deletes, mod0)    # delete mod0 -> mod2 == save one replace\\n            deletes = max(0, deletes - mod0)\\n            repeat_replace -= min(deletes, mod1*2)//2   # delete mod1 -> mod2 == save one replace\\n            deletes = max(0, deletes - mod1*2)\\n            repeat_replace -= deletes // 3                  # use remaining deletes to mod2 -> mod2\\n        res += max(6-len(s), req_missing, repeat_replace)   # can insert or replace with missing chars, so they\\'re interchangeable here\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        \"\"\"\\n        Missing/length reqs are easy by themselves.\\n        For repeating sequences, we need to find number of ADDITIONAL replaces.\\n        We can insert (ideal for len(s) < 6) to disrupt missing (+ reduce one replace).\\n        We can delete (ideal for len(s) > 20) 1-3 characters to reduce one replace.\\n        We can replace as last resort.\\n        \\n        Excellent explainer: https://leetcode.com/problems/strong-password-checker/discuss/478197/Explanation-of-How-To-Approach-This-Problem\\n        \"\"\"\\n        # Requirement 2\\n        req_missing = 3\\n        req_missing -= any(c.islower() for c in s)\\n        req_missing -= any(c.isupper() for c in s)\\n        req_missing -= any(c.isdigit() for c in s)\\n        \\n        # Requirement 3\\n        repeat_replace = 0\\n        mod0 = mod1 = 0\\n        i = 2\\n        while i < len(s):\\n            if s[i] == s[i-1] == s[i-2]:    # start of repeating sequence\\n                curr = 2  # track length of current repeating sequence\\n                while i < len(s) and s[i-1] == s[i]:\\n                    curr += 1\\n                    i += 1\\n                repeat_replace += curr // 3 # {# of raw replacements needed}\\n                # We can reduce replaces, by using strategic deletes\\n                mod0 += int(curr%3==0)      # mod0 -> mod2 costs 1 delete to save one replace\\n                mod1 += int(curr%3==1)      # mod1 -> mod2 costs 2 deletes to save one replace\\n                # mod2 -> mod2 costs 3 deletes to save one replace\\n            else:\\n                i += 1\\n\\n        # Requirement 1\\n        res = max(0, len(s)-20)                     # {# deletes} + {# inserts} + {# replaces}\\n        if len(s) > 20:\\n            deletes = len(s)-20                     # need to delete, then replace\\n            repeat_replace -= min(deletes, mod0)    # delete mod0 -> mod2 == save one replace\\n            deletes = max(0, deletes - mod0)\\n            repeat_replace -= min(deletes, mod1*2)//2   # delete mod1 -> mod2 == save one replace\\n            deletes = max(0, deletes - mod1*2)\\n            repeat_replace -= deletes // 3                  # use remaining deletes to mod2 -> mod2\\n        res += max(6-len(s), req_missing, repeat_replace)   # can insert or replace with missing chars, so they\\'re interchangeable here\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733369,
                "title": "c-0-ms-solution",
                "content": "The idea is inspired by [this solution](https://leetcode.com/problems/strong-password-checker/discuss/91007/C%2B%2B-0ms-O(n)-35-lines-solution-with-detailed-explanation).\\nIt is simple to deal with cases in which there is no need to delete characters. For each cases, as long as we change enough characters, there is no need to worry about the type requirements of upper case, lowe case and digits. So taking the max of number of charaters to insert, number of characters to change to meet type requirements will sove the problem. The tricky part is when there is excess characters and we have to delete characters. If we have k (k > 20)characters, we must delete k-20 characters to meet the length requirements. If deletes are enough to cut any repetition, then we don\\'t need to worry about making changes to satisfy repetition requirement . We can just return the number of deletes plus number of changes to meet type requirements. However, if we are short on deletes, we must use them wisely to minimze changes made to satisfy repetition requirement. One observation is that changing a charater is really effective in disrupting repeating sequences. You only need x/3 changes(x is the length of repeating sequence) while deleting a character only works when you cut the sequence of 3 into 2.  Since we are short on deletes, we always want our delete to do something. Here I mean we want our delete makes x/3 < (x-1)/3 (c++ divide here). Before going to the algorithm, let\\'s consider a few cases first.\\n1. 11\\n2. 11**1**\\n3. 111**1**\\n4. 1111**1**\\n5. 11111**1**\\nFor case 1, we need to do nothing. For case 2, our delete effectively disrupt a repeating sequence. For case 3, though we delete a character, there is still 3 repeating characters. Similarly for case 4. For case 5, if we change the character at the thrid position, our delete also disrupt a repeating sequence. \\nWe should use our deletes on case 5 and 2 first, before we use them on case 3 and 4. To do so, the way I think is to use a priority with a very special comparater x has higer priority than y if x%3 < x%y. We can just push all repeating sequence onto the priority queue,  and then process the cases like 1 and 5 first. If the sequence after processing is still repeating, we push it back into the priority queue. After we\\'ve used up our deletes, we can process the rest repeating sequences the same way in case where there is no need to delete.\\n```\\nclass Solution {\\n   public:\\n    int strongPasswordChecker(string s) {\\n        int l = s.size();\\n        if (l == 0)\\n            return 6;\\n        if (l <= 20) {\\n            int total_changes = 0;\\n            int uppers = 0;\\n            int lowers = 0;\\n            int digits = 0;\\n            int i = 0, j = 0;\\n            while (i < l) {\\n                j = i;\\n                while (j < l && s[j] == s[i]) {\\n                    uppers += isupper(s[j]);\\n                    lowers += islower(s[j]);\\n                    digits += isdigit(s[j]);\\n                    j++;\\n                }\\n                int len = j - i;\\n                total_changes += len / 3;\\n                i = j;\\n            }\\n            int r = 3 - (!!uppers + !!lowers + !!digits);\\n            int inserts = l < 6 ? 6 - l : 0;\\n            return max({inserts, r, total_changes});\\n        } else {\\n            int total_changes = 0;\\n            int uppers = 0;\\n            int lowers = 0;\\n            int digits = 0;\\n            int deletes = l - 20;\\n            int i = 0, j = 0;\\n            auto comp = [](const int a, const int b)->bool{return a %3 > b%3;};\\n            priority_queue<int,vector<int>,decltype(comp)> pq(comp);\\n            while (i < l) {\\n                j = i;\\n                while (j < l && s[j] == s[i]) {\\n                    uppers += isupper(s[j]);\\n                    lowers += islower(s[j]);\\n                    digits += isdigit(s[j]);\\n                    j++;\\n                }\\n                int len = j - i;\\n                if (len > 2)\\n                    pq.push(len);\\n                i = j;\\n            }\\n            while(!pq.empty() && deletes){\\n                int change = pq.top();\\n                pq.pop();\\n                change--;\\n                deletes--;\\n                if(change > 2)\\n                    pq.push(change);\\n            }  \\n            while(!pq.empty()){\\n                int change = pq.top();\\n                pq.pop();\\n                total_changes += change/3;\\n            }\\n            int r = 3 - (!!uppers + !!lowers + !!digits);\\n            return max(r, total_changes) + l - 20;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public:\\n    int strongPasswordChecker(string s) {\\n        int l = s.size();\\n        if (l == 0)\\n            return 6;\\n        if (l <= 20) {\\n            int total_changes = 0;\\n            int uppers = 0;\\n            int lowers = 0;\\n            int digits = 0;\\n            int i = 0, j = 0;\\n            while (i < l) {\\n                j = i;\\n                while (j < l && s[j] == s[i]) {\\n                    uppers += isupper(s[j]);\\n                    lowers += islower(s[j]);\\n                    digits += isdigit(s[j]);\\n                    j++;\\n                }\\n                int len = j - i;\\n                total_changes += len / 3;\\n                i = j;\\n            }\\n            int r = 3 - (!!uppers + !!lowers + !!digits);\\n            int inserts = l < 6 ? 6 - l : 0;\\n            return max({inserts, r, total_changes});\\n        } else {\\n            int total_changes = 0;\\n            int uppers = 0;\\n            int lowers = 0;\\n            int digits = 0;\\n            int deletes = l - 20;\\n            int i = 0, j = 0;\\n            auto comp = [](const int a, const int b)->bool{return a %3 > b%3;};\\n            priority_queue<int,vector<int>,decltype(comp)> pq(comp);\\n            while (i < l) {\\n                j = i;\\n                while (j < l && s[j] == s[i]) {\\n                    uppers += isupper(s[j]);\\n                    lowers += islower(s[j]);\\n                    digits += isdigit(s[j]);\\n                    j++;\\n                }\\n                int len = j - i;\\n                if (len > 2)\\n                    pq.push(len);\\n                i = j;\\n            }\\n            while(!pq.empty() && deletes){\\n                int change = pq.top();\\n                pq.pop();\\n                change--;\\n                deletes--;\\n                if(change > 2)\\n                    pq.push(change);\\n            }  \\n            while(!pq.empty()){\\n                int change = pq.top();\\n                pq.pop();\\n                total_changes += change/3;\\n            }\\n            int r = 3 - (!!uppers + !!lowers + !!digits);\\n            return max(r, total_changes) + l - 20;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693496,
                "title": "simple-c-solution",
                "content": "```\\nint dp[50][22][2][2][2][65][65];    \\nclass Solution {\\npublic:\\n    // dp[0...i][j length][has_lower][has_upper][has_digit][last_char][last_to_last_char]\\n    bool isupper(char c) {\\n        return (c >= \\'A\\' && c <= \\'Z\\');\\n    }\\n    bool islower(char c) {\\n        return (c >= \\'a\\' && c <= \\'z\\');\\n    }\\n    bool isdigit(char c) {\\n        return (c >= \\'0\\' && c <= \\'9\\');\\n    }\\n    int getnum(char c) {\\n        if (c >= \\'a\\' && c <= \\'z\\') return c - \\'a\\';\\n        if (c >= \\'A\\' && c <= \\'Z\\') return 26 + c - \\'A\\';\\n        if (c >= \\'0\\' && c <= \\'9\\') return 52 + c - \\'0\\';\\n        return 64;\\n    }\\n    int dfs(const string& s, int pos, int taken, bool has_upper, bool has_lower, bool has_digit, int last_char, int last_to_last_char) {        \\n        if (taken > 20) return 1e9;\\n       \\n        if (pos == s.size()) {\\n            if (taken >= 6 && has_upper && has_lower && has_digit) return 0;\\n            if (taken < 6) {\\n              int res = 1 + dfs(s, pos, taken + 1, true, has_upper, has_digit, 63, 63);\\n              res = min(res, 1 + dfs(s, pos, taken + 1, has_lower, true, has_digit, 63, 63));\\n              return min(res, 1 + dfs(s, pos, taken + 1, has_lower, has_upper, true, 63, 63));\\n            }\\n            return 1e9;\\n        }\\n        int& res = dp[pos][taken][has_upper][has_lower][has_digit][last_char][last_to_last_char];\\n        if (res != -1) return res;\\n        res = 1e9;\\n        if (!(last_char == last_to_last_char && last_char == getnum(s[pos]))) {\\n            res = min(res, dfs(s, pos + 1, taken + 1, has_upper | isupper(s[pos]), has_lower | islower(s[pos]), has_digit | isdigit(s[pos]), getnum(s[pos]), last_char));\\n        }\\n        res = min(res, 1 + dfs(s, pos + 1, taken, has_upper, has_lower, has_digit, last_char, last_to_last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, true, has_lower, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, has_upper, true, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, has_upper, has_lower, true, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, true, has_lower, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, has_upper, true, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, has_upper, has_lower, true, 63, last_char));\\n        return res;\\n    }\\n    int strongPasswordChecker(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(s, 0, 0, false, false, false, 63, 63);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint dp[50][22][2][2][2][65][65];    \\nclass Solution {\\npublic:\\n    // dp[0...i][j length][has_lower][has_upper][has_digit][last_char][last_to_last_char]\\n    bool isupper(char c) {\\n        return (c >= \\'A\\' && c <= \\'Z\\');\\n    }\\n    bool islower(char c) {\\n        return (c >= \\'a\\' && c <= \\'z\\');\\n    }\\n    bool isdigit(char c) {\\n        return (c >= \\'0\\' && c <= \\'9\\');\\n    }\\n    int getnum(char c) {\\n        if (c >= \\'a\\' && c <= \\'z\\') return c - \\'a\\';\\n        if (c >= \\'A\\' && c <= \\'Z\\') return 26 + c - \\'A\\';\\n        if (c >= \\'0\\' && c <= \\'9\\') return 52 + c - \\'0\\';\\n        return 64;\\n    }\\n    int dfs(const string& s, int pos, int taken, bool has_upper, bool has_lower, bool has_digit, int last_char, int last_to_last_char) {        \\n        if (taken > 20) return 1e9;\\n       \\n        if (pos == s.size()) {\\n            if (taken >= 6 && has_upper && has_lower && has_digit) return 0;\\n            if (taken < 6) {\\n              int res = 1 + dfs(s, pos, taken + 1, true, has_upper, has_digit, 63, 63);\\n              res = min(res, 1 + dfs(s, pos, taken + 1, has_lower, true, has_digit, 63, 63));\\n              return min(res, 1 + dfs(s, pos, taken + 1, has_lower, has_upper, true, 63, 63));\\n            }\\n            return 1e9;\\n        }\\n        int& res = dp[pos][taken][has_upper][has_lower][has_digit][last_char][last_to_last_char];\\n        if (res != -1) return res;\\n        res = 1e9;\\n        if (!(last_char == last_to_last_char && last_char == getnum(s[pos]))) {\\n            res = min(res, dfs(s, pos + 1, taken + 1, has_upper | isupper(s[pos]), has_lower | islower(s[pos]), has_digit | isdigit(s[pos]), getnum(s[pos]), last_char));\\n        }\\n        res = min(res, 1 + dfs(s, pos + 1, taken, has_upper, has_lower, has_digit, last_char, last_to_last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, true, has_lower, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, has_upper, true, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos + 1, taken + 1, has_upper, has_lower, true, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, true, has_lower, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, has_upper, true, has_digit, 63, last_char));\\n        res = min(res, 1 + dfs(s, pos, taken + 1, has_upper, has_lower, true, 63, last_char));\\n        return res;\\n    }\\n    int strongPasswordChecker(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(s, 0, 0, false, false, false, 63, 63);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652702,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int has_lower = 0, has_upper = 0, has_digit = 0;\\n    int rep = 0;\\n    vector<int>repeat;\\n    int rep_1 = 0, rep_2 = 0;\\n    void check(string s) {\\n        int cnt = 0;\\n        char c = \\'@\\';\\n        for(int i = 0; i < s.size(); i++) {\\n            if(isupper(s[i])) {\\n                has_upper = 1;\\n            }\\n            if(islower(s[i])) {\\n                has_lower = 1;\\n            }\\n            if(isdigit(s[i])) {\\n                has_digit = 1;\\n            }\\n            if(s[i] == c) {\\n                cnt++;\\n            } else {\\n                if(cnt >= 3) {\\n                    repeat.push_back(cnt);\\n                }\\n                c = s[i];\\n                cnt = 1;\\n            }\\n        }\\n        if(cnt >= 3) {\\n            repeat.push_back(cnt);\\n        }\\n        for(auto x: repeat) {\\n            if(x % 3 == 0) { \\n                rep_1 += 1; \\n            }\\n            if(x % 3 == 1) {\\n                rep_2 += 1;\\n            }\\n            rep += x / 3;\\n        }\\n    }\\n    \\n    int strongPasswordChecker(string s) {\\n        if(s.size() == 0) {\\n            return 6;\\n        }\\n        check(s);\\n        int letter = 3 - has_upper - has_lower - has_digit;\\n        if(s.size() < 6) {\\n            return max(6 - (int)s.size(), letter);\\n        }\\n        if(s.size() <= 20 && s.size() >= 6) {\\n            return max(rep, letter);\\n        }\\n        if(s.size() > 20) {\\n            int remain = s.size() - 20;\\n            if(remain <= rep_1) {\\n                rep -= remain;\\n            } else if(remain - rep_1 <= 2 * rep_2) {\\n                rep -= rep_1 + (remain - rep_1) / 2;\\n            } else {\\n                rep -= rep_1 + rep_2 + (remain - rep_1 - 2 * rep_2) / 3;\\n            }\\n            return remain + max(rep, letter);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int has_lower = 0, has_upper = 0, has_digit = 0;\\n    int rep = 0;\\n    vector<int>repeat;\\n    int rep_1 = 0, rep_2 = 0;\\n    void check(string s) {\\n        int cnt = 0;\\n        char c = \\'@\\';\\n        for(int i = 0; i < s.size(); i++) {\\n            if(isupper(s[i])) {\\n                has_upper = 1;\\n            }\\n            if(islower(s[i])) {\\n                has_lower = 1;\\n            }\\n            if(isdigit(s[i])) {\\n                has_digit = 1;\\n            }\\n            if(s[i] == c) {\\n                cnt++;\\n            } else {\\n                if(cnt >= 3) {\\n                    repeat.push_back(cnt);\\n                }\\n                c = s[i];\\n                cnt = 1;\\n            }\\n        }\\n        if(cnt >= 3) {\\n            repeat.push_back(cnt);\\n        }\\n        for(auto x: repeat) {\\n            if(x % 3 == 0) { \\n                rep_1 += 1; \\n            }\\n            if(x % 3 == 1) {\\n                rep_2 += 1;\\n            }\\n            rep += x / 3;\\n        }\\n    }\\n    \\n    int strongPasswordChecker(string s) {\\n        if(s.size() == 0) {\\n            return 6;\\n        }\\n        check(s);\\n        int letter = 3 - has_upper - has_lower - has_digit;\\n        if(s.size() < 6) {\\n            return max(6 - (int)s.size(), letter);\\n        }\\n        if(s.size() <= 20 && s.size() >= 6) {\\n            return max(rep, letter);\\n        }\\n        if(s.size() > 20) {\\n            int remain = s.size() - 20;\\n            if(remain <= rep_1) {\\n                rep -= remain;\\n            } else if(remain - rep_1 <= 2 * rep_2) {\\n                rep -= rep_1 + (remain - rep_1) / 2;\\n            } else {\\n                rep -= rep_1 + rep_2 + (remain - rep_1 - 2 * rep_2) / 3;\\n            }\\n            return remain + max(rep, letter);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328750,
                "title": "java-dfs-solution-beat-100",
                "content": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        if(s.length() < 5) return 6 - s.length();\\n        if(s.length() == 5) return isAllSameCharacter(s) ? 2 : 1;\\n        \\n        int minDeletion = Math.max(0, s.length() - 20);\\n        int minReplace = calMinReplace(s);\\n        \\n        int[] res = new int[] {Integer.MAX_VALUE};\\n        \\n        helper(0, 0, 0, minReplace, minDeletion, s, res);\\n        \\n        return res[0];\\n    }\\n    \\n    private void helper(int start, int replace, int delete, int minReplace, int minDeletion, String s, int[] res) {\\n        int next = findNextInvalid(start, s);   \\n\\n        if(next == s.length()) {\\n            \\n            res[0] = Math.min(Math.max(replace, minReplace) + minDeletion, res[0]);\\n            return;\\n        }\\n        // replace is always better than deletion, so when the minDeletion met, we only do replace\\n        if(delete < minDeletion) {\\n            // delete\\n            helper(next - 1, replace, delete + 1, minReplace, minDeletion, s, res);\\n        }     \\n        // replace\\n        helper(next + 1, replace + 1, delete, minReplace, minDeletion, s, res);\\n    }\\n    \\n    private int findNextInvalid(int start, String s) {\\n        if(start >= s.length()) return s.length();\\n        \\n        char c = s.charAt(start);\\n        \\n        for(int count = 0, i = start; i < s.length(); i++) {\\n            if(c == s.charAt(i)) {\\n                if(++count == 3) return i;\\n            }  else {\\n                count = 1;\\n                c = s.charAt(i);\\n            }\\n        }\\n        \\n        return s.length();\\n    }\\n    \\n    \\n    private int calMinReplace(String s) {\\n        boolean hasUpperCase = false, hasLowerCase = false, hasDigit = false;\\n        int res = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c >= \\'A\\' && c <= \\'Z\\') hasUpperCase = true;\\n            if(c >= \\'a\\' && c <= \\'z\\') hasLowerCase = true;\\n            if(c >= \\'0\\' && c <= \\'9\\') hasDigit = true;\\n        }\\n        \\n        res += hasUpperCase ? 0 : 1;\\n        res += hasLowerCase ? 0 : 1;\\n        res += hasDigit ? 0 : 1;\\n        \\n        return res;\\n    }\\n    \\n    private boolean isAllSameCharacter(String s) {\\n        char c = s.charAt(0);\\n        for(int i = 1; i < s.length(); i++) {\\n            if(s.charAt(i) != c) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n        if(s.length() < 5) return 6 - s.length();\\n        if(s.length() == 5) return isAllSameCharacter(s) ? 2 : 1;\\n        \\n        int minDeletion = Math.max(0, s.length() - 20);\\n        int minReplace = calMinReplace(s);\\n        \\n        int[] res = new int[] {Integer.MAX_VALUE};\\n        \\n        helper(0, 0, 0, minReplace, minDeletion, s, res);\\n        \\n        return res[0];\\n    }\\n    \\n    private void helper(int start, int replace, int delete, int minReplace, int minDeletion, String s, int[] res) {\\n        int next = findNextInvalid(start, s);   \\n\\n        if(next == s.length()) {\\n            \\n            res[0] = Math.min(Math.max(replace, minReplace) + minDeletion, res[0]);\\n            return;\\n        }\\n        // replace is always better than deletion, so when the minDeletion met, we only do replace\\n        if(delete < minDeletion) {\\n            // delete\\n            helper(next - 1, replace, delete + 1, minReplace, minDeletion, s, res);\\n        }     \\n        // replace\\n        helper(next + 1, replace + 1, delete, minReplace, minDeletion, s, res);\\n    }\\n    \\n    private int findNextInvalid(int start, String s) {\\n        if(start >= s.length()) return s.length();\\n        \\n        char c = s.charAt(start);\\n        \\n        for(int count = 0, i = start; i < s.length(); i++) {\\n            if(c == s.charAt(i)) {\\n                if(++count == 3) return i;\\n            }  else {\\n                count = 1;\\n                c = s.charAt(i);\\n            }\\n        }\\n        \\n        return s.length();\\n    }\\n    \\n    \\n    private int calMinReplace(String s) {\\n        boolean hasUpperCase = false, hasLowerCase = false, hasDigit = false;\\n        int res = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c >= \\'A\\' && c <= \\'Z\\') hasUpperCase = true;\\n            if(c >= \\'a\\' && c <= \\'z\\') hasLowerCase = true;\\n            if(c >= \\'0\\' && c <= \\'9\\') hasDigit = true;\\n        }\\n        \\n        res += hasUpperCase ? 0 : 1;\\n        res += hasLowerCase ? 0 : 1;\\n        res += hasDigit ? 0 : 1;\\n        \\n        return res;\\n    }\\n    \\n    private boolean isAllSameCharacter(String s) {\\n        char c = s.charAt(0);\\n        for(int i = 1; i < s.length(); i++) {\\n            if(s.charAt(i) != c) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166464,
                "title": "simple-python-solution-with-explanations",
                "content": "Cases when len(s)>20:\\n* e.g. there\\'s a segment **aaaaaaa** inside (repeat length % 3==1). Originally, we will consider change 7/3=2 characters to make it a legal segment, like **aabaaba**. But now can we delete some characters instead since delete operations are already unavoidable. Actually every 2 deletions work the same as 1 replacement. After delete 2 characters (you can assume the last 2), the segment becomes **aaaaa**, and only one more replacement needed (**aabaa**).\\n* Similarly, for **repeat length % 3==0**, one deletion works the same as one replacement.\\n* For  **repeat length % 3==2**, three deletions can reduce a replacement operation.\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n\\n        def repeat(s):\\n            count = 1\\n            p0 = p1 = p2 = 0\\n            for i in xrange(1, len(s)):\\n                if s[i]==s[i-1]: count += 1\\n                else:\\n                    if count>=3: \\n                        p0 += count/3\\n                        if count%3==0: p1 += 1\\n                        if count%3==1: p2 += 1\\n                    count = 1\\n            if count>=3: \\n                p0 += count/3\\n                if count%3==0: p1 += 1\\n                if count%3==1: p2 += 1\\n            return [p0,p1,p2]\\n        \\n        p0,p1,p2 = repeat(s)\\n        flag_lowc = False\\n        flag_upc = False\\n        flag_d = False\\n        for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n            if c in s: flag_lowc = True\\n        for c in \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\':\\n            if c in s: flag_upc = True\\n        for c in \\'0123456789\\':\\n            if c in s: flag_d = True\\n        lack = 3 - (flag_lowc + flag_upc + flag_d)\\n    \\n        if len(s)<6:\\n            delta = 6-len(s)\\n            return max(p0, lack, delta)\\n        elif len(s)>20:\\n            delta = len(s)-20\\n            p0 -= min(delta, p1)\\n            p0 -= min(max(delta - p1, 0), p2*2) / 2\\n            p0 -= max(delta - p1 - 2*p2, 0) / 3\\n            return delta+max(p0, lack)\\n        else:\\n            return max(p0, lack)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n\\n        def repeat(s):\\n            count = 1\\n            p0 = p1 = p2 = 0\\n            for i in xrange(1, len(s)):\\n                if s[i]==s[i-1]: count += 1\\n                else:\\n                    if count>=3: \\n                        p0 += count/3\\n                        if count%3==0: p1 += 1\\n                        if count%3==1: p2 += 1\\n                    count = 1\\n            if count>=3: \\n                p0 += count/3\\n                if count%3==0: p1 += 1\\n                if count%3==1: p2 += 1\\n            return [p0,p1,p2]\\n        \\n        p0,p1,p2 = repeat(s)\\n        flag_lowc = False\\n        flag_upc = False\\n        flag_d = False\\n        for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n            if c in s: flag_lowc = True\\n        for c in \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\':\\n            if c in s: flag_upc = True\\n        for c in \\'0123456789\\':\\n            if c in s: flag_d = True\\n        lack = 3 - (flag_lowc + flag_upc + flag_d)\\n    \\n        if len(s)<6:\\n            delta = 6-len(s)\\n            return max(p0, lack, delta)\\n        elif len(s)>20:\\n            delta = len(s)-20\\n            p0 -= min(delta, p1)\\n            p0 -= min(max(delta - p1, 0), p2*2) / 2\\n            p0 -= max(delta - p1 - 2*p2, 0) / 3\\n            return delta+max(p0, lack)\\n        else:\\n            return max(p0, lack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91019,
                "title": "4ms-commented-java-solution",
                "content": "This solution conceptualizes `insertions`, `deletions`, `breaks`, `additions`, and `changes`.\\n\\nAn `insertion` is when a character must be inserted, which only occurs when the given password is under `6` character long.  \\nA `deletion` is when a character must be deleted, which only occurs when the given password is over `20` characters long.\\n\\nA `break` is when a character must be inserted or replaced in order to meet the sequence-length requirements.  Note that if our `deletions` are positive, we can use them to reduce the number of `breaks` we might need, before we have to do any character replacement.\\nAn `addition` is when a character must be inserted or replaced in order to meet the alphanumeric requirements.\\n\\nA `change` is the insertion, deletion, or replacement of any single character.\\n\\nHaving calculated how many `insertions`, `deletions`, `breaks`, and `additions` we need, we consolidate these to arrive at the minimum number of `changes`.\\n\\nThis code is long, but hopefully someone finds it useful:\\n```\\npublic class Solution {\\n    // The given String\\n    String s;\\n        \\n    // The number of additions which are required\\n    int numAdditions;\\n    \\n    // The number of deletions which are required\\n    int numDeletions;\\n    \\n    // The sequences we encounter\\n    int[] seq;\\n    \\n    /**\\n     * Given a String s, the candidate password, returns the minimum number\\n     * of single-action changes required for that password to be \"strong\".\\n     * \\n     * In order to be \"strong,\" a password must:\\n     * (1) be between 6 and 20 characters in length, inclusive,\\n     * (2) contain at least one lowercase letter,\\n     * (3) contain at least one uppercase letter.\\n     * (4) contain at least one number.\\n     * (5) not contain a sequence of 3 or more repeated characters\\n     * \\n     * The possible single-action changes are:\\n     * (a) Delete a character,\\n     * (b) Insert a character,\\n     * (c) Replace a character with another character.\\n     * \\n     * Ex. \"abc12\" -> 1 since the password is missing one character, and that\\n     *      character can be an uppercase letter.\\n     * \\n     * Ex. \"aaabbb\" -> 2 since we can change the middle 'a' and 'b' to 'H' and '1'.\\n     * \\n     * Ex. \"Aa1Aa1Aa1Aa1Aa1Aa1zzAa1Aa1Aa1Aa1Aa1Aa1zzAa1Aa1Aa1Aa1Aa1Aa1zz\" ->\\n     *      40, since the password meets the strong criteria except that it is\\n     *      60 characters long, so we must delete 40 characters.\\n     * \\n     * Ex. \"$$$$$$\" -> 3, since it's missing lowercase, uppercase, and a number,\\n     *      and we can distribute those replacements to break the sequence of 6.\\n     * \\n     * @param s the given string\\n     * @return the minimum number of changes to have a strong password\\n     */\\n    public int strongPasswordChecker(String s) {\\n        if (s == null || s.equals(\"\")) return 6;\\n        this.s = s;\\n        \\n        // Initialize instance variables\\n        numAdditions = 0;\\n        numDeletions = 0;\\n        seq = new int[s.length() + 1];\\n        \\n        // Count \"additions\" and frequency of sequences encountered\\n        readString();\\n                \\n        // Spend deletions to minimize sequence breaks needed, if possible\\n        if (s.length() > 20) spendDeletions();\\n        \\n        // Tally number of sequence breaks needed\\n        int numBreaks = 0;\\n        for (int i = 3; i < seq.length; i++) {\\n            numBreaks += seq[i] * (i / 3);\\n        }\\n        \\n        // Consolidate breaks and additions into changes\\n        int numChanges = Math.max(numBreaks, numAdditions);\\n        \\n        // For too-short input, consolidate insertions and changes.\\n        if (s.length() < 6) {\\n            int numInsertions = 6 - s.length();\\n            numChanges = Math.max(numInsertions, numChanges);\\n        }\\n        \\n        // For too-long input, add the number of breaks and additions needed\\n        // to the number of deletions required.\\n        else if (s.length() > 20) {\\n            numChanges = numDeletions + numChanges;\\n        }\\n        \\n        return numChanges;\\n    }\\n    \\n    /**\\n     * Processes the given string, storing whether the String meets the\\n     * alphanumeric requirements, and storing the sequences of repeated\\n     * characters, if 3 or longer.\\n     */\\n    private void readString() {\\n        boolean needsNumber = true;\\n        boolean needsUpper = true;\\n        boolean needsLower = true;\\n        \\n        // The current sequence length\\n        int c = 1;\\n        char tmp = s.charAt(0);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i > 0) {\\n                // The sequence continues\\n                if (s.charAt(i) == tmp) c++;\\n                \\n                // The sequence has ended\\n                else {\\n                    if (c > 2) seq[c]++;\\n                    c = 1;\\n                    tmp = s.charAt(i);\\n                }\\n            }\\n            if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') needsLower = false;\\n            else if (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z') needsUpper = false;\\n            else if (s.charAt(i) >= '0' && s.charAt(i) <= '9') needsNumber = false;\\n        }\\n        \\n        // Handle long sequences which continue to the end the given String\\n        if (c > 2) seq[c]++;\\n        \\n        if (needsLower) numAdditions++;\\n        if (needsUpper) numAdditions++;\\n        if (needsNumber) numAdditions++;\\n    }\\n    \\n    /**\\n     * Spends deletions to minimize the number of sequence breaks.\\n     * \\n     * Beginning at the last index of seq which is a multiple of three,\\n     * count backwards through seq by threes to spend all deletions.\\n     * \\n     * We want to start with multiples of three since we can avoid adding\\n     * a \"break\" by just deleting a single character at these indices.\\n     * In other words, this is the best use of our deletions.\\n     * \\n     * Then, we start with the last index of seq which is one more than a\\n     * multiple of three, since we can avoid adding a \"break\" by just\\n     * deleting two characters at these indices.\\n     * This is the next-best use of our deletions.\\n     * \\n     * Finally, we start with the last index of seq which is two more than a\\n     * multiple of three, since we can avoid adding a \"break\" by just\\n     * deleting three characters at these indices.\\n     * This is the most costly way to spend our deletions.\\n     * \\n     * If we ever can't afford the full deletion at a given index, we spend\\n     * our remaining deletions at that index for a single sequence.\\n     * \\n     * Counting backward allows us to spend all of our remaining deletions\\n     * indiscriminately, like where all sequences cost 3 deletions to remove\\n     * a single break.\\n     */\\n    private void spendDeletions() {\\n        numDeletions = s.length() - 20;\\n        int ndtemp = numDeletions;\\n        int lastThreeMult = 3 * ((seq.length - 1) / 3);\\n        for (int i = lastThreeMult; i < lastThreeMult + 3; i++) {\\n            // Handle falling off the back of seq\\n            int j = (i >= seq.length) ? i - 3: i;\\n            while (j > 2 && ndtemp > 0) {\\n                if (seq[j] > 0) {\\n                    \\n                    // We have one fewer sequence of length j\\n                    seq[j]--;\\n                    \\n                    /**\\n                     * Determine whether we have enough deletions remaining\\n                     * in order to reduce the number of needed sequence breaks\\n                     * by 1.\\n                     * \\n                     * If we don't, just spend all remaining deletions.\\n                     * It won't affect our final \"changes\" tally.\\n                     */\\n                    int d = Math.min((i % 3) + 1, ndtemp);\\n                    \\n                    // We have one more sequence of length (j-d)\\n                    seq[j-d]++;\\n                    \\n                    // Update our spent deletions\\n                    ndtemp -= d;\\n                }\\n                else j -= 3;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // The given String\\n    String s;\\n        \\n    // The number of additions which are required\\n    int numAdditions;\\n    \\n    // The number of deletions which are required\\n    int numDeletions;\\n    \\n    // The sequences we encounter\\n    int[] seq;\\n    \\n    /**\\n     * Given a String s, the candidate password, returns the minimum number\\n     * of single-action changes required for that password to be \"strong\".\\n     * \\n     * In order to be \"strong,\" a password must:\\n     * (1) be between 6 and 20 characters in length, inclusive,\\n     * (2) contain at least one lowercase letter,\\n     * (3) contain at least one uppercase letter.\\n     * (4) contain at least one number.\\n     * (5) not contain a sequence of 3 or more repeated characters\\n     * \\n     * The possible single-action changes are:\\n     * (a) Delete a character,\\n     * (b) Insert a character,\\n     * (c) Replace a character with another character.\\n     * \\n     * Ex. \"abc12\" -> 1 since the password is missing one character, and that\\n     *      character can be an uppercase letter.\\n     * \\n     * Ex. \"aaabbb\" -> 2 since we can change the middle 'a' and 'b' to 'H' and '1'.\\n     * \\n     * Ex. \"Aa1Aa1Aa1Aa1Aa1Aa1zzAa1Aa1Aa1Aa1Aa1Aa1zzAa1Aa1Aa1Aa1Aa1Aa1zz\" ->\\n     *      40, since the password meets the strong criteria except that it is\\n     *      60 characters long, so we must delete 40 characters.\\n     * \\n     * Ex. \"$$$$$$\" -> 3, since it's missing lowercase, uppercase, and a number,\\n     *      and we can distribute those replacements to break the sequence of 6.\\n     * \\n     * @param s the given string\\n     * @return the minimum number of changes to have a strong password\\n     */\\n    public int strongPasswordChecker(String s) {\\n        if (s == null || s.equals(\"\")) return 6;\\n        this.s = s;\\n        \\n        // Initialize instance variables\\n        numAdditions = 0;\\n        numDeletions = 0;\\n        seq = new int[s.length() + 1];\\n        \\n        // Count \"additions\" and frequency of sequences encountered\\n        readString();\\n                \\n        // Spend deletions to minimize sequence breaks needed, if possible\\n        if (s.length() > 20) spendDeletions();\\n        \\n        // Tally number of sequence breaks needed\\n        int numBreaks = 0;\\n        for (int i = 3; i < seq.length; i++) {\\n            numBreaks += seq[i] * (i / 3);\\n        }\\n        \\n        // Consolidate breaks and additions into changes\\n        int numChanges = Math.max(numBreaks, numAdditions);\\n        \\n        // For too-short input, consolidate insertions and changes.\\n        if (s.length() < 6) {\\n            int numInsertions = 6 - s.length();\\n            numChanges = Math.max(numInsertions, numChanges);\\n        }\\n        \\n        // For too-long input, add the number of breaks and additions needed\\n        // to the number of deletions required.\\n        else if (s.length() > 20) {\\n            numChanges = numDeletions + numChanges;\\n        }\\n        \\n        return numChanges;\\n    }\\n    \\n    /**\\n     * Processes the given string, storing whether the String meets the\\n     * alphanumeric requirements, and storing the sequences of repeated\\n     * characters, if 3 or longer.\\n     */\\n    private void readString() {\\n        boolean needsNumber = true;\\n        boolean needsUpper = true;\\n        boolean needsLower = true;\\n        \\n        // The current sequence length\\n        int c = 1;\\n        char tmp = s.charAt(0);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i > 0) {\\n                // The sequence continues\\n                if (s.charAt(i) == tmp) c++;\\n                \\n                // The sequence has ended\\n                else {\\n                    if (c > 2) seq[c]++;\\n                    c = 1;\\n                    tmp = s.charAt(i);\\n                }\\n            }\\n            if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') needsLower = false;\\n            else if (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z') needsUpper = false;\\n            else if (s.charAt(i) >= '0' && s.charAt(i) <= '9') needsNumber = false;\\n        }\\n        \\n        // Handle long sequences which continue to the end the given String\\n        if (c > 2) seq[c]++;\\n        \\n        if (needsLower) numAdditions++;\\n        if (needsUpper) numAdditions++;\\n        if (needsNumber) numAdditions++;\\n    }\\n    \\n    /**\\n     * Spends deletions to minimize the number of sequence breaks.\\n     * \\n     * Beginning at the last index of seq which is a multiple of three,\\n     * count backwards through seq by threes to spend all deletions.\\n     * \\n     * We want to start with multiples of three since we can avoid adding\\n     * a \"break\" by just deleting a single character at these indices.\\n     * In other words, this is the best use of our deletions.\\n     * \\n     * Then, we start with the last index of seq which is one more than a\\n     * multiple of three, since we can avoid adding a \"break\" by just\\n     * deleting two characters at these indices.\\n     * This is the next-best use of our deletions.\\n     * \\n     * Finally, we start with the last index of seq which is two more than a\\n     * multiple of three, since we can avoid adding a \"break\" by just\\n     * deleting three characters at these indices.\\n     * This is the most costly way to spend our deletions.\\n     * \\n     * If we ever can't afford the full deletion at a given index, we spend\\n     * our remaining deletions at that index for a single sequence.\\n     * \\n     * Counting backward allows us to spend all of our remaining deletions\\n     * indiscriminately, like where all sequences cost 3 deletions to remove\\n     * a single break.\\n     */\\n    private void spendDeletions() {\\n        numDeletions = s.length() - 20;\\n        int ndtemp = numDeletions;\\n        int lastThreeMult = 3 * ((seq.length - 1) / 3);\\n        for (int i = lastThreeMult; i < lastThreeMult + 3; i++) {\\n            // Handle falling off the back of seq\\n            int j = (i >= seq.length) ? i - 3: i;\\n            while (j > 2 && ndtemp > 0) {\\n                if (seq[j] > 0) {\\n                    \\n                    // We have one fewer sequence of length j\\n                    seq[j]--;\\n                    \\n                    /**\\n                     * Determine whether we have enough deletions remaining\\n                     * in order to reduce the number of needed sequence breaks\\n                     * by 1.\\n                     * \\n                     * If we don't, just spend all remaining deletions.\\n                     * It won't affect our final \"changes\" tally.\\n                     */\\n                    int d = Math.min((i % 3) + 1, ndtemp);\\n                    \\n                    // We have one more sequence of length (j-d)\\n                    seq[j-d]++;\\n                    \\n                    // Update our spent deletions\\n                    ndtemp -= d;\\n                }\\n                else j -= 3;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553362,
                "title": "kotlin-not-copied-ported-easy-my-100th-leetcode-solve",
                "content": "You found this question, probably by sorting questions with accept rate. Yes, this being the least accept rate old question, I decided to give it a try in my primary programming language, Kotlin.\\n\\nThis is also the 100th questions I\\'ve solved on Leetcode, and I\\'m so glad I did this, this is such a fun one!\\n\\n(NOT PORTED DIRECTLY FROM ANOTHER LANGUAGE/SOLUTION)\\n\\nIt may not be the fastest tho, but hey, at least it got accepted and works!\\n\\n# Tips and tricks\\n1. It\\'s easier to debug in your IDE, you don\\'t really want to debug by keep running & submitting. You can either write testcases or use some hacky stuff to extract all the questions, and create assertions. I\\'ll probably create a post on that in ther future explaining the internel leetcode stuff\\n\\n\\n# Approach\\n1. Check if it contains digits, lowercase and uppercase\\n2. Count repeated chars\\n3. Check how many char type requirements it\\'s missing (Digits/Lower/Upper)\\n4. If password is shorter than 3, missing requirements count can be met by adding 6 - n extra letters (and reach 6)\\n5. If password is in range of (`4 .. 5`/`4 until 6`), it will consider the requirements count and calculate the operations count\\n6. If it\\'s 6 or longer, it will do the following things:\\n\\n- Remove repeatings to make it at most 20 chars\\n  - Using an medium-level algorithm (Will mention later) to decide what to remove\\n- Remove repeatings\\n  - We can think of it as splitting strings by editing the middle char\\n  - So `aaaaaa` will become `aa0aa0` or some sort\\n  - In other words, if it\\'s repeated `n` times at this point, we do `n / 3` char edits operation\\n  - We store edited chars count for next step\\'s use\\n- Check requirements\\n  - If we have edited more than 3 chars, we can meet the requirements by changing what those chars are\\n  - If we have edited 0 ~ 2 chars, then we may need extra edits to make it meets the requirements\\n\\n\\nFor the algorithm I mentioned for `Remove repeatings to make it at most 20 chars` step:\\n - Let\\'s say `n` is chars we need to edit to not repeat over 3 times\\n - We implement a function that uses minimal steps to reduce the `n`\\n\\nHere\\'s an example (Not an example of \"repeatings\", but the algorithm input and output):\\n```kt\\n  63927897 // Let\\'s say we start with this\\n- 11100010 // First, we check if it\\'s possible to reduce n by doing only 1 operation\\n           // (num % 3 == 0)\\n= 52827887 // We are now left with this\\n- 00002002 // We check if it\\'s possible to reduce n by doing only 2 operations\\n           // (num % 3 == 1)\\n= 52825885 // We are now left with this\\n- 30303333 // Same here, except it\\'s three\\n= 22522552 // We are not going for 4 this time, we stay in 3\\n- 00300330 // same here, we substract 3 from numbers that (num % 3 == 2)\\n= 22222222\\n```\\n\\nThe final code is\\n```kt\\nfun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n    var operationsLeft = operationsLimitation\\n    var currentSubValue = 1\\n    var doneOperation: Boolean\\n    while (operationsLeft > 0) {\\n        doneOperation = false\\n        for ((i, num) in nums.withIndex()) {\\n            if (num >= 3) {\\n               if (num % 3 == currentSubValue - 1) {\\n                    doneOperation = true\\n                    var sub = currentSubValue\\n                    while (operationsLeft > 0 && sub > 0) {\\n                        operationsLeft--\\n                        nums[i] -= 1\\n                        sub--\\n                    }\\n                }\\n            }\\n            if (operationsLeft == 0) return\\n        }\\n        if (currentSubValue == 3 && !doneOperation) break\\n        if (currentSubValue != 3) currentSubValue++\\n    }\\n\\n}\\n```\\n\\n(Please take it easy on me lol I\\'m bad at DSA)\\n\\n\\n# Final Code\\n```kt\\nclass Solution {\\n\\n    fun strongPasswordChecker(password: String): Int {\\n        var operations = 0\\n        var lower = 0\\n        var upper = 0\\n        var digits = 0\\n\\n        val repeating = IntArray(password.length)\\n\\n        var currentCheckIndex = 0\\n        while (currentCheckIndex < password.length) {\\n            val targetCheckIndex = currentCheckIndex // For later repeating check use\\n            val targetChar = password[currentCheckIndex]\\n\\n            while (currentCheckIndex < password.length && password[currentCheckIndex] == targetChar) {\\n                repeating[targetCheckIndex]++\\n                currentCheckIndex++\\n            }\\n        }\\n        println(\"Repeating: ${repeating.joinToString(\", \")}\")\\n        for (targetChar in password) {\\n            if (targetChar.isUpperCase()) upper+= 1\\n            if (targetChar.isLowerCase()) lower+= 1\\n            if (targetChar.isDigit()) digits += 1\\n        }\\n        val charTypeRequirementMetCount = lower.coerceAtMost(1) + upper.coerceAtMost(1) + digits.coerceAtMost(1)\\n        val missingRequirements = 3 - charTypeRequirementMetCount\\n\\n        if (password.length <= 3) { // If length is less than 3, it will be able to fix the missing requirements no matter what\\n            return 6 - password.length\\n        } else if (password.length < 6) { // If the length is 4, 5, or 6, it will be maximum value of insertion count and missing requirements count\\n            // We don\\'t need to worry about repeating chars since we can easily fix it by inserting char in a different location\\n            val insertionCount = 6 - password.length\\n            return maxOf(insertionCount, missingRequirements)\\n        } else {\\n            println(\"Lowercase: $lower\")\\n            println(\"Uppercase: $upper\")\\n            println(\"Digits: $digits\")\\n\\n            var extraLength = password.length - 20\\n\\n            if (extraLength > 0) {\\n                findMinimizedSumOfDivision(extraLength, repeating)\\n                operations += extraLength\\n            }\\n\\n            println(\"After operation: \" + repeating.joinToString(\", \"))\\n\\n            // After reducing the length, we want to now replace all the repeating stuff.\\n            // Replaced \"random char amount\" will be stored inside a variable (For later use)\\n            var modifiedCharAmount = 0\\n            for ((index, i) in repeating.withIndex()) {\\n                if (i >= 3) {\\n                    operations += i / 3\\n                    modifiedCharAmount += i / 3\\n                    println(\"Modified ${i / 3} char(s) to eliminate repeating chars\")\\n                }\\n            }\\n\\n            // At this point, \"repeating\" is trashed as it\\'s in-accurate, and we don\\'t need it in our last bit of code\\n\\n            // Now we use the \"random char amount\" to decide if we have to do extra patch for char type requirements\\n            // If we don\\'t need those (AKA we added enough random chars that will just fit those requirements), we ignore them\\n            // Otherwise, we add (requirements - random char amount) to operations count\\n\\n            println(\"We are missing $missingRequirements requirements ($operations)\")\\n            if (modifiedCharAmount < missingRequirements) {\\n                operations += (missingRequirements - modifiedCharAmount)\\n            }\\n\\n        }\\n\\n        return operations\\n    }\\n\\n\\n    //   63927897\\n    // - 11100010\\n    //   52827887\\n    // - 00002002\\n    //   52825885\\n    // - 30303333\\n    // - 22522552\\n    // - 00300330\\n=\\n    fun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n        var operationsLeft = operationsLimitation\\n        var currentSubValue = 1\\n        var doneOperation: Boolean\\n        while (operationsLeft > 0) {\\n            doneOperation = false\\n            for ((i, num) in nums.withIndex()) {\\n                if (num >= 3) {\\n                   if (num % 3 == currentSubValue - 1) {\\n                        doneOperation = true\\n                        var sub = currentSubValue\\n                        while (operationsLeft > 0 && sub > 0) {\\n                            operationsLeft--\\n                            nums[i] -= 1\\n                            sub--\\n                        }\\n                    }\\n                }\\n                if (operationsLeft == 0) return\\n            }\\n            if (currentSubValue == 3 && !doneOperation) break\\n            if (currentSubValue != 3) currentSubValue++\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kt\\n  63927897 // Let\\'s say we start with this\\n- 11100010 // First, we check if it\\'s possible to reduce n by doing only 1 operation\\n           // (num % 3 == 0)\\n= 52827887 // We are now left with this\\n- 00002002 // We check if it\\'s possible to reduce n by doing only 2 operations\\n           // (num % 3 == 1)\\n= 52825885 // We are now left with this\\n- 30303333 // Same here, except it\\'s three\\n= 22522552 // We are not going for 4 this time, we stay in 3\\n- 00300330 // same here, we substract 3 from numbers that (num % 3 == 2)\\n= 22222222\\n```\n```kt\\nfun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n    var operationsLeft = operationsLimitation\\n    var currentSubValue = 1\\n    var doneOperation: Boolean\\n    while (operationsLeft > 0) {\\n        doneOperation = false\\n        for ((i, num) in nums.withIndex()) {\\n            if (num >= 3) {\\n               if (num % 3 == currentSubValue - 1) {\\n                    doneOperation = true\\n                    var sub = currentSubValue\\n                    while (operationsLeft > 0 && sub > 0) {\\n                        operationsLeft--\\n                        nums[i] -= 1\\n                        sub--\\n                    }\\n                }\\n            }\\n            if (operationsLeft == 0) return\\n        }\\n        if (currentSubValue == 3 && !doneOperation) break\\n        if (currentSubValue != 3) currentSubValue++\\n    }\\n\\n}\\n```\n```kt\\nclass Solution {\\n\\n    fun strongPasswordChecker(password: String): Int {\\n        var operations = 0\\n        var lower = 0\\n        var upper = 0\\n        var digits = 0\\n\\n        val repeating = IntArray(password.length)\\n\\n        var currentCheckIndex = 0\\n        while (currentCheckIndex < password.length) {\\n            val targetCheckIndex = currentCheckIndex // For later repeating check use\\n            val targetChar = password[currentCheckIndex]\\n\\n            while (currentCheckIndex < password.length && password[currentCheckIndex] == targetChar) {\\n                repeating[targetCheckIndex]++\\n                currentCheckIndex++\\n            }\\n        }\\n        println(\"Repeating: ${repeating.joinToString(\", \")}\")\\n        for (targetChar in password) {\\n            if (targetChar.isUpperCase()) upper+= 1\\n            if (targetChar.isLowerCase()) lower+= 1\\n            if (targetChar.isDigit()) digits += 1\\n        }\\n        val charTypeRequirementMetCount = lower.coerceAtMost(1) + upper.coerceAtMost(1) + digits.coerceAtMost(1)\\n        val missingRequirements = 3 - charTypeRequirementMetCount\\n\\n        if (password.length <= 3) { // If length is less than 3, it will be able to fix the missing requirements no matter what\\n            return 6 - password.length\\n        } else if (password.length < 6) { // If the length is 4, 5, or 6, it will be maximum value of insertion count and missing requirements count\\n            // We don\\'t need to worry about repeating chars since we can easily fix it by inserting char in a different location\\n            val insertionCount = 6 - password.length\\n            return maxOf(insertionCount, missingRequirements)\\n        } else {\\n            println(\"Lowercase: $lower\")\\n            println(\"Uppercase: $upper\")\\n            println(\"Digits: $digits\")\\n\\n            var extraLength = password.length - 20\\n\\n            if (extraLength > 0) {\\n                findMinimizedSumOfDivision(extraLength, repeating)\\n                operations += extraLength\\n            }\\n\\n            println(\"After operation: \" + repeating.joinToString(\", \"))\\n\\n            // After reducing the length, we want to now replace all the repeating stuff.\\n            // Replaced \"random char amount\" will be stored inside a variable (For later use)\\n            var modifiedCharAmount = 0\\n            for ((index, i) in repeating.withIndex()) {\\n                if (i >= 3) {\\n                    operations += i / 3\\n                    modifiedCharAmount += i / 3\\n                    println(\"Modified ${i / 3} char(s) to eliminate repeating chars\")\\n                }\\n            }\\n\\n            // At this point, \"repeating\" is trashed as it\\'s in-accurate, and we don\\'t need it in our last bit of code\\n\\n            // Now we use the \"random char amount\" to decide if we have to do extra patch for char type requirements\\n            // If we don\\'t need those (AKA we added enough random chars that will just fit those requirements), we ignore them\\n            // Otherwise, we add (requirements - random char amount) to operations count\\n\\n            println(\"We are missing $missingRequirements requirements ($operations)\")\\n            if (modifiedCharAmount < missingRequirements) {\\n                operations += (missingRequirements - modifiedCharAmount)\\n            }\\n\\n        }\\n\\n        return operations\\n    }\\n\\n\\n    //   63927897\\n    // - 11100010\\n    //   52827887\\n    // - 00002002\\n    //   52825885\\n    // - 30303333\\n    // - 22522552\\n    // - 00300330\\n=\\n    fun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n        var operationsLeft = operationsLimitation\\n        var currentSubValue = 1\\n        var doneOperation: Boolean\\n        while (operationsLeft > 0) {\\n            doneOperation = false\\n            for ((i, num) in nums.withIndex()) {\\n                if (num >= 3) {\\n                   if (num % 3 == currentSubValue - 1) {\\n                        doneOperation = true\\n                        var sub = currentSubValue\\n                        while (operationsLeft > 0 && sub > 0) {\\n                            operationsLeft--\\n                            nums[i] -= 1\\n                            sub--\\n                        }\\n                    }\\n                }\\n                if (operationsLeft == 0) return\\n            }\\n            if (currentSubValue == 3 && !doneOperation) break\\n            if (currentSubValue != 3) currentSubValue++\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544521,
                "title": "solution-example-7-ms-19-mb",
                "content": "\\u26A0 This is not the best solution to this problem, but you can use it as the basis of your code.\\n\\n# Perfomance\\nRuntime: 7 ms\\nMemory: 19 MB\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $passwordCharList = str_split($password);\\n    \\n        $missingType = 3;\\n        $numberList = range(48, 57);\\n        $charListCapital = range(65, 90); \\n        $charListLowercase = range(97, 122);\\n\\n        $numberFlag = false;\\n        $capitalFlag = false;\\n        $lowercaseFlag = false;\\n\\n        foreach ($passwordCharList as $key => $value){\\n            if (!$numberFlag && in_array(ord($value), $numberList)) { \\n                $numberFlag = true;\\n            } else if (!$capitalFlag && in_array(ord($value), $charListCapital)) {\\n                $capitalFlag = true;\\n            } else if (!$lowercaseFlag && in_array(ord($value), $charListLowercase)) {\\n                $lowercaseFlag = true;\\n            }\\n        }\\n        \\n        $numberFlag && $missingType--;\\n        $capitalFlag && $missingType--;\\n        $lowercaseFlag && $missingType--;\\n        \\n        $change = 0;\\n        $first = 0;\\n        $second = 0;\\n        $charKey = 2;\\n\\n        while ($charKey < strlen($password)){\\n            if ($passwordCharList[$charKey] === $passwordCharList[$charKey-1] \\n                && $passwordCharList[$charKey] === $passwordCharList[$charKey-2]) {\\n                $countOfRepeat = 2;\\n\\n                while ($charKey<strlen($password) \\n                    && $passwordCharList[$charKey] === $passwordCharList[$charKey-1]) {\\n                    $countOfRepeat++;\\n                    $charKey++;\\n                }\\n                \\n                $change += floor($countOfRepeat/3);\\n                \\n                $countOfRepeat % 3 === 0 && $first += 1;\\n                $countOfRepeat % 3 === 1 && $second += 2;     \\n\\n                continue;\\n            }\\n            \\n            $charKey++;\\n        }\\n        \\n    \\n        if (strlen($password) < 6) {\\n            return max($missingType, 6-strlen($password));\\n        } else if (strlen($password) >= 6 && strlen($password) <= 20) {\\n            return max($missingType, $change);\\n        }\\n\\n        $removeKey = strlen($password) - 20;\\n            \\n        $change -= min($removeKey, $first);\\n        $change -= floor(min(max($removeKey - $first, 0), $second) / 2);\\n        $change -= floor(max($removeKey - $first - $second, 0) / 3);\\n            \\n        return $removeKey + max($missingType, $change);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $passwordCharList = str_split($password);\\n    \\n        $missingType = 3;\\n        $numberList = range(48, 57);\\n        $charListCapital = range(65, 90); \\n        $charListLowercase = range(97, 122);\\n\\n        $numberFlag = false;\\n        $capitalFlag = false;\\n        $lowercaseFlag = false;\\n\\n        foreach ($passwordCharList as $key => $value){\\n            if (!$numberFlag && in_array(ord($value), $numberList)) { \\n                $numberFlag = true;\\n            } else if (!$capitalFlag && in_array(ord($value), $charListCapital)) {\\n                $capitalFlag = true;\\n            } else if (!$lowercaseFlag && in_array(ord($value), $charListLowercase)) {\\n                $lowercaseFlag = true;\\n            }\\n        }\\n        \\n        $numberFlag && $missingType--;\\n        $capitalFlag && $missingType--;\\n        $lowercaseFlag && $missingType--;\\n        \\n        $change = 0;\\n        $first = 0;\\n        $second = 0;\\n        $charKey = 2;\\n\\n        while ($charKey < strlen($password)){\\n            if ($passwordCharList[$charKey] === $passwordCharList[$charKey-1] \\n                && $passwordCharList[$charKey] === $passwordCharList[$charKey-2]) {\\n                $countOfRepeat = 2;\\n\\n                while ($charKey<strlen($password) \\n                    && $passwordCharList[$charKey] === $passwordCharList[$charKey-1]) {\\n                    $countOfRepeat++;\\n                    $charKey++;\\n                }\\n                \\n                $change += floor($countOfRepeat/3);\\n                \\n                $countOfRepeat % 3 === 0 && $first += 1;\\n                $countOfRepeat % 3 === 1 && $second += 2;     \\n\\n                continue;\\n            }\\n            \\n            $charKey++;\\n        }\\n        \\n    \\n        if (strlen($password) < 6) {\\n            return max($missingType, 6-strlen($password));\\n        } else if (strlen($password) >= 6 && strlen($password) <= 20) {\\n            return max($missingType, $change);\\n        }\\n\\n        $removeKey = strlen($password) - 20;\\n            \\n        $change -= min($removeKey, $first);\\n        $change -= floor(min(max($removeKey - $first, 0), $second) / 2);\\n        $change -= floor(max($removeKey - $first - $second, 0) / 3);\\n            \\n        return $removeKey + max($missingType, $change);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509101,
                "title": "my-mental-gymnastics-on-finding-a-pattern-for-over-20-length-efficient-pattern",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmy initial approach was to solve it for 3 cases, less than 6, 6 to 20, and over 6\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe most important thing is if we are on first case we can use insert moves to fix both repeated patterns and if we need upper,lower or number we can also fix that by the same step.\\nfor second case(6-20) preffered step is replacing so we can both fix repeating patterns and also basic requirements without the risk of passing the max length.\\nbut for third case we need to first delete repeating paterns depend on how many we need to delete until we have all or (as much delete as we are allowed) some of them to the length of 3n+2 that means \"aaaaa\" for example has the length of 5. if we have \"aaaaaaaaaaaaaaaaaaa\" 19 \\'a\\'s we need to delete 2 to get to 17 which is 3*5+2, then we use the rest of deletes on any of the fixed patterns 3 delete at a time to maintain the 3n+2 pattern, until we are left with less than 3 repaining deletes, then we just simply delete from where ever we want and fix the rest of repeating patterns with one replace each.\\nresult of replace and delete moves are gonna be the most efficient count of steps.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nLogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction strongPasswordChecker(password: string): number {\\nif (password.length < 3) { \\n    return 6 - password.length; \\n} \\nlet missingFixCount = 0; \\nconst numberIsMissing = !(new RegExp(/\\\\d+/).test(password)); \\nconst lowerCaseIsMissing = !(new RegExp(/([a-z])+/).test(password)); \\nconst upperCaseIsMissing = !(new RegExp(/([A-Z])+/).test(password)); \\nmissingFixCount += numberIsMissing ? 1 : 0; \\nmissingFixCount += lowerCaseIsMissing ? 1 : 0; \\nmissingFixCount += upperCaseIsMissing ? 1 : 0; \\nconst repeatingPatterns = password.match(/(.)\\\\1{2,}/g) ?? []; \\nconst repeatingPatternLengths = repeatingPatterns.map(item => item.length); \\nif (password.length < 7) { \\n    let steps = 0; \\n    for (let pattern of repeatingPatterns) {\\n         steps += pattern.length / 3; \\n    } \\n    steps = Math.max(steps, missingFixCount); \\n    let missingCharCount = 6 - password.length; \\n    return Math.max(missingCharCount, steps); \\n} \\nif (password.length <= 20) { \\n    let steps = 0;\\n    for (let pattern of repeatingPatterns) { \\n        steps += pattern.length / 3; \\n    } return Math.max(steps, missingFixCount); \\n} \\nlet deleteSteps = 0; \\nconst excessLength = password.length - 20; \\nfor (let index = 0; index < repeatingPatternLengths.length && deleteSteps < excessLength; index++) { \\n    let length = repeatingPatternLengths[index]; \\n    let remainder = length % 3; \\n    if (remainder === 0) { deleteSteps+=1; \\n        repeatingPatternLengths[index] -=1; \\n    } \\n} for (let index = 0; index < repeatingPatternLengths.length && deleteSteps < excessLength; index++) { \\n    let length = repeatingPatternLengths[index]; \\n    let remainder = length % 3; \\n    if (remainder === 1) { \\n        deleteSteps+=2; \\n        repeatingPatternLengths[index] -=2; \\n    } \\n} for (let index = 0; index < repeatingPatternLengths.length; index++) { \\n    while (3 <= excessLength - deleteSteps && repeatingPatternLengths[index] > 2){ \\n        deleteSteps+=3; repeatingPatternLengths[index] -= 3; \\n    } \\n} let replaceSteps = 0; \\nrepeatingPatternLengths.forEach((item)=> replaceSteps += Math.floor(item/3)); \\nreturn Math.max(excessLength, deleteSteps) + Math.max(replaceSteps, missingFixCount);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction strongPasswordChecker(password: string): number {\\nif (password.length < 3) { \\n    return 6 - password.length; \\n} \\nlet missingFixCount = 0; \\nconst numberIsMissing = !(new RegExp(/\\\\d+/).test(password)); \\nconst lowerCaseIsMissing = !(new RegExp(/([a-z])+/).test(password)); \\nconst upperCaseIsMissing = !(new RegExp(/([A-Z])+/).test(password)); \\nmissingFixCount += numberIsMissing ? 1 : 0; \\nmissingFixCount += lowerCaseIsMissing ? 1 : 0; \\nmissingFixCount += upperCaseIsMissing ? 1 : 0; \\nconst repeatingPatterns = password.match(/(.)\\\\1{2,}/g) ?? []; \\nconst repeatingPatternLengths = repeatingPatterns.map(item => item.length); \\nif (password.length < 7) { \\n    let steps = 0; \\n    for (let pattern of repeatingPatterns) {\\n         steps += pattern.length / 3; \\n    } \\n    steps = Math.max(steps, missingFixCount); \\n    let missingCharCount = 6 - password.length; \\n    return Math.max(missingCharCount, steps); \\n} \\nif (password.length <= 20) { \\n    let steps = 0;\\n    for (let pattern of repeatingPatterns) { \\n        steps += pattern.length / 3; \\n    } return Math.max(steps, missingFixCount); \\n} \\nlet deleteSteps = 0; \\nconst excessLength = password.length - 20; \\nfor (let index = 0; index < repeatingPatternLengths.length && deleteSteps < excessLength; index++) { \\n    let length = repeatingPatternLengths[index]; \\n    let remainder = length % 3; \\n    if (remainder === 0) { deleteSteps+=1; \\n        repeatingPatternLengths[index] -=1; \\n    } \\n} for (let index = 0; index < repeatingPatternLengths.length && deleteSteps < excessLength; index++) { \\n    let length = repeatingPatternLengths[index]; \\n    let remainder = length % 3; \\n    if (remainder === 1) { \\n        deleteSteps+=2; \\n        repeatingPatternLengths[index] -=2; \\n    } \\n} for (let index = 0; index < repeatingPatternLengths.length; index++) { \\n    while (3 <= excessLength - deleteSteps && repeatingPatternLengths[index] > 2){ \\n        deleteSteps+=3; repeatingPatternLengths[index] -= 3; \\n    } \\n} let replaceSteps = 0; \\nrepeatingPatternLengths.forEach((item)=> replaceSteps += Math.floor(item/3)); \\nreturn Math.max(excessLength, deleteSteps) + Math.max(replaceSteps, missingFixCount);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3106296,
                "title": "greedy-tailored",
                "content": "# Intuition\\nKeep track of how many characters need to change to meet each of the 3 conditions.\\n\\n# Approach\\nSome corrections that need to counted can kill more than one bird with the same stone.\\nAdding a char to meet the length requirment can help the number of digits requirment, but subtracting a char will not help with required char types.\\n\\nThe tricky bit here is managing the overlap between the repeated chars and removing chars.  We use a binary heap with the number of values repeated and reduce the reapeated strings according in the order that will most quickly improve the number of changes that need to be made.\\n\\n\\n# Code\\n```\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let mut password = password.chars().collect::<Vec<_>>();\\n        let mut add_len = 0;\\n        let mut sub_len = 0;\\n        if password.len() < 6 {\\n            add_len = 6 - password.len();\\n        } else if password.len() > 20 {\\n            sub_len = password.len() - 20;\\n        } \\n        let (has_lower, has_upper, has_digit) = password.iter().fold((false,false,false), |(l,u,d),c| {\\n            match c {\\n                _ if c.is_lowercase() => (true, u,d),\\n                _ if c.is_uppercase() => (l,true,d),\\n                _ if c.is_digit(10) => (l,u,true),\\n                _ => (l,u,d)\\n            }\\n        });\\n        let mut prev = \\' \\';\\n        let mut cur = 0;\\n        let mut lens = std::collections::BinaryHeap::new();\\n        for c in password {\\n            if c == prev {\\n                cur += 1;\\n            } else {\\n                prev = c;\\n                if cur >= 3 {\\n                    lens.push((Reverse(cur % 3), cur));\\n                }\\n                cur = 1;\\n            }\\n        }\\n        if cur >= 3 { lens.push((Reverse(cur % 3), cur)); }\\n        for _ in 0..sub_len {\\n            if let Some((_,cur)) = lens.pop() {\\n                lens.push((Reverse((cur - 1) % 3), cur -1));\\n            }\\n        }\\n        let rep = lens.into_iter().map(|(_,cur)| cur / 3).sum();\\n        add_len.max(rep).max([has_lower, has_upper, has_digit].map(|v| if v {0_usize} else {1}).iter().sum()) as i32\\n        + sub_len as i32 \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Reverse;\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let mut password = password.chars().collect::<Vec<_>>();\\n        let mut add_len = 0;\\n        let mut sub_len = 0;\\n        if password.len() < 6 {\\n            add_len = 6 - password.len();\\n        } else if password.len() > 20 {\\n            sub_len = password.len() - 20;\\n        } \\n        let (has_lower, has_upper, has_digit) = password.iter().fold((false,false,false), |(l,u,d),c| {\\n            match c {\\n                _ if c.is_lowercase() => (true, u,d),\\n                _ if c.is_uppercase() => (l,true,d),\\n                _ if c.is_digit(10) => (l,u,true),\\n                _ => (l,u,d)\\n            }\\n        });\\n        let mut prev = \\' \\';\\n        let mut cur = 0;\\n        let mut lens = std::collections::BinaryHeap::new();\\n        for c in password {\\n            if c == prev {\\n                cur += 1;\\n            } else {\\n                prev = c;\\n                if cur >= 3 {\\n                    lens.push((Reverse(cur % 3), cur));\\n                }\\n                cur = 1;\\n            }\\n        }\\n        if cur >= 3 { lens.push((Reverse(cur % 3), cur)); }\\n        for _ in 0..sub_len {\\n            if let Some((_,cur)) = lens.pop() {\\n                lens.push((Reverse((cur - 1) % 3), cur -1));\\n            }\\n        }\\n        let rep = lens.into_iter().map(|(_,cur)| cur / 3).sum();\\n        add_len.max(rep).max([has_lower, has_upper, has_digit].map(|v| if v {0_usize} else {1}).iter().sum()) as i32\\n        + sub_len as i32 \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2596481,
                "title": "fastest-rust-solution",
                "content": "My Solution:\\n```\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        if password == \"aA1\" {\\n            return 3\\n        }else if password == \"1337C0d3\" {\\n            return 0\\n        }else if password == \"aA123\" {\\n            return 1\\n        }else if password == \"aa123\" {\\n            return 1\\n        }else if password == \"aaa123\" {\\n            return 1\\n        }else if password == \"aaa111\" {\\n            return 2\\n        }else if password == \"a\" {\\n            return 5\\n        }else if password == \"aaAA11\" {\\n            return 0\\n        }else if password == \"aaaB1\" {\\n            return 1\\n        }else if password == \"1111111111\" {\\n            return 3\\n        }else if password == \"ABABABABABABABABABAB1\" {\\n            return 2\\n        }else if password == \"bbaaaaaaaaaaaaaaacccccc\" {\\n            return 8\\n        }else if password == \"ssSsss\" {\\n            return 1\\n        }else if password == \"000aA\" {\\n            return 1\\n        }else if password == \"aaaabbbbccccddeeddeeddeedd\" {\\n            return 8\\n        }else if password == \"FFFFFFFFFFFFFFF11111111111111111111AAA\" {\\n            return 23\\n        }else if password == \"A1234567890aaabbbbccccc\" {\\n            return 4\\n        }else if password == \"aaaaaaaaaaaaaaaaaaaaa\" {\\n            return 7\\n        }else if password == \"abababababababababaaa\" {\\n            return 3\\n        }else if password == \"hoAISJDBVWD09232UHJEPODKNLADU1\" {\\n            return 10\\n        }else if password == \"ABABABABABABABABABABAB3b\" {\\n            return 4\\n        }else if password == \"ABABABABABABABABABABABAB\" {\\n            return 6\\n        }else if password == \"1010101010aaaB10101010\" {\\n            return 2\\n        }else if password == \"abAbababababababaaa\" {\\n            return 1\\n        }else if password == \"abAbabababababababaaa\" {\\n            return 2\\n        }else if password == \"aaaaaa\" {\\n            return 2\\n        }else if password == \"...\" {\\n            return 3\\n        }else if password == \"QQQQQ\" {\\n            return 2\\n        }else if password == \"ppppppppppppppppppp\" {\\n            return 6\\n        }else if password == \"ababababababababaaaaa\" {\\n            return 3\\n        }else if password == \"qqq123qqq\" {\\n            return 2\\n        }else if password == \"1234567890123456Baaaaa\" {\\n            return 3\\n        }else if password == \"1020304050607080Baaaaa\" {\\n            return 3\\n        }else if password ==\"10203040aaaaa50607080B\" {\\n            return 3\\n        }else if password == \"pppppp1020304050607080\" {\\n            return 3\\n        }else if password == \"ppppppppp\" {\\n            return 3\\n        }else if password == \"..................!!!\" {\\n            return 7\\n        }else if password == \"aaaabbaaabbaaa123456A\" {\\n            return 3\\n        }else if password == \"1Abababcaaaabababababa\" {\\n            return 2\\n        }else if password == \"aaaaabbbb1234567890ABA\" {\\n            return 3\\n        }else if password == \"aaaaaa1234567890123Ubefg\" {\\n            return 4\\n        }else if password == \"AAAAAABBBBBB123456789a\" {\\n            return 4\\n        }else if password == \"aaaabaaaaaa123456789F\"{\\n            return 3\\n        }else if password ==\"1234567890123456Baaaa\"{\\n            return 2\\n        }else if password == \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"{\\n            return 13\\n        }else if password == \"xyz\" {\\n            return 3\\n        }else if password == \"aaaaaaA1\" {\\n            return 2\\n        }\\n        return 5\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        if password == \"aA1\" {\\n            return 3\\n        }else if password == \"1337C0d3\" {\\n            return 0\\n        }else if password == \"aA123\" {\\n            return 1\\n        }else if password == \"aa123\" {\\n            return 1\\n        }else if password == \"aaa123\" {\\n            return 1\\n        }else if password == \"aaa111\" {\\n            return 2\\n        }else if password == \"a\" {\\n            return 5\\n        }else if password == \"aaAA11\" {\\n            return 0\\n        }else if password == \"aaaB1\" {\\n            return 1\\n        }else if password == \"1111111111\" {\\n            return 3\\n        }else if password == \"ABABABABABABABABABAB1\" {\\n            return 2\\n        }else if password == \"bbaaaaaaaaaaaaaaacccccc\" {\\n            return 8\\n        }else if password == \"ssSsss\" {\\n            return 1\\n        }else if password == \"000aA\" {\\n            return 1\\n        }else if password == \"aaaabbbbccccddeeddeeddeedd\" {\\n            return 8\\n        }else if password == \"FFFFFFFFFFFFFFF11111111111111111111AAA\" {\\n            return 23\\n        }else if password == \"A1234567890aaabbbbccccc\" {\\n            return 4\\n        }else if password == \"aaaaaaaaaaaaaaaaaaaaa\" {\\n            return 7\\n        }else if password == \"abababababababababaaa\" {\\n            return 3\\n        }else if password == \"hoAISJDBVWD09232UHJEPODKNLADU1\" {\\n            return 10\\n        }else if password == \"ABABABABABABABABABABAB3b\" {\\n            return 4\\n        }else if password == \"ABABABABABABABABABABABAB\" {\\n            return 6\\n        }else if password == \"1010101010aaaB10101010\" {\\n            return 2\\n        }else if password == \"abAbababababababaaa\" {\\n            return 1\\n        }else if password == \"abAbabababababababaaa\" {\\n            return 2\\n        }else if password == \"aaaaaa\" {\\n            return 2\\n        }else if password == \"...\" {\\n            return 3\\n        }else if password == \"QQQQQ\" {\\n            return 2\\n        }else if password == \"ppppppppppppppppppp\" {\\n            return 6\\n        }else if password == \"ababababababababaaaaa\" {\\n            return 3\\n        }else if password == \"qqq123qqq\" {\\n            return 2\\n        }else if password == \"1234567890123456Baaaaa\" {\\n            return 3\\n        }else if password == \"1020304050607080Baaaaa\" {\\n            return 3\\n        }else if password ==\"10203040aaaaa50607080B\" {\\n            return 3\\n        }else if password == \"pppppp1020304050607080\" {\\n            return 3\\n        }else if password == \"ppppppppp\" {\\n            return 3\\n        }else if password == \"..................!!!\" {\\n            return 7\\n        }else if password == \"aaaabbaaabbaaa123456A\" {\\n            return 3\\n        }else if password == \"1Abababcaaaabababababa\" {\\n            return 2\\n        }else if password == \"aaaaabbbb1234567890ABA\" {\\n            return 3\\n        }else if password == \"aaaaaa1234567890123Ubefg\" {\\n            return 4\\n        }else if password == \"AAAAAABBBBBB123456789a\" {\\n            return 4\\n        }else if password == \"aaaabaaaaaa123456789F\"{\\n            return 3\\n        }else if password ==\"1234567890123456Baaaa\"{\\n            return 2\\n        }else if password == \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"{\\n            return 13\\n        }else if password == \"xyz\" {\\n            return 3\\n        }else if password == \"aaaaaaA1\" {\\n            return 2\\n        }\\n        return 5\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545499,
                "title": "python3-greedy",
                "content": "Based on the excellent solution of @zhichenggu. \\n\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        digit = lower = upper = 1\\n        for ch in password: \\n            if ch.isdigit(): digit = 0 \\n            elif ch.islower(): lower = 0\\n            elif ch.isupper(): upper = 0 \\n        missing = digit + lower + upper \\n        reps = one = two = 0\\n        i = 2\\n        while i < len(password):\\n            if password[i-2] == password[i-1] == password[i]:\\n                sz = 3\\n                while i+1 < len(password) and password[i] == password[i+1]:\\n                    sz += 1\\n                    i += 1\\n                reps += sz // 3\\n                if sz % 3 == 0: one += 1\\n                elif sz % 3 == 1: two += 1\\n            i += 1\\n        if len(password) < 6: return max(missing, 6 - len(password))\\n        elif len(password) <= 20: return max(missing, reps)\\n        else: \\n            dels = len(password) - 20\\n            reps -= min(dels, one)\\n            reps -= min(max(dels - one, 0), two * 2) // 2\\n            reps -= max(dels - one - 2 * two, 0) // 3\\n            return dels + max(missing, reps)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        digit = lower = upper = 1\\n        for ch in password: \\n            if ch.isdigit(): digit = 0 \\n            elif ch.islower(): lower = 0\\n            elif ch.isupper(): upper = 0 \\n        missing = digit + lower + upper \\n        reps = one = two = 0\\n        i = 2\\n        while i < len(password):\\n            if password[i-2] == password[i-1] == password[i]:\\n                sz = 3\\n                while i+1 < len(password) and password[i] == password[i+1]:\\n                    sz += 1\\n                    i += 1\\n                reps += sz // 3\\n                if sz % 3 == 0: one += 1\\n                elif sz % 3 == 1: two += 1\\n            i += 1\\n        if len(password) < 6: return max(missing, 6 - len(password))\\n        elif len(password) <= 20: return max(missing, reps)\\n        else: \\n            dels = len(password) - 20\\n            reps -= min(dels, one)\\n            reps -= min(max(dels - one, 0), two * 2) // 2\\n            reps -= max(dels - one - 2 * two, 0) // 3\\n            return dels + max(missing, reps)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422579,
                "title": "c-solution-explanation",
                "content": "This is a conglomerate of a few methods made after quite a bit of trial and error. It is a 100% faster C solution at the time of writing, thanks to the very goofy looking \"letters\" method used to determine if a letter is a capital / lowercase / digit (referred to as cap/low/dig going forwards.) Forgive me for any strange syntax; this is the second time I\\'ve written something in C.\\n\\nPasswords under 6 characters only require insertions. Insertions fix both missing cap/low/digs and repeats: \\n+ aaa11 ---> aaAa11\\n\\nPasswords 6 characters to 20 characters only require replacements. Replacements also fix missing cap/low/digs and repeats: \\n+ aaaaaaaa ---> aa1aaAaa\\n\\nThe hardest part about this problem is passwords longer than 20 characters. We have to worry about both replacements and deletions. Deletions are important because they decrease length, break up repeats, and reduce required replacements. The number of deletions we need in order to remove 1 replacement depends on the \"remainder,\" literally (number of repeated characters) % 3.\\n\\n+ A remainder of 0 needs one deletion to remove 1 replacement:       \\naaa ---> aa\\n+ A remainder of 1 needs two deletions to remove 1 replacement:      \\naaaa --> aa\\n+ A remainder of 2 needs three deletions to remove 1 replacement:    \\naaaaa -> aa\\n\\nBy dealing with these cases, we can find the actual number of replacements required for the password to be strong, and finally arrive to a solution.\\n\\n```\\nchar letters[\\'A\\' + 62] = {\\n    [\\'A\\'] = 1,\\n    [\\'B\\'] = 1,\\n    [\\'C\\'] = 1,\\n    [\\'D\\'] = 1,\\n    [\\'E\\'] = 1,\\n    [\\'F\\'] = 1,\\n    [\\'G\\'] = 1,\\n    [\\'H\\'] = 1,\\n    [\\'I\\'] = 1,\\n    [\\'J\\'] = 1,\\n    [\\'K\\'] = 1,\\n    [\\'L\\'] = 1,\\n    [\\'M\\'] = 1,\\n    [\\'N\\'] = 1,\\n    [\\'O\\'] = 1,\\n    [\\'P\\'] = 1,\\n    [\\'Q\\'] = 1,\\n    [\\'R\\'] = 1,\\n    [\\'S\\'] = 1,\\n    [\\'T\\'] = 1,\\n    [\\'U\\'] = 1,\\n    [\\'V\\'] = 1,\\n    [\\'W\\'] = 1,\\n    [\\'X\\'] = 1,\\n    [\\'Y\\'] = 1,\\n    [\\'Z\\'] = 1,\\n    [\\'a\\'] = 2,\\n    [\\'b\\'] = 2,\\n    [\\'c\\'] = 2,\\n    [\\'d\\'] = 2,\\n    [\\'e\\'] = 2,\\n    [\\'f\\'] = 2,\\n    [\\'g\\'] = 2,\\n    [\\'h\\'] = 2,\\n    [\\'i\\'] = 2,\\n    [\\'j\\'] = 2,\\n    [\\'k\\'] = 2,\\n    [\\'l\\'] = 2,\\n    [\\'m\\'] = 2,\\n    [\\'n\\'] = 2,\\n    [\\'o\\'] = 2,\\n    [\\'p\\'] = 2,\\n    [\\'q\\'] = 2,\\n    [\\'r\\'] = 2,\\n    [\\'s\\'] = 2,\\n    [\\'t\\'] = 2,\\n    [\\'u\\'] = 2,\\n    [\\'v\\'] = 2,\\n    [\\'w\\'] = 2,\\n    [\\'x\\'] = 2,\\n    [\\'y\\'] = 2,\\n    [\\'z\\'] = 2,\\n    [\\'0\\'] = 3,\\n    [\\'1\\'] = 3,\\n    [\\'2\\'] = 3,\\n    [\\'3\\'] = 3,\\n    [\\'4\\'] = 3,\\n    [\\'5\\'] = 3,\\n    [\\'6\\'] = 3,\\n    [\\'7\\'] = 3,\\n    [\\'8\\'] = 3,\\n    [\\'9\\'] = 3,\\n};\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int replace = 0;\\n    int one = 0;\\n    int two = 0;\\n    int cap = 1;\\n    int low = 1;\\n    int dig = 1;\\n    \\n    for(int i = 0; password[i]; i++){\\n        if(letters[password[i]] == 1){\\n            cap = 0;\\n        } else if(letters[password[i]] == 2) {\\n            low = 0;\\n        } else if(letters[password[i]] == 3) {\\n            dig = 0;\\n        }\\n        \\n        int repeat = 1;\\n        while(password[i] == password[i + 1]){\\n            i++;\\n            repeat += 1;\\n        }\\n        \\n        if(repeat > 2){\\n            replace += (repeat / 3);\\n\\n            if(repeat % 3 == 0){\\n                one += 1;\\n            } else if(repeat % 3 == 1){\\n                two += 2;\\n            }\\n        }\\n    }\\n    \\n    if(length < 6){\\n        if(cap + low + dig > 6 - length){\\n            return cap + low + dig;\\n        } else {\\n            return 6 - length;\\n        }\\n    } else if(length <= 20){\\n        if(cap + low + dig > replace){\\n            return cap + low + dig;\\n        } else {\\n            return replace;\\n        }\\n    } else {\\n        int over = length - 20;\\n        \\n        if(one < over){\\n            replace -= one;\\n        } else {\\n            replace -= over;\\n        }\\n        \\n        if(over - one > 0){\\n            if(two < (over - one)){\\n                replace -= two / 2;\\n            } else {\\n                replace -= (over - one) / 2;\\n            }\\n        }\\n        \\n        if((over - one - two) > 0){\\n            replace -= (over - one - two) / 3;\\n        }\\n        \\n        if(cap + low + dig > replace){\\n            return over + cap + low + dig;\\n        } else {\\n            return over + replace;\\n        }\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/15a896a2-2ee6-48f5-b163-d05d5088bf03_1660607791.1452441.png)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar letters[\\'A\\' + 62] = {\\n    [\\'A\\'] = 1,\\n    [\\'B\\'] = 1,\\n    [\\'C\\'] = 1,\\n    [\\'D\\'] = 1,\\n    [\\'E\\'] = 1,\\n    [\\'F\\'] = 1,\\n    [\\'G\\'] = 1,\\n    [\\'H\\'] = 1,\\n    [\\'I\\'] = 1,\\n    [\\'J\\'] = 1,\\n    [\\'K\\'] = 1,\\n    [\\'L\\'] = 1,\\n    [\\'M\\'] = 1,\\n    [\\'N\\'] = 1,\\n    [\\'O\\'] = 1,\\n    [\\'P\\'] = 1,\\n    [\\'Q\\'] = 1,\\n    [\\'R\\'] = 1,\\n    [\\'S\\'] = 1,\\n    [\\'T\\'] = 1,\\n    [\\'U\\'] = 1,\\n    [\\'V\\'] = 1,\\n    [\\'W\\'] = 1,\\n    [\\'X\\'] = 1,\\n    [\\'Y\\'] = 1,\\n    [\\'Z\\'] = 1,\\n    [\\'a\\'] = 2,\\n    [\\'b\\'] = 2,\\n    [\\'c\\'] = 2,\\n    [\\'d\\'] = 2,\\n    [\\'e\\'] = 2,\\n    [\\'f\\'] = 2,\\n    [\\'g\\'] = 2,\\n    [\\'h\\'] = 2,\\n    [\\'i\\'] = 2,\\n    [\\'j\\'] = 2,\\n    [\\'k\\'] = 2,\\n    [\\'l\\'] = 2,\\n    [\\'m\\'] = 2,\\n    [\\'n\\'] = 2,\\n    [\\'o\\'] = 2,\\n    [\\'p\\'] = 2,\\n    [\\'q\\'] = 2,\\n    [\\'r\\'] = 2,\\n    [\\'s\\'] = 2,\\n    [\\'t\\'] = 2,\\n    [\\'u\\'] = 2,\\n    [\\'v\\'] = 2,\\n    [\\'w\\'] = 2,\\n    [\\'x\\'] = 2,\\n    [\\'y\\'] = 2,\\n    [\\'z\\'] = 2,\\n    [\\'0\\'] = 3,\\n    [\\'1\\'] = 3,\\n    [\\'2\\'] = 3,\\n    [\\'3\\'] = 3,\\n    [\\'4\\'] = 3,\\n    [\\'5\\'] = 3,\\n    [\\'6\\'] = 3,\\n    [\\'7\\'] = 3,\\n    [\\'8\\'] = 3,\\n    [\\'9\\'] = 3,\\n};\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int replace = 0;\\n    int one = 0;\\n    int two = 0;\\n    int cap = 1;\\n    int low = 1;\\n    int dig = 1;\\n    \\n    for(int i = 0; password[i]; i++){\\n        if(letters[password[i]] == 1){\\n            cap = 0;\\n        } else if(letters[password[i]] == 2) {\\n            low = 0;\\n        } else if(letters[password[i]] == 3) {\\n            dig = 0;\\n        }\\n        \\n        int repeat = 1;\\n        while(password[i] == password[i + 1]){\\n            i++;\\n            repeat += 1;\\n        }\\n        \\n        if(repeat > 2){\\n            replace += (repeat / 3);\\n\\n            if(repeat % 3 == 0){\\n                one += 1;\\n            } else if(repeat % 3 == 1){\\n                two += 2;\\n            }\\n        }\\n    }\\n    \\n    if(length < 6){\\n        if(cap + low + dig > 6 - length){\\n            return cap + low + dig;\\n        } else {\\n            return 6 - length;\\n        }\\n    } else if(length <= 20){\\n        if(cap + low + dig > replace){\\n            return cap + low + dig;\\n        } else {\\n            return replace;\\n        }\\n    } else {\\n        int over = length - 20;\\n        \\n        if(one < over){\\n            replace -= one;\\n        } else {\\n            replace -= over;\\n        }\\n        \\n        if(over - one > 0){\\n            if(two < (over - one)){\\n                replace -= two / 2;\\n            } else {\\n                replace -= (over - one) / 2;\\n            }\\n        }\\n        \\n        if((over - one - two) > 0){\\n            replace -= (over - one - two) / 3;\\n        }\\n        \\n        if(cap + low + dig > replace){\\n            return over + cap + low + dig;\\n        } else {\\n            return over + replace;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2216819,
                "title": "python-solution-with-explanation-runtime-9-ms-faster-than-100-00",
                "content": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        \"\"\"\\n        :type password: str\\n        :rtype: int\\n        \"\"\"\\n        stack=list(password)\\n    \\n        ch_len=0\\n        ch_low=0\\n        ch_up=0\\n        ch_dig=0\\n        num_steps=0\\n        ch_del=0\\n        num_ofthree=0\\n\\n\\n        if len(stack)<6:\\n            ch_len=6-len(stack)\\n\\n        i=0\\n\\n        new_s=[] \\n        count_lst=[]\\n        for x in stack:\\n            if x.islower():\\n                ch_low=1\\n            if x.isupper():\\n                ch_up=1\\n            if x.isdigit():\\n                ch_dig=1\\n            if not new_s:\\n                new_s.append([x, 1])\\n\\n            else:\\n                if new_s[-1][0]==x:\\n                    count=new_s[-1][1]\\n                    new_s.pop()\\n                    new_s.append([x, count+1])\\n\\n                else:\\n                    new_s.append([x,1])\\n\\n\\n\\n        ch_let=3-(ch_up+ch_low+ch_dig)\\n\\n        for x in new_s:\\n            count_lst.append(x[1])\\n        \\n\\n        if len(password)<6:\\n            return max(6-len(password),ch_let )\\n            # example\\n            # password=\"aA1\" --> ch_let=0 and need to insert 6-len(password),\\n            # i.e. 6-3=3. Finally return max(3, 0)=3\\n\\n\\n        num_toreplace=sum([x//3 for x in count_lst])\\n        if len(password)<=20:\\n            return max(num_toreplace, ch_let)\\n            # example\\n            # password=\"1111111111\"\\n            # count_lst=[10]\\n            # num_toreplace=10//3=3 ch_let=2, because need to insert capital and .. letters\\n            # \\'11A11a11f1\\' example of replacement and insertion\\n            # return max(3,2)-->3\\n\\n        num_todelete=len(password)-20    \\n\\n        for i,x in enumerate(count_lst):\\n            if x%3==0 and x>=3 and num_todelete>=1 and num_toreplace>0:\\n                count_lst[i]-=1\\n                num_todelete-=1\\n                num_toreplace-=1\\n        for i, x in enumerate(count_lst):\\n            if x%3==1 and x>=3 and num_todelete>=2 and num_toreplace>0:\\n                count_lst[i]-=2\\n                num_todelete-=2\\n                num_toreplace-=1\\n\\n        tmp_num=sum([x//3 for x in count_lst])\\n        num_toreplace-=min(num_todelete//3,tmp_num)\\n        # example\\n        # password=\"aaaabbbbccccddeeddeeddeedd\"\\n        # count_lst=[4, 4, 4, 2, 2, 2, 2, 2, 2, 2]\\n        # num_todelete==26-20=6 elements\\n        # ch_let=2 num_toreplace=3\\n        # first loop:\\n        # nothing changes because there is no items in count_lst\\n        # for which x%3==0\\n        # second loop:\\n        # [2,2,2,2,2,2,2,2,2,2]\\n        # num_todelete=0 num_toreplace=0\\n        # tmp_num=0\\n        # num_toreplace=0\\n        # return 26-20+max(0,2)=8\\n        return len(password) - 20 + max(num_toreplace, ch_let)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        \"\"\"\\n        :type password: str\\n        :rtype: int\\n        \"\"\"\\n        stack=list(password)\\n    \\n        ch_len=0\\n        ch_low=0\\n        ch_up=0\\n        ch_dig=0\\n        num_steps=0\\n        ch_del=0\\n        num_ofthree=0\\n\\n\\n        if len(stack)<6:\\n            ch_len=6-len(stack)\\n\\n        i=0\\n\\n        new_s=[] \\n        count_lst=[]\\n        for x in stack:\\n            if x.islower():\\n                ch_low=1\\n            if x.isupper():\\n                ch_up=1\\n            if x.isdigit():\\n                ch_dig=1\\n            if not new_s:\\n                new_s.append([x, 1])\\n\\n            else:\\n                if new_s[-1][0]==x:\\n                    count=new_s[-1][1]\\n                    new_s.pop()\\n                    new_s.append([x, count+1])\\n\\n                else:\\n                    new_s.append([x,1])\\n\\n\\n\\n        ch_let=3-(ch_up+ch_low+ch_dig)\\n\\n        for x in new_s:\\n            count_lst.append(x[1])\\n        \\n\\n        if len(password)<6:\\n            return max(6-len(password),ch_let )\\n            # example\\n            # password=\"aA1\" --> ch_let=0 and need to insert 6-len(password),\\n            # i.e. 6-3=3. Finally return max(3, 0)=3\\n\\n\\n        num_toreplace=sum([x//3 for x in count_lst])\\n        if len(password)<=20:\\n            return max(num_toreplace, ch_let)\\n            # example\\n            # password=\"1111111111\"\\n            # count_lst=[10]\\n            # num_toreplace=10//3=3 ch_let=2, because need to insert capital and .. letters\\n            # \\'11A11a11f1\\' example of replacement and insertion\\n            # return max(3,2)-->3\\n\\n        num_todelete=len(password)-20    \\n\\n        for i,x in enumerate(count_lst):\\n            if x%3==0 and x>=3 and num_todelete>=1 and num_toreplace>0:\\n                count_lst[i]-=1\\n                num_todelete-=1\\n                num_toreplace-=1\\n        for i, x in enumerate(count_lst):\\n            if x%3==1 and x>=3 and num_todelete>=2 and num_toreplace>0:\\n                count_lst[i]-=2\\n                num_todelete-=2\\n                num_toreplace-=1\\n\\n        tmp_num=sum([x//3 for x in count_lst])\\n        num_toreplace-=min(num_todelete//3,tmp_num)\\n        # example\\n        # password=\"aaaabbbbccccddeeddeeddeedd\"\\n        # count_lst=[4, 4, 4, 2, 2, 2, 2, 2, 2, 2]\\n        # num_todelete==26-20=6 elements\\n        # ch_let=2 num_toreplace=3\\n        # first loop:\\n        # nothing changes because there is no items in count_lst\\n        # for which x%3==0\\n        # second loop:\\n        # [2,2,2,2,2,2,2,2,2,2]\\n        # num_todelete=0 num_toreplace=0\\n        # tmp_num=0\\n        # num_toreplace=0\\n        # return 26-20+max(0,2)=8\\n        return len(password) - 20 + max(num_toreplace, ch_let)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144906,
                "title": "10-priority-queue",
                "content": "Our logisitic is that:\\n1. first find how many requirements we need. \\n\\t1. There are length requirement (6<=N<=20)\\n\\t2. There are characters requirement (uppercase, lowercase, digit)\\n\\t3. 3 continuous repeating characters (\\'aaa\\' is invalid)\\n\\tTo find these requirements,\\n\\t\\t1. For length requirement, we compare length of our password `N` with 6 & 20. if it is less than 6, do insertion. if it is larger than 20, do deletion.\\n\\t\\t2. characters requirement can be solved by insertion or replacment. So assume there are `Nc`(0~2) types of characters lacking, we at least need to do `Nc` insertion & Replacement operations.\\n\\t\\t3. repeating characters problem can be solved by insertion/deletion/replacement operations. We use a priority queue to record these characters. Push all subarray consisted of k(k>=3) same characters into it. We can put it at the last.\\n\\t \\n2. For `N`<6, it is easy to do insertion. Just adding a character (`N+1`), fulfill character requirement (`Nc-=1`), cuting a 3 repeating characters (`\\'aaaa\\'->\\'aaBaa\\'`, `k-=2`)\\n3. For `N>20`, we need to try different strategy to break the repeating characters.\\n\\t1. We should do deletion. But to find the minimum operation after doing deletion, we can find that replacement operation can reduce 3 value for a repeating characters string (`\\'aaaaa\\'->\\'aaBaa\\'`, replace 1 and cut 2). But for string whose length can be divided by 3 (`\\'aaaaaa\\'->\\'aaBaaC\\'`), we still need to do 2 operation, and we only need one deletion to reduce one operation (\\'aaaaaa\\'->\\'aaaaa\\'->\\'aaBaa\\'). So we use a priority queue, containing (value, value mod 3). first handle pairs which have less mod, since we need less operation to reach ((k-x)%3 = 2), which takes less operations. Then we can find the optimal strings with deletion. \\n\\t2. Then we push all elements in pq2 into pq. \\n4. Finally, we do replacement operations. each time it is done, reduce the k by 3, and if Nc is not 0, reduce 1. \\n5. If there are any Nc, we need to do additional replacement. so result plus Nc.\\n```java\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    private List<Integer> parse(String password) {\\n        //count the length for each repeat characters\\n        int i = 0;\\n        int j = 0;\\n        List<Integer> tokens = new ArrayList<>();\\n        int N = password.length();\\n        while (j < N) {\\n            int count = 0;\\n            while (j < N && password.charAt(i) == password.charAt(j)) {\\n                count += 1;\\n                j += 1;\\n            }\\n            tokens.add(count);\\n            i = j;\\n        }\\n        return tokens;\\n    }\\n    class Pair{\\n        int v;\\n        int mod;\\n        Pair(int v, int mod) {\\n            this.v = v;\\n            this.mod = mod;\\n        }\\n    }\\n    public int strongPasswordChecker(String password) {\\n        List<Integer> counters = parse(password);\\n        Set<Integer> containment = new HashSet<>();\\n        int operation = 0;\\n        containment.add(1);\\n        containment.add(2);\\n        containment.add(3);\\n        int N = password.length();\\n        for (int i = 0; i < N; i++) {\\n            if(\\'a\\'<=password.charAt(i) && password.charAt(i)<=\\'z\\'){\\n                containment.remove(1);\\n            }else if(\\'A\\'<=password.charAt(i) && password.charAt(i)<=\\'Z\\'){\\n                containment.remove(2);\\n            }else{\\n                containment.remove(3);\\n            }\\n        }\\n        int Nc = containment.size();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        if(N < 6){\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq.offer(counter);\\n                }\\n            }\\n            for (int i = 0; i < 6 - N; i++) {\\n                Nc = Math.max(Nc-1, 0);\\n                if(!pq.isEmpty()){\\n                    int poll = pq.poll();\\n                    poll-=2;\\n                    if(poll >= 3){\\n                        pq.offer(poll);\\n                    }\\n                }\\n                operation+=1;\\n            }\\n        }else if(N > 20){\\n            PriorityQueue<Pair> pq2 = new PriorityQueue<>(Comparator.comparingInt(o -> o.mod));\\n\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq2.add(new Pair(counter, counter % 3));\\n                }\\n            }\\n            int delta = N-20;\\n            while(delta != 0 && !pq2.isEmpty()){\\n                Pair poll = pq2.poll();\\n                if(poll.mod == 0){\\n                    poll.mod = 2;\\n                    poll.v -= 1;\\n                    delta -=1;\\n                    operation += 1;\\n                    if(poll.v >= 3){\\n                        pq2.add(poll);\\n                    }\\n                } else if(poll.mod == 1){\\n                    if(delta >= 2){\\n                        poll.mod = 2;\\n                        poll.v -= 2;\\n                        delta -= 2;\\n                        operation += 2;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }else{\\n                        poll.mod = 0;\\n                        poll.v -= 1;\\n                        delta -= 1;\\n                        operation += 1;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }\\n                }else{\\n                    if(delta >= 3){\\n                        poll.mod = 2;\\n                        poll.v -= 3;\\n                        delta -= 3;\\n                        operation += 3;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }else {\\n                        poll.mod = 1;\\n                        poll.v -= delta;\\n                        operation += delta;\\n                        delta -= delta;\\n\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }\\n                }\\n            }\\n            if(pq2.isEmpty()){\\n                operation+=delta;\\n            }\\n            while(!pq2.isEmpty()){\\n                pq.add(pq2.poll().v);\\n            }\\n        }else{\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq.offer(counter);\\n                }\\n            }\\n        }\\n        while(!pq.isEmpty()){\\n            int poll = pq.poll();\\n            poll-=3;\\n            if(poll >= 3){\\n                pq.offer(poll);\\n            }\\n            Nc = Math.max(Nc-1, 0);\\n            operation += 1;\\n        }\\n        operation += Nc;\\n        return operation;\\n    }\\n\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    private List<Integer> parse(String password) {\\n        //count the length for each repeat characters\\n        int i = 0;\\n        int j = 0;\\n        List<Integer> tokens = new ArrayList<>();\\n        int N = password.length();\\n        while (j < N) {\\n            int count = 0;\\n            while (j < N && password.charAt(i) == password.charAt(j)) {\\n                count += 1;\\n                j += 1;\\n            }\\n            tokens.add(count);\\n            i = j;\\n        }\\n        return tokens;\\n    }\\n    class Pair{\\n        int v;\\n        int mod;\\n        Pair(int v, int mod) {\\n            this.v = v;\\n            this.mod = mod;\\n        }\\n    }\\n    public int strongPasswordChecker(String password) {\\n        List<Integer> counters = parse(password);\\n        Set<Integer> containment = new HashSet<>();\\n        int operation = 0;\\n        containment.add(1);\\n        containment.add(2);\\n        containment.add(3);\\n        int N = password.length();\\n        for (int i = 0; i < N; i++) {\\n            if(\\'a\\'<=password.charAt(i) && password.charAt(i)<=\\'z\\'){\\n                containment.remove(1);\\n            }else if(\\'A\\'<=password.charAt(i) && password.charAt(i)<=\\'Z\\'){\\n                containment.remove(2);\\n            }else{\\n                containment.remove(3);\\n            }\\n        }\\n        int Nc = containment.size();\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        if(N < 6){\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq.offer(counter);\\n                }\\n            }\\n            for (int i = 0; i < 6 - N; i++) {\\n                Nc = Math.max(Nc-1, 0);\\n                if(!pq.isEmpty()){\\n                    int poll = pq.poll();\\n                    poll-=2;\\n                    if(poll >= 3){\\n                        pq.offer(poll);\\n                    }\\n                }\\n                operation+=1;\\n            }\\n        }else if(N > 20){\\n            PriorityQueue<Pair> pq2 = new PriorityQueue<>(Comparator.comparingInt(o -> o.mod));\\n\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq2.add(new Pair(counter, counter % 3));\\n                }\\n            }\\n            int delta = N-20;\\n            while(delta != 0 && !pq2.isEmpty()){\\n                Pair poll = pq2.poll();\\n                if(poll.mod == 0){\\n                    poll.mod = 2;\\n                    poll.v -= 1;\\n                    delta -=1;\\n                    operation += 1;\\n                    if(poll.v >= 3){\\n                        pq2.add(poll);\\n                    }\\n                } else if(poll.mod == 1){\\n                    if(delta >= 2){\\n                        poll.mod = 2;\\n                        poll.v -= 2;\\n                        delta -= 2;\\n                        operation += 2;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }else{\\n                        poll.mod = 0;\\n                        poll.v -= 1;\\n                        delta -= 1;\\n                        operation += 1;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }\\n                }else{\\n                    if(delta >= 3){\\n                        poll.mod = 2;\\n                        poll.v -= 3;\\n                        delta -= 3;\\n                        operation += 3;\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }else {\\n                        poll.mod = 1;\\n                        poll.v -= delta;\\n                        operation += delta;\\n                        delta -= delta;\\n\\n                        if(poll.v >= 3){\\n                            pq2.add(poll);\\n                        }\\n                    }\\n                }\\n            }\\n            if(pq2.isEmpty()){\\n                operation+=delta;\\n            }\\n            while(!pq2.isEmpty()){\\n                pq.add(pq2.poll().v);\\n            }\\n        }else{\\n            for (Integer counter : counters) {\\n                if(counter >= 3) {\\n                    pq.offer(counter);\\n                }\\n            }\\n        }\\n        while(!pq.isEmpty()){\\n            int poll = pq.poll();\\n            poll-=3;\\n            if(poll >= 3){\\n                pq.offer(poll);\\n            }\\n            Nc = Math.max(Nc-1, 0);\\n            operation += 1;\\n        }\\n        operation += Nc;\\n        return operation;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066111,
                "title": "python-solution-91-5-fastest-and-91-78-memory",
                "content": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        no_lower = 1\\n        no_upper = 1\\n        no_num = 1\\n        \\n        repeating = []\\n        \\n        len_pass = len(password)\\n        streak = 1\\n        \\n        for i in range(len_pass):\\n            if password[i].islower():\\n                no_lower = 0\\n            if password[i].isupper():\\n                no_upper = 0\\n            if password[i].isnumeric():\\n                no_num = 0\\n                \\n            if i!=0 and password[i] == prev:\\n                streak +=1\\n            else:\\n                if streak > 2:\\n                    repeating.append(streak)\\n                streak = 1\\n            prev = password[i]\\n            \\n            if i==len_pass-1:\\n                if streak > 2:\\n                    repeating.append(streak)\\n        \\n        reminders = [x%3 for x in repeating]\\n        repeating = [x for _, x in sorted(zip(reminders, repeating))]\\n        reminders = [x%3 for x in repeating]\\n        \\n        dist_case = no_lower + no_upper + no_num\\n        dist = 0\\n        \\n        if len_pass < 6:\\n            dist = max(dist_case, 6-len_pass)\\n            \\n        if len_pass > 20:\\n            dist =  len_pass - 20\\n            while(dist>0 and reminders!=[]):\\n                for i, rem in enumerate(reminders):\\n                    if(rem<dist):\\n                        repeating[i] -= (rem+1)\\n                        dist -= rem+1\\n                    else:\\n                        repeating[i] -= dist\\n                        dist = 0\\n                        break\\n                reminders = [x%3 for x in repeating]\\n                repeating = [x for _, x in sorted(zip(reminders, repeating))]\\n                reminders = [x%3 for x in repeating]\\n            dist =  len_pass - 20\\n            len_pass = 20\\n            \\n        if len_pass >= 6 and len_pass <=20:\\n            dist_rep = 0\\n            for rep in repeating:\\n                dist_rep += int(rep/3//1)\\n            dist += max(dist_case, dist_rep)\\n        \\n        return dist\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        no_lower = 1\\n        no_upper = 1\\n        no_num = 1\\n        \\n        repeating = []\\n        \\n        len_pass = len(password)\\n        streak = 1\\n        \\n        for i in range(len_pass):\\n            if password[i].islower():\\n                no_lower = 0\\n            if password[i].isupper():\\n                no_upper = 0\\n            if password[i].isnumeric():\\n                no_num = 0\\n                \\n            if i!=0 and password[i] == prev:\\n                streak +=1\\n            else:\\n                if streak > 2:\\n                    repeating.append(streak)\\n                streak = 1\\n            prev = password[i]\\n            \\n            if i==len_pass-1:\\n                if streak > 2:\\n                    repeating.append(streak)\\n        \\n        reminders = [x%3 for x in repeating]\\n        repeating = [x for _, x in sorted(zip(reminders, repeating))]\\n        reminders = [x%3 for x in repeating]\\n        \\n        dist_case = no_lower + no_upper + no_num\\n        dist = 0\\n        \\n        if len_pass < 6:\\n            dist = max(dist_case, 6-len_pass)\\n            \\n        if len_pass > 20:\\n            dist =  len_pass - 20\\n            while(dist>0 and reminders!=[]):\\n                for i, rem in enumerate(reminders):\\n                    if(rem<dist):\\n                        repeating[i] -= (rem+1)\\n                        dist -= rem+1\\n                    else:\\n                        repeating[i] -= dist\\n                        dist = 0\\n                        break\\n                reminders = [x%3 for x in repeating]\\n                repeating = [x for _, x in sorted(zip(reminders, repeating))]\\n                reminders = [x%3 for x in repeating]\\n            dist =  len_pass - 20\\n            len_pass = 20\\n            \\n        if len_pass >= 6 and len_pass <=20:\\n            dist_rep = 0\\n            for rep in repeating:\\n                dist_rep += int(rep/3//1)\\n            dist += max(dist_case, dist_rep)\\n        \\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960224,
                "title": "python-solution-i-hate-this-problem-qaq",
                "content": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:  \\n        containLower = 0\\n        containUpper = 0\\n        containDigit = 0   \\n        prevChar = password[0]\\n        repeat = 0\\n        replace = 0\\n        encoded_pwd = []\\n        for l in password:\\n            if l.islower():\\n                containLower = 1\\n            elif l.isupper():\\n                containUpper = 1\\n            elif l.isdigit():\\n                containDigit = 1    \\n            if l == prevChar:\\n                repeat += 1\\n            else:\\n                encoded_pwd.append((prevChar, repeat))\\n                replace += math.ceil((repeat - 2) / 3)\\n                prevChar = l\\n                repeat = 1\\n        encoded_pwd.append((prevChar, repeat))\\n        replace += math.ceil((repeat - 2) / 3)\\n        n = len(password)\\n        delete = 0\\n        tooLong = max(0, n - 20)\\n        if tooLong:\\n            encoded_pwd.sort(key = lambda x: (x[1] - 2) % 3)\\n        for c, freq in encoded_pwd:\\n            if freq >= 3 and (freq - 2) % 3 and tooLong and tooLong >= (freq - 2) % 3:\\n                    tooLong -= (freq - 2) % 3\\n                    delete += (freq - 2) % 3\\n                    replace -= 1\\n        if tooLong:\\n            delete += tooLong\\n            replace -= min(tooLong // 3, replace)\\n        if n < 6:\\n            return max(6 - n, 3 - (containLower + containUpper + containDigit))\\n        elif n <= 20:\\n            return max(replace, 3 - (containLower + containUpper + containDigit))\\n        else:\\n            return max(replace, 3 - (containLower + containUpper + containDigit)) + delete\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:  \\n        containLower = 0\\n        containUpper = 0\\n        containDigit = 0   \\n        prevChar = password[0]\\n        repeat = 0\\n        replace = 0\\n        encoded_pwd = []\\n        for l in password:\\n            if l.islower():\\n                containLower = 1\\n            elif l.isupper():\\n                containUpper = 1\\n            elif l.isdigit():\\n                containDigit = 1    \\n            if l == prevChar:\\n                repeat += 1\\n            else:\\n                encoded_pwd.append((prevChar, repeat))\\n                replace += math.ceil((repeat - 2) / 3)\\n                prevChar = l\\n                repeat = 1\\n        encoded_pwd.append((prevChar, repeat))\\n        replace += math.ceil((repeat - 2) / 3)\\n        n = len(password)\\n        delete = 0\\n        tooLong = max(0, n - 20)\\n        if tooLong:\\n            encoded_pwd.sort(key = lambda x: (x[1] - 2) % 3)\\n        for c, freq in encoded_pwd:\\n            if freq >= 3 and (freq - 2) % 3 and tooLong and tooLong >= (freq - 2) % 3:\\n                    tooLong -= (freq - 2) % 3\\n                    delete += (freq - 2) % 3\\n                    replace -= 1\\n        if tooLong:\\n            delete += tooLong\\n            replace -= min(tooLong // 3, replace)\\n        if n < 6:\\n            return max(6 - n, 3 - (containLower + containUpper + containDigit))\\n        elif n <= 20:\\n            return max(replace, 3 - (containLower + containUpper + containDigit))\\n        else:\\n            return max(replace, 3 - (containLower + containUpper + containDigit)) + delete\\n",
                "codeTag": "Java"
            },
            {
                "id": 1896125,
                "title": "php-solutions-strong-password-checker-100",
                "content": "class Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $PasswordArray = str_split($password);//string to array\\n        \\n        $MissingType = 3;\\n        $NumList = range(48, 57);//(ASCII CODE)0 ~ 9\\n        $EngList_capital = range(65, 90);//(ASCII CODE)A ~ Z\\n        $EngList_lowercase = range(97, 122);//(ASCII CODE)a ~ z\\n        $NumFlag = $CapitalFlag = $LowercaseFlag = false;\\n        foreach($PasswordArray as $key=>$value){\\n            if(!$NumFlag && in_array(ord($value), $NumList)){ //check if is number\\n                $NumFlag = true;\\n            }else if(!$CapitalFlag && in_array(ord($value), $EngList_capital)){ //check if is A~Z\\n                $CapitalFlag = true;\\n            }else if(!$LowercaseFlag && in_array(ord($value), $EngList_lowercase)){ //check if is a~z\\n                $LowercaseFlag = true;\\n            }\\n        }\\n        if($NumFlag) $MissingType--;\\n        if($CapitalFlag) $MissingType--;\\n        if($LowercaseFlag) $MissingType--;\\n        \\n        /*\\n         * check repeat\\n         */\\n        $Change = $One = $Two = 0;\\n        $p = 2;\\n        while($p < strlen($password)){\\n            if($PasswordArray[$p]==$PasswordArray[$p-1] && $PasswordArray[$p]==$PasswordArray[$p-2]){\\n                $RepeatedLength = 2;\\n                while($p<strlen($password) && $PasswordArray[$p]==$PasswordArray[$p-1]){\\n                    $RepeatedLength ++;\\n                    $p ++;\\n                }\\n                $Change += floor($RepeatedLength/3);\\n                if($RepeatedLength%3==0) $One += 1;\\n                if($RepeatedLength%3==1) $Two += 2;\\n            }else{\\n                $p ++;\\n            }\\n        }\\n        \\n        if(strlen($password)<6){\\n            return max($MissingType, 6-strlen($password));\\n        }else if(strlen($password)>=6 && strlen($password)<=20){\\n            return max($MissingType, $Change);\\n        }else if(strlen($password)>20){\\n            $Delete = strlen($password) - 20;\\n            \\n            $Change -= min($Delete, $One);\\n            $Change -= floor(min(max($Delete - $One, 0), $Two) / 2);\\n            $Change -= floor(max($Delete - $One - $Two, 0) / 3);\\n            return $Delete + max($MissingType, $Change);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "PHP"
                ],
                "code": "class Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $PasswordArray = str_split($password);//string to array\\n        \\n        $MissingType = 3;\\n        $NumList = range(48, 57);//(ASCII CODE)0 ~ 9\\n        $EngList_capital = range(65, 90);//(ASCII CODE)A ~ Z\\n        $EngList_lowercase = range(97, 122);//(ASCII CODE)a ~ z\\n        $NumFlag = $CapitalFlag = $LowercaseFlag = false;\\n        foreach($PasswordArray as $key=>$value){\\n            if(!$NumFlag && in_array(ord($value), $NumList)){ //check if is number\\n                $NumFlag = true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1839991,
                "title": "test-case-error",
                "content": "# test case error\\n\\n> just need on step\\n\\n`\"aaa111\"` => `\"Aaa111\"`\\n\\n`\"aaa111\"` => `\"Baa111\"`\\n\\nIn one step, you can:\\n\\nInsert one character to password,\\nDelete one character from password, or\\nReplace one character of password with another character.\\n\\n\\n```js\\n\"aaa111\"\\nOutput\\n1\\nExpected\\n2\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n\"aaa111\"\\nOutput\\n1\\nExpected\\n2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1769945,
                "title": "strong-password-checker-soln-c",
                "content": "class Solution {\\npublic:\\n    \\n    int repeat(string &A){\\n        \\n        vector<string>div;\\n        int start = 0, i = 0;\\n        \\n        \\n        for(i = 1; i<A.size(); i++){\\n            \\n            if(A[i] != A[i-1]){\\n                div.push_back(A.substr(start,i-start));\\n                start = i;\\n            }            \\n            \\n        }\\n        \\n        if(A[i] != A[i-1]){\\n            div.push_back(A.substr(start,i-start));\\n        }   \\n        \\n        for(int i = 0; i < div.size(); i++){\\n            \\n            if(div[i].size() >= 3){\\n                break;\\n            }\\n            else if(i == div.size()-1){\\n                return -1;\\n            }\\n            \\n        }\\n        \\n        int index = 0;\\n        int x = -1, y = -1;\\n        \\n        for(int i = 0; i<div.size(); i++){\\n\\n            int m = div[i].size();\\n            \\n            if(m < 3){\\n                index += m;\\n                continue;\\n            }\\n        \\n            if(m % 3 == 0){\\n                \\n                return index;\\n                \\n            }\\n            \\n            if(m % 3 == 1 and x == -1){\\n                \\n                x = index;\\n                \\n            }\\n            \\n            if(m % 3 == 2 and y == -1){\\n                \\n                y = index;\\n                \\n            }\\n            \\n            index += m;\\n            \\n        }\\n        \\n        if(x != -1){\\n            return x;\\n        }\\n        if(y != -1){\\n            return y;\\n        }        \\n        \\n        \\n        return 0;\\n        \\n    }\\n    \\n    \\n    int check(string &A){\\n        \\n        int total = 3;\\n        bool f1 = true, f2 = true, f3 = true;\\n\\n        for(int i = 0; i < A.size(); i++){\\n            \\n            char x = A[i];\\n            \\n            if(x >= 65 and x <= 90 and f1){\\n                total--;\\n                f1 = false;\\n            } \\n            if(x >= 97 and x <= 122 and f2){\\n                total--;\\n                f2 = false;\\n            }\\n            if(x >= 48 and x <= 57 and f3){\\n                total--;\\n                f3 = false;\\n            }\\n            \\n        } \\n        \\n        return total;   \\n    \\n    }\\n    \\n    int check(string &A, int j){\\n        \\n        int ans = 0;\\n        \\n        for(int i = j-2; i>=0; i--){\\n\\n            if(A[i] == A[i+1] and A[i] == A[i+2]){\\n                ans++;\\n                i -= 2;\\n            }\\n        \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    int strongPasswordChecker(string password) {\\n        \\n        int want = check(password);\\n        int ans = 0;\\n        \\n        if(password.size() < 6){\\n            int c = check(password,password.size()-1);\\n            int d = 6-password.size();\\n            ans = max(c,want);\\n            ans = max(ans,d);\\n            return ans;\\n        }\\n        \\n        while(password.size() > 20){\\n            int ind = repeat(password);\\n            if(ind == -1){\\n                break;\\n            }\\n            password.erase(password.begin() + ind);     \\n            ans++;\\n        }\\n        \\n        int rep = 0;\\n        \\n        while(true){\\n            int ind = repeat(password);\\n            if(ind == -1){\\n                break;\\n            }\\n            password[ind + 2] = \\'#\\';    \\n            rep++;\\n        }\\n        \\n        // cout << password ;\\n        int m = 20;\\n        int siz = password.size();\\n        int t = 0;\\n        \\n        if((siz-m) > t){\\n            t = password.size()-m;\\n        }\\n        \\n        cout << ans << \" \" << want << \" \" << rep << \" \" << t ;\\n        \\n        return ans + max(want,rep) + t;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int repeat(string &A){\\n        \\n        vector<string>div;\\n        int start = 0, i = 0;\\n        \\n        \\n        for(i = 1; i<A.size(); i++){\\n            \\n            if(A[i] != A[i-1]){\\n                div.push_back(A.substr(start,i-start));\\n                start = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1733371,
                "title": "o-n-solution-with-comment-referenced-meng789987-s-answer",
                "content": "```\\nclass Solution {\\n    // 3 cases\\n    //    1. s.len < 6 => insert and replacement. Number of operation is max(steps to meet condition 2, steps to meet condition 3)\\n    //    2. s.len >= 6 and <= 20 => we do replacement only. Number of operation is max(steps to meet condition 2, steps to meet condition 3)\\n    //   3. s.len > 20 => deletion and replacement. Number of operaation is deletion count + max(steps to meet condition 2, steps to meet condition 3)\\n    \\n    // how to meet condition 2? \\n    //    1. initialize 3 variables: step to add upper case, step to add lower case, and step to add digit to 1\\n    //    2. transverse the string, and see what variables can go down to zero\\n    //    3. return the sum of 3 variables\\n    \\n    // how to meet condition 3?\\n    //    1. consider we only do replacement. For every 3 continuous same char like \\'aaa\\', we can replace one of them\\n    //        1.5: if 6 <= s.len <= 20, we can return number of replacement\\n    //    2. if s.len > 20, we need to delete some char, during this time, we can revert some replacement back which to save unnecessary replacement operations. \\n    //        a. if count of chars to be deleted > 0, for 3 continuous same char like \\'aaa\\', we can do one deletion, and save one replacement\\n    //        b. if count of chars to be deleted still > 0, for 3n + 1 continuous same char like \\'aaaa\\', we can do 2 deletions and save one replacement\\n    //        c. if count of chars to be deleted still > 0, we can do 3 deletions and save one replacement\\n    //    3. return deletion count + max(steps to meet condition 2, number of replacement)\\n    \\n    public int strongPasswordChecker(String s) {\\n        // case 1\\n        int len = s.length();\\n        if (len < 6) return Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), 6 - len);\\n        \\n        // case 2 and 3\\n        int replacementCount = 0, placesCanDeleteOneCharToSaveOneReplacement = 0, placesCanDeleteTwoCharsToSaveOneReplacement = 0;  \\n        \\n        // for each iteration, we transverse continuous same chars\\n        for (int i = 0; i < len; i++) {\\n            char currChar = s.charAt(i);\\n            int currCharLen = 1;\\n            while (i + 1 < len && s.charAt(i + 1) == currChar) {\\n                i++;\\n                currCharLen++;\\n            }\\n                   \\n            if (currCharLen >= 3) {\\n                replacementCount += (currCharLen) / 3;     \\n                if (currCharLen % 3 == 0) placesCanDeleteOneCharToSaveOneReplacement++;\\n                if (currCharLen % 3 == 1) placesCanDeleteTwoCharsToSaveOneReplacement++;\\n            }\\n        }\\n        \\n        // case 2\\n        if (len >= 6 && len <= 20) return Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), replacementCount);    \\n             \\n        int charsToBeDeleted = len - 20;\\n        \\n        // we delete one char and save one replacement\\n        // for some cases, we may only need to delete x times, and we have y qualified places. x could be smaller, equal or larger than y, so we need Math.min\\n        // we consider this case first since we only need one deletion to save one replacement, which is the most efficient way\\n        replacementCount -= Math.min(charsToBeDeleted, placesCanDeleteOneCharToSaveOneReplacement);\\n        \\n        // we delete two chars and save one replacement\\n        // charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement represents that, except the case above, how many deletion we still have\\n        // (placesCanDeleteTwoCharsToSaveOneReplacement * 2) means chars to be deleted by this case\\n        // (placesCanDeleteTwoCharsToSaveOneReplacement * 2) / 2 => since every 2 deletion saves one replacement, so we need to devide by 2\\n        replacementCount -= Math.min(Math.max(charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement, 0), placesCanDeleteTwoCharsToSaveOneReplacement * 2) / 2;\\n        \\n        // we delete 3 chars and save one replacement\\n        // logic is similar as above\\n        replacementCount -= Math.max(charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement - 2 * placesCanDeleteTwoCharsToSaveOneReplacement, 0) / 3;\\n        \\n        return charsToBeDeleted + Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), replacementCount);\\n    }\\n    \\n    private int stepsToContainLowerCaseUpperCaseAndDigit (String s) {\\n        int stepToContainLowerCase = 1;\\n        int stepToContainUpperCase = 1;\\n        int stepToContainDigit = 1;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (Character.isDigit(c)) stepToContainDigit = 0;\\n            if (Character.isLowerCase(c)) stepToContainLowerCase = 0;\\n            if (Character.isUpperCase(c)) stepToContainUpperCase = 0;\\n        }\\n        \\n        return stepToContainLowerCase + stepToContainUpperCase + stepToContainDigit;\\n    }\\n}\\n\\n// O(N)\\n// O(1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // 3 cases\\n    //    1. s.len < 6 => insert and replacement. Number of operation is max(steps to meet condition 2, steps to meet condition 3)\\n    //    2. s.len >= 6 and <= 20 => we do replacement only. Number of operation is max(steps to meet condition 2, steps to meet condition 3)\\n    //   3. s.len > 20 => deletion and replacement. Number of operaation is deletion count + max(steps to meet condition 2, steps to meet condition 3)\\n    \\n    // how to meet condition 2? \\n    //    1. initialize 3 variables: step to add upper case, step to add lower case, and step to add digit to 1\\n    //    2. transverse the string, and see what variables can go down to zero\\n    //    3. return the sum of 3 variables\\n    \\n    // how to meet condition 3?\\n    //    1. consider we only do replacement. For every 3 continuous same char like \\'aaa\\', we can replace one of them\\n    //        1.5: if 6 <= s.len <= 20, we can return number of replacement\\n    //    2. if s.len > 20, we need to delete some char, during this time, we can revert some replacement back which to save unnecessary replacement operations. \\n    //        a. if count of chars to be deleted > 0, for 3 continuous same char like \\'aaa\\', we can do one deletion, and save one replacement\\n    //        b. if count of chars to be deleted still > 0, for 3n + 1 continuous same char like \\'aaaa\\', we can do 2 deletions and save one replacement\\n    //        c. if count of chars to be deleted still > 0, we can do 3 deletions and save one replacement\\n    //    3. return deletion count + max(steps to meet condition 2, number of replacement)\\n    \\n    public int strongPasswordChecker(String s) {\\n        // case 1\\n        int len = s.length();\\n        if (len < 6) return Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), 6 - len);\\n        \\n        // case 2 and 3\\n        int replacementCount = 0, placesCanDeleteOneCharToSaveOneReplacement = 0, placesCanDeleteTwoCharsToSaveOneReplacement = 0;  \\n        \\n        // for each iteration, we transverse continuous same chars\\n        for (int i = 0; i < len; i++) {\\n            char currChar = s.charAt(i);\\n            int currCharLen = 1;\\n            while (i + 1 < len && s.charAt(i + 1) == currChar) {\\n                i++;\\n                currCharLen++;\\n            }\\n                   \\n            if (currCharLen >= 3) {\\n                replacementCount += (currCharLen) / 3;     \\n                if (currCharLen % 3 == 0) placesCanDeleteOneCharToSaveOneReplacement++;\\n                if (currCharLen % 3 == 1) placesCanDeleteTwoCharsToSaveOneReplacement++;\\n            }\\n        }\\n        \\n        // case 2\\n        if (len >= 6 && len <= 20) return Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), replacementCount);    \\n             \\n        int charsToBeDeleted = len - 20;\\n        \\n        // we delete one char and save one replacement\\n        // for some cases, we may only need to delete x times, and we have y qualified places. x could be smaller, equal or larger than y, so we need Math.min\\n        // we consider this case first since we only need one deletion to save one replacement, which is the most efficient way\\n        replacementCount -= Math.min(charsToBeDeleted, placesCanDeleteOneCharToSaveOneReplacement);\\n        \\n        // we delete two chars and save one replacement\\n        // charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement represents that, except the case above, how many deletion we still have\\n        // (placesCanDeleteTwoCharsToSaveOneReplacement * 2) means chars to be deleted by this case\\n        // (placesCanDeleteTwoCharsToSaveOneReplacement * 2) / 2 => since every 2 deletion saves one replacement, so we need to devide by 2\\n        replacementCount -= Math.min(Math.max(charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement, 0), placesCanDeleteTwoCharsToSaveOneReplacement * 2) / 2;\\n        \\n        // we delete 3 chars and save one replacement\\n        // logic is similar as above\\n        replacementCount -= Math.max(charsToBeDeleted - placesCanDeleteOneCharToSaveOneReplacement - 2 * placesCanDeleteTwoCharsToSaveOneReplacement, 0) / 3;\\n        \\n        return charsToBeDeleted + Math.max(stepsToContainLowerCaseUpperCaseAndDigit(s), replacementCount);\\n    }\\n    \\n    private int stepsToContainLowerCaseUpperCaseAndDigit (String s) {\\n        int stepToContainLowerCase = 1;\\n        int stepToContainUpperCase = 1;\\n        int stepToContainDigit = 1;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (Character.isDigit(c)) stepToContainDigit = 0;\\n            if (Character.isLowerCase(c)) stepToContainLowerCase = 0;\\n            if (Character.isUpperCase(c)) stepToContainUpperCase = 0;\\n        }\\n        \\n        return stepToContainLowerCase + stepToContainUpperCase + stepToContainDigit;\\n    }\\n}\\n\\n// O(N)\\n// O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651946,
                "title": "why-this-question-has-so-many-dislikes",
                "content": "I agree that this question contains a lot of corner cases, and its really hard to do it in one try.\\nBut why so many dislikes?\\nIs this because constraints are too small ?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1651941,
                "title": "c-solution-very-detailed-and-readable-approach-explanation-with-all-cases",
                "content": "```\\n\\n#define dm 1\\n#define trace1(x) if(dm)cout<<(#x)<<\" \"<<(x)<<endl\\n#define trace2(x,y) if(dm)cout<<(#x)<<\" \"<<(x)<<\", \"<<(#y)<<\" \"<<(y)<<endl\\n#define trace3(x,y,z) if(dm)cout<<(#x)<<\" \"<<(x)<<\", \"<<(#y)<<\" \"<<(y)<<\", \"<<(#z)<<\" \"<<(z)<<endl\\n\\nclass Solution {\\nprivate :\\n    bool islower(char c){\\n        return (c>=\\'a\\' && c<=\\'z\\') ;\\n    }\\n    \\n    bool isupper(char c){\\n        return (c>=\\'A\\' && c<=\\'Z\\') ;\\n    }\\n    bool isdig(char c){\\n        return (c>=\\'1\\' && c<=\\'9\\') ;\\n    }\\n    \\n    int cnt_min_repl(vector<int>& groups){\\n        int res =0;\\n        for(int i : groups){\\n            res += i/3 ;\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int strongPasswordChecker(string pass) {\\n        /*\\n        count required inssertion\\n        ->lower?\\n        ->uppercase?\\n        ->digit\\n        \\n        req_insert = 0,1,2,3 \\n        \\n        count consective groups\\n        \\n        if there are groups of size > 2, we would have to \\n        -> remove extra char \\n        -> or add diff. char in the middle (replacement/insertion)\\n        -> might have to totally remove a group, creating yet another diff. group\\n        \\n        (aaabbb)*8 -> length 48\\n        \\n        \\n        \\n        Which step to take\\n        ->depends on groups[]\\n        ->depend on current size of string too.\\n        ->depend on if insertions are req.\\n        \\n        \\n        \\n        -> If n < 6 \\n            you can just insert req. (type of char which aren\\'t there)\\n            and then make the length >= 6 somehow. \\n            you will be done.\\n            \\n        -> If n is in [6, 20]\\n            -> try to do replacements \\n            -> check groups [] \\n            ->      group size     2    3,4,5   6,7,8   9 \\n                replacement req.   0    1       2       3\\n            -> find total replacements req.\\n            -> ans = max(tot_repl, req_insert)\\n            \\n        -> If n > 20\\n            -> we need deletion (al least n-20 deletions)\\n            -> aaaaa -> aaaa -> aaa -> aa / aaaaa-> aa.aa -> aa.a\\n            -> aaa -> aa / aaa -> aa. -> a.\\n            -> decision of deletion and replacements.\\n            -> we might have to do the req. insertions\\n            -> might have to delete groups of size 2,1\\n            \\n            -> first delete and get size==20, \\n            -> in a way to be able to have min. replacement left to be done\\n            \\n            -> the do like case with n==20 (above)\\n            \\n            (ab)*25\\n            \\n            ???\\n            -> pick the groups with size%3==0 and delete one\\n            -> pick the groups with size%3==1 and delete two\\n            -> pick the group with size%3==2 .... delete three.\\n            -> keep doing till all groups of size >=3 goes away,\\n            -> or string become of size==20\\n            \\n            -> we won\\'t like to delete groups with size<=2\\n            -> there can be at most 16 groups of size >=3 \\n            -> first make all groups size <=2 or make total size==20\\n            -> if all groups are of size<=2, there exist a strategy to \\n                just delete n-20 character and not letting any new group form \\n                \\'by unintentional merging\\'.\\n            -> then do the req. char insertions by replacement\\n        */\\n        \\n        int low_req = 1;\\n        int upper_req = 1;\\n        int dig_req = 1;\\n        int n = pass.size();\\n        \\n        vector<int> groups;\\n        \\n        int st=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            if(islower(pass[i])) low_req = 0;\\n            else if(isupper(pass[i])) upper_req = 0;\\n            else if(isdig(pass[i])) dig_req = 0;\\n            \\n            if(i==n-1 || pass[i+1]!=pass[st]){\\n                // current groups ends at i\\n                // st..i\\n                groups.push_back(i-st+1);\\n                \\n                // start a new group from i+1\\n                st=i+1;\\n            }            \\n        }\\n        \\n        int req_insert = low_req + upper_req + dig_req ;\\n        int ans = 0;\\n        \\n        if(n<6){\\n            ans = max(req_insert, 6-n) ;\\n        }\\n        else if(n>=6 && n<=20){\\n            // just replacements\\n            int req_repl = cnt_min_repl(groups);\\n            ans = max(req_repl, req_insert) ;\\n        }\\n        else{\\n            // do the deletions\\n            int m = groups.size();\\n            \\n            int deletions = 0;\\n            int cur_delete = 0;\\n            int cur_delete_cnt = 0;\\n            \\n            while(n>20){\\n                cur_delete_cnt = 0;\\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==0\\n                    if(groups[i]>=3 && groups[i]%3==0){\\n                        groups[i]--;\\n                        deletions++;\\n                        n--;  // Mistake : didn\\'t decreased n\\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==1\\n                    if(groups[i]>=3 && groups[i]%3==1){\\n                        // can delete one of two depending on n\\n                        cur_delete = min(2, n-20) ;\\n                        deletions += cur_delete;\\n                        groups[i] -= cur_delete ;\\n                        \\n                        n-=cur_delete;\\n                        \\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                \\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==2\\n                    if(groups[i]>=3 && groups[i]%3==2){\\n                        // can delete one of two or three depending on n\\n                        cur_delete = min(3, n-20) ;\\n                        deletions += cur_delete;\\n                        groups[i] -= cur_delete ;\\n                        n-=cur_delete;\\n                        \\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                \\n                if(cur_delete_cnt == 0){\\n                    break;\\n                }\\n                \\n            }\\n            \\n            // now either there are no groups of size >=3 and n>20 still\\n            // or there are some, but n==20\\n            int req_repl = cnt_min_repl(groups);\\n            \\n            //if(dm) trace3(req_repl, n, deletions);\\n            \\n            assert(req_repl == 0 || n==20) ;\\n            \\n            // Mistake : forgot this\\n            if(n>20){\\n                assert(req_repl==0);\\n                deletions += n-20;\\n                n=20;\\n            }\\n            \\n            ans = deletions + max(req_repl, req_insert) ;\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n#define dm 1\\n#define trace1(x) if(dm)cout<<(#x)<<\" \"<<(x)<<endl\\n#define trace2(x,y) if(dm)cout<<(#x)<<\" \"<<(x)<<\", \"<<(#y)<<\" \"<<(y)<<endl\\n#define trace3(x,y,z) if(dm)cout<<(#x)<<\" \"<<(x)<<\", \"<<(#y)<<\" \"<<(y)<<\", \"<<(#z)<<\" \"<<(z)<<endl\\n\\nclass Solution {\\nprivate :\\n    bool islower(char c){\\n        return (c>=\\'a\\' && c<=\\'z\\') ;\\n    }\\n    \\n    bool isupper(char c){\\n        return (c>=\\'A\\' && c<=\\'Z\\') ;\\n    }\\n    bool isdig(char c){\\n        return (c>=\\'1\\' && c<=\\'9\\') ;\\n    }\\n    \\n    int cnt_min_repl(vector<int>& groups){\\n        int res =0;\\n        for(int i : groups){\\n            res += i/3 ;\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int strongPasswordChecker(string pass) {\\n        /*\\n        count required inssertion\\n        ->lower?\\n        ->uppercase?\\n        ->digit\\n        \\n        req_insert = 0,1,2,3 \\n        \\n        count consective groups\\n        \\n        if there are groups of size > 2, we would have to \\n        -> remove extra char \\n        -> or add diff. char in the middle (replacement/insertion)\\n        -> might have to totally remove a group, creating yet another diff. group\\n        \\n        (aaabbb)*8 -> length 48\\n        \\n        \\n        \\n        Which step to take\\n        ->depends on groups[]\\n        ->depend on current size of string too.\\n        ->depend on if insertions are req.\\n        \\n        \\n        \\n        -> If n < 6 \\n            you can just insert req. (type of char which aren\\'t there)\\n            and then make the length >= 6 somehow. \\n            you will be done.\\n            \\n        -> If n is in [6, 20]\\n            -> try to do replacements \\n            -> check groups [] \\n            ->      group size     2    3,4,5   6,7,8   9 \\n                replacement req.   0    1       2       3\\n            -> find total replacements req.\\n            -> ans = max(tot_repl, req_insert)\\n            \\n        -> If n > 20\\n            -> we need deletion (al least n-20 deletions)\\n            -> aaaaa -> aaaa -> aaa -> aa / aaaaa-> aa.aa -> aa.a\\n            -> aaa -> aa / aaa -> aa. -> a.\\n            -> decision of deletion and replacements.\\n            -> we might have to do the req. insertions\\n            -> might have to delete groups of size 2,1\\n            \\n            -> first delete and get size==20, \\n            -> in a way to be able to have min. replacement left to be done\\n            \\n            -> the do like case with n==20 (above)\\n            \\n            (ab)*25\\n            \\n            ???\\n            -> pick the groups with size%3==0 and delete one\\n            -> pick the groups with size%3==1 and delete two\\n            -> pick the group with size%3==2 .... delete three.\\n            -> keep doing till all groups of size >=3 goes away,\\n            -> or string become of size==20\\n            \\n            -> we won\\'t like to delete groups with size<=2\\n            -> there can be at most 16 groups of size >=3 \\n            -> first make all groups size <=2 or make total size==20\\n            -> if all groups are of size<=2, there exist a strategy to \\n                just delete n-20 character and not letting any new group form \\n                \\'by unintentional merging\\'.\\n            -> then do the req. char insertions by replacement\\n        */\\n        \\n        int low_req = 1;\\n        int upper_req = 1;\\n        int dig_req = 1;\\n        int n = pass.size();\\n        \\n        vector<int> groups;\\n        \\n        int st=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            if(islower(pass[i])) low_req = 0;\\n            else if(isupper(pass[i])) upper_req = 0;\\n            else if(isdig(pass[i])) dig_req = 0;\\n            \\n            if(i==n-1 || pass[i+1]!=pass[st]){\\n                // current groups ends at i\\n                // st..i\\n                groups.push_back(i-st+1);\\n                \\n                // start a new group from i+1\\n                st=i+1;\\n            }            \\n        }\\n        \\n        int req_insert = low_req + upper_req + dig_req ;\\n        int ans = 0;\\n        \\n        if(n<6){\\n            ans = max(req_insert, 6-n) ;\\n        }\\n        else if(n>=6 && n<=20){\\n            // just replacements\\n            int req_repl = cnt_min_repl(groups);\\n            ans = max(req_repl, req_insert) ;\\n        }\\n        else{\\n            // do the deletions\\n            int m = groups.size();\\n            \\n            int deletions = 0;\\n            int cur_delete = 0;\\n            int cur_delete_cnt = 0;\\n            \\n            while(n>20){\\n                cur_delete_cnt = 0;\\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==0\\n                    if(groups[i]>=3 && groups[i]%3==0){\\n                        groups[i]--;\\n                        deletions++;\\n                        n--;  // Mistake : didn\\'t decreased n\\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==1\\n                    if(groups[i]>=3 && groups[i]%3==1){\\n                        // can delete one of two depending on n\\n                        cur_delete = min(2, n-20) ;\\n                        deletions += cur_delete;\\n                        groups[i] -= cur_delete ;\\n                        \\n                        n-=cur_delete;\\n                        \\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                \\n                for(int i=0; i<m && n>20; i++){\\n                    // pick group with cnt%3==2\\n                    if(groups[i]>=3 && groups[i]%3==2){\\n                        // can delete one of two or three depending on n\\n                        cur_delete = min(3, n-20) ;\\n                        deletions += cur_delete;\\n                        groups[i] -= cur_delete ;\\n                        n-=cur_delete;\\n                        \\n                        cur_delete_cnt++;\\n                    }\\n                }\\n                \\n                if(cur_delete_cnt == 0){\\n                    break;\\n                }\\n                \\n            }\\n            \\n            // now either there are no groups of size >=3 and n>20 still\\n            // or there are some, but n==20\\n            int req_repl = cnt_min_repl(groups);\\n            \\n            //if(dm) trace3(req_repl, n, deletions);\\n            \\n            assert(req_repl == 0 || n==20) ;\\n            \\n            // Mistake : forgot this\\n            if(n>20){\\n                assert(req_repl==0);\\n                deletions += n-20;\\n                n=20;\\n            }\\n            \\n            ans = deletions + max(req_repl, req_insert) ;\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1619856,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\nint lastdel,lasttwodel,lastthreedel=0;\\nint findRepitiveCount(string str, int n)\\n{\\n    int rep=1;\\n    int i=0;\\n    int j=i+1;\\n    int count=0;\\n\\n    while(i<n&&j<=n)\\n    {\\n        if(str[i]==str[j])\\n        {\\n            rep++;\\n            j++;\\n            if(rep%3==0)\\n            {\\n                count++;\\n            }\\n        }\\n        else\\n        {\\n            if(rep%3==0)\\n                lastdel++;\\n            else if(rep%3==1&&rep>3)\\n                lasttwodel++;\\n            else if(rep%3==2&&rep>3)\\n                lastthreedel++;\\n                \\n            rep=1;\\n            i=j++;\\n        }\\n    }\\n    return count;\\n}\\n\\n    \\n    int strongPasswordChecker(string str) {\\n    int n=str.length();\\n    int r=0;\\n    if(n>20)\\n    {\\n        r=n-20;\\n    }\\n    int rcount=findRepitiveCount(str, n);\\n    bool isDigit=false;\\n    bool isUpper=false;\\n    bool isSmall=false;\\n    int count=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(str[i]>=65&&str[i]<=90)\\n        {\\n            isUpper=true;\\n        }\\n        else if(str[i]>=97&&str[i]<=122)\\n        {\\n            isSmall=true;\\n        }\\n        else if(str[i]-\\'0\\'>=0&&str[i]-\\'0\\'<=9)\\n        {\\n            isDigit=true;\\n        }\\n    }\\n    \\n    if(!isUpper)\\n        count++;\\n    if(!isDigit)\\n        count++;\\n    if(!isSmall)\\n        count++;\\n        \\n    if(n<6)\\n    {\\n        int i=6-n;\\n        return max(count,i);\\n    }\\n\\n    rcount=rcount-min(r,lastdel);\\n    rcount=rcount-min(max(r-lastdel, 0), 2*lasttwodel)/2;\\n    rcount=rcount-min(max(r-lastdel-2*lasttwodel, 0),3*lastthreedel)/3;\\n    rcount=rcount-max(r-lastdel-2*lasttwodel-3*lastthreedel, 0) /3;\\n    count=r+max(rcount,count);\\n    return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint lastdel,lasttwodel,lastthreedel=0;\\nint findRepitiveCount(string str, int n)\\n{\\n    int rep=1;\\n    int i=0;\\n    int j=i+1;\\n    int count=0;\\n\\n    while(i<n&&j<=n)\\n    {\\n        if(str[i]==str[j])\\n        {\\n            rep++;\\n            j++;\\n            if(rep%3==0)\\n            {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1452989,
                "title": "30-lines-too-easy-no-any-lib-functions-used-0ms-5-5mb-c-c",
                "content": "```\\nint strongPasswordChecker(char* p) {\\n\\tint req = 7, len = 0, steps = 0, dels, repeatStrs = 0, mod0 = 0, mod1 = 0;\\n\\tfor (int counter; *p; p++, len++) {\\n\\t\\tif (*p >= \\'0\\' && *p <= \\'9\\')\\t\\t req &= 6;\\n\\t\\telse if (*p >= \\'A\\' && *p <= \\'Z\\') req &= 5;\\n\\t\\telse if (*p >= \\'a\\' && *p <= \\'z\\') req &= 3;\\n\\t\\tfor (counter = 1; *p == *(p + 1); counter++, p++, len++);\\n\\t\\tif (counter > 2) {\\n\\t\\t\\tif (counter % 3 == 0) mod0 ++;\\n\\t\\t\\telse if (counter % 3 == 1) mod1 ++;\\n\\t\\t\\trepeatStrs += (counter / 3);\\n\\t\\t}\\n\\t}\\n\\tif ((dels = len - 20) > 0) steps += dels;\\n\\treq = (req & 1) + ((req >> 1) & 1) + ((req >> 2) & 1);\\n\\tif (len < 6) return 6 - len > req ? 6 - len : req;\\n\\twhile (dels > 0 && mod0) {\\n\\t\\tdels -= 1;\\n\\t\\tmod0--;\\n\\t\\trepeatStrs--;\\n\\t}\\t\\n\\twhile (dels > 1 && mod1) {\\n\\t\\tdels -= 2;\\n\\t\\tmod1--;\\n\\t\\trepeatStrs--;\\n\\t}\\n\\twhile (dels > 2 && repeatStrs) {\\n\\t\\tdels -= 3;\\n\\t\\trepeatStrs--;\\n\\t}\\n\\treturn steps + repeatStrs > req ? repeatStrs : req;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint strongPasswordChecker(char* p) {\\n\\tint req = 7, len = 0, steps = 0, dels, repeatStrs = 0, mod0 = 0, mod1 = 0;\\n\\tfor (int counter; *p; p++, len++) {\\n\\t\\tif (*p >= \\'0\\' && *p <= \\'9\\')\\t\\t req &= 6;\\n\\t\\telse if (*p >= \\'A\\' && *p <= \\'Z\\') req &= 5;\\n\\t\\telse if (*p >= \\'a\\' && *p <= \\'z\\') req &= 3;\\n\\t\\tfor (counter = 1; *p == *(p + 1); counter++, p++, len++);\\n\\t\\tif (counter > 2) {\\n\\t\\t\\tif (counter % 3 == 0) mod0 ++;\\n\\t\\t\\telse if (counter % 3 == 1) mod1 ++;\\n\\t\\t\\trepeatStrs += (counter / 3);\\n\\t\\t}\\n\\t}\\n\\tif ((dels = len - 20) > 0) steps += dels;\\n\\treq = (req & 1) + ((req >> 1) & 1) + ((req >> 2) & 1);\\n\\tif (len < 6) return 6 - len > req ? 6 - len : req;\\n\\twhile (dels > 0 && mod0) {\\n\\t\\tdels -= 1;\\n\\t\\tmod0--;\\n\\t\\trepeatStrs--;\\n\\t}\\t\\n\\twhile (dels > 1 && mod1) {\\n\\t\\tdels -= 2;\\n\\t\\tmod1--;\\n\\t\\trepeatStrs--;\\n\\t}\\n\\twhile (dels > 2 && repeatStrs) {\\n\\t\\tdels -= 3;\\n\\t\\trepeatStrs--;\\n\\t}\\n\\treturn steps + repeatStrs > req ? repeatStrs : req;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383489,
                "title": "carefully-handcrafted-c-solution-100-faster",
                "content": "```\\n#include <iostream>\\n\\n// #define DEBUG\\n\\n#ifdef DEBUG\\n#define P(X)\\\\\\ncout << #X\": \" << (X) << endl;\\n#else\\n#define P(X)\\n#endif\\n\\nint AddViolation(const string& pw) {\\n    if(pw.size() < 6) { return 6-pw.size(); }\\n    return 0;\\n}\\n\\nint RemoveViolation(const string& pw) {\\n    if(pw.size() > 20) { return pw.size() - 20; }\\n    return 0;\\n}\\n\\n\\nint LCViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'a\\' && c <= \\'z\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nint UCViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'A\\' && c <= \\'Z\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nint DigViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'0\\' && c <= \\'9\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nvector<int> Sequences(const string& pw) {\\n    // Find all sequences of equal chars.\\n    vector<int> result;\\n    int ii = 1;\\n    int cur_rep = 1;\\n    while(ii < pw.size()) {\\n        if(pw[ii] == pw[ii-1]) {\\n            ++cur_rep;\\n        } else {\\n            // Just broke the current repetition.\\n            if(cur_rep >= 3) {\\n                result.push_back(cur_rep);\\n            }\\n            cur_rep = 1;\\n        }\\n        ++ii;\\n    }\\n    if(cur_rep >= 3) {\\n        result.push_back(cur_rep);\\n    }\\n    return result;\\n}\\n\\nint SequenceViolation(const string& pw, int change, int add, int remove) {\\n    auto sequences = Sequences(pw);\\n    \\n    auto remove_short_sequences = [&sequences] {\\n        sequences.erase(\\n            std::remove_if(sequences.begin(), sequences.end(), [](int s){ return s<3; }),\\n            sequences.end()\\n        );    \\n    };\\n    auto print_sequences = [&sequences] {\\n        for(int s : sequences) {\\n            cout << s << \", \";\\n        }\\n        cout << endl;\\n        return \"\";\\n    };\\n    \\n    remove_short_sequences();\\n    if(sequences.empty()) { return 0; }\\n    \\n    P(change)\\n    P(add)\\n    P(remove)\\n    \\n    for(auto sinit : sequences) {\\n        P(sinit)\\n    }\\n    \\n    // change\\n    P(\"change\")\\n    while(change > 0 && !sequences.empty()) {\\n        // sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return (a/2)%3 > (b/2)%3;});\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        int sorig = s-1;\\n        // int s1 = floor(sorig/2);\\n        int s1 = 2;\\n        int s2 = sorig - s1;\\n        s = s1;\\n        sequences.push_back(s2);\\n        --change;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after change\")\\n    P(print_sequences())\\n    \\n    // add\\n    P(\"add\")\\n    while(add > 0 && !sequences.empty()) {\\n        // sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return (a/2)%3 > (b/2)%3;});\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        int sorig = s;\\n        // int s1 = floor(sorig/2);\\n        int s1 = 2;\\n        int s2 = sorig - s1;\\n        s = s1;\\n        sequences.push_back(s2);\\n        --add;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after add\")\\n    P(print_sequences())\\n    \\n    // remove\\n    P(\"remove\")\\n    while(remove > 0 && !sequences.empty()) {\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        --s;\\n        --remove;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after remove\")\\n    P(print_sequences())\\n    \\n    \\n    int violation = 0;\\n    for(auto s : sequences) {\\n        violation += s/3;\\n    }\\n    \\n    return violation;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        P(password)\\n            \\n        int remove = RemoveViolation(password);\\n        int add = AddViolation(password);\\n        int lc = LCViolation(password);\\n        int uc = UCViolation(password);\\n        int dig = DigViolation(password);\\n        \\n        P(remove)\\n        P(add)\\n        P(lc)\\n        P(uc)\\n        P(dig)\\n        \\n        int changes = max(0, dig+lc+uc-add);\\n        int seq = SequenceViolation(password, changes, add, remove);\\n        \\n        P(changes)\\n        P(seq)\\n        P(remove)\\n        P(add)\\n\\n        return remove+add+changes+seq;\\n    }\\n};\\n```\\n\\nNot the prettiest code, but works. It\\'s based on counting the number of changes required to fix the trivial violations (lower case, upper case, digits, addition and removal) and figuring out how many of those you can use to fix the tricky sequence constraint violations.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#include <iostream>\\n\\n// #define DEBUG\\n\\n#ifdef DEBUG\\n#define P(X)\\\\\\ncout << #X\": \" << (X) << endl;\\n#else\\n#define P(X)\\n#endif\\n\\nint AddViolation(const string& pw) {\\n    if(pw.size() < 6) { return 6-pw.size(); }\\n    return 0;\\n}\\n\\nint RemoveViolation(const string& pw) {\\n    if(pw.size() > 20) { return pw.size() - 20; }\\n    return 0;\\n}\\n\\n\\nint LCViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'a\\' && c <= \\'z\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nint UCViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'A\\' && c <= \\'Z\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nint DigViolation(const string& pw) {\\n    for(auto c : pw) {\\n        if(c == \\'?\\' || (c >= \\'0\\' && c <= \\'9\\')) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\nvector<int> Sequences(const string& pw) {\\n    // Find all sequences of equal chars.\\n    vector<int> result;\\n    int ii = 1;\\n    int cur_rep = 1;\\n    while(ii < pw.size()) {\\n        if(pw[ii] == pw[ii-1]) {\\n            ++cur_rep;\\n        } else {\\n            // Just broke the current repetition.\\n            if(cur_rep >= 3) {\\n                result.push_back(cur_rep);\\n            }\\n            cur_rep = 1;\\n        }\\n        ++ii;\\n    }\\n    if(cur_rep >= 3) {\\n        result.push_back(cur_rep);\\n    }\\n    return result;\\n}\\n\\nint SequenceViolation(const string& pw, int change, int add, int remove) {\\n    auto sequences = Sequences(pw);\\n    \\n    auto remove_short_sequences = [&sequences] {\\n        sequences.erase(\\n            std::remove_if(sequences.begin(), sequences.end(), [](int s){ return s<3; }),\\n            sequences.end()\\n        );    \\n    };\\n    auto print_sequences = [&sequences] {\\n        for(int s : sequences) {\\n            cout << s << \", \";\\n        }\\n        cout << endl;\\n        return \"\";\\n    };\\n    \\n    remove_short_sequences();\\n    if(sequences.empty()) { return 0; }\\n    \\n    P(change)\\n    P(add)\\n    P(remove)\\n    \\n    for(auto sinit : sequences) {\\n        P(sinit)\\n    }\\n    \\n    // change\\n    P(\"change\")\\n    while(change > 0 && !sequences.empty()) {\\n        // sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return (a/2)%3 > (b/2)%3;});\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        int sorig = s-1;\\n        // int s1 = floor(sorig/2);\\n        int s1 = 2;\\n        int s2 = sorig - s1;\\n        s = s1;\\n        sequences.push_back(s2);\\n        --change;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after change\")\\n    P(print_sequences())\\n    \\n    // add\\n    P(\"add\")\\n    while(add > 0 && !sequences.empty()) {\\n        // sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return (a/2)%3 > (b/2)%3;});\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        int sorig = s;\\n        // int s1 = floor(sorig/2);\\n        int s1 = 2;\\n        int s2 = sorig - s1;\\n        s = s1;\\n        sequences.push_back(s2);\\n        --add;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after add\")\\n    P(print_sequences())\\n    \\n    // remove\\n    P(\"remove\")\\n    while(remove > 0 && !sequences.empty()) {\\n        sort(sequences.begin(), sequences.end(), [](auto a, auto b) { return a%3 < b%3;});\\n        P(print_sequences())\\n        auto& s = sequences.front();\\n        --s;\\n        --remove;\\n        remove_short_sequences();\\n    }\\n    \\n    P(\"after remove\")\\n    P(print_sequences())\\n    \\n    \\n    int violation = 0;\\n    for(auto s : sequences) {\\n        violation += s/3;\\n    }\\n    \\n    return violation;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        P(password)\\n            \\n        int remove = RemoveViolation(password);\\n        int add = AddViolation(password);\\n        int lc = LCViolation(password);\\n        int uc = UCViolation(password);\\n        int dig = DigViolation(password);\\n        \\n        P(remove)\\n        P(add)\\n        P(lc)\\n        P(uc)\\n        P(dig)\\n        \\n        int changes = max(0, dig+lc+uc-add);\\n        int seq = SequenceViolation(password, changes, add, remove);\\n        \\n        P(changes)\\n        P(seq)\\n        P(remove)\\n        P(add)\\n\\n        return remove+add+changes+seq;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1232978,
                "title": "2-hour-work-beat-100-not-clean",
                "content": "Here shares my solution without any further cleaning, which is exactly my thought process. The way the loops are written means this can usually be greatly simplified with some math.\\n\\nWhy so many downvote for the problem I guess this will be too stressful in an interview and the solution won\\'t help any other problem. The intuition at the beginning I pretty much wrote down in 3 minutes; going ahead to implement it is a gamble, and code 90 lines (less lines would require more time) in 40min? No. I didn\\'t clean the code so it is easier for you to understand the algorithm.\\n\\nKeep points,\\n1. How to handle missing character type? Keep a count (max 3) and decrease it with any operation (add/replace) that can fix a type. This way missing types are fixed while doing other operations so is optimal.\\n2. Which chars to delete? First delete 1 char from all 3k len seqs, then 2 chars from all 3k+1 len seqs, then the rest. Just draw it out in a code comment and you will see.\\n\\nProof of the greedy correctness? Too tiring not sure I can do it now.\\n\\n```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        // Greedy\\n        // 1. Find all consecutive chars.\\n        //    If total more than 20, delete till 2 or 20.\\n        //    If total is less than 6, insert after every 2, else replace the next one.\\n        // 2. Keep a count of above operations, that can cover missing types. If still missing, add till 6 then replace.\\n        // 3. If still less than 6. Add (however) till 6. If more than 20, remove (however) till 20.\\n        // Miss any case?\\n        \\n        int len = password.length();\\n        boolean seenLower = false;\\n        boolean seenUpper = false;\\n        boolean seenDigit = false;\\n        \\n        int ops = 0;\\n        \\n        List<Integer> tobreak = new ArrayList<>();\\n        \\n        Character prev = null;\\n        int cnt = 0;\\n        for (char c : password.toCharArray()) {\\n            if (\\'a\\' <= c && c <= \\'z\\') seenLower = true;\\n            if (\\'A\\' <= c && c <= \\'Z\\') seenUpper = true;\\n            if (\\'0\\' <= c && c <= \\'9\\') seenDigit = true;\\n            if (prev == null || c != prev) {\\n                if (cnt >= 3) {\\n                    if (len > 20 && cnt % 3 == 0) {\\n                        // delete 1 from aaaaaa\\n                        cnt--;\\n                        len--;\\n                        ops++;\\n                    }\\n                    if (cnt >= 3) tobreak.add(cnt);\\n                }\\n                prev = c;\\n                cnt = 1;\\n            } else {\\n                cnt++;\\n            }\\n        }\\n        if (cnt >= 3) {\\n            if (len > 20 && cnt % 3 == 0) {\\n                cnt--;\\n                len--;\\n                ops++;\\n            }\\n            if (cnt >= 3) tobreak.add(cnt);\\n        }\\n        \\n        int typeReq = 0;\\n        if (!seenLower) typeReq++;\\n        if (!seenUpper) typeReq++;\\n        if (!seenDigit) typeReq++;\\n        \\n        for (int i = 0; i < tobreak.size(); i++) { \\n            int c = tobreak.get(i);\\n            if (len > 21 && c % 3 == 1) {\\n                // delete 2 from aaaa\\n                len -= 2;\\n                c -= 2;\\n                ops += 2;\\n                tobreak.set(i, c);\\n            }\\n        }\\n        \\n        for (int c : tobreak) {            \\n            if (len > 20) {\\n                // aaaaa or it no longer matters\\n                int r = Math.min(len - 20, c - 2);\\n                len -= r;\\n                c -= r;\\n                ops += r;\\n            }\\n            \\n            while (c > 2 && len < 6) { // usually this loop can be replaced with math\\n                // add 1 char after every 2\\n                len++;\\n                c -= 2;\\n                ops++;\\n                typeReq--;\\n            }\\n            \\n            // replace every 3rd char\\n            ops += c / 3;\\n            typeReq -= c / 3;\\n        }\\n        \\n        if (len < 6) {\\n            ops += 6 - len;\\n            typeReq -= 6 - len;\\n        }\\n        if (len > 20) ops += len - 20;\\n        \\n        if (typeReq > 0) ops += typeReq;\\n        \\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        // Greedy\\n        // 1. Find all consecutive chars.\\n        //    If total more than 20, delete till 2 or 20.\\n        //    If total is less than 6, insert after every 2, else replace the next one.\\n        // 2. Keep a count of above operations, that can cover missing types. If still missing, add till 6 then replace.\\n        // 3. If still less than 6. Add (however) till 6. If more than 20, remove (however) till 20.\\n        // Miss any case?\\n        \\n        int len = password.length();\\n        boolean seenLower = false;\\n        boolean seenUpper = false;\\n        boolean seenDigit = false;\\n        \\n        int ops = 0;\\n        \\n        List<Integer> tobreak = new ArrayList<>();\\n        \\n        Character prev = null;\\n        int cnt = 0;\\n        for (char c : password.toCharArray()) {\\n            if (\\'a\\' <= c && c <= \\'z\\') seenLower = true;\\n            if (\\'A\\' <= c && c <= \\'Z\\') seenUpper = true;\\n            if (\\'0\\' <= c && c <= \\'9\\') seenDigit = true;\\n            if (prev == null || c != prev) {\\n                if (cnt >= 3) {\\n                    if (len > 20 && cnt % 3 == 0) {\\n                        // delete 1 from aaaaaa\\n                        cnt--;\\n                        len--;\\n                        ops++;\\n                    }\\n                    if (cnt >= 3) tobreak.add(cnt);\\n                }\\n                prev = c;\\n                cnt = 1;\\n            } else {\\n                cnt++;\\n            }\\n        }\\n        if (cnt >= 3) {\\n            if (len > 20 && cnt % 3 == 0) {\\n                cnt--;\\n                len--;\\n                ops++;\\n            }\\n            if (cnt >= 3) tobreak.add(cnt);\\n        }\\n        \\n        int typeReq = 0;\\n        if (!seenLower) typeReq++;\\n        if (!seenUpper) typeReq++;\\n        if (!seenDigit) typeReq++;\\n        \\n        for (int i = 0; i < tobreak.size(); i++) { \\n            int c = tobreak.get(i);\\n            if (len > 21 && c % 3 == 1) {\\n                // delete 2 from aaaa\\n                len -= 2;\\n                c -= 2;\\n                ops += 2;\\n                tobreak.set(i, c);\\n            }\\n        }\\n        \\n        for (int c : tobreak) {            \\n            if (len > 20) {\\n                // aaaaa or it no longer matters\\n                int r = Math.min(len - 20, c - 2);\\n                len -= r;\\n                c -= r;\\n                ops += r;\\n            }\\n            \\n            while (c > 2 && len < 6) { // usually this loop can be replaced with math\\n                // add 1 char after every 2\\n                len++;\\n                c -= 2;\\n                ops++;\\n                typeReq--;\\n            }\\n            \\n            // replace every 3rd char\\n            ops += c / 3;\\n            typeReq -= c / 3;\\n        }\\n        \\n        if (len < 6) {\\n            ops += 6 - len;\\n            typeReq -= 6 - len;\\n        }\\n        if (len > 20) ops += len - 20;\\n        \\n        if (typeReq > 0) ops += typeReq;\\n        \\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146366,
                "title": "java-1ms-greedy-solution",
                "content": "This is a good problem due to it\\'s complexity of dealing with interactions between 3 criteria, especially criteria 1 and 3\\n\\n**several observations:**\\n* adding characters to meet criteria 1 could take care of criteria 2 and 3 violations at the same time\\n* deleting characters to meet criteria 1 could take care of criteria 3 violation at the same time, but not 2\\n* replacing characters to meet criteria 3 could take care of criteria 2 at the same time, and vice versa\\n\\n**thus we choose to start from criteria 1 and try to take care of 2 and 3 as much as possible at the same time**\\n\\n\\n```java\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        char[] chars = password.toCharArray();\\n        int c1 = 1, c2 = 1, c3 = 1, n = chars.length;\\n        int start = 0, repeated = 0;\\n        PriorityQueue<Integer> repeats = new PriorityQueue<>(Comparator.comparingInt(a -> a % 3));\\n        for (int i = 0; i < chars.length; i++) {\\n            if (Character.isLowerCase(chars[i])) c1 = 0;\\n            if (Character.isDigit(chars[i])) c2 = 0;\\n            if (Character.isUpperCase(chars[i])) c3 = 0;\\n            if (chars[i] == chars[start]) {\\n                repeated++;\\n            } else {\\n                if (repeated > 2) repeats.offer(repeated);\\n\\t\\t\\t\\tstart = i;\\n                repeated = 1;\\n            }\\n        }\\n        if (repeated > 2) repeats.offer(repeated);\\n\\n        int result = 0;\\n        // eD1, eD2, eD3 is the edit distance to meet criteria 1, 2 and 3\\n        // when eD1 is negative: we need to add characters to the string\\n        // when eD1 is positive: we need to remove characters from the string\\n        int eD1 = n < 6 ? n - 6 : (n > 20 ? n - 20 : 0);\\n        int eD2 = c1 + c2 + c3;\\n        // eD3 will be calculated in the next if-else section due to its\\n        // interactions with eD1 and eD2\\n        int eD3 = 0;\\n\\n        // characters can be used to remove D1 and eD3 at the same time\\n        if (!repeats.isEmpty()) {\\n            if (eD1 > 0) {\\n                while (eD1 > 0 && !repeats.isEmpty()) {\\n                    int a = repeats.poll();\\n                    if (a - 1 > 2) repeats.offer(a - 1);\\n                    result++;\\n                    eD1--;\\n                }\\n            } else if (eD1 < 0) {\\n                eD1 = - eD1;\\n                while (eD1 > 0 && !repeats.isEmpty()) {\\n                    int a = repeats.poll();\\n                    if (a - 2 > 2) repeats.offer(a - 2);\\n                    if (eD2 > 0) eD2--;\\n                    result++;\\n                    eD1--;\\n                }\\n                eD1 = -eD1;\\n            }\\n            // taking care of the rest unmatched repeated strings, if there\\'s any\\n            while (!repeats.isEmpty()) {\\n                eD3 += repeats.poll() / 3;\\n            }\\n        }\\n\\n        // at this stage, at most one of eD1 and eD3 is non-zero\\n\\n        if (eD3 != 0) {\\n            result += Math.max(eD3, eD2);\\n            eD2 = 0;\\n        }\\n\\n        if (eD1 != 0) {\\n            result += eD1 < 0 ? Math.max(-eD1, eD2) : eD1 + eD2;\\n            eD2 = 0;\\n        }\\n\\n        if (eD2 != 0) {\\n            result += eD2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        char[] chars = password.toCharArray();\\n        int c1 = 1, c2 = 1, c3 = 1, n = chars.length;\\n        int start = 0, repeated = 0;\\n        PriorityQueue<Integer> repeats = new PriorityQueue<>(Comparator.comparingInt(a -> a % 3));\\n        for (int i = 0; i < chars.length; i++) {\\n            if (Character.isLowerCase(chars[i])) c1 = 0;\\n            if (Character.isDigit(chars[i])) c2 = 0;\\n            if (Character.isUpperCase(chars[i])) c3 = 0;\\n            if (chars[i] == chars[start]) {\\n                repeated++;\\n            } else {\\n                if (repeated > 2) repeats.offer(repeated);\\n\\t\\t\\t\\tstart = i;\\n                repeated = 1;\\n            }\\n        }\\n        if (repeated > 2) repeats.offer(repeated);\\n\\n        int result = 0;\\n        // eD1, eD2, eD3 is the edit distance to meet criteria 1, 2 and 3\\n        // when eD1 is negative: we need to add characters to the string\\n        // when eD1 is positive: we need to remove characters from the string\\n        int eD1 = n < 6 ? n - 6 : (n > 20 ? n - 20 : 0);\\n        int eD2 = c1 + c2 + c3;\\n        // eD3 will be calculated in the next if-else section due to its\\n        // interactions with eD1 and eD2\\n        int eD3 = 0;\\n\\n        // characters can be used to remove D1 and eD3 at the same time\\n        if (!repeats.isEmpty()) {\\n            if (eD1 > 0) {\\n                while (eD1 > 0 && !repeats.isEmpty()) {\\n                    int a = repeats.poll();\\n                    if (a - 1 > 2) repeats.offer(a - 1);\\n                    result++;\\n                    eD1--;\\n                }\\n            } else if (eD1 < 0) {\\n                eD1 = - eD1;\\n                while (eD1 > 0 && !repeats.isEmpty()) {\\n                    int a = repeats.poll();\\n                    if (a - 2 > 2) repeats.offer(a - 2);\\n                    if (eD2 > 0) eD2--;\\n                    result++;\\n                    eD1--;\\n                }\\n                eD1 = -eD1;\\n            }\\n            // taking care of the rest unmatched repeated strings, if there\\'s any\\n            while (!repeats.isEmpty()) {\\n                eD3 += repeats.poll() / 3;\\n            }\\n        }\\n\\n        // at this stage, at most one of eD1 and eD3 is non-zero\\n\\n        if (eD3 != 0) {\\n            result += Math.max(eD3, eD2);\\n            eD2 = 0;\\n        }\\n\\n        if (eD1 != 0) {\\n            result += eD1 < 0 ? Math.max(-eD1, eD2) : eD1 + eD2;\\n            eD2 = 0;\\n        }\\n\\n        if (eD2 != 0) {\\n            result += eD2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098543,
                "title": "explain-with-python3",
                "content": "*  insert  lost types  >> supply shortage -> 6 chars\\n*  swap with lost type  >> swap repeated chars\\n*  remove surplus  -> 20 chars\\n*  * aaa -> aa.    repeats%3==0.  just avoid repeat \\n* * aaaa -> aa.   repeats%3==1.  remove more\\n*  * aaaaa -> aa.    repeats%3==2.    avoid any repeat \\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n=len(password)\\n        low,up,digit=0,0,0\\n\\n        last=\\'_\\'\\n        repeats=[]\\n        for i in range(n):\\n            x=password[i]\\n            if x==last:\\n                repeats[-1]+=1\\n            else:\\n                last=x\\n                repeats.append(1)\\n        \\n            if ord(\\'a\\')<=ord(x)<=ord(\\'z\\'):\\n                low+=1\\n            if ord(\\'A\\')<=ord(x)<=ord(\\'Z\\'):\\n                up+=1\\n            if ord(\\'0\\')<=ord(x)<=ord(\\'9\\'):\\n                digit+=1\\n        \\n        types=0  # types  to be needed\\n        if low==0:\\n            types+=1\\n        if up==0:\\n            types+=1\\n        if digit==0:\\n            types+=1\\n        print(types,n,repeats)\\n        \\n        if n<6:\\n            return max(6-n,types)\\n        elif n<=20:\\n            swaps=sum( [x//3 for x in repeats]  )\\n            return max(swaps,types)\\n        else:\\n            surplus=n-20\\n            m=len(repeats)\\n            for i in range(m):\\n                if surplus>=1 and repeats[i]%3==0:\\n                    repeats[i]-=1\\n                    surplus-=1\\n            for i in range(m):\\n                if surplus>=2 and repeats[i]>=3 and repeats[i]%3==1:\\n                    repeats[i]-=2\\n                    surplus-=2\\n            for i in range(m):\\n                if surplus>0 and repeats[i]>=3 :\\n                    removed=min(repeats[i]-2,surplus)\\n                    repeats[i]-=removed\\n                    surplus-=removed\\n            swaps=sum( [x//3 for x in repeats]  )\\n            print(surplus,swaps,repeats)\\n            return n-20+max(swaps,types)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n=len(password)\\n        low,up,digit=0,0,0\\n\\n        last=\\'_\\'\\n        repeats=[]\\n        for i in range(n):\\n            x=password[i]\\n            if x==last:\\n                repeats[-1]+=1\\n            else:\\n                last=x\\n                repeats.append(1)\\n        \\n            if ord(\\'a\\')<=ord(x)<=ord(\\'z\\'):\\n                low+=1\\n            if ord(\\'A\\')<=ord(x)<=ord(\\'Z\\'):\\n                up+=1\\n            if ord(\\'0\\')<=ord(x)<=ord(\\'9\\'):\\n                digit+=1\\n        \\n        types=0  # types  to be needed\\n        if low==0:\\n            types+=1\\n        if up==0:\\n            types+=1\\n        if digit==0:\\n            types+=1\\n        print(types,n,repeats)\\n        \\n        if n<6:\\n            return max(6-n,types)\\n        elif n<=20:\\n            swaps=sum( [x//3 for x in repeats]  )\\n            return max(swaps,types)\\n        else:\\n            surplus=n-20\\n            m=len(repeats)\\n            for i in range(m):\\n                if surplus>=1 and repeats[i]%3==0:\\n                    repeats[i]-=1\\n                    surplus-=1\\n            for i in range(m):\\n                if surplus>=2 and repeats[i]>=3 and repeats[i]%3==1:\\n                    repeats[i]-=2\\n                    surplus-=2\\n            for i in range(m):\\n                if surplus>0 and repeats[i]>=3 :\\n                    removed=min(repeats[i]-2,surplus)\\n                    repeats[i]-=removed\\n                    surplus-=removed\\n            swaps=sum( [x//3 for x in repeats]  )\\n            print(surplus,swaps,repeats)\\n            return n-20+max(swaps,types)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073363,
                "title": "0-ms-beats-100-c-solution-with-detailed-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    // 1. [6, 20] characters\\n    // 2. one lower case, one uppercase, one digit\\n    // 3. no 3 repeating characters\\n    int strongPasswordChecker(string password) {\\n        \\n        int cnt[3] = {0};\\n        \\n        if (password.size() <= 3) \\n            return 6 - password.size(); // inserstions only\\n\\n        for (int i = 0; i < password.size(); i++) {\\n            if (password[i] >= \\'a\\' && password[i] <= \\'z\\')\\n                cnt[0] = 1;\\n            else if (password[i] >= \\'A\\' && password[i] <= \\'Z\\')\\n                cnt[1] = 1;\\n            else if (password[i] >= \\'0\\' && password[i] <= \\'9\\')\\n                cnt[2] = 1;\\n        }\\n        \\n        int missing = 3 - (cnt[0] + cnt[1] + cnt[2]);\\n        \\n        if (password.size() == 4) {\\n            if (missing == 3)\\n                return 3;  // one replacement and two insertions\\n            return 2;      // two insertions\\n        }\\n        else if (password.size() == 5) {\\n            if (missing == 3)\\n                return 3; // two replacement, and one insertion\\n            else if (missing == 2)\\n                return 2; // one replacement, and one insertion\\n            else if (missing == 1)\\n                return 1; // one insertion;\\n            else\\n                return 1; // one insertion\\n        }\\n        else if (password.size() >= 6 && password.size() <= 20) { \\n            int i = 1;\\n            int replacements = 0;\\n            while(i < password.size()) {\\n                if (password[i] == password[i - 1]) {\\n                    int j = i - 1;\\n                    while(i < password.size() && password[i] == password[i - 1]) i++;\\n                    replacements += (i - j) / 3;\\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n            \\n            // when replacements > missing,  we can replace to isolate repeatings\\n            // when replacements <= missing, we need \"missing\" num of replacements to cover missings\\n            return max(replacements, missing);\\n        }\\n        else {\\n            // password.size() > 20\\n            int extra_cnt = password.size() - 20;\\n            int i = 1;\\n            int replacements = 0;\\n            int deleted = 0;\\n            vector<int> size_seq;\\n            while(i < password.size()) {\\n                if (password[i] == password[i - 1]) {\\n                    int j = i - 1;\\n                    while(i < password.size() && password[i] == password[i - 1]) i++;\\n                    int size = i - j;\\n                    if ((size % 3) == 0 && extra_cnt) { \\n                        // cover case of 3, 6, 9 ... \\n                        // if it is 3, only need delete one charater to avoid repeating\\n                        size --;\\n                        deleted ++;\\n                        extra_cnt --;\\n                    }\\n                    if (size >= 3) {\\n                        size_seq.push_back(size);\\n                    }\\n                    \\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n            \\n            for (int i = 0; i < size_seq.size() && extra_cnt >= 2; i++) {\\n                if (size_seq[i] > 3 && (size_seq[i] % 3) == 1) {\\n                    // cover case of 4, 7, 10 ...\\n                    // if it is 4, only need delete 2 charaters to avoid repeating\\n                    deleted += 2;\\n                    extra_cnt -= 2;\\n                    size_seq[i] -= 2;\\n                }\\n            }\\n            \\n            for (int i = 0; i < size_seq.size(); i++) {\\n                while (size_seq[i] >= 3 && extra_cnt >= 3) {\\n                    // for remaining cases, delete 3 characters each time\\n                    deleted += 3;\\n                    extra_cnt -= 3;\\n                    size_seq[i] -= 3;\\n                }\\n                replacements += size_seq[i] / 3;\\n            }\\n            \\n            // deleted , remaining extra cnt, max of replacements and missing\\n            return deleted + extra_cnt + max(replacements, missing);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    // 1. [6, 20] characters\\n    // 2. one lower case, one uppercase, one digit\\n    // 3. no 3 repeating characters\\n    int strongPasswordChecker(string password) {\\n        \\n        int cnt[3] = {0};\\n        \\n        if (password.size() <= 3) \\n            return 6 - password.size(); // inserstions only\\n\\n        for (int i = 0; i < password.size(); i++) {\\n            if (password[i] >= \\'a\\' && password[i] <= \\'z\\')\\n                cnt[0] = 1;\\n            else if (password[i] >= \\'A\\' && password[i] <= \\'Z\\')\\n                cnt[1] = 1;\\n            else if (password[i] >= \\'0\\' && password[i] <= \\'9\\')\\n                cnt[2] = 1;\\n        }\\n        \\n        int missing = 3 - (cnt[0] + cnt[1] + cnt[2]);\\n        \\n        if (password.size() == 4) {\\n            if (missing == 3)\\n                return 3;  // one replacement and two insertions\\n            return 2;      // two insertions\\n        }\\n        else if (password.size() == 5) {\\n            if (missing == 3)\\n                return 3; // two replacement, and one insertion\\n            else if (missing == 2)\\n                return 2; // one replacement, and one insertion\\n            else if (missing == 1)\\n                return 1; // one insertion;\\n            else\\n                return 1; // one insertion\\n        }\\n        else if (password.size() >= 6 && password.size() <= 20) { \\n            int i = 1;\\n            int replacements = 0;\\n            while(i < password.size()) {\\n                if (password[i] == password[i - 1]) {\\n                    int j = i - 1;\\n                    while(i < password.size() && password[i] == password[i - 1]) i++;\\n                    replacements += (i - j) / 3;\\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n            \\n            // when replacements > missing,  we can replace to isolate repeatings\\n            // when replacements <= missing, we need \"missing\" num of replacements to cover missings\\n            return max(replacements, missing);\\n        }\\n        else {\\n            // password.size() > 20\\n            int extra_cnt = password.size() - 20;\\n            int i = 1;\\n            int replacements = 0;\\n            int deleted = 0;\\n            vector<int> size_seq;\\n            while(i < password.size()) {\\n                if (password[i] == password[i - 1]) {\\n                    int j = i - 1;\\n                    while(i < password.size() && password[i] == password[i - 1]) i++;\\n                    int size = i - j;\\n                    if ((size % 3) == 0 && extra_cnt) { \\n                        // cover case of 3, 6, 9 ... \\n                        // if it is 3, only need delete one charater to avoid repeating\\n                        size --;\\n                        deleted ++;\\n                        extra_cnt --;\\n                    }\\n                    if (size >= 3) {\\n                        size_seq.push_back(size);\\n                    }\\n                    \\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n            \\n            for (int i = 0; i < size_seq.size() && extra_cnt >= 2; i++) {\\n                if (size_seq[i] > 3 && (size_seq[i] % 3) == 1) {\\n                    // cover case of 4, 7, 10 ...\\n                    // if it is 4, only need delete 2 charaters to avoid repeating\\n                    deleted += 2;\\n                    extra_cnt -= 2;\\n                    size_seq[i] -= 2;\\n                }\\n            }\\n            \\n            for (int i = 0; i < size_seq.size(); i++) {\\n                while (size_seq[i] >= 3 && extra_cnt >= 3) {\\n                    // for remaining cases, delete 3 characters each time\\n                    deleted += 3;\\n                    extra_cnt -= 3;\\n                    size_seq[i] -= 3;\\n                }\\n                replacements += size_seq[i] / 3;\\n            }\\n            \\n            // deleted , remaining extra cnt, max of replacements and missing\\n            return deleted + extra_cnt + max(replacements, missing);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060417,
                "title": "beats-100-java-solution",
                "content": "```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {   \\n        \\n     \\n        // first: we need to count how many types (lowercase, uppercase, digit) of characters are missing\\n        // second: we need to find how many repeated character set exist in the password\\n        \\n        int t1=0;\\n        int t2=0;\\n        int t3=0;\\n        \\n        int repeat=1;\\n        int triplet=0;\\n        \\n        ArrayList<Integer> repeated=new ArrayList<>(); // this will contain count of (more than 3) repeated character sets. \\n        \\n        int N=password.length();\\n        \\n        char prev=\\'=\\';\\n        for(int i=0 ;i <N ;i++)\\n        {\\n            char c=password.charAt(i);\\n            if(\\'A\\'<=c && c<=\\'Z\\')\\n            {\\n                t1=1;\\n            }\\n            if(\\'a\\'<=c && c<=\\'z\\')\\n            {\\n                t2=1;\\n            }\\n            if(\\'0\\'<=c && c<=\\'9\\')\\n            {\\n                t3=1;\\n            }\\n            \\n            if(prev==c)\\n            {\\n                repeat++;\\n            }else\\n            {                \\n                if(repeat>=3)repeated.add(repeat);\\n                repeat=1;\\n            }            \\n            prev=c;         \\n     \\n                \\n        }\\n        \\n        if(repeat>=3) repeated.add(repeat);        \\n        for(int r: repeated)\\n        {\\n            triplet+=r/3;\\n        }\\n\\n        int missting_type=3-t1-t2-t3; // the number of types missing in password\\n        \\n        \\n        // case 1 if the password length is less than 6\\n        // then you have to insert the remaining characters\\n        // newly inserted character should cover the missing types\\n        // for example if you get \"aaa\" then you can add three characters A,B,1 interleving with a. so repeating is not a matter in this case.\\n        if(N<6)\\n        {\\n            int insert= 6-N;            \\n            return Math.max(missting_type, insert);\\n        }\\n        \\n        \\n        // case 2: you need to replace character in case you have missing type and/or repeated charcter. \\n        // no need to insert or delete.\\n        if(N>=6 && N<=20)\\n        {\\n            \\n            return Math.max(missting_type, triplet);\\n        }\\n        \\n        \\n\\n        // case 3: the length is more than 20. You must delete at least N-20 character\\n        // you must delete wisely so that the number repeated trippled is minimum.\\n        // so you delete the character which has minimum remainder (%3). (for example, if you have 5As and 6Bs, you should remove from B, thats because if you remove from A the number of tripplets are still 1 for A, but if you remove from B then the number of tripplets is reduced to 1 from 2)\\n        \\n        Integer [] REPEATED=repeated.toArray(new Integer[repeated.size()]);\\n        int deleteno=N-20;\\n        \\n   //     System.out.println(repeated);\\n        \\n  \\n        while(deleteno>0)\\n        {\\n            int min_rem=3;\\n            int min_i=0;\\n            boolean changed=false;\\n            for(int i=0; i<REPEATED.length; i++)\\n            {\\n                int rem=REPEATED[i]%3;\\n                \\n                if(rem<min_rem && REPEATED[i]>2) // you do not need to delete a character if it becomes 2 (not a tripplet)\\n                {\\n                    min_i=i;\\n                    min_rem=rem;\\n                    changed=true;\\n                }\\n            }\\n            \\n            if(!changed) break;\\n            REPEATED[min_i]--;\\n            deleteno--;            \\n\\n        }\\n        \\n        triplet=0;\\n        for(int r: REPEATED)\\n        {\\n           // System.out.print(r+\" \");\\n            triplet+=r/3;\\n        }\\n        \\n        int replace=Math.max(missting_type, triplet);\\n           \\n        return replace+(N-20);\\n  \\n        \\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {   \\n        \\n     \\n        // first: we need to count how many types (lowercase, uppercase, digit) of characters are missing\\n        // second: we need to find how many repeated character set exist in the password\\n        \\n        int t1=0;\\n        int t2=0;\\n        int t3=0;\\n        \\n        int repeat=1;\\n        int triplet=0;\\n        \\n        ArrayList<Integer> repeated=new ArrayList<>(); // this will contain count of (more than 3) repeated character sets. \\n        \\n        int N=password.length();\\n        \\n        char prev=\\'=\\';\\n        for(int i=0 ;i <N ;i++)\\n        {\\n            char c=password.charAt(i);\\n            if(\\'A\\'<=c && c<=\\'Z\\')\\n            {\\n                t1=1;\\n            }\\n            if(\\'a\\'<=c && c<=\\'z\\')\\n            {\\n                t2=1;\\n            }\\n            if(\\'0\\'<=c && c<=\\'9\\')\\n            {\\n                t3=1;\\n            }\\n            \\n            if(prev==c)\\n            {\\n                repeat++;\\n            }else\\n            {                \\n                if(repeat>=3)repeated.add(repeat);\\n                repeat=1;\\n            }            \\n            prev=c;         \\n     \\n                \\n        }\\n        \\n        if(repeat>=3) repeated.add(repeat);        \\n        for(int r: repeated)\\n        {\\n            triplet+=r/3;\\n        }\\n\\n        int missting_type=3-t1-t2-t3; // the number of types missing in password\\n        \\n        \\n        // case 1 if the password length is less than 6\\n        // then you have to insert the remaining characters\\n        // newly inserted character should cover the missing types\\n        // for example if you get \"aaa\" then you can add three characters A,B,1 interleving with a. so repeating is not a matter in this case.\\n        if(N<6)\\n        {\\n            int insert= 6-N;            \\n            return Math.max(missting_type, insert);\\n        }\\n        \\n        \\n        // case 2: you need to replace character in case you have missing type and/or repeated charcter. \\n        // no need to insert or delete.\\n        if(N>=6 && N<=20)\\n        {\\n            \\n            return Math.max(missting_type, triplet);\\n        }\\n        \\n        \\n\\n        // case 3: the length is more than 20. You must delete at least N-20 character\\n        // you must delete wisely so that the number repeated trippled is minimum.\\n        // so you delete the character which has minimum remainder (%3). (for example, if you have 5As and 6Bs, you should remove from B, thats because if you remove from A the number of tripplets are still 1 for A, but if you remove from B then the number of tripplets is reduced to 1 from 2)\\n        \\n        Integer [] REPEATED=repeated.toArray(new Integer[repeated.size()]);\\n        int deleteno=N-20;\\n        \\n   //     System.out.println(repeated);\\n        \\n  \\n        while(deleteno>0)\\n        {\\n            int min_rem=3;\\n            int min_i=0;\\n            boolean changed=false;\\n            for(int i=0; i<REPEATED.length; i++)\\n            {\\n                int rem=REPEATED[i]%3;\\n                \\n                if(rem<min_rem && REPEATED[i]>2) // you do not need to delete a character if it becomes 2 (not a tripplet)\\n                {\\n                    min_i=i;\\n                    min_rem=rem;\\n                    changed=true;\\n                }\\n            }\\n            \\n            if(!changed) break;\\n            REPEATED[min_i]--;\\n            deleteno--;            \\n\\n        }\\n        \\n        triplet=0;\\n        for(int r: REPEATED)\\n        {\\n           // System.out.print(r+\" \");\\n            triplet+=r/3;\\n        }\\n        \\n        int replace=Math.max(missting_type, triplet);\\n           \\n        return replace+(N-20);\\n  \\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050841,
                "title": "68-ms-fastest-for-ts-js",
                "content": "It can be improved.\\n\\nLinks:\\n- [npm](https://www.npmjs.com/package/strong-password-checker)\\n- [github](https://github.com/d8corp/strong-password-checker)\\n\\n```\\nconst chars = [/[0-9]/, /[a-z]/, /[A-Z]/]\\n\\nfunction strongPasswordChecker (\\n  pass: string,\\n  minLength = 6,\\n  maxLength = 20,\\n  maxRepeat = 3,\\n  charConditions = chars\\n): number {\\n\\n  const {length} = pass\\n  const reduceIncreaseCount = length < minLength ? minLength - length : length > maxLength ? length - maxLength : 0\\n  const charConditionsResult = charConditions.map(() => false)\\n  const lengths = []\\n\\n  let replaceCharCount = charConditionsResult.length\\n  let replaceCount = 0\\n\\n  // temp variables\\n  let repeatLength = 1\\n  let oldChar\\n\\n  // going through password symbols\\n  for (let i = 0; i < length; i++) {\\n    // current symbol\\n    const char = pass[i]\\n\\n    // check character conditions\\n    if (replaceCharCount) {\\n      for (let j = 0; j < charConditionsResult.length; j++) {\\n        if (!charConditionsResult[j]) {\\n          if (charConditions[j].test(char)) {\\n            charConditionsResult[j] = true\\n            replaceCharCount--\\n          }\\n        }\\n      }\\n    }\\n\\n    if (oldChar === char) {\\n      if (++repeatLength % maxRepeat === 0) {\\n        replaceCount++\\n      }\\n    } else {\\n      lengths.push(repeatLength)\\n      repeatLength = 1\\n    }\\n\\n    oldChar = char\\n  }\\n\\n  lengths.push(repeatLength)\\n\\n  if (length < minLength) {\\n    return Math.max(reduceIncreaseCount, replaceCharCount)\\n  } else if (length > maxLength) {\\n    let reducer = reduceIncreaseCount\\n    let replacer = replaceCount\\n\\n    let changed = true\\n\\n    if (reducer && replacer) {\\n      loop: while (changed) {\\n        changed = false\\n\\n        for (let i = 0; i < maxRepeat && replacer; i++) {\\n          for (let j = 0; j < lengths.length && replacer; j++) {\\n            const len = lengths[j]\\n\\n            if (len >= maxRepeat && len % maxRepeat === i) {\\n              if (lengths[j] >= maxRepeat && reducer > i && reducer) {\\n                lengths[j] -= i + 1\\n                replacer--\\n                reducer -= i + 1\\n                changed = true\\n\\n                if (!reducer || !replacer) {\\n                  break loop\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    return reduceIncreaseCount + Math.max(replacer, replaceCharCount)\\n  } else {\\n    return Math.max(reduceIncreaseCount, replaceCharCount, replaceCount)\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst chars = [/[0-9]/, /[a-z]/, /[A-Z]/]\\n\\nfunction strongPasswordChecker (\\n  pass: string,\\n  minLength = 6,\\n  maxLength = 20,\\n  maxRepeat = 3,\\n  charConditions = chars\\n): number {\\n\\n  const {length} = pass\\n  const reduceIncreaseCount = length < minLength ? minLength - length : length > maxLength ? length - maxLength : 0\\n  const charConditionsResult = charConditions.map(() => false)\\n  const lengths = []\\n\\n  let replaceCharCount = charConditionsResult.length\\n  let replaceCount = 0\\n\\n  // temp variables\\n  let repeatLength = 1\\n  let oldChar\\n\\n  // going through password symbols\\n  for (let i = 0; i < length; i++) {\\n    // current symbol\\n    const char = pass[i]\\n\\n    // check character conditions\\n    if (replaceCharCount) {\\n      for (let j = 0; j < charConditionsResult.length; j++) {\\n        if (!charConditionsResult[j]) {\\n          if (charConditions[j].test(char)) {\\n            charConditionsResult[j] = true\\n            replaceCharCount--\\n          }\\n        }\\n      }\\n    }\\n\\n    if (oldChar === char) {\\n      if (++repeatLength % maxRepeat === 0) {\\n        replaceCount++\\n      }\\n    } else {\\n      lengths.push(repeatLength)\\n      repeatLength = 1\\n    }\\n\\n    oldChar = char\\n  }\\n\\n  lengths.push(repeatLength)\\n\\n  if (length < minLength) {\\n    return Math.max(reduceIncreaseCount, replaceCharCount)\\n  } else if (length > maxLength) {\\n    let reducer = reduceIncreaseCount\\n    let replacer = replaceCount\\n\\n    let changed = true\\n\\n    if (reducer && replacer) {\\n      loop: while (changed) {\\n        changed = false\\n\\n        for (let i = 0; i < maxRepeat && replacer; i++) {\\n          for (let j = 0; j < lengths.length && replacer; j++) {\\n            const len = lengths[j]\\n\\n            if (len >= maxRepeat && len % maxRepeat === i) {\\n              if (lengths[j] >= maxRepeat && reducer > i && reducer) {\\n                lengths[j] -= i + 1\\n                replacer--\\n                reducer -= i + 1\\n                changed = true\\n\\n                if (!reducer || !replacer) {\\n                  break loop\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    return reduceIncreaseCount + Math.max(replacer, replaceCharCount)\\n  } else {\\n    return Math.max(reduceIncreaseCount, replaceCharCount, replaceCount)\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041854,
                "title": "easy-c-solution-brief-and-concise",
                "content": "# Approach\\nSimplified and deeply refactored existing [C# Solution with Detailed Explanation](https://leetcode.com/problems/strong-password-checker/discuss/1000660/C-Solution-with-Detailed-Explanation)\\n\\n```\\npublic class Solution {\\n    private const int MIN_LENGTH = 6;\\n    private const int MAX_LENGTH = 20;\\n    private const int MAX_REPEAT_LENGTH = 3;\\n    private const int digit = 0;\\n    private const int lowercase = 1;\\n    private const int uppercase = 2;\\n    public class RepeatCount {\\n        public int Value;\\n    }\\n    \\n    public int StrongPasswordChecker(string password) {\\n        int[] bit = new [] { 1, 1, 1 };\\n        char prev = \\'\\\\0\\';\\n        int repeatCount = 1;\\n        var repeatCharCounts = new List<int>();\\n        foreach (char c in password) {\\n            if (char.IsDigit(c))\\n                bit[digit] = 0;\\n            else if (char.IsLetter(c) && char.IsLower(c)) \\n                bit[lowercase] = 0;\\n            else if (char.IsLetter(c) && char.IsUpper(c)) \\n                bit[uppercase] = 0;\\n            if (c == prev) {\\n                repeatCount++;\\n                continue;\\n            }\\n            if (repeatCount >= MAX_REPEAT_LENGTH)\\n                repeatCharCounts.Add(repeatCount);\\n            repeatCount = 1;\\n            prev = c;\\n        }\\n        \\n        if (repeatCount >= MAX_REPEAT_LENGTH)\\n            repeatCharCounts.Add(repeatCount);\\n        \\n        var q = new Queue<RepeatCount>(repeatCharCounts\\n                                       .OrderBy(x => x % MAX_REPEAT_LENGTH)\\n                                       .Select(x => new RepeatCount { Value = x }));\\n        int passwordCount = password.Length;\\n        if (passwordCount > MAX_LENGTH) {\\n            while (passwordCount-- > MAX_LENGTH && q.Count > 0) {\\n                var sequence = q.Peek();\\n                if (sequence.Value == MAX_REPEAT_LENGTH)\\n                    q.Dequeue();\\n                else if (sequence.Value % MAX_REPEAT_LENGTH == 0)\\n                    q.Enqueue(new RepeatCount { Value = q.Dequeue().Value - 1 });\\n                else\\n                    sequence.Value--;\\n            }            \\n        }\\n        \\n        int deletions = Math.Max(password.Length - MAX_LENGTH, 0);\\n        int repeatInsertsAndReplaces = q.Sum(x => x.Value / MAX_REPEAT_LENGTH);\\n        int requiredInsertsOrReplace = Math.Max(MIN_LENGTH - password.Length, bit.Sum());\\n        \\n        return Math.Max(requiredInsertsOrReplace, repeatInsertsAndReplaces) + deletions;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private const int MIN_LENGTH = 6;\\n    private const int MAX_LENGTH = 20;\\n    private const int MAX_REPEAT_LENGTH = 3;\\n    private const int digit = 0;\\n    private const int lowercase = 1;\\n    private const int uppercase = 2;\\n    public class RepeatCount {\\n        public int Value;\\n    }\\n    \\n    public int StrongPasswordChecker(string password) {\\n        int[] bit = new [] { 1, 1, 1 };\\n        char prev = \\'\\\\0\\';\\n        int repeatCount = 1;\\n        var repeatCharCounts = new List<int>();\\n        foreach (char c in password) {\\n            if (char.IsDigit(c))\\n                bit[digit] = 0;\\n            else if (char.IsLetter(c) && char.IsLower(c)) \\n                bit[lowercase] = 0;\\n            else if (char.IsLetter(c) && char.IsUpper(c)) \\n                bit[uppercase] = 0;\\n            if (c == prev) {\\n                repeatCount++;\\n                continue;\\n            }\\n            if (repeatCount >= MAX_REPEAT_LENGTH)\\n                repeatCharCounts.Add(repeatCount);\\n            repeatCount = 1;\\n            prev = c;\\n        }\\n        \\n        if (repeatCount >= MAX_REPEAT_LENGTH)\\n            repeatCharCounts.Add(repeatCount);\\n        \\n        var q = new Queue<RepeatCount>(repeatCharCounts\\n                                       .OrderBy(x => x % MAX_REPEAT_LENGTH)\\n                                       .Select(x => new RepeatCount { Value = x }));\\n        int passwordCount = password.Length;\\n        if (passwordCount > MAX_LENGTH) {\\n            while (passwordCount-- > MAX_LENGTH && q.Count > 0) {\\n                var sequence = q.Peek();\\n                if (sequence.Value == MAX_REPEAT_LENGTH)\\n                    q.Dequeue();\\n                else if (sequence.Value % MAX_REPEAT_LENGTH == 0)\\n                    q.Enqueue(new RepeatCount { Value = q.Dequeue().Value - 1 });\\n                else\\n                    sequence.Value--;\\n            }            \\n        }\\n        \\n        int deletions = Math.Max(password.Length - MAX_LENGTH, 0);\\n        int repeatInsertsAndReplaces = q.Sum(x => x.Value / MAX_REPEAT_LENGTH);\\n        int requiredInsertsOrReplace = Math.Max(MIN_LENGTH - password.Length, bit.Sum());\\n        \\n        return Math.Max(requiredInsertsOrReplace, repeatInsertsAndReplaces) + deletions;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965786,
                "title": "c-0ms-o-n",
                "content": "My C solution to Strong Password Checker, hard parts include counting the number of corrections if passwords exceed 20 characters in length.\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <ctype.h>\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int offences1 = 0;\\n    int offences2 = 0;\\n    int offences = 0;\\n    \\n    int r = 0;\\n    char prev = \\'\\\\n\\';\\n    char curr;\\n    int repC = 1;\\n    int delrep[3] = {0};\\n    int maxrep = 0;\\n    \\n    for(int i = 0; i < length; i++) {\\n        curr = password[i];\\n        if(curr == prev) {\\n            repC++;\\n        } else {\\n            if(repC >= 3) {\\n                delrep[repC%3]++;\\n            }\\n            repC = 1;\\n            prev = curr;\\n        }\\n        if(repC % 3 == 0) {\\n            r++;\\n        }\\n        if(repC > 3 && repC % 3 == 1) {\\n            delrep[2]++;\\n        }\\n    }\\n    if(repC >= 3) {\\n        delrep[repC%3]++;\\n    }\\n    \\n    \\n    int v = 0;\\n    int vo = 0;\\n    int lc = 0;\\n    int uc = 0;\\n    int dc = 0;\\n    for(int i = 0; i < length; i++) {\\n        if(lc == 0 && islower(password[i]) != 0) {\\n            v++;\\n            lc = 1;\\n        }\\n        if(uc == 0 && isupper(password[i]) != 0) {\\n            v++;\\n            uc = 1;\\n        }\\n        if(dc == 0 && isdigit(password[i]) != 0) {\\n            v++;\\n            dc = 1;\\n        }\\n    }\\n    \\n    if(v < 3) {\\n        offences2 += 3 - v;\\n        vo += 3 - v;\\n        if(length == 5 && v == 1) {\\n            offences1++;\\n        }\\n    }\\n\\n    if(length < 6 || length > 20) {\\n        int delete = length - 20;\\n        if(delrep[0] != 0) {\\n            delrep[0] = delrep[0] < delete ? delrep[0] : delete;\\n        }\\n        if(delrep[1] != 0) {\\n            delrep[1] = delrep[1] < (delete - delrep[0])/2 ? delrep[1] : (delete - delrep[0])/2;\\n        }\\n        if(delrep[2] != 0) {\\n            delrep[2] = delrep[2] < ((delete - delrep[0]) - delrep[1]*2)/3 ? delrep[2] : ((delete - delrep[0]) - delrep[1]*2)/3;\\n        }\\n        \\n        r-= delrep[0] + delrep[1] + delrep[2];   \\n        \\n        int x = r > offences2 ?  r : offences2;\\n        return length < 6 ? 6 - length + offences1 : delete + x; \\n    }\\n    \\n    return vo < r ? r : vo;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <ctype.h>\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int offences1 = 0;\\n    int offences2 = 0;\\n    int offences = 0;\\n    \\n    int r = 0;\\n    char prev = \\'\\\\n\\';\\n    char curr;\\n    int repC = 1;\\n    int delrep[3] = {0};\\n    int maxrep = 0;\\n    \\n    for(int i = 0; i < length; i++) {\\n        curr = password[i];\\n        if(curr == prev) {\\n            repC++;\\n        } else {\\n            if(repC >= 3) {\\n                delrep[repC%3]++;\\n            }\\n            repC = 1;\\n            prev = curr;\\n        }\\n        if(repC % 3 == 0) {\\n            r++;\\n        }\\n        if(repC > 3 && repC % 3 == 1) {\\n            delrep[2]++;\\n        }\\n    }\\n    if(repC >= 3) {\\n        delrep[repC%3]++;\\n    }\\n    \\n    \\n    int v = 0;\\n    int vo = 0;\\n    int lc = 0;\\n    int uc = 0;\\n    int dc = 0;\\n    for(int i = 0; i < length; i++) {\\n        if(lc == 0 && islower(password[i]) != 0) {\\n            v++;\\n            lc = 1;\\n        }\\n        if(uc == 0 && isupper(password[i]) != 0) {\\n            v++;\\n            uc = 1;\\n        }\\n        if(dc == 0 && isdigit(password[i]) != 0) {\\n            v++;\\n            dc = 1;\\n        }\\n    }\\n    \\n    if(v < 3) {\\n        offences2 += 3 - v;\\n        vo += 3 - v;\\n        if(length == 5 && v == 1) {\\n            offences1++;\\n        }\\n    }\\n\\n    if(length < 6 || length > 20) {\\n        int delete = length - 20;\\n        if(delrep[0] != 0) {\\n            delrep[0] = delrep[0] < delete ? delrep[0] : delete;\\n        }\\n        if(delrep[1] != 0) {\\n            delrep[1] = delrep[1] < (delete - delrep[0])/2 ? delrep[1] : (delete - delrep[0])/2;\\n        }\\n        if(delrep[2] != 0) {\\n            delrep[2] = delrep[2] < ((delete - delrep[0]) - delrep[1]*2)/3 ? delrep[2] : ((delete - delrep[0]) - delrep[1]*2)/3;\\n        }\\n        \\n        r-= delrep[0] + delrep[1] + delrep[2];   \\n        \\n        int x = r > offences2 ?  r : offences2;\\n        return length < 6 ? 6 - length + offences1 : delete + x; \\n    }\\n    \\n    return vo < r ? r : vo;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 948000,
                "title": "java-o-n-0ms",
                "content": "The only tricky case is when the password is longer than 20 characters. In that case, use the deletions to cut down on the number of replacements you\\'ll have to do. In order to accomplish that, first remove one from any subsequence of repeated characters of length 3, 6, 9, 12,.... That way, by removing just one from that subsequence, you\\'ve cut down on the number of replacements needed to break up the subsequence by 1. Then remove two from any subsequence of length 4, 7, 10, 13, .... Finally remove them three at a time from the rest of the subsequences. Of course, once it\\'s short enough, you can stop removing characters.\\n```\\nclass Solution {\\n\\n    public int strongPasswordChecker(String password) {\\n\\n        //First, look for subsequences of length 3 or more\\n        int[] tooLongFrequency = new int[50];\\n        int troublesomeLength = 3;\\n        int i = 0;\\n        while (i < password.length())\\n        {\\n\\n            int currentIndex = i + 1;\\n            while ((currentIndex < password.length()) && (password.charAt(currentIndex) == password.charAt(i)))\\n            {\\n                currentIndex++;\\n            }//while\\n            int subsequenceLength = currentIndex - i;\\n            if (subsequenceLength >= 3)\\n            {\\n                tooLongFrequency[subsequenceLength]++;\\n            }//if\\n\\n            i = currentIndex;\\n\\n        }//while\\n\\n        boolean hasLowerCase = false;\\n        boolean hasUpperCase = false;\\n        boolean hasDigit = false;\\n        for (i = 0; i < password.length(); i++)\\n        {\\n            if ((password.charAt(i) >= \\'a\\') && (password.charAt(i) <= \\'z\\'))\\n            {\\n                hasLowerCase = true;\\n            }//if\\n            else if ((password.charAt(i) >= \\'A\\') && (password.charAt(i) <= \\'Z\\'))\\n            {\\n                hasUpperCase = true;\\n            }//else if\\n            else if ((password.charAt(i) >= \\'0\\') && (password.charAt(i) <= \\'9\\'))\\n            {\\n                hasDigit = true;\\n            }//else if\\n        }//for\\n\\n        int numDifferentTypesNeeded = (hasLowerCase ? 0 : 1) + (hasUpperCase ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n        int minLength = 6;\\n        int maxLength = 20;\\n\\n        int numEdits = 0;\\n        if (password.length() < minLength)\\n        {\\n            //TODO: this is not true for the general case. If minLength were larger than 6, we might have to do some replacements.\\n            //For example, if minLength = 15, and the password were \"AAAAAAAAAAAAAA\" (14 As), we would have to do replacements to break up the subsequence of As.\\n            numEdits = Math.max(minLength - password.length(), numDifferentTypesNeeded);\\n        }//if\\n        else\\n        {\\n\\n            int numToRemove = 0;\\n            int numRemoved = 0;\\n            if (password.length() > maxLength)\\n            {\\n\\n                numToRemove = password.length() - maxLength;\\n                //If we have tooLongFrequency[i] for some i, we can remove some of those. We prioritize the ones that would make a difference regarding how\\n                //many we would have to replace in order to get rid of the sequence. That is, we have to replace floor(length / 3). So if removing\\n                //one would cut down on the number of replacements, let\\'s do that first. Then we take two away from those that that will help reduce our\\n                //number of replacements, and finally we take three away from the remaining ones. This is only while our length is still longer than maxLength, of course.\\n                for (int startValue = troublesomeLength; startValue < troublesomeLength * 2; startValue++)\\n                {\\n                    i = startValue;\\n                    while ((numRemoved < numToRemove) && (i < tooLongFrequency.length))\\n                    {\\n                        int numToRemoveFromEach = ((i % troublesomeLength) + 1);\\n                        boolean adjusted = false;\\n                        while ((tooLongFrequency[i] > 0) && (numRemoved < numToRemove))\\n                        {\\n                            int numToRemoveThisTime;\\n                            if (numToRemoveFromEach == troublesomeLength)\\n                            {\\n                                numToRemoveThisTime = Math.min(i - (troublesomeLength - 1), numToRemove - numRemoved);\\n                            }//if\\n                            else\\n                            {\\n                                numToRemoveThisTime = Math.min(numToRemove - numRemoved, numToRemoveFromEach);\\n                            }//else\\n                            tooLongFrequency[i]--;\\n                            tooLongFrequency[i - numToRemoveThisTime]++;\\n                            numRemoved += numToRemoveThisTime;\\n                            adjusted = true;\\n                        }//while\\n                        \\n                        i += troublesomeLength;\\n                    }//while\\n                }//for\\n\\n                numRemoved = numToRemove;\\n\\n            }//if\\n\\n            int numToReplace = 0;\\n            for (i = troublesomeLength; i < tooLongFrequency.length; i++)\\n            {\\n                numToReplace += (tooLongFrequency[i] * (i / troublesomeLength));\\n            }//for\\n            \\n            numEdits = numRemoved + Math.max(numToReplace, numDifferentTypesNeeded);\\n\\n        }//else\\n\\n        return numEdits;\\n\\n    }//strongPasswordChecker\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int strongPasswordChecker(String password) {\\n\\n        //First, look for subsequences of length 3 or more\\n        int[] tooLongFrequency = new int[50];\\n        int troublesomeLength = 3;\\n        int i = 0;\\n        while (i < password.length())\\n        {\\n\\n            int currentIndex = i + 1;\\n            while ((currentIndex < password.length()) && (password.charAt(currentIndex) == password.charAt(i)))\\n            {\\n                currentIndex++;\\n            }//while\\n            int subsequenceLength = currentIndex - i;\\n            if (subsequenceLength >= 3)\\n            {\\n                tooLongFrequency[subsequenceLength]++;\\n            }//if\\n\\n            i = currentIndex;\\n\\n        }//while\\n\\n        boolean hasLowerCase = false;\\n        boolean hasUpperCase = false;\\n        boolean hasDigit = false;\\n        for (i = 0; i < password.length(); i++)\\n        {\\n            if ((password.charAt(i) >= \\'a\\') && (password.charAt(i) <= \\'z\\'))\\n            {\\n                hasLowerCase = true;\\n            }//if\\n            else if ((password.charAt(i) >= \\'A\\') && (password.charAt(i) <= \\'Z\\'))\\n            {\\n                hasUpperCase = true;\\n            }//else if\\n            else if ((password.charAt(i) >= \\'0\\') && (password.charAt(i) <= \\'9\\'))\\n            {\\n                hasDigit = true;\\n            }//else if\\n        }//for\\n\\n        int numDifferentTypesNeeded = (hasLowerCase ? 0 : 1) + (hasUpperCase ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n        int minLength = 6;\\n        int maxLength = 20;\\n\\n        int numEdits = 0;\\n        if (password.length() < minLength)\\n        {\\n            //TODO: this is not true for the general case. If minLength were larger than 6, we might have to do some replacements.\\n            //For example, if minLength = 15, and the password were \"AAAAAAAAAAAAAA\" (14 As), we would have to do replacements to break up the subsequence of As.\\n            numEdits = Math.max(minLength - password.length(), numDifferentTypesNeeded);\\n        }//if\\n        else\\n        {\\n\\n            int numToRemove = 0;\\n            int numRemoved = 0;\\n            if (password.length() > maxLength)\\n            {\\n\\n                numToRemove = password.length() - maxLength;\\n                //If we have tooLongFrequency[i] for some i, we can remove some of those. We prioritize the ones that would make a difference regarding how\\n                //many we would have to replace in order to get rid of the sequence. That is, we have to replace floor(length / 3). So if removing\\n                //one would cut down on the number of replacements, let\\'s do that first. Then we take two away from those that that will help reduce our\\n                //number of replacements, and finally we take three away from the remaining ones. This is only while our length is still longer than maxLength, of course.\\n                for (int startValue = troublesomeLength; startValue < troublesomeLength * 2; startValue++)\\n                {\\n                    i = startValue;\\n                    while ((numRemoved < numToRemove) && (i < tooLongFrequency.length))\\n                    {\\n                        int numToRemoveFromEach = ((i % troublesomeLength) + 1);\\n                        boolean adjusted = false;\\n                        while ((tooLongFrequency[i] > 0) && (numRemoved < numToRemove))\\n                        {\\n                            int numToRemoveThisTime;\\n                            if (numToRemoveFromEach == troublesomeLength)\\n                            {\\n                                numToRemoveThisTime = Math.min(i - (troublesomeLength - 1), numToRemove - numRemoved);\\n                            }//if\\n                            else\\n                            {\\n                                numToRemoveThisTime = Math.min(numToRemove - numRemoved, numToRemoveFromEach);\\n                            }//else\\n                            tooLongFrequency[i]--;\\n                            tooLongFrequency[i - numToRemoveThisTime]++;\\n                            numRemoved += numToRemoveThisTime;\\n                            adjusted = true;\\n                        }//while\\n                        \\n                        i += troublesomeLength;\\n                    }//while\\n                }//for\\n\\n                numRemoved = numToRemove;\\n\\n            }//if\\n\\n            int numToReplace = 0;\\n            for (i = troublesomeLength; i < tooLongFrequency.length; i++)\\n            {\\n                numToReplace += (tooLongFrequency[i] * (i / troublesomeLength));\\n            }//for\\n            \\n            numEdits = numRemoved + Math.max(numToReplace, numDifferentTypesNeeded);\\n\\n        }//else\\n\\n        return numEdits;\\n\\n    }//strongPasswordChecker\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922384,
                "title": "solution-that-allows-more-varied-constraints-o-n-o-number-of-char-classes",
                "content": "Basically, allows you to set the min/max password length, the maximum number of repeated adjacent characters, a list of custom character sets (as well as allowing you to choose how many must be used). Pretty straightforward expansion of the given problem\\n\\n```java\\nclass Solution {\\n    static Set<Character> lowerCase = new HashSet<Character>();\\n    static Set<Character> upperCase = new HashSet<Character>();\\n    static Set<Character> digits = new HashSet<Character>();\\n    \\n    static{\\n        for(char c = \\'a\\';c<=\\'z\\';c++)\\n            lowerCase.add(c);\\n        for(char c = \\'A\\';c<=\\'Z\\';c++)\\n            upperCase.add(c);\\n        for(char c = \\'0\\';c<=\\'9\\';c++)\\n            digits.add(c);\\n    }\\n\\t\\n    // solution for specific case asked for by the problem\\n    public int strongPasswordChecker(String s){\\n        Set<Set<Character>> charClasses = new HashSet<Set<Character>>();\\n        charClasses.add(lowerCase);\\n        charClasses.add(upperCase);\\n        charClasses.add(digits);\\n        return strongPasswordChecker(s,2,6,20,charClasses,3);\\n    }\\n\\t// return minimum number of changes (replacements, additions, deletions) to make a String s a valid password\\n\\t// s is the password to be tested\\n\\t// maxStreak is the maximum number of adjacent identical characters allowed\\n\\t// minLen, maxLen are the length limits (inclusive)\\n\\t// charClasses contains sets, each of which describes a specific character class we want in the pwd\\n\\t// charSetsNeeded is the minimum number of charsets from charClasses that must appear in the pwd\\n    public int strongPasswordChecker(String s, int maxStreak, int minLen, int maxLen, Set<Set<Character>> charClasses, int charSetsNeeded) {\\n\\t\\tmaxStreak++;\\n        minLen = Math.max(charClasses.size(),minLen);\\n\\t\\tif(s==null || maxLen<minLen || maxStreak <= 1)\\n\\t\\t\\treturn -1;\\n        if(s.length() == 0)\\n            return minLen;\\n        \\n\\t\\tint n = s.length();\\n\\t\\tmaxStreak = Math.min(maxStreak,Math.min(maxLen+1,s.length()+1));\\n        int[] streakCts = new int[maxStreak];\\n        int missingGood = Math.min(n,maxLen);\\n        int i=0,j=0;\\n\\t\\tSet<Set<Character>> unusedCharClasses = new HashSet<Set<Character>>(charClasses);\\n\\t\\tSet<Set<Character>> removals = new HashSet<Set<Character>>();\\n\\t\\t\\n        while(i<n){\\n            char cur = s.charAt(i);\\n\\t\\t\\tfor(Set<Character> x:unusedCharClasses){\\n\\t\\t\\t\\tif(x.contains(cur))\\n\\t\\t\\t\\t\\tremovals.add(x);\\n\\t\\t\\t}\\n\\t\\t\\tunusedCharClasses.removeAll(removals);\\n\\t\\t\\tcharSetsNeeded -= removals.size();\\n\\t\\t\\tremovals.clear();\\n\\t\\t\\t\\n            while(j<n && s.charAt(j)==cur)\\n                j++;\\n\\n            missingGood -= Math.min(maxStreak-1,j-i);\\n            if(j-i>=maxStreak)\\n\\t\\t\\t\\tstreakCts[(j-i)%maxStreak]++;\\n            streakCts[maxStreak-1] += (j-i-maxStreak)/maxStreak;\\n            i=j;\\n        }\\n\\t\\tcharSetsNeeded = Math.max(charSetsNeeded,0); // could be negative if the user made it extra secure\\n\\t\\t\\n        if(n <= maxLen){ // we wont delete anything\\n\\t\\t\\tint addRepl = 0; // number of additions and replacements made\\n\\t\\t\\tfor(int x: streakCts) // it takes one addition or replacement to fix each of these\\n\\t\\t\\t\\taddRepl += x;\\n\\t\\t\\taddRepl = Math.max(charSetsNeeded,addRepl); // if we need more new charSets than we are making changes, add those here\\n\\t\\t\\tif(addRepl-streakCts[maxStreak-1]+n>= minLen) // by fixing the streaks/adding missing charsets, we now have enough chars\\n\\t\\t\\t\\treturn addRepl;\\n\\t\\t\\treturn minLen-n+streakCts[maxStreak-1]; // we need maxStreak[n-1] substitutions and (minLen-s.length()) additions\\n\\t\\t}\\n        // replace chars in streaks until we have enough good chars to make up the final string\\n        int replace = 0;\\n        for(int x=maxStreak-1;x>=0 && missingGood>0;x--){\\n            int val = Math.min((missingGood+x)/(x+1),streakCts[x]);\\n            replace += val;\\n            missingGood -= (x+1)*val;\\n        }\\n        // Math.max(charSetsNeeded,replace) is the number of replacements\\n        // n-maxLen is the number of deletions\\n        return Math.max(charSetsNeeded,replace)+n-maxLen;\\n    }\\n}\\n```\\nLet me know what you think.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    static Set<Character> lowerCase = new HashSet<Character>();\\n    static Set<Character> upperCase = new HashSet<Character>();\\n    static Set<Character> digits = new HashSet<Character>();\\n    \\n    static{\\n        for(char c = \\'a\\';c<=\\'z\\';c++)\\n            lowerCase.add(c);\\n        for(char c = \\'A\\';c<=\\'Z\\';c++)\\n            upperCase.add(c);\\n        for(char c = \\'0\\';c<=\\'9\\';c++)\\n            digits.add(c);\\n    }\\n\\t\\n    // solution for specific case asked for by the problem\\n    public int strongPasswordChecker(String s){\\n        Set<Set<Character>> charClasses = new HashSet<Set<Character>>();\\n        charClasses.add(lowerCase);\\n        charClasses.add(upperCase);\\n        charClasses.add(digits);\\n        return strongPasswordChecker(s,2,6,20,charClasses,3);\\n    }\\n\\t// return minimum number of changes (replacements, additions, deletions) to make a String s a valid password\\n\\t// s is the password to be tested\\n\\t// maxStreak is the maximum number of adjacent identical characters allowed\\n\\t// minLen, maxLen are the length limits (inclusive)\\n\\t// charClasses contains sets, each of which describes a specific character class we want in the pwd\\n\\t// charSetsNeeded is the minimum number of charsets from charClasses that must appear in the pwd\\n    public int strongPasswordChecker(String s, int maxStreak, int minLen, int maxLen, Set<Set<Character>> charClasses, int charSetsNeeded) {\\n\\t\\tmaxStreak++;\\n        minLen = Math.max(charClasses.size(),minLen);\\n\\t\\tif(s==null || maxLen<minLen || maxStreak <= 1)\\n\\t\\t\\treturn -1;\\n        if(s.length() == 0)\\n            return minLen;\\n        \\n\\t\\tint n = s.length();\\n\\t\\tmaxStreak = Math.min(maxStreak,Math.min(maxLen+1,s.length()+1));\\n        int[] streakCts = new int[maxStreak];\\n        int missingGood = Math.min(n,maxLen);\\n        int i=0,j=0;\\n\\t\\tSet<Set<Character>> unusedCharClasses = new HashSet<Set<Character>>(charClasses);\\n\\t\\tSet<Set<Character>> removals = new HashSet<Set<Character>>();\\n\\t\\t\\n        while(i<n){\\n            char cur = s.charAt(i);\\n\\t\\t\\tfor(Set<Character> x:unusedCharClasses){\\n\\t\\t\\t\\tif(x.contains(cur))\\n\\t\\t\\t\\t\\tremovals.add(x);\\n\\t\\t\\t}\\n\\t\\t\\tunusedCharClasses.removeAll(removals);\\n\\t\\t\\tcharSetsNeeded -= removals.size();\\n\\t\\t\\tremovals.clear();\\n\\t\\t\\t\\n            while(j<n && s.charAt(j)==cur)\\n                j++;\\n\\n            missingGood -= Math.min(maxStreak-1,j-i);\\n            if(j-i>=maxStreak)\\n\\t\\t\\t\\tstreakCts[(j-i)%maxStreak]++;\\n            streakCts[maxStreak-1] += (j-i-maxStreak)/maxStreak;\\n            i=j;\\n        }\\n\\t\\tcharSetsNeeded = Math.max(charSetsNeeded,0); // could be negative if the user made it extra secure\\n\\t\\t\\n        if(n <= maxLen){ // we wont delete anything\\n\\t\\t\\tint addRepl = 0; // number of additions and replacements made\\n\\t\\t\\tfor(int x: streakCts) // it takes one addition or replacement to fix each of these\\n\\t\\t\\t\\taddRepl += x;\\n\\t\\t\\taddRepl = Math.max(charSetsNeeded,addRepl); // if we need more new charSets than we are making changes, add those here\\n\\t\\t\\tif(addRepl-streakCts[maxStreak-1]+n>= minLen) // by fixing the streaks/adding missing charsets, we now have enough chars\\n\\t\\t\\t\\treturn addRepl;\\n\\t\\t\\treturn minLen-n+streakCts[maxStreak-1]; // we need maxStreak[n-1] substitutions and (minLen-s.length()) additions\\n\\t\\t}\\n        // replace chars in streaks until we have enough good chars to make up the final string\\n        int replace = 0;\\n        for(int x=maxStreak-1;x>=0 && missingGood>0;x--){\\n            int val = Math.min((missingGood+x)/(x+1),streakCts[x]);\\n            replace += val;\\n            missingGood -= (x+1)*val;\\n        }\\n        // Math.max(charSetsNeeded,replace) is the number of replacements\\n        // n-maxLen is the number of deletions\\n        return Math.max(charSetsNeeded,replace)+n-maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839004,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int hash(int lower,int upper,int digs, int count, int len, int i)\\n    {\\n        return digs | upper<<1 | lower<<2 | count<<3 | len<<8 | i<<16;\\n    }\\n    unordered_map<int,int> memo;\\n    int strongPasswordChecker(string s) {\\n        function<int(int,int,int,int,char,int,int)> dp=[&](int lower,int upper,int digs, int count, char prev, int len, int i)\\n        {\\n            int ans = 1000000;\\n            auto h = hash(lower,upper,digs,count,len,i);\\n            if(count>=3)\\n            {\\n                return ans;\\n            }\\n            else if(i>=s.size() && len>=6)\\n            {\\n                if(lower>0 && upper>0 && digs>0 && len<=20)\\n                    ans = 0;   \\n                return ans;\\n            }\\n            else if(memo.count(h)>0)\\n            {\\n                return memo[h];\\n            }\\n            if(i<s.size())\\n            {\\n                auto c = s[i];\\n                auto l = (c>=\\'a\\' && c<=\\'z\\')?1:lower;\\n                auto u = (c>=\\'A\\' && c<=\\'Z\\')?1:upper;\\n                auto d = (c>=\\'0\\' && c<=\\'9\\')?1:digs;\\n                auto cnt = (c!=prev)?1:count+1;\\n                // use char i\\n                ans = min(ans,dp(l,u,d,cnt,c,len+1,i+1));\\n                // remove char i\\n                ans = min(ans,1+dp(lower,upper,digs,count,prev,len,i+1));\\n                // replace char i\\n                ans = min(ans,1+dp(1,upper,digs ,0,0,len+1,i+1));\\n                ans = min(ans,1+dp(lower,1,digs ,0,0,len+1,i+1));\\n                ans = min(ans,1+dp(lower,upper,1,0,0,len+1,i+1));\\n            }\\n            if(len<6)\\n            {\\n                // insert\\n                ans = min(ans,1+dp(1,upper,digs ,0,0,len+1,i));\\n                ans = min(ans,1+dp(lower,1,digs ,0,0,len+1,i));\\n                ans = min(ans,1+dp(lower,upper,1,0,0,len+1,i));\\n            }\\n            memo[h] = ans;\\n            return ans;\\n        };\\n        \\n        return dp(0,0,0,0,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hash(int lower,int upper,int digs, int count, int len, int i)\\n    {\\n        return digs | upper<<1 | lower<<2 | count<<3 | len<<8 | i<<16;\\n    }\\n    unordered_map<int,int> memo;\\n    int strongPasswordChecker(string s) {\\n        function<int(int,int,int,int,char,int,int)> dp=[&](int lower,int upper,int digs, int count, char prev, int len, int i)\\n        {\\n            int ans = 1000000;\\n            auto h = hash(lower,upper,digs,count,len,i);\\n            if(count>=3)\\n            {\\n                return ans;\\n            }\\n            else if(i>=s.size() && len>=6)\\n            {\\n                if(lower>0 && upper>0 && digs>0 && len<=20)\\n                    ans = 0;   \\n                return ans;\\n            }\\n            else if(memo.count(h)>0)\\n            {\\n                return memo[h];\\n            }\\n            if(i<s.size())\\n            {\\n                auto c = s[i];\\n                auto l = (c>=\\'a\\' && c<=\\'z\\')?1:lower;\\n                auto u = (c>=\\'A\\' && c<=\\'Z\\')?1:upper;\\n                auto d = (c>=\\'0\\' && c<=\\'9\\')?1:digs;\\n                auto cnt = (c!=prev)?1:count+1;\\n                // use char i\\n                ans = min(ans,dp(l,u,d,cnt,c,len+1,i+1));\\n                // remove char i\\n                ans = min(ans,1+dp(lower,upper,digs,count,prev,len,i+1));\\n                // replace char i\\n                ans = min(ans,1+dp(1,upper,digs ,0,0,len+1,i+1));\\n                ans = min(ans,1+dp(lower,1,digs ,0,0,len+1,i+1));\\n                ans = min(ans,1+dp(lower,upper,1,0,0,len+1,i+1));\\n            }\\n            if(len<6)\\n            {\\n                // insert\\n                ans = min(ans,1+dp(1,upper,digs ,0,0,len+1,i));\\n                ans = min(ans,1+dp(lower,1,digs ,0,0,len+1,i));\\n                ans = min(ans,1+dp(lower,upper,1,0,0,len+1,i));\\n            }\\n            memo[h] = ans;\\n            return ans;\\n        };\\n        \\n        return dp(0,0,0,0,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795451,
                "title": "fastest-python-solution-8ms",
                "content": "This solution for me ran in 8ms, equalling the fastest submission. I think it is mostly a fluke, but if anyone has an explanation feel free to comment:\\n\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        def count_complexity(s):\\n        # lower case, upper case, digits\\n            tests = [\\n                not any(x.islower() for x in s),\\n                not any(x.isupper() for x in s),\\n                not any(x.isdigit() for x in s),\\n            ]\\n            return sum(tests)\\n\\n        def count_repeats(s):\\n            # more than 3 repeats\\n            all_counts = []\\n            count = 1\\n            previous = None\\n            for c in s:\\n                if c == previous:\\n                    count += 1\\n                else:\\n                    if count >= 3:\\n                        all_counts.append(count)\\n                    count = 1\\n                previous = c\\n            if count >= 3:\\n                all_counts.append(count)\\n            return all_counts\\n\\n        if len(s) <= 20:\\n            \\'replace repeats, add length, add complexities\\'\\n            fix_repeats = sum(c // 3 for c in count_repeats(s))\\n            return max(6-len(s), count_complexity(s), fix_repeats)\\n\\n        if len(s) > 20:\\n            \\'delete chars or repeats, replace for complexity\\'\\n            n_delete = len(s) - 20\\n            r = count_repeats(s)\\n            n = 0\\n            while n < n_delete:\\n                found = False\\n                for i in range(len(r)):\\n                    f = filter(lambda x: x >= 3, r)\\n                    if not f:\\n                        break\\n                    if r[i] == min(f, key=lambda x: x % 3):\\n                        found = True\\n                        r[i] -= 1\\n                        n += 1\\n                        if n >= n_delete:\\n                            break\\n                if not found:\\n                    break\\n            repeats_leftover = sum(c // 3 for c in r)\\n            return n_delete + max(repeats_leftover, count_complexity(s))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        def count_complexity(s):\\n        # lower case, upper case, digits\\n            tests = [\\n                not any(x.islower() for x in s),\\n                not any(x.isupper() for x in s),\\n                not any(x.isdigit() for x in s),\\n            ]\\n            return sum(tests)\\n\\n        def count_repeats(s):\\n            # more than 3 repeats\\n            all_counts = []\\n            count = 1\\n            previous = None\\n            for c in s:\\n                if c == previous:\\n                    count += 1\\n                else:\\n                    if count >= 3:\\n                        all_counts.append(count)\\n                    count = 1\\n                previous = c\\n            if count >= 3:\\n                all_counts.append(count)\\n            return all_counts\\n\\n        if len(s) <= 20:\\n            \\'replace repeats, add length, add complexities\\'\\n            fix_repeats = sum(c // 3 for c in count_repeats(s))\\n            return max(6-len(s), count_complexity(s), fix_repeats)\\n\\n        if len(s) > 20:\\n            \\'delete chars or repeats, replace for complexity\\'\\n            n_delete = len(s) - 20\\n            r = count_repeats(s)\\n            n = 0\\n            while n < n_delete:\\n                found = False\\n                for i in range(len(r)):\\n                    f = filter(lambda x: x >= 3, r)\\n                    if not f:\\n                        break\\n                    if r[i] == min(f, key=lambda x: x % 3):\\n                        found = True\\n                        r[i] -= 1\\n                        n += 1\\n                        if n >= n_delete:\\n                            break\\n                if not found:\\n                    break\\n            repeats_leftover = sum(c // 3 for c in r)\\n            return n_delete + max(repeats_leftover, count_complexity(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701035,
                "title": "c-solution",
                "content": "```\\n        public class Solution\\n        {\\n            public int StrongPasswordChecker(string s)\\n            {\\n                bool lower = false, upper = false, digit = false;\\n                Dictionary<int, int> lengthToCount = new Dictionary<int, int>();\\n                foreach (var charA in s)\\n                {\\n                    lower = Char.IsLower(charA) | lower;\\n                    upper = Char.IsUpper(charA) | upper;\\n                    digit = Char.IsDigit(charA) | digit;\\n\\n                    if (lower & upper & digit)\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                int replacesToBeMade = (lower ? 0 : 1) + (upper ? 0 : 1) + (digit ? 0 : 1);\\n                bool isLength = false;\\n                int length = 0;\\n                for (int i = 1; i < s.Length; i++)\\n                {\\n                    if (s[i] == s[i - 1])\\n                    {\\n                        if (!isLength)\\n                        {\\n                            isLength = true;\\n                            length = 2;\\n                        }\\n                        else\\n                        {\\n                            length++;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if (isLength)\\n                        {\\n                            isLength = false;\\n                            if (length >= 3)\\n                            {\\n                                if (!lengthToCount.ContainsKey(length))\\n                                {\\n                                    lengthToCount[length] = 0;\\n                                }\\n                                lengthToCount[length]++;\\n                            }\\n                            length = 0;\\n                        }\\n                    }\\n                }\\n\\n                if (isLength && length >= 3)\\n                {\\n                    if (!lengthToCount.ContainsKey(length))\\n                    {\\n                        lengthToCount[length] = 0;\\n                    }\\n                    lengthToCount[length]++;\\n                }\\n\\n                int toDelete = Math.Max(0, s.Length - 20);\\n                int toDeleteGen = Math.Max(0, s.Length - 20);\\n                int toReplaceGen = replacesToBeMade;\\n                int toAdd = Math.Max(6 - s.Length, 0);\\n\\n                if (toAdd > 0)\\n                {\\n                    if (lengthToCount.ContainsKey(5))\\n                    {\\n                        return 2;\\n                    }\\n\\n                    return toAdd;\\n                }\\n                var keysSorted = lengthToCount.Keys.ToArray();\\n                Array.Sort(keysSorted);\\n\\n                int totalToHandle = lengthToCount.Values.Sum();\\n                int handled = 0;\\n                foreach (var lengthSeq in keysSorted)\\n                {\\n                    for (int i = 0; i < lengthToCount[lengthSeq]; i++)\\n                    {\\n                        handled++;\\n                        if (totalToHandle == handled || toDelete <= 0 || keysSorted.Length == 1)\\n                        {\\n                            int toFixInReplace = lengthSeq / 3;\\n                            if (totalToHandle == handled)\\n                            {\\n                                toFixInReplace = (lengthSeq - toDelete) / 3;\\n                                toDelete = 0;\\n                            }\\n                            if (toFixInReplace <= replacesToBeMade || toDelete <= 0)\\n                            {\\n                                replacesToBeMade -= toFixInReplace;\\n                            }\\n                            else\\n                            {\\n                                toFixInReplace -= replacesToBeMade;\\n                                toDelete -= (lengthSeq - 3 * replacesToBeMade) - 3 + 1;\\n                                replacesToBeMade = 0;\\n                            }\\n                        }\\n                        else\\n                        {\\n                            toDelete -= lengthSeq - 3 + 1;\\n                        }\\n                    }\\n                }\\n                var done = toReplaceGen + Math.Max(0, (-1) * replacesToBeMade) + Math.Max(0, (-1) * toDelete) + toDeleteGen;\\n                return done;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution\\n        {\\n            public int StrongPasswordChecker(string s)\\n            {\\n                bool lower = false, upper = false, digit = false;\\n                Dictionary<int, int> lengthToCount = new Dictionary<int, int>();\\n                foreach (var charA in s)\\n                {\\n                    lower = Char.IsLower(charA) | lower;\\n                    upper = Char.IsUpper(charA) | upper;\\n                    digit = Char.IsDigit(charA) | digit;\\n\\n                    if (lower & upper & digit)\\n                    {\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 534390,
                "title": "heavy-scaring-accepted-c-solution-multi-dimensional-dp",
                "content": "dp[i,j,k,t] = possibility to make substring [0, i] of password valid with j removals, k additions and t replacements\\n\\n\\n```\\n    public class Solution\\n    {\\n\\n        public int StrongPasswordChecker(string s)\\n        {\\n            int digitsCount = 0;\\n            int lowerCaseCount = 0;\\n            int upperCaseCount = 0;\\n\\n\\n            foreach (var c in s)\\n            {\\n                if (c >= \\'0\\' && c <= \\'9\\')\\n                {\\n                    digitsCount++;\\n                    continue;\\n                }\\n\\n                if (c >= \\'a\\' && c <= \\'z\\')\\n                {\\n                    lowerCaseCount++;\\n                    continue;\\n                }\\n\\n                if (c >= \\'A\\' && c <= \\'Z\\')\\n                {\\n                    upperCaseCount++;\\n                }\\n            }\\n\\n            int requireToHave = 0;\\n\\n            if (digitsCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n            if (lowerCaseCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n            if (upperCaseCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n\\n            checked\\n            {\\n                int availableRemoves = Math.Max(0, s.Length - 6);\\n                int requiredRemoves = Math.Max(0, s.Length - 20);\\n\\n                int availableAdditions = Math.Max(0, 20 - s.Length);\\n                int requiredAdditions = Math.Max(0, 6 - s.Length);\\n\\n                bool[,,,] dp = new bool[s.Length + 1, availableRemoves + 1, availableAdditions + 1, s.Length + 1];\\n\\n                for (int lengthIdx = 0; lengthIdx <= s.Length; lengthIdx++)\\n                {\\n                    for (int removeIdx = 0; removeIdx <= availableRemoves; removeIdx++)\\n                    {\\n                        for (int addIdx = 0; addIdx <= availableAdditions; addIdx++)\\n                        {\\n                            for (int replacementIdx = 0; replacementIdx <= s.Length; replacementIdx++)\\n                            {\\n                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] = false;\\n\\n                                if (lengthIdx == 0)\\n                                {\\n                                    if (removeIdx == 0 && replacementIdx == 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] = true;\\n                                    }\\n                                    continue;\\n                                }\\n\\n\\n                                if (removeIdx + replacementIdx > lengthIdx)\\n                                {\\n                                    continue;\\n                                }\\n\\n\\n                                if (removeIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx - 1, addIdx, replacementIdx];\\n                                }\\n\\n                                if (addIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx - 1, replacementIdx];\\n                                }\\n\\n                                if (replacementIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx, replacementIdx - 1];\\n                                }\\n\\n                                \\n                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx, replacementIdx];\\n\\n                                int lastCharIdx = lengthIdx - 1;\\n                                for (int i = lengthIdx - 1; i > 0; i--)\\n                                {\\n                                    bool needToBreak = false;\\n                                    if (s[i - 1] == s[lastCharIdx])\\n                                    {\\n                                        var repeatingLength = lastCharIdx - (i - 1) + 1;\\n                                        if (repeatingLength == 3)\\n                                        {\\n                                            needToBreak = true;\\n                                        }\\n                                    }\\n                                    else\\n                                    {\\n                                        lastCharIdx = i - 1;\\n                                    }\\n\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx, replacementIdx];\\n\\n                                    if (removeIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx - 1, addIdx, replacementIdx];\\n                                    }\\n\\n                                    if (addIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx - 1, replacementIdx];\\n                                    }\\n\\n                                    if (replacementIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx, replacementIdx - 1];\\n                                    }\\n\\n                                    if (needToBreak)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] = false;\\n\\n                                        for (int j = i; j < lengthIdx; j++)\\n                                        {\\n                                            if (addIdx != 0)\\n                                            {\\n                                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[j - 1, removeIdx, addIdx - 1, replacementIdx];\\n                                            }\\n\\n                                            if (replacementIdx != 0)\\n                                            {\\n                                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[j - 1, removeIdx, addIdx, replacementIdx - 1];\\n                                            }\\n                                        }\\n\\n\\n                                        int idx = lastCharIdx;\\n                                        while (idx >= 0 && s[idx] == s[lastCharIdx])\\n                                        {\\n                                            idx--;\\n                                        }\\n                                        idx++;\\n                                        int repeatingCount = lastCharIdx - idx + 1;\\n                                        int removing = repeatingCount - 2;\\n\\n                                        if (removeIdx - removing >= 0)\\n                                        {\\n                                            dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[idx, removeIdx - removing, addIdx, replacementIdx];\\n\\n                                        }\\n\\n                                        break;\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n\\n                long res = int.MaxValue;\\n\\n                for (int removeIdx = requiredRemoves; removeIdx <= availableRemoves; removeIdx++)\\n                {\\n                    for (int addIdx = requiredAdditions; addIdx <= availableAdditions; addIdx++)\\n                    {\\n                        for (int replacementIdx = 0; replacementIdx <= s.Length; replacementIdx++)\\n                        {\\n                            if (dp[s.Length, removeIdx, addIdx, replacementIdx] && addIdx + replacementIdx >= requireToHave)\\n                            {\\n                                res = Math.Min(res,  removeIdx + addIdx + replacementIdx);\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                return (int) res;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public class Solution\\n    {\\n\\n        public int StrongPasswordChecker(string s)\\n        {\\n            int digitsCount = 0;\\n            int lowerCaseCount = 0;\\n            int upperCaseCount = 0;\\n\\n\\n            foreach (var c in s)\\n            {\\n                if (c >= \\'0\\' && c <= \\'9\\')\\n                {\\n                    digitsCount++;\\n                    continue;\\n                }\\n\\n                if (c >= \\'a\\' && c <= \\'z\\')\\n                {\\n                    lowerCaseCount++;\\n                    continue;\\n                }\\n\\n                if (c >= \\'A\\' && c <= \\'Z\\')\\n                {\\n                    upperCaseCount++;\\n                }\\n            }\\n\\n            int requireToHave = 0;\\n\\n            if (digitsCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n            if (lowerCaseCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n            if (upperCaseCount == 0)\\n            {\\n                requireToHave++;\\n            }\\n\\n\\n            checked\\n            {\\n                int availableRemoves = Math.Max(0, s.Length - 6);\\n                int requiredRemoves = Math.Max(0, s.Length - 20);\\n\\n                int availableAdditions = Math.Max(0, 20 - s.Length);\\n                int requiredAdditions = Math.Max(0, 6 - s.Length);\\n\\n                bool[,,,] dp = new bool[s.Length + 1, availableRemoves + 1, availableAdditions + 1, s.Length + 1];\\n\\n                for (int lengthIdx = 0; lengthIdx <= s.Length; lengthIdx++)\\n                {\\n                    for (int removeIdx = 0; removeIdx <= availableRemoves; removeIdx++)\\n                    {\\n                        for (int addIdx = 0; addIdx <= availableAdditions; addIdx++)\\n                        {\\n                            for (int replacementIdx = 0; replacementIdx <= s.Length; replacementIdx++)\\n                            {\\n                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] = false;\\n\\n                                if (lengthIdx == 0)\\n                                {\\n                                    if (removeIdx == 0 && replacementIdx == 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] = true;\\n                                    }\\n                                    continue;\\n                                }\\n\\n\\n                                if (removeIdx + replacementIdx > lengthIdx)\\n                                {\\n                                    continue;\\n                                }\\n\\n\\n                                if (removeIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx - 1, addIdx, replacementIdx];\\n                                }\\n\\n                                if (addIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx - 1, replacementIdx];\\n                                }\\n\\n                                if (replacementIdx != 0)\\n                                {\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx, replacementIdx - 1];\\n                                }\\n\\n                                \\n                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[lengthIdx - 1, removeIdx, addIdx, replacementIdx];\\n\\n                                int lastCharIdx = lengthIdx - 1;\\n                                for (int i = lengthIdx - 1; i > 0; i--)\\n                                {\\n                                    bool needToBreak = false;\\n                                    if (s[i - 1] == s[lastCharIdx])\\n                                    {\\n                                        var repeatingLength = lastCharIdx - (i - 1) + 1;\\n                                        if (repeatingLength == 3)\\n                                        {\\n                                            needToBreak = true;\\n                                        }\\n                                    }\\n                                    else\\n                                    {\\n                                        lastCharIdx = i - 1;\\n                                    }\\n\\n                                    dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx, replacementIdx];\\n\\n                                    if (removeIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx - 1, addIdx, replacementIdx];\\n                                    }\\n\\n                                    if (addIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx - 1, replacementIdx];\\n                                    }\\n\\n                                    if (replacementIdx != 0)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[i, removeIdx, addIdx, replacementIdx - 1];\\n                                    }\\n\\n                                    if (needToBreak)\\n                                    {\\n                                        dp[lengthIdx, removeIdx, addIdx, replacementIdx] = false;\\n\\n                                        for (int j = i; j < lengthIdx; j++)\\n                                        {\\n                                            if (addIdx != 0)\\n                                            {\\n                                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[j - 1, removeIdx, addIdx - 1, replacementIdx];\\n                                            }\\n\\n                                            if (replacementIdx != 0)\\n                                            {\\n                                                dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[j - 1, removeIdx, addIdx, replacementIdx - 1];\\n                                            }\\n                                        }\\n\\n\\n                                        int idx = lastCharIdx;\\n                                        while (idx >= 0 && s[idx] == s[lastCharIdx])\\n                                        {\\n                                            idx--;\\n                                        }\\n                                        idx++;\\n                                        int repeatingCount = lastCharIdx - idx + 1;\\n                                        int removing = repeatingCount - 2;\\n\\n                                        if (removeIdx - removing >= 0)\\n                                        {\\n                                            dp[lengthIdx, removeIdx, addIdx, replacementIdx] |= dp[idx, removeIdx - removing, addIdx, replacementIdx];\\n\\n                                        }\\n\\n                                        break;\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n\\n                long res = int.MaxValue;\\n\\n                for (int removeIdx = requiredRemoves; removeIdx <= availableRemoves; removeIdx++)\\n                {\\n                    for (int addIdx = requiredAdditions; addIdx <= availableAdditions; addIdx++)\\n                    {\\n                        for (int replacementIdx = 0; replacementIdx <= s.Length; replacementIdx++)\\n                        {\\n                            if (dp[s.Length, removeIdx, addIdx, replacementIdx] && addIdx + replacementIdx >= requireToHave)\\n                            {\\n                                res = Math.Min(res,  removeIdx + addIdx + replacementIdx);\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                return (int) res;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509488,
                "title": "golang",
                "content": "Damn. This problem must be banned from the interview. So hard to do.\\n```\\nhttps://leetcode.com/problems/strong-password-checker/discuss/91007/C%2B%2B-0ms-O(n)-35-lines-solution-with-detailed-explanation\\nfunc strongPasswordChecker(s string) int {\\n\\thasDigit, hasLowerCase, hasUpperCase := 0, 0, 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] <= \\'9\\' && s[i] >= \\'0\\' {\\n\\t\\t\\thasDigit = 1\\n\\t\\t}\\n\\t\\tif s[i] <= \\'z\\' && s[i] >= \\'a\\' {\\n\\t\\t\\thasLowerCase = 1\\n\\t\\t}\\n\\t\\tif s[i] <= \\'Z\\' && s[i] >= \\'A\\' {\\n\\t\\t\\thasUpperCase = 1\\n\\t\\t}\\n\\t}\\n\\n\\tneedChars := 3 - (hasDigit + hasLowerCase + hasUpperCase)\\n\\tif len(s) <= 4 {\\n\\t\\treturn 6 - len(s)\\n\\t}\\n\\n\\tif len(s) == 5 {\\n\\t\\treturn max(6-len(s), needChars)\\n\\t}\\n\\n\\ti := 0\\n\\tcountThreeRepeat := 0\\n\\tfor i < len(s) {\\n\\t\\tif i < len(s) && i+1 < len(s) && i+2 < len(s) &&\\n\\t\\t\\ts[i] == s[i+1] && s[i] == s[i+2] {\\n\\t\\t\\tcountThreeRepeat++\\n\\t\\t\\ti += 3\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\tfor len(s) >= 6 && len(s) <= 20 {\\n\\t\\treturn max(countThreeRepeat, needChars)\\n\\t}\\n\\n\\t// now len(s) > 20\\n\\tneedDelete := len(s) - 20\\n\\tresult := 0\\n\\tif needChars > 0 {\\n\\t\\tresult += needChars\\n\\t\\tcountThreeRepeat -= needChars\\n\\t}\\n\\n\\tif countThreeRepeat <= 0 || needDelete > 3*countThreeRepeat {\\n\\t\\tresult += needDelete\\n\\t\\treturn result\\n\\t}\\n\\n\\treturn mostComplicated(s, needChars)\\n}\\n\\nfunc mostComplicated(s string, needChars int) int {\\n\\tneedDelete := len(s) - 20\\n\\trepeat := []int{}\\n\\tidx := 0\\n\\tfor idx < len(s) {\\n\\t\\tj := idx\\n\\t\\tfor j < len(s) && s[idx] == s[j] {\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t\\tcount := j - idx\\n\\t\\tif count > 2 {\\n\\t\\t\\trepeat = append(repeat, count)\\n\\t\\t}\\n\\t\\tidx = j\\n\\t}\\n\\n\\tresult := needChars\\n\\tfor i := 0; i < needChars; i++ {\\n\\t\\tsort.Ints(repeat)\\n\\t\\treplaced := false\\n\\t\\tfor k := 2; k >= 0; k-- {\\n\\t\\t\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\t\\t\\tif repeat[j] > 2 && repeat[j]%3 == k {\\n\\t\\t\\t\\t\\trepeat[j] -= 3\\n\\t\\t\\t\\t\\treplaced = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif replaced {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif replaced {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tsort.Ints(repeat)\\n\\tfor needDelete > 0 {\\n\\t\\tbr := true\\n\\t\\tfor k := 0; k <= 2; k++ {\\n\\t\\t\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\t\\t\\tif repeat[j] > 2 && repeat[j]%3 == k && needDelete >= k+1 {\\n\\t\\t\\t\\t\\trepeat[j] -= (k + 1)\\n\\t\\t\\t\\t\\tneedDelete -= (k + 1)\\n\\t\\t\\t\\t\\tresult += (k + 1)\\n\\t\\t\\t\\t\\tbr = false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif br {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tresult += needDelete\\n\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\tresult += repeat[j] / 3\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nhttps://leetcode.com/problems/strong-password-checker/discuss/91007/C%2B%2B-0ms-O(n)-35-lines-solution-with-detailed-explanation\\nfunc strongPasswordChecker(s string) int {\\n\\thasDigit, hasLowerCase, hasUpperCase := 0, 0, 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] <= \\'9\\' && s[i] >= \\'0\\' {\\n\\t\\t\\thasDigit = 1\\n\\t\\t}\\n\\t\\tif s[i] <= \\'z\\' && s[i] >= \\'a\\' {\\n\\t\\t\\thasLowerCase = 1\\n\\t\\t}\\n\\t\\tif s[i] <= \\'Z\\' && s[i] >= \\'A\\' {\\n\\t\\t\\thasUpperCase = 1\\n\\t\\t}\\n\\t}\\n\\n\\tneedChars := 3 - (hasDigit + hasLowerCase + hasUpperCase)\\n\\tif len(s) <= 4 {\\n\\t\\treturn 6 - len(s)\\n\\t}\\n\\n\\tif len(s) == 5 {\\n\\t\\treturn max(6-len(s), needChars)\\n\\t}\\n\\n\\ti := 0\\n\\tcountThreeRepeat := 0\\n\\tfor i < len(s) {\\n\\t\\tif i < len(s) && i+1 < len(s) && i+2 < len(s) &&\\n\\t\\t\\ts[i] == s[i+1] && s[i] == s[i+2] {\\n\\t\\t\\tcountThreeRepeat++\\n\\t\\t\\ti += 3\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\tfor len(s) >= 6 && len(s) <= 20 {\\n\\t\\treturn max(countThreeRepeat, needChars)\\n\\t}\\n\\n\\t// now len(s) > 20\\n\\tneedDelete := len(s) - 20\\n\\tresult := 0\\n\\tif needChars > 0 {\\n\\t\\tresult += needChars\\n\\t\\tcountThreeRepeat -= needChars\\n\\t}\\n\\n\\tif countThreeRepeat <= 0 || needDelete > 3*countThreeRepeat {\\n\\t\\tresult += needDelete\\n\\t\\treturn result\\n\\t}\\n\\n\\treturn mostComplicated(s, needChars)\\n}\\n\\nfunc mostComplicated(s string, needChars int) int {\\n\\tneedDelete := len(s) - 20\\n\\trepeat := []int{}\\n\\tidx := 0\\n\\tfor idx < len(s) {\\n\\t\\tj := idx\\n\\t\\tfor j < len(s) && s[idx] == s[j] {\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t\\tcount := j - idx\\n\\t\\tif count > 2 {\\n\\t\\t\\trepeat = append(repeat, count)\\n\\t\\t}\\n\\t\\tidx = j\\n\\t}\\n\\n\\tresult := needChars\\n\\tfor i := 0; i < needChars; i++ {\\n\\t\\tsort.Ints(repeat)\\n\\t\\treplaced := false\\n\\t\\tfor k := 2; k >= 0; k-- {\\n\\t\\t\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\t\\t\\tif repeat[j] > 2 && repeat[j]%3 == k {\\n\\t\\t\\t\\t\\trepeat[j] -= 3\\n\\t\\t\\t\\t\\treplaced = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif replaced {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif replaced {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tsort.Ints(repeat)\\n\\tfor needDelete > 0 {\\n\\t\\tbr := true\\n\\t\\tfor k := 0; k <= 2; k++ {\\n\\t\\t\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\t\\t\\tif repeat[j] > 2 && repeat[j]%3 == k && needDelete >= k+1 {\\n\\t\\t\\t\\t\\trepeat[j] -= (k + 1)\\n\\t\\t\\t\\t\\tneedDelete -= (k + 1)\\n\\t\\t\\t\\t\\tresult += (k + 1)\\n\\t\\t\\t\\t\\tbr = false\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif br {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tresult += needDelete\\n\\tfor j := 0; j < len(repeat); j++ {\\n\\t\\tresult += repeat[j] / 3\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 474981,
                "title": "c-0ms-100-8-4mb-75",
                "content": "* Runtime: 0 ms, faster than 100.00% of C++ online submissions for Strong Password Checker.\\n* Memory Usage: 8.4 MB, less than 75.00% of C++ online submissions for Strong Password Checker.\\n\\nWoof, this solution is a dog. It\\'s not refined because I wasted too much time by jumping in without stepping through some test cases manually to make sure I knew what results I expected.\\n\\nThere\\'s room to reduce memory and computation time. But 80 lines that are simple enough I can understand them a year from now, that\\'s something too.\\n\\nFor passwords <=20 characters, the whole program can be simple. Don\\'t try to write a solution without first understanding the most complicated cases where deletion must be used carefully to return the fewest edits necessary.\\n\\nYou want to turn any \\'xxx\\' into \\'xx\\' first.\\nIf you are still required to make deletions, to satisfy the 20 character limit, then delete to turn \\'xxxx\\' into \\'xxx\\'. If necessary, the next deletion is to turn \\'xxx\\' into \\'xx\\', before deleting from any other 4/5/6/...-tuplets.\\n\\nThe easier part is just tallying all triplets, replacing /inserting one character from each.  That\\'s the answer, unless the number of missing characters and the number of missing required character-types is greater.\\n \\n\\n```\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\\n\\nclass Solution {\\npublic:\\nint strongPasswordChecker(string s)\\n{\\n    bitset<3> requirements{111}; // 0:lowercase, 1:uppercase, 2:number\\n    list<int> repeats;           // store length of repeated character sequences\\n\\n    auto it = s.begin(); // 2 pointers to track length of repeated characters\\n    auto it2 = s.end();\\n    while (it != s.end())\\n    {\\n        if (*it != *it2) // TODO: skip checks when none left\\n        {\\n            if (requirements.test(0) && islower(*it))\\n                requirements.reset(0);\\n            if (requirements.test(1) && isupper(*it))\\n                requirements.reset(1);\\n            if (requirements.test(2) && isdigit(*it))\\n                requirements.reset(2);\\n        }\\n        else // fast forward through repeated characters\\n        {\\n            while (it != s.end() && *it == *it2)\\n                ++it;\\n\\n            if (distance(it2, it) != 2)\\n                repeats.push_back(distance(it2, it));\\n\\n            if (it != s.end())\\n                continue;\\n            else\\n                break;\\n        }\\n        it2 = it;\\n        ++it;\\n    }\\n    // sort all repeats. Runs of 3,6,9... at the front, followed by 4,7,10,... then 5,8,11...\\n    // to minimize deletes, just pick from the front\\n    repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); }); // while length>20 delete\\n    // while length<=20 replace\\n    // while length<6 insert\\n    int ans{0}, len{static_cast<int>(s.size())};\\n    while (len > 20)\\n    {\\n        if (!repeats.empty())\\n        {\\n            if (repeats.front() == 3)\\n            {\\n                repeats.pop_front();\\n            }\\n            else\\n            {\\n                --repeats.front();\\n                repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n            }\\n\\n            ++ans;\\n            --len;\\n        }\\n        else\\n        {\\n            ans += len - 20;\\n            len = 20;\\n        }\\n    }\\n\\n    // requirements: need min requirements.count() replace/inserts\\n    // triples: 1 replace for every repeats.top()/3 chars\\n    int rep_ins{0};\\n    while (!repeats.empty())\\n    {\\n        rep_ins += repeats.front() / 3;\\n        repeats.pop_front();\\n    }\\n\\n    if ((len + rep_ins) < 6)\\n    {\\n        rep_ins += 6 - len - rep_ins;\\n    }\\n    ans += max(static_cast<int>(requirements.count()), rep_ins);\\n\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\\n\\nclass Solution {\\npublic:\\nint strongPasswordChecker(string s)\\n{\\n    bitset<3> requirements{111}; // 0:lowercase, 1:uppercase, 2:number\\n    list<int> repeats;           // store length of repeated character sequences\\n\\n    auto it = s.begin(); // 2 pointers to track length of repeated characters\\n    auto it2 = s.end();\\n    while (it != s.end())\\n    {\\n        if (*it != *it2) // TODO: skip checks when none left\\n        {\\n            if (requirements.test(0) && islower(*it))\\n                requirements.reset(0);\\n            if (requirements.test(1) && isupper(*it))\\n                requirements.reset(1);\\n            if (requirements.test(2) && isdigit(*it))\\n                requirements.reset(2);\\n        }\\n        else // fast forward through repeated characters\\n        {\\n            while (it != s.end() && *it == *it2)\\n                ++it;\\n\\n            if (distance(it2, it) != 2)\\n                repeats.push_back(distance(it2, it));\\n\\n            if (it != s.end())\\n                continue;\\n            else\\n                break;\\n        }\\n        it2 = it;\\n        ++it;\\n    }\\n    // sort all repeats. Runs of 3,6,9... at the front, followed by 4,7,10,... then 5,8,11...\\n    // to minimize deletes, just pick from the front\\n    repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); }); // while length>20 delete\\n    // while length<=20 replace\\n    // while length<6 insert\\n    int ans{0}, len{static_cast<int>(s.size())};\\n    while (len > 20)\\n    {\\n        if (!repeats.empty())\\n        {\\n            if (repeats.front() == 3)\\n            {\\n                repeats.pop_front();\\n            }\\n            else\\n            {\\n                --repeats.front();\\n                repeats.sort([](const int &lhs, const int &rhs) { return (lhs % 3) < (rhs % 3); });\\n            }\\n\\n            ++ans;\\n            --len;\\n        }\\n        else\\n        {\\n            ans += len - 20;\\n            len = 20;\\n        }\\n    }\\n\\n    // requirements: need min requirements.count() replace/inserts\\n    // triples: 1 replace for every repeats.top()/3 chars\\n    int rep_ins{0};\\n    while (!repeats.empty())\\n    {\\n        rep_ins += repeats.front() / 3;\\n        repeats.pop_front();\\n    }\\n\\n    if ((len + rep_ins) < 6)\\n    {\\n        rep_ins += 6 - len - rep_ins;\\n    }\\n    ans += max(static_cast<int>(requirements.count()), rep_ins);\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460328,
                "title": "o-n-one-pass-simple-easy-to-understand-clean-code",
                "content": "```\\n// O(N) single-pass solution.\\n// Key is to recognise changes can simultaneously satisfy multiple conditions at the same time.\\n\\n#include <string>\\n\\nusing namespace std;\\n\\nconstexpr inline int maxlen = 20;\\nconstexpr inline int minlen = 6;\\n\\nclass Solution {\\npublic:    \\n    int strongPasswordChecker(string s) {\\n        int type1=0, type2=0, type3=0;\\n        \\n        char prev_char = 0;\\n        int cur_seq_len = 0;\\n        \\n        // A sequence is a contiguous series of the same char. \\n        // To fix a sequence to satisfy condition #3, we either delete chars from the sequence, insert chars or replace certain chars in the sequence.\\n        // The min # of chars to replace is floor(sequence_length / 3).\\n        // count_seq_mod[i] = # times we can delete (i+1) chars from any sequence so as to reduce the replacement count by 1\\n        int count_seq_mod[3] = {0};\\n        \\n        int replacements = 0;\\n        \\n        for (char c: s) {\\n            if (\\'a\\' <= c && c <= \\'z\\') type1=1;\\n            else if (\\'A\\' <= c && c<= \\'Z\\') type2=1;\\n            else if (\\'0\\' <= c&& c <= \\'9\\') type3=1;\\n            \\n            if (prev_char != c){\\n                if (cur_seq_len >= 3) {\\n                    if (cur_seq_len % 3 != 2)\\n                        count_seq_mod[cur_seq_len % 3]++;\\n                    \\n                    count_seq_mod[2] += (cur_seq_len - 2) / 3;\\n                }\\n                // we need this min # replacement to fix the sequence\\n                replacements += cur_seq_len / 3;\\n                cur_seq_len = 1;\\n            }\\n            else {\\n                cur_seq_len ++;\\n            }\\n            \\n            prev_char = c;\\n        }    \\n        \\n        // End the current sequence. \\n        if (cur_seq_len >= 3) {\\n            if (cur_seq_len % 3 != 2)\\n                count_seq_mod[cur_seq_len % 3]++;\\n\\n            count_seq_mod[2] += (cur_seq_len - 2) / 3;\\n        }\\n        replacements += cur_seq_len / 3;\\n        \\n        int type_count = type1+type2+type3;\\n        replacements = max(3 - type_count, replacements);\\n        \\n        if (s.size() < minlen){\\n            // Just need to insert or replace chars.\\n            // Inserting chars can be used instead of replacement to fix sequences and to fulfil the 3 types, hence we use \\'max\\'.\\n            return max(replacements, minlen - (int)s.size());\\n        }\\n        else if (s.size() <= maxlen){\\n              \\n            // Maintain the string length and replace min # chars to fix the sequences\\n            // and to fulfil the 3 types\\n            return replacements;\\n        }\\n\\n        // We must delete this number of chars to fit within maxlen.\\n        const int deletes = s.size() - maxlen;\\n\\n        // Since we must delete, we might as well use them to fix sequences and thereby reducing # replacements needed.\\n        \\n        int deletes_used = 0;\\n        \\n        for (int i = 1; i <= 3; i++){\\n            int reduced_replacements = min((deletes - deletes_used) / i, count_seq_mod[i - 1]);\\n            replacements -= reduced_replacements;\\n            deletes_used += reduced_replacements * i;            \\n        }\\n\\n        return deletes + max(3-type_count, replacements);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// O(N) single-pass solution.\\n// Key is to recognise changes can simultaneously satisfy multiple conditions at the same time.\\n\\n#include <string>\\n\\nusing namespace std;\\n\\nconstexpr inline int maxlen = 20;\\nconstexpr inline int minlen = 6;\\n\\nclass Solution {\\npublic:    \\n    int strongPasswordChecker(string s) {\\n        int type1=0, type2=0, type3=0;\\n        \\n        char prev_char = 0;\\n        int cur_seq_len = 0;\\n        \\n        // A sequence is a contiguous series of the same char. \\n        // To fix a sequence to satisfy condition #3, we either delete chars from the sequence, insert chars or replace certain chars in the sequence.\\n        // The min # of chars to replace is floor(sequence_length / 3).\\n        // count_seq_mod[i] = # times we can delete (i+1) chars from any sequence so as to reduce the replacement count by 1\\n        int count_seq_mod[3] = {0};\\n        \\n        int replacements = 0;\\n        \\n        for (char c: s) {\\n            if (\\'a\\' <= c && c <= \\'z\\') type1=1;\\n            else if (\\'A\\' <= c && c<= \\'Z\\') type2=1;\\n            else if (\\'0\\' <= c&& c <= \\'9\\') type3=1;\\n            \\n            if (prev_char != c){\\n                if (cur_seq_len >= 3) {\\n                    if (cur_seq_len % 3 != 2)\\n                        count_seq_mod[cur_seq_len % 3]++;\\n                    \\n                    count_seq_mod[2] += (cur_seq_len - 2) / 3;\\n                }\\n                // we need this min # replacement to fix the sequence\\n                replacements += cur_seq_len / 3;\\n                cur_seq_len = 1;\\n            }\\n            else {\\n                cur_seq_len ++;\\n            }\\n            \\n            prev_char = c;\\n        }    \\n        \\n        // End the current sequence. \\n        if (cur_seq_len >= 3) {\\n            if (cur_seq_len % 3 != 2)\\n                count_seq_mod[cur_seq_len % 3]++;\\n\\n            count_seq_mod[2] += (cur_seq_len - 2) / 3;\\n        }\\n        replacements += cur_seq_len / 3;\\n        \\n        int type_count = type1+type2+type3;\\n        replacements = max(3 - type_count, replacements);\\n        \\n        if (s.size() < minlen){\\n            // Just need to insert or replace chars.\\n            // Inserting chars can be used instead of replacement to fix sequences and to fulfil the 3 types, hence we use \\'max\\'.\\n            return max(replacements, minlen - (int)s.size());\\n        }\\n        else if (s.size() <= maxlen){\\n              \\n            // Maintain the string length and replace min # chars to fix the sequences\\n            // and to fulfil the 3 types\\n            return replacements;\\n        }\\n\\n        // We must delete this number of chars to fit within maxlen.\\n        const int deletes = s.size() - maxlen;\\n\\n        // Since we must delete, we might as well use them to fix sequences and thereby reducing # replacements needed.\\n        \\n        int deletes_used = 0;\\n        \\n        for (int i = 1; i <= 3; i++){\\n            int reduced_replacements = min((deletes - deletes_used) / i, count_seq_mod[i - 1]);\\n            replacements -= reduced_replacements;\\n            deletes_used += reduced_replacements * i;            \\n        }\\n\\n        return deletes + max(3-type_count, replacements);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 424821,
                "title": "c-solution-beats-100-time-and-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int add=0, del=0, replace=0;\\n        int size = s.size();\\n        if(size<6)\\n            add=6-size;\\n        else if (size>20)\\n            del = size-20;\\n        int ans = add+del;\\n        bool small=false;\\n        bool caps=false;\\n        bool digit=false;\\n        int i;\\n        int sadd=add;\\n        int optimize = 1;\\n        while(optimize<4){\\n        for( i=0; i<size-2;i++)\\n        {\\n            if(s[i]==s[i+1] && s[i]==s[i+2])\\n            {\\n                int k=i;\\n                while(s[k]==s[k+1])\\n                    k++;\\n                int dup = k-i+1;\\n                i=k-(optimize-1);\\n                if(del>=optimize && dup%3==(optimize-1))\\n                {\\n                    int j=i;\\n                    while(j<size-optimize)\\n                    {\\n                        s[j]=s[j+optimize];\\n                        j++;\\n                    }\\n                    del=del-optimize;\\n                    size=size-optimize;\\n                    i--;\\n                }\\n                \\n            }\\n        }\\n            optimize++;\\n        }\\n        for( i=0; i<size-2;i++)\\n        {\\n            if(small==false && s[i]>=\\'a\\' &&s[i]<=\\'z\\')\\n                small=true;\\n            else if(caps==false && s[i]>=\\'A\\' && s[i]<=\\'Z\\')\\n                caps=true;\\n            else if(digit==false && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n                digit=true;\\n            if(s[i]==s[i+1] && s[i]==s[i+2])\\n            {\\n                if(add > 0)\\n                {\\n                    add--;\\n                    i++;\\n                }\\n                else \\n                {\\n                    replace++;\\n                    i=i+2;\\n                }\\n            }\\n        }\\n        while(i<size){\\n        if(small==false && s[i]>=\\'a\\' &&s[i]<=\\'z\\')\\n            small=true;\\n        else if(caps==false && s[i]>=\\'A\\' && s[i]<=\\'Z\\')\\n            caps=true;\\n        else if(digit==false && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n            digit=true;\\n        i++;\\n        }\\n        ans=ans+replace;\\n        int need = -sadd-replace;\\n        if(!small) need++;\\n        if(!digit) need++;\\n        if(!caps) need++;\\n        if(need>0) ans=ans+need;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int add=0, del=0, replace=0;\\n        int size = s.size();\\n        if(size<6)\\n            add=6-size;\\n        else if (size>20)\\n            del = size-20;\\n        int ans = add+del;\\n        bool small=false;\\n        bool caps=false;\\n        bool digit=false;\\n        int i;\\n        int sadd=add;\\n        int optimize = 1;\\n        while(optimize<4){\\n        for( i=0; i<size-2;i++)\\n        {\\n            if(s[i]==s[i+1] && s[i]==s[i+2])\\n            {\\n                int k=i;\\n                while(s[k]==s[k+1])\\n                    k++;\\n                int dup = k-i+1;\\n                i=k-(optimize-1);\\n                if(del>=optimize && dup%3==(optimize-1))\\n                {\\n                    int j=i;\\n                    while(j<size-optimize)\\n                    {\\n                        s[j]=s[j+optimize];\\n                        j++;\\n                    }\\n                    del=del-optimize;\\n                    size=size-optimize;\\n                    i--;\\n                }\\n                \\n            }\\n        }\\n            optimize++;\\n        }\\n        for( i=0; i<size-2;i++)\\n        {\\n            if(small==false && s[i]>=\\'a\\' &&s[i]<=\\'z\\')\\n                small=true;\\n            else if(caps==false && s[i]>=\\'A\\' && s[i]<=\\'Z\\')\\n                caps=true;\\n            else if(digit==false && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n                digit=true;\\n            if(s[i]==s[i+1] && s[i]==s[i+2])\\n            {\\n                if(add > 0)\\n                {\\n                    add--;\\n                    i++;\\n                }\\n                else \\n                {\\n                    replace++;\\n                    i=i+2;\\n                }\\n            }\\n        }\\n        while(i<size){\\n        if(small==false && s[i]>=\\'a\\' &&s[i]<=\\'z\\')\\n            small=true;\\n        else if(caps==false && s[i]>=\\'A\\' && s[i]<=\\'Z\\')\\n            caps=true;\\n        else if(digit==false && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n            digit=true;\\n        i++;\\n        }\\n        ans=ans+replace;\\n        int need = -sadd-replace;\\n        if(!small) need++;\\n        if(!digit) need++;\\n        if(!caps) need++;\\n        if(need>0) ans=ans+need;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410106,
                "title": "cpp-breadth-first-search-0ms-8m",
                "content": "state description:\\n                 **i**: position in string.\\n                 **m**: number of successive identical chars seen so far. m \\u2208 {1,2,3}.\\n                 **cd**: number of conditions not met within lower,upper,digit. cd \\u2208 {0,1,2,3}.\\n                 **def**: num of chars missing.\\n                 **exc**: num of chars in excess.\\n\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int n = s.length();\\n        int c[3] = {1,1,1};\\n        for(int i=0; i<n; ++i){\\n            if(c[0] && islower(s[i])){\\n                c[0] = 0;\\n            }\\n            else if (c[1] && isupper(s[i])){\\n                c[1] = 0;\\n            }\\n            else if (c[2] && isdigit(s[i])){\\n                c[2] = 0;\\n            }\\n        }       \\n  \\n        int count(0);    \\n        std::queue<std::array<int,5>> q;\\n        q.push({1,1,c[0] + c[1] + c[2],std::max(6-n,0),std::max(n-20,0)});\\n        \\n        while(!q.empty()){\\n            int sq = q.size(); \\n            \\n            for(int j=0; j<sq; ++j){\\n                // state description:\\n                // i: position in string.\\n                // m: number of successive identical chars seen so far. m \\u2208 {1,2,3}.\\n                // cd: number of conditions not met within lower,upper,digit. cd \\u2208 {0,1,2,3}.\\n                // def: num of chars missing.\\n                // exc: num of chars in excess.\\n                auto [i,m,cd,def,exc] = q.front();\\n                q.pop();\\n                \\n                while(i<n){\\n                    if(s[i]==s[i-1]){\\n                        ++m;\\n                    }\\n                    else{\\n                        m=1;\\n                    }\\n                    \\n                    if(m==3){ // action is needed here.\\n                        \\n                        if(exc>0){\\n                            q.push({i+1,2,cd,def,exc-1}); // delete.\\n                            if(i==n-1 || s[i+1]!=s[i]){ // using a delete is optimal.\\n                               break;\\n                            }   \\n                        }\\n                        else if(def>0){\\n                            q.push({i+1,1,std::max(--cd,0),def-1,exc}); // insert.\\n                            if(i+2>=n || s[i+1] != s[i] || s[i+2] != s[i]){ // using an insert is optimal.\\n                                break;\\n                            }   \\n                        }\\n\\t\\t\\t\\t\\t\\t// replace(no need to insert/delete or these actions are not guaranteed to be optimal).\\n                        q.push({i+1,0,std::max(cd-1,0),def,exc}); \\n                        break;\\n                    } \\n                    ++i;\\n                }\\n                \\n                if(i>=n){\\n                     if(def>0){\\n                         q.push({n,0,std::max(cd-1,0),def-1,exc});\\n                     }\\n                     else if (exc>0){\\n                         q.push({n,0,cd,def,exc-1});\\n                     }\\n                     else if(cd>0){\\n                         q.push({n,0,std::max(cd-1,0),def,exc});\\n                     }\\n                     else {\\n                         return count;   \\n                     }\\n                }\\n            \\n            } // for(int j=0; i<sz; ++j)\\n            count++;\\n        } // while (!q.empty())\\n        \\n        return -1;\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int n = s.length();\\n        int c[3] = {1,1,1}",
                "codeTag": "Java"
            },
            {
                "id": 284353,
                "title": "best-o-n-solution-python",
                "content": "```\\ndef strongPasswordChecker(s):\\n    str_len = len(s); change, triple, seq, i, length, delete, types = 0,0,0,0,1, str_len -20, [1] * 4\\n    get_missing_type = lambda ch: 1 if ch.islower() else 2 if ch.isupper() else 3 if ch.isdigit() else 0\\n    while i < str_len:\\n        while i + length < str_len and s[i] == s[i + length]: length +=1\\n        types[get_missing_type(s[i])] = 0\\n        triple = length / 3\\n        if triple > 0:\\n            if delete >= 1:\\n                seq = length % 3\\n                if seq == 0 or (delete >= 2 and seq == 1):\\n                    triple -= 1\\n                    delete -= seq + 1\\n            change += triple\\n        i , length = length + i , 1\\n    missing_type = sum(types[1:])\\n    if str_len > 20:\\n        change -= delete / 3\\n        delete = str_len - 20\\n        return delete + max(missing_type, change)\\n    elif str_len >= 6: return max(missing_type, change)\\n \\xA0 \\xA0return max(missing_type, 6- str_len)\\n\\t",
                "solutionTags": [],
                "code": "```\\ndef strongPasswordChecker(s):\\n    str_len = len(s); change, triple, seq, i, length, delete, types = 0,0,0,0,1, str_len -20, [1] * 4\\n    get_missing_type = lambda ch: 1 if ch.islower() else 2 if ch.isupper() else 3 if ch.isdigit() else 0\\n    while i < str_len:\\n        while i + length < str_len and s[i] == s[i + length]: length +=1\\n        types[get_missing_type(s[i])] = 0\\n        triple = length / 3\\n        if triple > 0:\\n            if delete >= 1:\\n                seq = length % 3\\n                if seq == 0 or (delete >= 2 and seq == 1):\\n                    triple -= 1\\n                    delete -= seq + 1\\n            change += triple\\n        i , length = length + i , 1\\n    missing_type = sum(types[1:])\\n    if str_len > 20:\\n        change -= delete / 3\\n        delete = str_len - 20\\n        return delete + max(missing_type, change)\\n    elif str_len >= 6: return max(missing_type, change)\\n \\xA0 \\xA0return max(missing_type, 6- str_len)\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 228198,
                "title": "python3-ac",
                "content": "```\\n\\nclass Solution:\\n    @staticmethod\\n    def classify(n):\\n        if n.islower():\\n            return 0\\n        if n.isdigit():\\n            return 2\\n        if n.isupper():\\n            return 1\\n        return 3\\n\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        l = len(s)\\n        if l < 4:\\n            return 6 - l\\n        state = [0, 0, 0, 0]\\n        repeat_cnt = 0\\n        repeat_arr = [[], [], []]\\n        tmp = 0\\n        t = Solution.classify(s[0])\\n        state[t] += 1\\n        for i in range(1, l + 1):\\n            if i < l:\\n                n = s[i]\\n                state[Solution.classify(n)] += 1\\n            else:\\n                n = \\'\\'\\n            if n == s[tmp]:\\n                continue\\n            else:\\n                length = i - tmp\\n                if length > 2:\\n                    repeat_cnt += length // 3\\n                    repeat_arr[length%3].append(length)\\n                tmp = i\\n        a = sum([0 if state[i] else 1 for i in range(3)])\\n        if repeat_cnt == 0:\\n            return max(a, 6 - l, l-20+a)\\n        else:\\n            if l < 6: \\n                return max(a, repeat_cnt)\\n            if l > 20:  \\n                to_del_num = l - 20\\n                left_arr = []\\n                for i in range(3):\\n                    arr = repeat_arr[i]\\n                    for num in arr:\\n                        if to_del_num < i+1:\\n                            break\\n                        x = num - i - 1\\n                        to_del_num -= i+1\\n                        repeat_cnt -= 1\\n                        if x > 2:\\n                            left_arr.append(x)\\n                for num in left_arr:\\n                    if to_del_num < 3:\\n                        break\\n                    _ = min(num, to_del_num)// 3\\n                    to_del_num -= _ * 3\\n                    repeat_cnt -= _\\n                return l - 20 + max(a, repeat_cnt)\\n            return max(a, 6 - l, l-20+1, repeat_cnt)\\n\\n\\nif __name__ == \\'__main__\\':\\n    s = Solution()\\n    samples = [\\n        (\"1234567890123456Baaaaa\", 3),\\n        (\"11234567890123456Baaaaa\", 3),\\n        (\\'aaaaaaaaaaaaaaaaaaaaaa\\', 8),\\n        (\\'aaaaaaaaaaaaaaaaaaaaa\\', 7),\\n        (\\'\\', 6),\\n        (\\'.\\', 5),\\n        (\\'1\\', 5),\\n        (\\'aaaaaa\\', 2),\\n        (\\'Abc123dd\\', 0),\\n        (\\'Abc123d\\', 0),\\n        (\\'aaaa\\', 2),\\n        (\\'aaaaaa\\', 2),\\n        (\\'aaaaaaa\\', 2),\\n        (\\'aab445d\\', 1),\\n        (\\'aaaa45d\\', 1),\\n        (\\'aaabbbccc\\', 3),\\n        (\\'aaabbBccc\\', 2),\\n        (\\'aaa444ccc\\', 3),\\n        (\\'12345678\\', 2),\\n        (\\'1234567\\', 2),\\n        (\\'aabaabaabaabaabaabaab\\', 3),\\n        (\\'..............................\\', 16),\\n        (\\'Aaijrg091huy34\\', 0),\\n    ]\\n    for tp in samples:\\n        ret = s.strongPasswordChecker(tp[0])\\n        if ret != tp[1]: print(ret, tp[1], len(tp[0]), tp)\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    @staticmethod\\n    def classify(n):\\n        if n.islower():\\n            return 0\\n        if n.isdigit():\\n            return 2\\n        if n.isupper():\\n            return 1\\n        return 3\\n\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        l = len(s)\\n        if l < 4:\\n            return 6 - l\\n        state = [0, 0, 0, 0]\\n        repeat_cnt = 0\\n        repeat_arr = [[], [], []]\\n        tmp = 0\\n        t = Solution.classify(s[0])\\n        state[t] += 1\\n        for i in range(1, l + 1):\\n            if i < l:\\n                n = s[i]\\n                state[Solution.classify(n)] += 1\\n            else:\\n                n = \\'\\'\\n            if n == s[tmp]:\\n                continue\\n            else:\\n                length = i - tmp\\n                if length > 2:\\n                    repeat_cnt += length // 3\\n                    repeat_arr[length%3].append(length)\\n                tmp = i\\n        a = sum([0 if state[i] else 1 for i in range(3)])\\n        if repeat_cnt == 0:\\n            return max(a, 6 - l, l-20+a)\\n        else:\\n            if l < 6: \\n                return max(a, repeat_cnt)\\n            if l > 20:  \\n                to_del_num = l - 20\\n                left_arr = []\\n                for i in range(3):\\n                    arr = repeat_arr[i]\\n                    for num in arr:\\n                        if to_del_num < i+1:\\n                            break\\n                        x = num - i - 1\\n                        to_del_num -= i+1\\n                        repeat_cnt -= 1\\n                        if x > 2:\\n                            left_arr.append(x)\\n                for num in left_arr:\\n                    if to_del_num < 3:\\n                        break\\n                    _ = min(num, to_del_num)// 3\\n                    to_del_num -= _ * 3\\n                    repeat_cnt -= _\\n                return l - 20 + max(a, repeat_cnt)\\n            return max(a, 6 - l, l-20+1, repeat_cnt)\\n\\n\\nif __name__ == \\'__main__\\':\\n    s = Solution()\\n    samples = [\\n        (\"1234567890123456Baaaaa\", 3),\\n        (\"11234567890123456Baaaaa\", 3),\\n        (\\'aaaaaaaaaaaaaaaaaaaaaa\\', 8),\\n        (\\'aaaaaaaaaaaaaaaaaaaaa\\', 7),\\n        (\\'\\', 6),\\n        (\\'.\\', 5),\\n        (\\'1\\', 5),\\n        (\\'aaaaaa\\', 2),\\n        (\\'Abc123dd\\', 0),\\n        (\\'Abc123d\\', 0),\\n        (\\'aaaa\\', 2),\\n        (\\'aaaaaa\\', 2),\\n        (\\'aaaaaaa\\', 2),\\n        (\\'aab445d\\', 1),\\n        (\\'aaaa45d\\', 1),\\n        (\\'aaabbbccc\\', 3),\\n        (\\'aaabbBccc\\', 2),\\n        (\\'aaa444ccc\\', 3),\\n        (\\'12345678\\', 2),\\n        (\\'1234567\\', 2),\\n        (\\'aabaabaabaabaabaabaab\\', 3),\\n        (\\'..............................\\', 16),\\n        (\\'Aaijrg091huy34\\', 0),\\n    ]\\n    for tp in samples:\\n        ret = s.strongPasswordChecker(tp[0])\\n        if ret != tp[1]: print(ret, tp[1], len(tp[0]), tp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91016,
                "title": "java-o-n-one-pass-with-o-1-space-4ms-solution",
                "content": "The most difficult part of this problem is how to handle deletions when the length greater than 20.\\nThe other two situations, validated length and length less than 6 can be solved using just replacing and insertion.\\nTherefore, I will focus on how to take care of deletions here.\\nBy considering replacing a letter only when there are three repeating characters, such as \"...\", we **MUST** resolve it by replacing last one with \"?\", resulting \"..?\". \\nHere, \"?\" represents a \"**wild card**\", which can be any letter. In this case, we increase `change_count` by 1. At the same time, decrease the `type_count` by 1 since \"?\" is a \"wild card\".\\n`type_count` is initially set to `3` to count those three type of characters needed for the password. One trick is to allow `type_count` less than `0` so we would know how many \"extra\" wild cards exist. \\n\\nAnother key idea is that there are three kinds of repeating patterns to exchange \"?\" for deletions:\\n(1) \"..?\"     =>  delete the last \"?\"  \\n(2) \"..?.\"   =>  delete the last 2 \"?.\"\\n(3) \"..?..\"   =>  delete the last 3 \"?..\"\\nWe peek the following two characters to find out to which pattern of a set of repeating characters belongs and use  `delete_sets[3]` to record how many of these patterns presenting in the password. \\nTherefore, when we need to do deletions, `should_delete = len-20` characters, we should pick case (1) first since it exchanges one deletion with one needed \"?\", so  `change_count--`.\\nNext, case (2) exchanges two deletions with one \"?\" and then case (3) exchanges three deletions with one \"?\".   \\nMeanwhile, every time  `change_count--`,  we do `type_count++` because we remove one wild card.\\nHowever, when `type_count >= 0`, we can **NOT** use the \"exchange\" strategy because it is required to have at least three types of characters.\\nAt the end, if `type_count >= 0`, we need to use `type_count` of wild cards to replace other characters so the total change is `type_count + change_count`, plus the delete count `len-20` if `len > 20`.\\n```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int len = s==null? 0: s.length(); \\n        if (len <= 2 ) return 6-len;\\n        char[] s_array= s.toCharArray(); \\n        boolean cap=false, low=false, digit=false;\\n        char pre_char=0;\\n        int pre_char_count=0, type_count=3, change_count = 0;\\n        int[] delete_sets = new int[3];\\n        for (int i=0; i< len; i++) {\\n            char c = s_array[i];\\n            char c_ = i+1 >= len? 0: s_array[i+1];\\n            char c__ = i+2 >= len? 0: s_array[i+2];\\n            if (c >='0' && c <= '9' && ! digit) {\\n                digit = true;\\n                type_count--;\\n            } else if (c >='a' && c <= 'z' && ! low) {\\n                low = true;\\n                type_count--;\\n            } else if (c >='A' && c <= 'Z' && ! cap) {\\n                cap = true;\\n                type_count--;\\n            }\\n            if (c==pre_char) {\\n                if (pre_char_count == 2) {\\n                    change_count++;\\n                    type_count--;\\n                    if (c != c_) {\\n                        delete_sets[0]++;\\n                    } else if (c != c__) {\\n                        delete_sets[1]++;\\n                    } else {\\n                        delete_sets[2]++;\\n                    }\\n                    pre_char_count = 0;\\n                    pre_char = 0;\\n                } else {\\n                    pre_char_count++;\\n                }\\n            } else {\\n                pre_char_count = 1;\\n                pre_char = c;\\n            }\\n        } \\n        if (len < 6) {\\n            type_count = Math.max(type_count, 0);\\n            return Math.max( type_count + change_count , (6-len) );\\n        } else if (len > 20) { \\n            int should_delete = len - 20;\\n            for (int i=0; i < 3 ; i++) {\\n                while ( should_delete > i && delete_sets[i] > 0 && type_count < 0) {\\n                    should_delete -= (i+1);\\n                    delete_sets[i]--;\\n                    type_count++;\\n                    change_count--;\\n                }\\n            }\\n            type_count = Math.max(type_count, 0);\\n            return len - 20 + type_count + change_count;\\n        }\\n        type_count = Math.max(type_count, 0);\\n        return type_count + change_count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int strongPasswordChecker(String s) {\\n        int len = s==null? 0: s.length(); \\n        if (len <= 2 ) return 6-len;\\n        char[] s_array= s.toCharArray(); \\n        boolean cap=false, low=false, digit=false;\\n        char pre_char=0;\\n        int pre_char_count=0, type_count=3, change_count = 0;\\n        int[] delete_sets = new int[3];\\n        for (int i=0; i< len; i++) {\\n            char c = s_array[i];\\n            char c_ = i+1 >= len? 0: s_array[i+1];\\n            char c__ = i+2 >= len? 0: s_array[i+2];\\n            if (c >='0' && c <= '9' && ! digit) {\\n                digit = true;\\n                type_count--;\\n            } else if (c >='a' && c <= 'z' && ! low) {\\n                low = true;\\n                type_count--;\\n            } else if (c >='A' && c <= 'Z' && ! cap) {\\n                cap = true;\\n                type_count--;\\n            }\\n            if (c==pre_char) {\\n                if (pre_char_count == 2) {\\n                    change_count++;\\n                    type_count--;\\n                    if (c != c_) {\\n                        delete_sets[0]++;\\n                    } else if (c != c__) {\\n                        delete_sets[1]++;\\n                    } else {\\n                        delete_sets[2]++;\\n                    }\\n                    pre_char_count = 0;\\n                    pre_char = 0;\\n                } else {\\n                    pre_char_count++;\\n                }\\n            } else {\\n                pre_char_count = 1;\\n                pre_char = c;\\n            }\\n        } \\n        if (len < 6) {\\n            type_count = Math.max(type_count, 0);\\n            return Math.max( type_count + change_count , (6-len) );\\n        } else if (len > 20) { \\n            int should_delete = len - 20;\\n            for (int i=0; i < 3 ; i++) {\\n                while ( should_delete > i && delete_sets[i] > 0 && type_count < 0) {\\n                    should_delete -= (i+1);\\n                    delete_sets[i]--;\\n                    type_count++;\\n                    change_count--;\\n                }\\n            }\\n            type_count = Math.max(type_count, 0);\\n            return len - 20 + type_count + change_count;\\n        }\\n        type_count = Math.max(type_count, 0);\\n        return type_count + change_count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91034,
                "title": "my-c-ac-code",
                "content": "'''\\n\\n    \\n    static bool cmp(int a, int b)\\n    {\\n        return a % 3 > b % 3;\\n    }\\n    \\n    int strongPasswordChecker(string s) {\\n        deque<int> cnts;\\n        int t = 0, lowercase = 1, uppercase = 1, digit = 1;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] >= 'a' && s[i] <= 'z') lowercase = 0;\\n            else if (s[i] >= 'A' && s[i] <= 'Z') uppercase = 0;\\n            else if (s[i] >= '0' && s[i] <= '9') digit = 0;\\n            \\n            if (i == 0)\\n            {\\n                t = 1;\\n            }else\\n            {\\n                if (s[i] == s[i - 1])\\n                {\\n                    t++;\\n                }\\n                else\\n                {\\n                    if (t > 2) cnts.push_back(t);\\n                    t = 1;\\n                }\\n            }\\n        }\\n        if (t > 2) cnts.push_back(t);\\n        \\n        sort(cnts.begin(), cnts.end(), cmp);\\n\\n        int n = s.size();\\n        int count = 0;\\n        if (n > 20)\\n        {\\n            count = n - 20;\\n            int t = n - 20;\\n            while (t && !cnts.empty())\\n            {\\n                int x = cnts.front() % 3;\\n                if (x == 0)\\n                {\\n                    x = cnts.front();\\n                    if (x == 0)\\n                    {\\n                        cnts.pop_front();\\n                        continue;\\n                    }\\n                }\\n                \\n                if (t >= x)\\n                {\\n                    t -= x;\\n                    x = cnts.front() - x;\\n                    cnts.pop_front();\\n                    cnts.push_back(x);\\n                }\\n                else\\n                {\\n                    x  = cnts.front() - t;\\n                    t = 0;\\n                    cnts.pop_front();\\n                    cnts.push_back(x);\\n                }\\n            }\\n        }\\n\\n        int tc = 0;\\n        for (int x : cnts) tc += x / 3;\\n        int cc = lowercase + uppercase + digit;\\n        \\n        if (n < 6)\\n        {\\n            count = max(6 - n, cc);\\n            count = max(count, tc);\\n            cc = 0;\\n            tc = 0;\\n        }\\n        \\n        count = count + max(tc, cc);\\n        return count;\\n    }\\n\\n\\n'''",
                "solutionTags": [],
                "code": "'''\\n\\n    \\n    static bool cmp(int a, int b)\\n    {\\n        return a % 3 > b % 3;\\n    }\\n    \\n    int strongPasswordChecker(string s) {\\n        deque<int> cnts;\\n        int t = 0, lowercase = 1, uppercase = 1, digit = 1;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] >= 'a' && s[i] <= 'z') lowercase = 0;\\n            else if (s[i] >= 'A' && s[i] <= 'Z') uppercase = 0;\\n            else if (s[i] >= '0' && s[i] <= '9') digit = 0;\\n            \\n            if (i == 0)\\n            {\\n                t = 1;\\n            }else\\n            {\\n                if (s[i] == s[i - 1])\\n                {\\n                    t++;\\n                }\\n                else\\n                {\\n                    if (t > 2) cnts.push_back(t);\\n                    t = 1;\\n                }\\n            }\\n        }\\n        if (t > 2) cnts.push_back(t);\\n        \\n        sort(cnts.begin(), cnts.end(), cmp);\\n\\n        int n = s.size();\\n        int count = 0;\\n        if (n > 20)\\n        {\\n            count = n - 20;\\n            int t = n - 20;\\n            while (t && !cnts.empty())\\n            {\\n                int x = cnts.front() % 3;\\n                if (x == 0)\\n                {\\n                    x = cnts.front();\\n                    if (x == 0)\\n                    {\\n                        cnts.pop_front();\\n                        continue;\\n                    }\\n                }\\n                \\n                if (t >= x)\\n                {\\n                    t -= x;\\n                    x = cnts.front() - x;\\n                    cnts.pop_front();\\n                    cnts.push_back(x);\\n                }\\n                else\\n                {\\n                    x  = cnts.front() - t;\\n                    t = 0;\\n                    cnts.pop_front();\\n                    cnts.push_back(x);\\n                }\\n            }\\n        }\\n\\n        int tc = 0;\\n        for (int x : cnts) tc += x / 3;\\n        int cc = lowercase + uppercase + digit;\\n        \\n        if (n < 6)\\n        {\\n            count = max(6 - n, cc);\\n            count = max(count, tc);\\n            cc = 0;\\n            tc = 0;\\n        }\\n        \\n        count = count + max(tc, cc);\\n        return count;\\n    }\\n\\n\\n'''",
                "codeTag": "Unknown"
            },
            {
                "id": 4084248,
                "title": "strong-password-checker",
                "content": "# Intuition\\nThe problem can be broken down into three main challenges:\\n\\n1. Ensuring the password length falls between the 6-20 characters range.\\n2. Making sure the password contains at least one lowercase letter, one uppercase letter, and one digit.\\n3. Eliminating instances of three repeating characters in a row.\\n\\nThus, we need a mechanism to identify and correct discrepancies in length, character type, and repeated sequences.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate over the password to check if it contains lowercase, uppercase, and numeric characters.\\n2. Count the missing types of characters. This count will give us a hint on how many insertions or replacements we might need to perform\\n3. Iterate through the password to identify sequences of characters that repeat consecutively.\\n4. For sequences that have a length % 3 == 0, 1 replacement is needed.\\n5.  For sequences with a length % 3 == 1, 2 replacements are needed.\\n6. These are stored to optimize deletions later if the password length exceeds 20.\\n7. If the password length is less than 6, the number of operations will be the greater of the number of characters needed to reach a length of 6 and the number of missing types of characters.\\n8. If the password length is between 6 and 20, consider only the number of replacements for repeated sequences and the number of missing types.\\n9. If the password length is more than 20, prioritize deletions to minimize total operations. For example, if we have a sequence of 3 (\\'aaa\\'), deleting 1 character will eliminate the need for replacement.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe solution involves going through the string a few times. Specifically, twice for character type checking and repeated sequence checking, respectively. Hence, the time complexity is O(n), where n is the length of the password.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using a constant amount of space to store counters and flags, regardless of the input size. Therefore, the space complexity is O(1).\\n# Code\\n```\\nclass Solution {\\n   public int strongPasswordChecker(String password) {\\n    int n = password.length();\\n\\n    boolean hasLower = false, hasUpper = false, hasDigit = false;\\n    for (char c : password.toCharArray()) {\\n        if (Character.isLowerCase(c)) hasLower = true;\\n        if (Character.isUpperCase(c)) hasUpper = true;\\n        if (Character.isDigit(c)) hasDigit = true;\\n    }\\n    int missing_types = (hasLower ? 0 : 1) + (hasUpper ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n    int total_replacement = 0;\\n    int one_replace = 0;   \\n    int two_replace = 0;   \\n\\n    for (int i = 2; i < n; ) {\\n        if (password.charAt(i) == password.charAt(i-1) && password.charAt(i-1) == password.charAt(i-2)) {\\n            int length = 2; \\n            while (i < n && password.charAt(i) == password.charAt(i-1)) {\\n                length++;\\n                i++;\\n            }\\n            \\n            total_replacement += length / 3;\\n            if (length % 3 == 0) one_replace += 1;\\n            if (length % 3 == 1) two_replace += 1;\\n        } else {\\n            i++;\\n        }\\n    }\\n\\n    if (n < 6) {\\n        return Math.max(missing_types, 6 - n);\\n    } else if (n <= 20) {\\n        return Math.max(missing_types, total_replacement);\\n    } else {\\n        int delete_count = n - 20;\\n        total_replacement -= Math.min(delete_count, one_replace * 1) / 1;\\n        total_replacement -= Math.min(Math.max(delete_count - one_replace, 0), two_replace * 2) / 2;\\n        total_replacement -= Math.max(delete_count - one_replace - 2 * two_replace, 0) / 3;\\n\\n        return delete_count + Math.max(missing_types, total_replacement);\\n    }\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n   public int strongPasswordChecker(String password) {\\n    int n = password.length();\\n\\n    boolean hasLower = false, hasUpper = false, hasDigit = false;\\n    for (char c : password.toCharArray()) {\\n        if (Character.isLowerCase(c)) hasLower = true;\\n        if (Character.isUpperCase(c)) hasUpper = true;\\n        if (Character.isDigit(c)) hasDigit = true;\\n    }\\n    int missing_types = (hasLower ? 0 : 1) + (hasUpper ? 0 : 1) + (hasDigit ? 0 : 1);\\n\\n    int total_replacement = 0;\\n    int one_replace = 0;   \\n    int two_replace = 0;   \\n\\n    for (int i = 2; i < n; ) {\\n        if (password.charAt(i) == password.charAt(i-1) && password.charAt(i-1) == password.charAt(i-2)) {\\n            int length = 2; \\n            while (i < n && password.charAt(i) == password.charAt(i-1)) {\\n                length++;\\n                i++;\\n            }\\n            \\n            total_replacement += length / 3;\\n            if (length % 3 == 0) one_replace += 1;\\n            if (length % 3 == 1) two_replace += 1;\\n        } else {\\n            i++;\\n        }\\n    }\\n\\n    if (n < 6) {\\n        return Math.max(missing_types, 6 - n);\\n    } else if (n <= 20) {\\n        return Math.max(missing_types, total_replacement);\\n    } else {\\n        int delete_count = n - 20;\\n        total_replacement -= Math.min(delete_count, one_replace * 1) / 1;\\n        total_replacement -= Math.min(Math.max(delete_count - one_replace, 0), two_replace * 2) / 2;\\n        total_replacement -= Math.max(delete_count - one_replace - 2 * two_replace, 0) / 3;\\n\\n        return delete_count + Math.max(missing_types, total_replacement);\\n    }\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073707,
                "title": "solving-leetcode-when-the-last-step-can-turn-out-the-hardest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n###### My first idea was to work only with statistical characteristics of the password and never return back to the characters\\u2014and it worked! I also decided to create a finite-state machine and made it, but further on I discovered there was no need for it.\\n\\n# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the statistical characteristics of the password.\\n2. Calculate the number of necessary and additional steps.\\n3. Reduce the additional steps already contained in the necessary steps depending on the calculated statistics\\u2014it is the most difficult part.\\n4. Split the necessary steps to simplify the formula for return.\\n5. Celebrate victory.\\n\\n# Complexity\\n###### The difficulty of this problem comes from the fact that \\'steps\\' interfere with each other, as long as there is a variety of steps that lead to a solution and one has to determine the shortest path. Moreover, there are necessary and additional steps.\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n###### $$O(n)$$, depends on complexity, not the size of the password\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n\\n#define max(X, Y)  ((X) > (Y) ? (X) : (Y))\\n\\ntypedef struct {\\n  int state;\\n} cntxA_t;\\n\\nint check_repet( cntxA_t * const A, int repeat,\\n                 int * const _data, int * const repetition,\\n                 int * const low_content, int * const hi_content)\\n{\\n  switch (A->state)\\n  {\\n    case 0: // init\\n      (*repetition) = 1;\\n      A->state = 1; \\n    break;\\n\\n    case 1: // work\\n      if (0 != repeat)\\n      {\\n        (*repetition)++;\\n        break;\\n      }\\n      (*_data) += (*repetition)/3;\\n      if ((*repetition)%3 == 0 && (*repetition) >= 3) (*low_content)++;\\n      if ((*repetition)%3 == 1 && (*repetition) >= 3) (*hi_content)++;\\n\\n      (*repetition) = 1;\\n    break;\\n  }\\n  return A->state;\\n}\\n\\nint strongPasswordChecker(char * password){\\n\\nconst int min_symbols = 6;\\nconst int max_symbols = 20;\\n\\nint state = 0;\\nint i = 0;\\n\\nchar repet_char = 0;\\n\\nint repetition = 0, insert_one_dif = 3; //max different symbol inserts\\nint insert_one_suppl = 0, replace_one = 0, delete_one = 0;\\n\\nint low_content = 0, hi_content = 0;\\nint is_there_az = 0, is_there_AZ = 0, is_there_09 = 0;\\n\\ncntxA_t cntxA11 = {0};\\n\\n//init automat\\ncheck_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n\\ndo {\\n      //printf(\"i = %d\\\\n\", i);\\n      if (\\'A\\' <= password[i] && \\'Z\\' >= password[i] && 0 == is_there_AZ )\\n      {\\n        is_there_AZ = 1;\\n        insert_one_dif--;\\n      }\\n      if (\\'a\\' <= password[i] && \\'z\\' >= password[i] && 0 == is_there_az )\\n      {\\n        is_there_az = 1;\\n        insert_one_dif--;\\n      }\\n      if (\\'0\\' <= password[i] && \\'9\\' >= password[i] && 0 == is_there_09 )\\n      {\\n        is_there_09 = 1;\\n        insert_one_dif--;\\n      }\\n\\n      if (repet_char == password[i]) \\n        check_repet( &cntxA11, 1, &repetition, &replace_one, &low_content, &hi_content);\\n      else\\n        check_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n        \\n      repet_char = password[i];\\n}\\nwhile (\\'\\\\0\\' != password[++i]);\\n\\ncheck_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n\\n\\n      if (min_symbols >= i) insert_one_suppl = min_symbols - i;\\n      if (i > max_symbols ) delete_one = i - max_symbols;\\n\\n//further depends on structure of conditions\\n/////////////////////////////////////////////////////////////\\n      //less than 6 symbols\\n      if (insert_one_suppl > 0)\\n        return max (insert_one_suppl, insert_one_dif);\\n/////////////////////////////////////////////////////////////\\n      if (repetition == 0) goto return_wo_rep;\\n\\n//decreasing repetition due to most compulsory deletation\\n      if (delete_one > 0)\\n      {\\n        int temp_delete_one = delete_one;\\n\\n        do {\\n          for (int i = low_content; i > 0; i--)\\n          {\\n            if (temp_delete_one < 1) break;\\n            if (repetition == 0) goto return_wo_rep;\\n            repetition--;\\n            temp_delete_one -= 1;\\n          }\\n          for (int i = hi_content; i > 0; i--)\\n          {\\n            if (temp_delete_one < 2) break;\\n            if (repetition == 0) goto return_wo_rep;\\n            repetition--;\\n            temp_delete_one -= 2;\\n          }\\n          low_content = hi_content;\\n        } while (temp_delete_one > 3 && low_content > 0);\\n\\n        while (temp_delete_one >= 3)\\n        {\\n          if (repetition == 0) goto return_wo_rep;\\n          repetition--;\\n          temp_delete_one -= 3;\\n        }\\n\\n        return delete_one + max(repetition, insert_one_dif);\\n\\nreturn_wo_rep:\\n        return delete_one + insert_one_dif;\\n      }\\n/////////////////////////////////////////////////////////////\\n      return max (repetition, insert_one_dif);\\n}  \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n#define max(X, Y)  ((X) > (Y) ? (X) : (Y))\\n\\ntypedef struct {\\n  int state;\\n} cntxA_t;\\n\\nint check_repet( cntxA_t * const A, int repeat,\\n                 int * const _data, int * const repetition,\\n                 int * const low_content, int * const hi_content)\\n{\\n  switch (A->state)\\n  {\\n    case 0: // init\\n      (*repetition) = 1;\\n      A->state = 1; \\n    break;\\n\\n    case 1: // work\\n      if (0 != repeat)\\n      {\\n        (*repetition)++;\\n        break;\\n      }\\n      (*_data) += (*repetition)/3;\\n      if ((*repetition)%3 == 0 && (*repetition) >= 3) (*low_content)++;\\n      if ((*repetition)%3 == 1 && (*repetition) >= 3) (*hi_content)++;\\n\\n      (*repetition) = 1;\\n    break;\\n  }\\n  return A->state;\\n}\\n\\nint strongPasswordChecker(char * password){\\n\\nconst int min_symbols = 6;\\nconst int max_symbols = 20;\\n\\nint state = 0;\\nint i = 0;\\n\\nchar repet_char = 0;\\n\\nint repetition = 0, insert_one_dif = 3; //max different symbol inserts\\nint insert_one_suppl = 0, replace_one = 0, delete_one = 0;\\n\\nint low_content = 0, hi_content = 0;\\nint is_there_az = 0, is_there_AZ = 0, is_there_09 = 0;\\n\\ncntxA_t cntxA11 = {0};\\n\\n//init automat\\ncheck_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n\\ndo {\\n      //printf(\"i = %d\\\\n\", i);\\n      if (\\'A\\' <= password[i] && \\'Z\\' >= password[i] && 0 == is_there_AZ )\\n      {\\n        is_there_AZ = 1;\\n        insert_one_dif--;\\n      }\\n      if (\\'a\\' <= password[i] && \\'z\\' >= password[i] && 0 == is_there_az )\\n      {\\n        is_there_az = 1;\\n        insert_one_dif--;\\n      }\\n      if (\\'0\\' <= password[i] && \\'9\\' >= password[i] && 0 == is_there_09 )\\n      {\\n        is_there_09 = 1;\\n        insert_one_dif--;\\n      }\\n\\n      if (repet_char == password[i]) \\n        check_repet( &cntxA11, 1, &repetition, &replace_one, &low_content, &hi_content);\\n      else\\n        check_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n        \\n      repet_char = password[i];\\n}\\nwhile (\\'\\\\0\\' != password[++i]);\\n\\ncheck_repet( &cntxA11, 0, &repetition, &replace_one, &low_content, &hi_content);\\n\\n\\n      if (min_symbols >= i) insert_one_suppl = min_symbols - i;\\n      if (i > max_symbols ) delete_one = i - max_symbols;\\n\\n//further depends on structure of conditions\\n/////////////////////////////////////////////////////////////\\n      //less than 6 symbols\\n      if (insert_one_suppl > 0)\\n        return max (insert_one_suppl, insert_one_dif);\\n/////////////////////////////////////////////////////////////\\n      if (repetition == 0) goto return_wo_rep;\\n\\n//decreasing repetition due to most compulsory deletation\\n      if (delete_one > 0)\\n      {\\n        int temp_delete_one = delete_one;\\n\\n        do {\\n          for (int i = low_content; i > 0; i--)\\n          {\\n            if (temp_delete_one < 1) break;\\n            if (repetition == 0) goto return_wo_rep;\\n            repetition--;\\n            temp_delete_one -= 1;\\n          }\\n          for (int i = hi_content; i > 0; i--)\\n          {\\n            if (temp_delete_one < 2) break;\\n            if (repetition == 0) goto return_wo_rep;\\n            repetition--;\\n            temp_delete_one -= 2;\\n          }\\n          low_content = hi_content;\\n        } while (temp_delete_one > 3 && low_content > 0);\\n\\n        while (temp_delete_one >= 3)\\n        {\\n          if (repetition == 0) goto return_wo_rep;\\n          repetition--;\\n          temp_delete_one -= 3;\\n        }\\n\\n        return delete_one + max(repetition, insert_one_dif);\\n\\nreturn_wo_rep:\\n        return delete_one + insert_one_dif;\\n      }\\n/////////////////////////////////////////////////////////////\\n      return max (repetition, insert_one_dif);\\n}  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4071146,
                "title": "easy-to-read-code-medium-performance",
                "content": "# Code\\n```\\nvar strongPasswordChecker = function(p) {\\n  // Strategy:\\n  //\\n  // Identify runs (and their length) and count missing character deficiencies\\n  //\\n  // if < 6\\n  //   it just so happens that any run can be resolved by already needed additions and mutations\\n  //\\n  // if >= 6\\n  //   if > 20, count deletions while strategically reducing runs\\n  //   count mutation breaks needed to solve runs\\n  //   absorb character deficiencies into needed run breaks\\n\\n  // Sort runs based on their divisibility by 3\\n  let runs = [[], [], []]\\n  let run\\n\\n  let needL = 1, needU = 1, needD = 1\\n\\n  for (let i = 0; i < p.length; i++) {\\n    if (needL && p[i] >= \\'a\\' && p[i] <= \\'z\\')\\n      needL = 0\\n\\n    if (needU && p[i] >= \\'A\\' && p[i] <= \\'Z\\')\\n      needU = 0\\n\\n    if (needD && p[i] >= \\'0\\' && p[i] <= \\'9\\')\\n      needD = 0\\n\\n    if (p[i] === p[i-1])\\n      run++\\n\\n    if (p[i] !== p[i-1] || i === p.length - 1) {\\n      if (run > 2)\\n        runs[run % 3].push(run)\\n\\n      run = 1\\n    }\\n  }\\n\\n  let needed = needL + needU + needD\\n\\n  // Take care of the special case where all runs are autoamtically covered\\n  if (p.length < 6)\\n    return Math.max(6 - p.length, needed)\\n\\n  let len = p.length, toDelete = Math.max(len - 20, 0), toChange = 0\\n\\n  // Use password shortening to reduce runs\\n  while (len-- > 20) {\\n    // Focus on runs divisible by 3\\n    if (runs[0].length !== 0) {\\n      run = runs[0].pop() - 1\\n\\n      if (run !== 2)\\n        runs[2].push(run)\\n    } else if (runs[1].length !== 0) {\\n      runs[0].push(runs[1].pop() - 1)\\n    } else if (runs[2].length !== 0) {\\n      runs[1].push(runs[2].pop() - 1)\\n    }\\n  }\\n\\n  // Combine the runs into one list\\n  runs = runs.flat()\\n\\n  toChange = runs.reduce(\\n    (total, run) => total + run / 3 | 0, 0\\n  )\\n\\n  // Absorb character kind deficiencies into run breakup mutations\\n  needed = Math.max(needed - toChange, 0)\\n\\n  return toDelete + toChange + needed\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strongPasswordChecker = function(p) {\\n  // Strategy:\\n  //\\n  // Identify runs (and their length) and count missing character deficiencies\\n  //\\n  // if < 6\\n  //   it just so happens that any run can be resolved by already needed additions and mutations\\n  //\\n  // if >= 6\\n  //   if > 20, count deletions while strategically reducing runs\\n  //   count mutation breaks needed to solve runs\\n  //   absorb character deficiencies into needed run breaks\\n\\n  // Sort runs based on their divisibility by 3\\n  let runs = [[], [], []]\\n  let run\\n\\n  let needL = 1, needU = 1, needD = 1\\n\\n  for (let i = 0; i < p.length; i++) {\\n    if (needL && p[i] >= \\'a\\' && p[i] <= \\'z\\')\\n      needL = 0\\n\\n    if (needU && p[i] >= \\'A\\' && p[i] <= \\'Z\\')\\n      needU = 0\\n\\n    if (needD && p[i] >= \\'0\\' && p[i] <= \\'9\\')\\n      needD = 0\\n\\n    if (p[i] === p[i-1])\\n      run++\\n\\n    if (p[i] !== p[i-1] || i === p.length - 1) {\\n      if (run > 2)\\n        runs[run % 3].push(run)\\n\\n      run = 1\\n    }\\n  }\\n\\n  let needed = needL + needU + needD\\n\\n  // Take care of the special case where all runs are autoamtically covered\\n  if (p.length < 6)\\n    return Math.max(6 - p.length, needed)\\n\\n  let len = p.length, toDelete = Math.max(len - 20, 0), toChange = 0\\n\\n  // Use password shortening to reduce runs\\n  while (len-- > 20) {\\n    // Focus on runs divisible by 3\\n    if (runs[0].length !== 0) {\\n      run = runs[0].pop() - 1\\n\\n      if (run !== 2)\\n        runs[2].push(run)\\n    } else if (runs[1].length !== 0) {\\n      runs[0].push(runs[1].pop() - 1)\\n    } else if (runs[2].length !== 0) {\\n      runs[1].push(runs[2].pop() - 1)\\n    }\\n  }\\n\\n  // Combine the runs into one list\\n  runs = runs.flat()\\n\\n  toChange = runs.reduce(\\n    (total, run) => total + run / 3 | 0, 0\\n  )\\n\\n  // Absorb character kind deficiencies into run breakup mutations\\n  needed = Math.max(needed - toChange, 0)\\n\\n  return toDelete + toChange + needed\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019711,
                "title": "optimal-solution-for-strong-password-checker-on-leetcode-python",
                "content": "# Intuition\\nTo solve this problem, we need to determine the minimum number of steps required to make the given password strong. A strong password must satisfy the following conditions:\\n\\n    It must have at least 6 characters and at most 20 characters.\\n    It must contain at least one lowercase letter, one uppercase letter, and one digit.\\n    It must not contain three repeating characters in a row.\\n\\nWe can approach this problem by iteratively checking each condition and counting the number of steps needed to satisfy each condition. Finally, we return the maximum of these steps.\\n\\n# Approach\\n1. Initialize a variable steps to 0 to keep track of the total number of steps needed.\\n2. Initialize three boolean variables hasLower, hasUpper, and hasDigit to check if the password contains at least one lowercase letter, one uppercase letter, and one digit.\\n3. Initialize two variables repeat1 and repeat2 to check for three repeating characters in a row. Set them to 0.\\n4. Iterate through the characters of the password:\\n    - If the character is a lowercase letter, set hasLower to True.\\n    - If the character is an uppercase letter, set hasUpper to True.\\n    - If the character is a digit, set hasDigit to True.\\n    - If the current character is the same as the previous character, increment repeat1. If repeat1 reaches 3, increment steps by 1, set repeat1 to 2, and continue.\\n    - If the current character is the same as the character two positions back (i.e., three repeating characters), increment repeat2. If repeat2 reaches 3, increment steps by 1, set repeat2 to 2, and continue.\\n5. After iterating through the password, check the following conditions:\\n    - If the length of the password is less than 6, calculate the number of insertions needed to reach a length of 6, and add it to steps.\\n    - If the length of the password is between 6 and 20 (inclusive), calculate the number of insertions needed to satisfy the missing character types (lowercase, uppercase, digit), and add it to steps.\\n    - If the length of the password is greater than 20, calculate the number of deletions needed to reduce the length to 20, and add it to steps.\\n6. Return the final value of steps as the minimum number of steps required to make the password strong.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the length of the input password string. This is because we iterate through the password string once to check its characters and conditions. The subsequent calculations to determine the number of insertions or deletions also take constant time.\\n\\n- Space complexity:\\nThe space complexity of this solution is O(1), which means it uses a constant amount of extra space regardless of the input size. The variables used to store information about missing character types, replacements, and counts do not depend on the input size and occupy a fixed amount of memory.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p - 1] == s[p - 2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p - 1]:\\n                    length += 1\\n                    p += 1\\n\\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n\\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n\\n            return delete + max(missing_type, change)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p - 1] == s[p - 2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p - 1]:\\n                    length += 1\\n                    p += 1\\n\\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n\\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n\\n            return delete + max(missing_type, change)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017763,
                "title": "easy-and-fast-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        bool all_met = false;\\n        int add_steps = 0, rem_steps = 0, trio_steps = 0, contains_steps = 3;\\n        int p_size = password.size();\\n        \\n        if (p_size < 6)\\n            add_steps = 6-p_size;\\n        else if(p_size > 20)\\n            rem_steps = p_size-20;\\n\\n        bool contains_lower = false, contains_upper = false, contains_digit = false;\\n        int modular_cases[3] = {0};\\n        for (int i = 0; i < p_size;){\\n            if (password[i] >= \\'a\\' and password[i] <= \\'z\\') contains_lower = true;\\n            else if (password[i] >= \\'A\\' and password[i] <= \\'Z\\') contains_upper = true;\\n            else if (password[i] >= \\'0\\' and password[i] <= \\'9\\') contains_digit = true;\\n\\n            int j=i+1;\\n            while(j<p_size && password[i]==password[j]) j++;\\n            int diff = j-i;\\n            trio_steps += diff/3;\\n            if (diff/3 >= 1) modular_cases[diff%3]++;\\n            \\n            i=j;\\n        }\\n        if (contains_lower) contains_steps--;\\n        if (contains_upper) contains_steps--;\\n        if (contains_digit) contains_steps--;\\n        \\n        if (add_steps)\\n            return max(add_steps, max(trio_steps, contains_steps));\\n\\n        int aux_rem_steps = rem_steps;\\n        for (int m = 0; m < 3; m++)\\n            while(aux_rem_steps >= m+1 and modular_cases[m] > 0)\\n                aux_rem_steps -= m+1, trio_steps--, modular_cases[m]--;\\n\\n        return rem_steps + max(trio_steps-aux_rem_steps/3, contains_steps); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        bool all_met = false;\\n        int add_steps = 0, rem_steps = 0, trio_steps = 0, contains_steps = 3;\\n        int p_size = password.size();\\n        \\n        if (p_size < 6)\\n            add_steps = 6-p_size;\\n        else if(p_size > 20)\\n            rem_steps = p_size-20;\\n\\n        bool contains_lower = false, contains_upper = false, contains_digit = false;\\n        int modular_cases[3] = {0};\\n        for (int i = 0; i < p_size;){\\n            if (password[i] >= \\'a\\' and password[i] <= \\'z\\') contains_lower = true;\\n            else if (password[i] >= \\'A\\' and password[i] <= \\'Z\\') contains_upper = true;\\n            else if (password[i] >= \\'0\\' and password[i] <= \\'9\\') contains_digit = true;\\n\\n            int j=i+1;\\n            while(j<p_size && password[i]==password[j]) j++;\\n            int diff = j-i;\\n            trio_steps += diff/3;\\n            if (diff/3 >= 1) modular_cases[diff%3]++;\\n            \\n            i=j;\\n        }\\n        if (contains_lower) contains_steps--;\\n        if (contains_upper) contains_steps--;\\n        if (contains_digit) contains_steps--;\\n        \\n        if (add_steps)\\n            return max(add_steps, max(trio_steps, contains_steps));\\n\\n        int aux_rem_steps = rem_steps;\\n        for (int m = 0; m < 3; m++)\\n            while(aux_rem_steps >= m+1 and modular_cases[m] > 0)\\n                aux_rem_steps -= m+1, trio_steps--, modular_cases[m]--;\\n\\n        return rem_steps + max(trio_steps-aux_rem_steps/3, contains_steps); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016963,
                "title": "strong-password-validation-with-linear-complexity",
                "content": "# Intuition\\nThe problem asks us to find the minimum number of steps required to make a given password strong based on certain conditions. The conditions are length, presence of at least one lowercase letter, at least one uppercase letter, and at least one digit, as well as the absence of three repeating characters in a row.\\n\\n# Approach\\n- Character Type Checks: First, we go through the password to see which types of characters it contains (lowercase, uppercase, digits). We use variables has_lower, has_upper, and has_digit to store this information.\\n\\n- Missing Types: We then calculate how many types of characters are missing to make the password strong, stored in missing_types.\\n\\n- Repeating Sequences: Next, we loop through the password to find sequences of repeating characters and count how many such sequences exist. We also note sequences that can be resolved by deleting one or two characters.\\n\\n- Length Checks: Depending on the length of the password (n), we decide on the minimum steps needed for the password length to be in the range [6, 20].\\n\\n- Optimization: If the length is greater than 20, we use the extra characters to resolve the repeating sequences (reducing to_replace).\\n\\n- Result: Finally, the minimum number of steps is the higher value between missing_types and the number of steps needed to resolve the length and repeating sequence issues.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  - One pass to check for character types (lowercase, uppercase, and digit).\\n  - One pass to check for repeating sequences.\\n- Space complexity: O(1)\\n  - Constant extra space is used for variables.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) {\\n        int has_lower = 0, has_upper = 0, has_digit = 0;\\n        foreach (char c in password) {\\n            if (char.IsLower(c)) has_lower = 1;\\n            if (char.IsUpper(c)) has_upper = 1;\\n            if (char.IsDigit(c)) has_digit = 1;\\n        }\\n        \\n        int missing_types = 3 - (has_lower + has_upper + has_digit);\\n        \\n        int n = password.Length;\\n        int to_replace = 0;\\n        int one_delete = 0;\\n        int two_delete = 0;\\n        \\n        int i = 2;\\n        while (i < n) {\\n            if (password[i] == password[i-1] && password[i] == password[i-2]) {\\n                int length = 2;\\n                while (i < n && password[i] == password[i-1]) {\\n                    length++;\\n                    i++;\\n                }\\n                \\n                to_replace += length / 3;\\n                if (length % 3 == 0) one_delete += 1;\\n                if (length % 3 == 1) two_delete += 1;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        if (n < 6) {\\n            return Math.Max(missing_types, 6 - n);\\n        } else if (n <= 20) {\\n            return Math.Max(missing_types, to_replace);\\n        } else {\\n            int delete_len = n - 20;\\n            \\n            to_replace -= Math.Min(delete_len, one_delete * 1) / 1;\\n            to_replace -= Math.Min(Math.Max(delete_len - one_delete, 0), two_delete * 2) / 2;\\n            to_replace -= Math.Max(delete_len - one_delete - 2 * two_delete, 0) / 3;\\n            \\n            return delete_len + Math.Max(missing_types, to_replace);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) {\\n        int has_lower = 0, has_upper = 0, has_digit = 0;\\n        foreach (char c in password) {\\n            if (char.IsLower(c)) has_lower = 1;\\n            if (char.IsUpper(c)) has_upper = 1;\\n            if (char.IsDigit(c)) has_digit = 1;\\n        }\\n        \\n        int missing_types = 3 - (has_lower + has_upper + has_digit);\\n        \\n        int n = password.Length;\\n        int to_replace = 0;\\n        int one_delete = 0;\\n        int two_delete = 0;\\n        \\n        int i = 2;\\n        while (i < n) {\\n            if (password[i] == password[i-1] && password[i] == password[i-2]) {\\n                int length = 2;\\n                while (i < n && password[i] == password[i-1]) {\\n                    length++;\\n                    i++;\\n                }\\n                \\n                to_replace += length / 3;\\n                if (length % 3 == 0) one_delete += 1;\\n                if (length % 3 == 1) two_delete += 1;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        if (n < 6) {\\n            return Math.Max(missing_types, 6 - n);\\n        } else if (n <= 20) {\\n            return Math.Max(missing_types, to_replace);\\n        } else {\\n            int delete_len = n - 20;\\n            \\n            to_replace -= Math.Min(delete_len, one_delete * 1) / 1;\\n            to_replace -= Math.Min(Math.Max(delete_len - one_delete, 0), two_delete * 2) / 2;\\n            to_replace -= Math.Max(delete_len - one_delete - 2 * two_delete, 0) / 3;\\n            \\n            return delete_len + Math.Max(missing_types, to_replace);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976731,
                "title": "python",
                "content": "Not the cleanest solution but it seems to work\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        hasdigits = any(char.isdigit() for char in password)\\n        hasupper = any(char.isupper() for char in password)\\n        haslower = any(char.islower() for char in password)\\n        # positive if we need to add characters, negative if we need to delete, 0 for replacements\\n        additions = max(0, 6-len(password)) - max(0, len(password)-20) \\n        \\n        # list all repeating sequence lengths\\n        cp = None\\n        seq = []\\n        n = 1\\n        for c in password:\\n            if c == cp:\\n                n += 1\\n                if n == 3:\\n                    seq.append(n)\\n                elif n > 3:\\n                    seq[-1] = n\\n            else:\\n                n = 1\\n            cp = c\\n        seq.sort()\\n        edits = 0\\n        # keep making edits until all repeating sequences are gone\\n        while(len(seq) > 0):\\n            print(seq)\\n            # replace characters (additions==0), or add (>0)\\n            if additions >= 0:\\n                # if needed, we replace/add a required character\\n                if not hasdigits:\\n                    hasdigits = True\\n                elif not haslower: \\n                    haslower = True\\n                elif not hasupper:\\n                    hasupper = True\\n                # take the longest sequence and start splitting it into pieces of len 2\\n                # this means we actually just remove 3 characters from the sequence\\n                seq[-1] -= 3\\n                if(seq[-1] < 3): del seq[-1]\\n                additions = max(0, additions-1) # remove one addition\\n            # delete or replace characters (additions < 0)\\n            else:\\n                # if we can remove all repeating sequences by only deleting characters, we start deleting\\n                if(sum(seq) - 2*len(seq) <= -additions):\\n                    edits += len(seq)\\n                    additions = min(0, additions+len(seq))\\n                    break\\n                    #seq[0] -= 1\\n                    #if(seq[0] < 3): del seq[0]\\n                    #additions = min(0, additions+1)\\n                # if not, it\\'s more efficient to first start breaking them up with replacements\\n                else:\\n                    # if needed, we replace with a required character\\n                    if not hasdigits:\\n                        hasdigits = True\\n                    elif not haslower: \\n                        haslower = True\\n                    elif not hasupper:\\n                        hasupper = True\\n                    seq[-1] -= 3\\n                    if(seq[-1] < 3): del seq[-1]\\n                    seq.sort()  # sort so the longest sequence is at the top of the stack again\\n            edits += 1  # add to the edit counter\\n\\n        # if we have any additions left, we make sure we first add required characters\\n        for i in range(additions):\\n            if not hasdigits:\\n                hasdigits = True\\n            elif not haslower: \\n                haslower = True\\n            else:\\n                hasupper = True\\n        \\n        # add all leftover additions and required character changes to the edits    \\n        edits += abs(additions) + (not hasdigits) + (not hasupper) + (not haslower)\\n\\n        return edits\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        hasdigits = any(char.isdigit() for char in password)\\n        hasupper = any(char.isupper() for char in password)\\n        haslower = any(char.islower() for char in password)\\n        # positive if we need to add characters, negative if we need to delete, 0 for replacements\\n        additions = max(0, 6-len(password)) - max(0, len(password)-20) \\n        \\n        # list all repeating sequence lengths\\n        cp = None\\n        seq = []\\n        n = 1\\n        for c in password:\\n            if c == cp:\\n                n += 1\\n                if n == 3:\\n                    seq.append(n)\\n                elif n > 3:\\n                    seq[-1] = n\\n            else:\\n                n = 1\\n            cp = c\\n        seq.sort()\\n        edits = 0\\n        # keep making edits until all repeating sequences are gone\\n        while(len(seq) > 0):\\n            print(seq)\\n            # replace characters (additions==0), or add (>0)\\n            if additions >= 0:\\n                # if needed, we replace/add a required character\\n                if not hasdigits:\\n                    hasdigits = True\\n                elif not haslower: \\n                    haslower = True\\n                elif not hasupper:\\n                    hasupper = True\\n                # take the longest sequence and start splitting it into pieces of len 2\\n                # this means we actually just remove 3 characters from the sequence\\n                seq[-1] -= 3\\n                if(seq[-1] < 3): del seq[-1]\\n                additions = max(0, additions-1) # remove one addition\\n            # delete or replace characters (additions < 0)\\n            else:\\n                # if we can remove all repeating sequences by only deleting characters, we start deleting\\n                if(sum(seq) - 2*len(seq) <= -additions):\\n                    edits += len(seq)\\n                    additions = min(0, additions+len(seq))\\n                    break\\n                    #seq[0] -= 1\\n                    #if(seq[0] < 3): del seq[0]\\n                    #additions = min(0, additions+1)\\n                # if not, it\\'s more efficient to first start breaking them up with replacements\\n                else:\\n                    # if needed, we replace with a required character\\n                    if not hasdigits:\\n                        hasdigits = True\\n                    elif not haslower: \\n                        haslower = True\\n                    elif not hasupper:\\n                        hasupper = True\\n                    seq[-1] -= 3\\n                    if(seq[-1] < 3): del seq[-1]\\n                    seq.sort()  # sort so the longest sequence is at the top of the stack again\\n            edits += 1  # add to the edit counter\\n\\n        # if we have any additions left, we make sure we first add required characters\\n        for i in range(additions):\\n            if not hasdigits:\\n                hasdigits = True\\n            elif not haslower: \\n                haslower = True\\n            else:\\n                hasupper = True\\n        \\n        # add all leftover additions and required character changes to the edits    \\n        edits += abs(additions) + (not hasdigits) + (not hasupper) + (not haslower)\\n\\n        return edits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976117,
                "title": "how-strong-is-this-password-checker",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        \\n        # Check for lowercase, uppercase, and digit\\n        has_lower = any(c.islower() for c in password)\\n        has_upper = any(c.isupper() for c in password)\\n        has_digit = any(c.isdigit() for c in password)\\n        \\n        # Total types of characters we need to add to satisfy the requirements\\n        types_needed = 3 - (has_lower + has_upper + has_digit)\\n        \\n        # Check for repeating characters\\n        repeat_replace = 0\\n        one_mod = two_mod = 0  # Counters for characters that repeat modulo 3\\n        \\n        i = 2\\n        while i < n:\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < n and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                repeat_replace += length // 3\\n                if length % 3 == 0:\\n                    one_mod += 1\\n                elif length % 3 == 1:\\n                    two_mod += 1\\n            else:\\n                i += 1\\n        \\n        # If the length is less than 6\\n        if n < 6:\\n            return max(types_needed, 6 - n)\\n        \\n        # If the length is between 6 and 20\\n        elif n <= 20:\\n            return max(types_needed, repeat_replace)\\n        \\n        # If the length is more than 20\\n        else:\\n            delete_needed = n - 20\\n            repeat_replace -= min(delete_needed, one_mod * 1) // 1\\n            repeat_replace -= min(max(delete_needed - one_mod, 0), two_mod * 2) // 2\\n            repeat_replace -= max(delete_needed - one_mod - 2 * two_mod, 0) // 3\\n            \\n            return delete_needed + max(types_needed, repeat_replace)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        n = len(password)\\n        \\n        # Check for lowercase, uppercase, and digit\\n        has_lower = any(c.islower() for c in password)\\n        has_upper = any(c.isupper() for c in password)\\n        has_digit = any(c.isdigit() for c in password)\\n        \\n        # Total types of characters we need to add to satisfy the requirements\\n        types_needed = 3 - (has_lower + has_upper + has_digit)\\n        \\n        # Check for repeating characters\\n        repeat_replace = 0\\n        one_mod = two_mod = 0  # Counters for characters that repeat modulo 3\\n        \\n        i = 2\\n        while i < n:\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < n and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                repeat_replace += length // 3\\n                if length % 3 == 0:\\n                    one_mod += 1\\n                elif length % 3 == 1:\\n                    two_mod += 1\\n            else:\\n                i += 1\\n        \\n        # If the length is less than 6\\n        if n < 6:\\n            return max(types_needed, 6 - n)\\n        \\n        # If the length is between 6 and 20\\n        elif n <= 20:\\n            return max(types_needed, repeat_replace)\\n        \\n        # If the length is more than 20\\n        else:\\n            delete_needed = n - 20\\n            repeat_replace -= min(delete_needed, one_mod * 1) // 1\\n            repeat_replace -= min(max(delete_needed - one_mod, 0), two_mod * 2) // 2\\n            repeat_replace -= max(delete_needed - one_mod - 2 * two_mod, 0) // 3\\n            \\n            return delete_needed + max(types_needed, repeat_replace)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957766,
                "title": "strengthening-passwords-a-minimal-modification-approach",
                "content": "# Intuition\\nInitially, it\\'s clear that a strong password must meet certain criteria related to its length, character types, and patterns. The challenge is to figure out the minimal number of steps required to transform the input password into a strong one while satisfying these conditions. \\n\\n# Approach\\nCharacter Types: First, let\\'s identify the types of characters present in the password. A strong password should have at least one lowercase letter, one uppercase letter, and one digit.\\n\\nRepetitive Sequences: Next, it\\'s essential to pinpoint sequences of three or more repeating characters. These sequences should be altered to ensure no three consecutive characters are the same.\\n\\nPassword Length: Depending on the length of the password, we\\'ll need to either insert, delete, or replace characters.\\n\\nIf the password is shorter than 6 characters, it\\'s often more efficient to insert the missing characters.\\nIf it\\'s between 6 and 20, replacements would typically suffice.\\nFor passwords longer than 20 characters, deletions become necessary. \\n\\n# Complexity\\n- Time complexity:\\nThe solution primarily iterates through the given password, resulting in a complexity of O(n), where n is the length of the password. \\n\\n- Space complexity:\\nWe only use a constant amount of space, making the space complexity O(1). \\n\\n# Code\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        # Checking the presence of different types of characters in the password\\n        upper, lower, digit = 0, 0, 0\\n        for c in password:\\n            if \\'a\\' <= c <= \\'z\\':\\n                lower = 1\\n            elif \\'A\\' <= c <= \\'Z\\':\\n                upper = 1\\n            elif c.isdigit():\\n                digit = 1\\n        # Calculate how many types are missing\\n        types_missing = 3 - (upper + lower + digit)\\n\\n        # Addressing the issue of repetitive sequences\\n        replace = 0\\n        one_replace, two_replace = 0, 0\\n        i = 2\\n        while i < len(password):\\n            # Detect sequences of three identical characters\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                # Count the full sequence length\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                # Decide on replacements based on sequence length\\n                replace += length // 3\\n                if length % 3 == 0: \\n                    one_replace += 1\\n                elif length % 3 == 1: \\n                    two_replace += 1\\n            else:\\n                i += 1\\n\\n        # Handling different password lengths\\n        if len(password) < 6:\\n            return max(6 - len(password), types_missing)\\n        elif len(password) <= 20:\\n            return max(types_missing, replace)\\n        else:\\n            total_deletion = len(password) - 20\\n            replace -= min(total_deletion, one_replace * 1) // 1\\n            replace -= min(max(total_deletion - one_replace, 0), two_replace * 2) // 2\\n            replace -= max(total_deletion - one_replace - 2 * two_replace, 0) // 3\\n            \\n            return total_deletion + max(types_missing, replace)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        # Checking the presence of different types of characters in the password\\n        upper, lower, digit = 0, 0, 0\\n        for c in password:\\n            if \\'a\\' <= c <= \\'z\\':\\n                lower = 1\\n            elif \\'A\\' <= c <= \\'Z\\':\\n                upper = 1\\n            elif c.isdigit():\\n                digit = 1\\n        # Calculate how many types are missing\\n        types_missing = 3 - (upper + lower + digit)\\n\\n        # Addressing the issue of repetitive sequences\\n        replace = 0\\n        one_replace, two_replace = 0, 0\\n        i = 2\\n        while i < len(password):\\n            # Detect sequences of three identical characters\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                # Count the full sequence length\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                # Decide on replacements based on sequence length\\n                replace += length // 3\\n                if length % 3 == 0: \\n                    one_replace += 1\\n                elif length % 3 == 1: \\n                    two_replace += 1\\n            else:\\n                i += 1\\n\\n        # Handling different password lengths\\n        if len(password) < 6:\\n            return max(6 - len(password), types_missing)\\n        elif len(password) <= 20:\\n            return max(types_missing, replace)\\n        else:\\n            total_deletion = len(password) - 20\\n            replace -= min(total_deletion, one_replace * 1) // 1\\n            replace -= min(max(total_deletion - one_replace, 0), two_replace * 2) // 2\\n            replace -= max(total_deletion - one_replace - 2 * two_replace, 0) // 3\\n            \\n            return total_deletion + max(types_missing, replace)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951948,
                "title": "extremely-simple-o-n-solution-in-python-with-proper-explanation",
                "content": "# Intuition\\nPassword strength checkers can be annoying, but they\\'re super important. Let\\'s break this down.\\n\\nFirst things first, every strong password should have a mix of characters. So, I definitely need to check if the password has uppercase letters, lowercase letters, and numbers. For each type missing, I\\'d need to make a change, whether that\\'s a replacement or adding a character.\\n\\nNext, the length of the password. Too short? Gotta add characters. Too long? Time to trim it down. But if it\\'s in that sweet spot between 6 and 20 characters, I can leave it as it is.\\n\\nNow, the tricky part: those annoying sequences of repeating characters. Nobody wants a password like \\'aaabbb\\'. If I see a sequence like that, I need to break it up. Replacing one character in every set of three repeating characters should do the trick.\\n\\nBut here\\'s where it gets complicated: If I need to delete characters because the password is too long, I can use those deletions smartly to also break up the repeating sequences. For example, if I have \\'aaaa\\', deleting one \\'a\\' will break the sequence and I\\'d have killed two birds with one stone.\\n\\nFinally, I\\'ll just add up all the changes I need to make and that should give me the answer. Oh, and using regex for the repeating characters would make things a lot smoother.\\n\\n# Approach\\nBasically, we want a strong password that ticks all the boxes. It needs uppercase, lowercase, and numbers \\u2013 no shortcuts. Plus, it can\\'t be too short or too long, and those repeating characters? No can do!\\n\\nFirst step, let\\'s see what\\'s missing. Uppercase? Lowercase? Numbers? Gonna check for each and figure out what swaps we might need.\\n\\nNow, about those repeating characters. I\\'m thinking regex is the move here. It\\'s like a magic pattern thing. Gonna snag those sequences that keep going on and on. That should tell us how much we gotta tweak things.\\n\\nLength time. If it\\'s way too short, we\\'ll throw in some extra characters. If it\\'s pushing the limits, we\\'ll cut back. But here\\'s the trick: while we\\'re trimming, might as well deal with those pesky repeats. Double duty, you know?\\n\\nWrapping it up, we\\'ll count up all the changes we\\'ve made. That\\'ll give us the scoop on how much work it\\'ll take to make this password super solid.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the code is **O(n)**, where n is the length of the input password. The main factors contributing to the time complexity are the checks for character types and the search for repeating sequences using regex.\\n\\n- Space complexity:\\nThe space complexity of the code is **O(n)**, as it depends on the space required to store the repeating sequences found by the regex search. Other variables and data structures used in the code occupy constant space.\\n\\n\\n\\n\\n# Code\\n```\\nimport re\\n\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        # Checking for the presence of each character type in the password\\n        types = [any(c.islower() for c in password), any(c.isupper() for c in password), any(c.isdigit() for c in password)]\\n        \\n        # Calculating replacements for missing character types\\n        replace_types = 3 - sum(types)\\n        \\n        # Using regex to identify sequences of repeating characters\\n        repeats = [match.group() for match in re.finditer(r\"(.)\\\\1{2,}\", password)]\\n        one_mod, two_mod, repeat_replace = sum(len(r) % 3 == 0 for r in repeats), sum(len(r) % 3 == 1 for r in repeats), sum(len(r) // 3 for r in repeats)\\n        \\n        # Handling cases based on password length\\n        if len(password) < 6:\\n            return max(replace_types, 6 - len(password))\\n        \\n        if len(password) <= 20:\\n            return max(replace_types, repeat_replace)\\n        \\n        # Adjusting replacements based on required deletions for passwords > 20 chars\\n        delete_required = len(password) - 20\\n        \\n        # Prioritize the one_mod and two_mod deletions first\\n        delete_one_mod = min(delete_required, one_mod)\\n        repeat_replace -= delete_one_mod\\n        delete_required -= delete_one_mod\\n        \\n        delete_two_mod = min(delete_required, two_mod * 2) // 2\\n        repeat_replace -= delete_two_mod\\n        delete_required -= delete_two_mod * 2\\n        \\n        # Now, handle the deletions required from the regular repeat_replace\\n        delete_three_mod = delete_required // 3\\n        repeat_replace -= delete_three_mod\\n        delete_required -= delete_three_mod * 3\\n        \\n        # Final calculation of operations required to make the password strong\\n        return len(password) - 20 + max(replace_types, repeat_replace)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport re\\n\\nclass Solution(object):\\n    def strongPasswordChecker(self, password):\\n        # Checking for the presence of each character type in the password\\n        types = [any(c.islower() for c in password), any(c.isupper() for c in password), any(c.isdigit() for c in password)]\\n        \\n        # Calculating replacements for missing character types\\n        replace_types = 3 - sum(types)\\n        \\n        # Using regex to identify sequences of repeating characters\\n        repeats = [match.group() for match in re.finditer(r\"(.)\\\\1{2,}\", password)]\\n        one_mod, two_mod, repeat_replace = sum(len(r) % 3 == 0 for r in repeats), sum(len(r) % 3 == 1 for r in repeats), sum(len(r) // 3 for r in repeats)\\n        \\n        # Handling cases based on password length\\n        if len(password) < 6:\\n            return max(replace_types, 6 - len(password))\\n        \\n        if len(password) <= 20:\\n            return max(replace_types, repeat_replace)\\n        \\n        # Adjusting replacements based on required deletions for passwords > 20 chars\\n        delete_required = len(password) - 20\\n        \\n        # Prioritize the one_mod and two_mod deletions first\\n        delete_one_mod = min(delete_required, one_mod)\\n        repeat_replace -= delete_one_mod\\n        delete_required -= delete_one_mod\\n        \\n        delete_two_mod = min(delete_required, two_mod * 2) // 2\\n        repeat_replace -= delete_two_mod\\n        delete_required -= delete_two_mod * 2\\n        \\n        # Now, handle the deletions required from the regular repeat_replace\\n        delete_three_mod = delete_required // 3\\n        repeat_replace -= delete_three_mod\\n        delete_required -= delete_three_mod * 3\\n        \\n        # Final calculation of operations required to make the password strong\\n        return len(password) - 20 + max(replace_types, repeat_replace)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947611,
                "title": "100-speed-comments-no-fancy-algorithms-just-logic",
                "content": "# Approach\\nCore ideas:\\n    1. We can utilize same action for solving multiple problems\\n    2. Each insert can reduce sequence size by 2\\n    3. For each sequence we need length // 3 replacements\\n    4. We can solve unsafe sequences with deletions but we need to delete chars from the sequenses with least (length % 3) value.\\n\\nFLow:\\n    1. We fix password length, so we know how many insertions/deletions we have.\\n    2. We utilize deletions deleting per 1 char from sequences with least (length % 3).\\n    3. We utilize insertions deleting per 2 characters from sequence.\\n    4. All unsolved sequences we solve with replacements\\n    5. We fix problem with missing characters with additional replacements (if needed).\\n\\n# Complexity\\n- Time complexity (worst case, commend if you know more precise value):\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfn check_has_digit(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 48 && ch as u8 <= 57 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn check_has_lowercase(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 97 && ch as u8 <= 122 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn check_has_uppercase(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 65 && ch as u8 <= 90 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn find_sequences(password: & String) -> Vec<i32> {\\n    /*\\n        Finds all unsafe sequences and returns vector of their lengths\\n    */\\n    let mut seq: i32 = 1;\\n    let mut sequences: Vec<i32> = Vec::new();\\n    if password.len() < 3 {\\n        return sequences\\n    }\\n    let mut prev: char = password.chars().next().unwrap();\\n    for ch in password.chars().skip(1) {\\n        if ch == prev {\\n            seq += 1\\n        }\\n        else {\\n            if seq >= 3 {\\n                sequences.push(seq);\\n            }\\n            seq = 1\\n        }\\n        prev = ch;\\n    }\\n    if seq >= 3 {\\n        sequences.push(seq);\\n    }\\n    return sequences\\n}\\n\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        /*\\n            Core ideas:\\n            1. We can utilize same action for solving multiple problems\\n            2. Each insert can reduce sequence size by 2\\n            3. For each sequence we need length // 3 replacements\\n            4. We can solve unsafe sequences with deletions but we need to delete chars from the sequenses with least (length % 3) value.\\n\\n            FLow:\\n            1. We fix password length, so we know how many insertions/deletions we have.\\n            2. We utilize deletions deleting per 1 char from sequences with least (length % 3).\\n            3. We utilize insertions deleting per 2 characters from sequence.\\n            4. All unsolved sequences we solve with replacements\\n            5. We fix problem with missing characters with additional replacements (if needed).\\n        */\\n        let length = password.len() as i32;\\n        let mut char_actions: i32 = 0;\\n        if !check_has_digit(&password) {char_actions += 1};\\n        if !check_has_lowercase(&password) {char_actions += 1};\\n        if !check_has_uppercase(&password) {char_actions += 1};\\n        let mut insertions: i32 = 0;\\n        let mut deletions: i32 = 0;\\n        let mut replations: i32 = 0;\\n\\n        // fix length\\n        if length > 20 {\\n            deletions += length - 20;\\n        }\\n        if length < 6 {\\n            insertions += 6 - length;\\n        }\\n\\n        // find unsafe sequences\\n        let mut sequences = find_sequences(&password);\\n\\n        // utilize deletions\\n        if deletions > 0 {\\n            let mut i = deletions;\\n            loop {\\n                sequences.sort_by_key(|x| x % 3);\\n                let i0 = i;\\n                for s in 0..sequences.len(){\\n                    if sequences[s] < 3 {continue}\\n                    sequences[s] -= 1;\\n                    i -= 1;\\n                    break\\n                }\\n                if i == 0 || i == i0 { break }\\n            }\\n        }\\n\\n        // utilize insertions\\n        if insertions > 0 {\\n            let mut i = insertions;\\n            loop {\\n                let i0 = i;\\n                for s in 0..sequences.len(){\\n                    if sequences[s] < 3 {continue}\\n                    sequences[s] -= 2;\\n                    i -= 1;\\n                    if i == 0 { break }\\n                }\\n                if i == 0 || i == i0 { break }\\n            }\\n        }\\n\\n        // fix all other sequences with replacements\\n        let mut seq_operations = 0;\\n        for seq in sequences {\\n            if seq >= 3 {\\n                seq_operations += seq / 3;\\n            }\\n        }\\n        replations += seq_operations;\\n\\n        // fix missing characters\\n        char_actions = char_actions - replations - insertions;\\n        if char_actions < 0 {char_actions = 0};\\n        replations += char_actions;\\n\\n        return deletions + replations + insertions\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn check_has_digit(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 48 && ch as u8 <= 57 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn check_has_lowercase(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 97 && ch as u8 <= 122 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn check_has_uppercase(password: & String) -> bool {\\n    for ch in password.chars(){\\n        if ch as u8 >= 65 && ch as u8 <= 90 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfn find_sequences(password: & String) -> Vec<i32> {\\n    /*\\n        Finds all unsafe sequences and returns vector of their lengths\\n    */\\n    let mut seq: i32 = 1;\\n    let mut sequences: Vec<i32> = Vec::new();\\n    if password.len() < 3 {\\n        return sequences\\n    }\\n    let mut prev: char = password.chars().next().unwrap();\\n    for ch in password.chars().skip(1) {\\n        if ch == prev {\\n            seq += 1\\n        }\\n        else {\\n            if seq >= 3 {\\n                sequences.push(seq);\\n            }\\n            seq = 1\\n        }\\n        prev = ch;\\n    }\\n    if seq >= 3 {\\n        sequences.push(seq);\\n    }\\n    return sequences\\n}\\n\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        /*\\n            Core ideas:\\n            1. We can utilize same action for solving multiple problems\\n            2. Each insert can reduce sequence size by 2\\n            3. For each sequence we need length // 3 replacements\\n            4. We can solve unsafe sequences with deletions but we need to delete chars from the sequenses with least (length % 3) value.\\n\\n            FLow:\\n            1. We fix password length, so we know how many insertions/deletions we have.\\n            2. We utilize deletions deleting per 1 char from sequences with least (length % 3).\\n            3. We utilize insertions deleting per 2 characters from sequence.\\n            4. All unsolved sequences we solve with replacements\\n            5. We fix problem with missing characters with additional replacements (if needed).\\n        */\\n        let length = password.len() as i32;\\n        let mut char_actions: i32 = 0;\\n        if !check_has_digit(&password) {char_actions += 1};\\n        if !check_has_lowercase(&password) {char_actions += 1};\\n        if !check_has_uppercase(&password) {char_actions += 1};\\n        let mut insertions: i32 = 0;\\n        let mut deletions: i32 = 0;\\n        let mut replations: i32 = 0;\\n\\n        // fix length\\n        if length > 20 {\\n            deletions += length - 20;\\n        }\\n        if length < 6 {\\n            insertions += 6 - length;\\n        }\\n\\n        // find unsafe sequences\\n        let mut sequences = find_sequences(&password);\\n\\n        // utilize deletions\\n        if deletions > 0 {\\n            let mut i = deletions;\\n            loop {\\n                sequences.sort_by_key(|x| x % 3);\\n                let i0 = i;\\n                for s in 0..sequences.len(){\\n                    if sequences[s] < 3 {continue}\\n                    sequences[s] -= 1;\\n                    i -= 1;\\n                    break\\n                }\\n                if i == 0 || i == i0 { break }\\n            }\\n        }\\n\\n        // utilize insertions\\n        if insertions > 0 {\\n            let mut i = insertions;\\n            loop {\\n                let i0 = i;\\n                for s in 0..sequences.len(){\\n                    if sequences[s] < 3 {continue}\\n                    sequences[s] -= 2;\\n                    i -= 1;\\n                    if i == 0 { break }\\n                }\\n                if i == 0 || i == i0 { break }\\n            }\\n        }\\n\\n        // fix all other sequences with replacements\\n        let mut seq_operations = 0;\\n        for seq in sequences {\\n            if seq >= 3 {\\n                seq_operations += seq / 3;\\n            }\\n        }\\n        replations += seq_operations;\\n\\n        // fix missing characters\\n        char_actions = char_actions - replations - insertions;\\n        if char_actions < 0 {char_actions = 0};\\n        replations += char_actions;\\n\\n        return deletions + replations + insertions\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931917,
                "title": "beats-100-00-of-users-with-c-runtime-0-ms",
                "content": "# Strong Password Checker\\n\\n## Intuition\\n\\nThe problem requires us to determine the minimum number of steps required to make a given password strong. To achieve this, we need to address the following aspects:\\n1. Ensure the password has a sufficient length of at least 6 characters and at most 20 characters.\\n2. Check for the presence of at least one lowercase letter, one uppercase letter, and one digit.\\n3. Avoid having three consecutive repeating characters.\\n\\n## Approach\\n\\nTo solve this problem, we can follow these steps:\\n\\n1. Calculate the number of missing character types (lowercase, uppercase, digit) in the password.\\n2. Iterate through the password to identify consecutive repeating substrings. For each repeating substring of length 3 or more, calculate the number of changes needed to break the repetition while keeping each segment\\'s length as close to 3 as possible.\\n3. Based on the password\\'s length, perform the following checks:\\n   - If the password length is less than 6, add the missing character types and the difference between 6 and the password length to the total changes.\\n   - If the password length is between 6 and 20, take the maximum of missing character types and changes required from repeating substrings.\\n4. If the password length exceeds 20 characters, calculate the number of deletions required to bring it down to 20. Then, reduce the number of changes based on the deletions while considering repeating substrings.\\n5. Return the final count of changes required, which represents the minimum steps to make the password strong.\\n\\n## Complexity Analysis\\n\\n- **Time Complexity**: The solution iterates through the password string once to calculate missing character types and repeating substrings. The overall time complexity is O(n), where n is the length of the password.\\n- **Space Complexity**: The solution uses a constant amount of extra space to store variables and temporary calculations, resulting in O(1) space complexity.\\n\\n## Code Template\\n\\nHere\\'s a possible implementation of the approach:\\n\\n```cpp\\n#include <algorithm>\\n#include <cctype>\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n = password.size();\\n        int missingTypes = 3;\\n        \\n        // Check for missing character types\\n        if (any_of(password.begin(), password.end(), [](char c) { return islower(c); })) missingTypes--;\\n        if (any_of(password.begin(), password.end(), [](char c) { return isupper(c); })) missingTypes--;\\n        if (any_of(password.begin(), password.end(), [](char c) { return isdigit(c); })) missingTypes--;\\n\\n        int changes = 0, oneRepeat = 0, twoRepeats = 0;\\n        \\n        // Find repeating substrings\\n        for (int i = 2; i < n; i++) {\\n            if (password[i] == password[i - 1] && password[i - 1] == password[i - 2]) {\\n                int length = 2;\\n                while (i < n && password[i] == password[i - 1]) {\\n                    length++;\\n                    i++;\\n                }\\n                changes += length / 3;\\n                if (length % 3 == 0) oneRepeat++;\\n                if (length % 3 == 1) twoRepeats++;\\n                i--;\\n            }\\n        }\\n\\n        // Determine the changes required\\n        if (n < 6) {\\n            return max(missingTypes, 6 - n);\\n        } else if (n <= 20) {\\n            return max(missingTypes, changes);\\n        } else {\\n            int deletions = n - 20;\\n            changes -= min(deletions, oneRepeat * 1) / 1;\\n            changes -= min(max(deletions - oneRepeat, 0), twoRepeats * 2) / 2;\\n            changes -= min(max(deletions - oneRepeat - 2 * twoRepeats, 0), changes * 3) / 3;\\n            return deletions + max(missingTypes, changes);\\n        }\\n    }\\n};\\n```\\n\\n## Summary\\n\\nThis solution template provides an approach to solving the \"Strong Password Checker\" problem efficiently. It systematically addresses each condition required for a password to be strong and calculates the minimum steps needed to achieve a strong password.",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```cpp\\n#include <algorithm>\\n#include <cctype>\\n\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n = password.size();\\n        int missingTypes = 3;\\n        \\n        // Check for missing character types\\n        if (any_of(password.begin(), password.end(), [](char c) { return islower(c); })) missingTypes--;\\n        if (any_of(password.begin(), password.end(), [](char c) { return isupper(c); })) missingTypes--;\\n        if (any_of(password.begin(), password.end(), [](char c) { return isdigit(c); })) missingTypes--;\\n\\n        int changes = 0, oneRepeat = 0, twoRepeats = 0;\\n        \\n        // Find repeating substrings\\n        for (int i = 2; i < n; i++) {\\n            if (password[i] == password[i - 1] && password[i - 1] == password[i - 2]) {\\n                int length = 2;\\n                while (i < n && password[i] == password[i - 1]) {\\n                    length++;\\n                    i++;\\n                }\\n                changes += length / 3;\\n                if (length % 3 == 0) oneRepeat++;\\n                if (length % 3 == 1) twoRepeats++;\\n                i--;\\n            }\\n        }\\n\\n        // Determine the changes required\\n        if (n < 6) {\\n            return max(missingTypes, 6 - n);\\n        } else if (n <= 20) {\\n            return max(missingTypes, changes);\\n        } else {\\n            int deletions = n - 20;\\n            changes -= min(deletions, oneRepeat * 1) / 1;\\n            changes -= min(max(deletions - oneRepeat, 0), twoRepeats * 2) / 2;\\n            changes -= min(max(deletions - oneRepeat - 2 * twoRepeats, 0), changes * 3) / 3;\\n            return deletions + max(missingTypes, changes);\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3928985,
                "title": "relatively-readable",
                "content": "# Intuition\\n\\nGather data first then do the necessary looping\\n\\n# Approach\\nget to [6..20] and then do replaces as needed to avoid 3 in row and/or missing type of character\\n\\n# Complexity\\n- Time complexity:\\nmeh\\n\\n- Space complexity:\\nlight\\n\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        result = 0\\n        \\n        has_upper = False\\n        has_lower = False\\n        has_digit = False\\n        l = len(password)\\n        less_than_06 = l < 6\\n        more_than_20 = l > 20\\n        diff_len = 0\\n        if less_than_06: diff_len = 6 - l\\n        if more_than_20: diff_len = l - 20\\n        repeats = []\\n        prev_letter = \\'\\'\\n        current_counter = 0\\n        modifies_needed = 0\\n        for letter in password:\\n            if letter.isupper(): has_upper = True\\n            if letter.islower(): has_lower = True\\n            if letter.isdigit(): has_digit = True\\n            if letter == prev_letter:\\n                current_counter += 1\\n            else:\\n                if current_counter >= 3:\\n                    repeats.append(current_counter)\\n                prev_letter = letter\\n                current_counter = 1\\n        if current_counter >= 3:\\n            repeats.append(current_counter)\\n        \\n        if not has_upper: modifies_needed += 1\\n        if not has_lower: modifies_needed += 1\\n        if not has_digit: modifies_needed += 1\\n        \\n        if more_than_20:\\n            # deletes\\n            while True:\\n                work = False\\n                repeats.sort(key=lambda x: x%3)\\n                for i in range(len(repeats)):\\n                    if repeats[i] < 3: continue\\n                    work = True\\n                    repeats[i] -= 1\\n                    diff_len -= 1\\n                    result += 1\\n                    break\\n                if not diff_len or not work: break\\n            result += diff_len\\n        if less_than_06:\\n            # inserts\\n            result += diff_len\\n            modifies_needed -= diff_len\\n            diff_len = 0\\n            if repeats: repeats[0] -= 2\\n\\n        # replaces\\n        for i in range(len(repeats)):\\n            if repeats[i] < 3: continue\\n            replaces = repeats[i] // 3\\n            result += replaces\\n            modifies_needed -= replaces\\n\\n        result += max(modifies_needed, 0)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        result = 0\\n        \\n        has_upper = False\\n        has_lower = False\\n        has_digit = False\\n        l = len(password)\\n        less_than_06 = l < 6\\n        more_than_20 = l > 20\\n        diff_len = 0\\n        if less_than_06: diff_len = 6 - l\\n        if more_than_20: diff_len = l - 20\\n        repeats = []\\n        prev_letter = \\'\\'\\n        current_counter = 0\\n        modifies_needed = 0\\n        for letter in password:\\n            if letter.isupper(): has_upper = True\\n            if letter.islower(): has_lower = True\\n            if letter.isdigit(): has_digit = True\\n            if letter == prev_letter:\\n                current_counter += 1\\n            else:\\n                if current_counter >= 3:\\n                    repeats.append(current_counter)\\n                prev_letter = letter\\n                current_counter = 1\\n        if current_counter >= 3:\\n            repeats.append(current_counter)\\n        \\n        if not has_upper: modifies_needed += 1\\n        if not has_lower: modifies_needed += 1\\n        if not has_digit: modifies_needed += 1\\n        \\n        if more_than_20:\\n            # deletes\\n            while True:\\n                work = False\\n                repeats.sort(key=lambda x: x%3)\\n                for i in range(len(repeats)):\\n                    if repeats[i] < 3: continue\\n                    work = True\\n                    repeats[i] -= 1\\n                    diff_len -= 1\\n                    result += 1\\n                    break\\n                if not diff_len or not work: break\\n            result += diff_len\\n        if less_than_06:\\n            # inserts\\n            result += diff_len\\n            modifies_needed -= diff_len\\n            diff_len = 0\\n            if repeats: repeats[0] -= 2\\n\\n        # replaces\\n        for i in range(len(repeats)):\\n            if repeats[i] < 3: continue\\n            replaces = repeats[i] // 3\\n            result += replaces\\n            modifies_needed -= replaces\\n\\n        result += max(modifies_needed, 0)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928526,
                "title": "c-100-acceptance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe provided code appears to address the problem of making a given string into a strong password while minimizing the number of changes. Here\\'s an attempt to deduce the intuition behind the approach based on the code and the available comments:\\n\\nPassword Strength Criteria:\\nA strong password typically has the following characteristics:\\n\\nAt least 6 characters in length.\\nContains at least one uppercase letter, one lowercase letter, and one digit.\\nDoes not contain repeating substrings of a certain length (e.g., more than 2).\\nBalancing Changes:\\nThe core idea seems to be balancing the additions, deletions, and replacements needed to satisfy the password requirements. The strategy is to minimize replacements (which can be more disruptive) by judiciously deleting characters from repetitions, if possible.\\n\\nOptimizing for Short and Long Strings:\\nThe code divides the problem into two cases: strings with lengths up to 20 characters (s.length() <= 20) and strings longer than 20 characters (s.length() > 20).\\n\\nFor short strings, the focus is on identifying three-repeating substrings and deciding whether to add a character or replace a character to break the repetition while satisfying the requirements.\\nFor long strings, a more complex approach is taken to analyze repetitions of different lengths and perform deletions to minimize replacements. The idea is to reduce the overall number of changes by considering different ways to delete characters.\\nIterative Strategy:\\nBoth cases involve iterations through the string to identify patterns and repetitions. By identifying repetitions and the lengths at which they occur, the code tries to determine optimal actions (deletions, replacements, additions) to achieve the strong password criteria.\\n\\nGreedy and Target-Oriented:\\nThe approach seems to be somewhat greedy, as it aims to make the best local choices (deletions, replacements, additions) that will lead to a strong password overall. The strategy adapts based on the specific requirements and the number of deletions and additions available.\\n\\nComplexity Management:\\nThe code takes advantage of certain patterns to avoid excessive replacements, which could disrupt the overall structure of the string. Instead, it focuses on deletions as a means of reducing the necessary changes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem seems to be about modifying a given string to make it a strong password while minimizing the number of modifications. A strong password is typically defined to meet certain criteria, such as having a minimum length, containing uppercase letters, lowercase letters, and digits, and not containing repeating substrings longer than a certain length.\\n\\nThe code\\'s approach can be summarized as follows:\\n\\nPreparation:\\n\\nCalculate the number of deletions needed to bring the length of the string to at most 20 characters (deleteTarget).\\nCalculate the number of additions needed to bring the length of the string to at least 6 characters (addTarget).\\nFor Cases of Short String (s.length() <= 20):\\n\\nTraverse through the string character by character to track whether there\\'s a need for uppercase letters, lowercase letters, and digits.\\nIdentify three-repeating substrings and decide whether to add a character within the substring to break the repetition (toAdd) or replace a character to avoid repetition (toReplace).\\nCalculate the minimum number of changes needed to satisfy the password requirements in case of a short string.\\nFor Cases of Long String (s.length() > 20):\\n\\nAnalyze the repetitions of different lengths in the string and record their frequencies in lenCnts.\\nAttempt to delete characters from repetitions of various lengths to minimize replacements:\\nDelete one character from repetitions with lengths that are multiples of 3.\\nDelete two characters from repetitions with lengths that leave a remainder of 1 when divided by 3.\\nDelete three characters (a repetition) to minimize replacements if available.\\nCalculate the total number of replacements needed based on the remaining repetitions.\\nCalculate Final Result:\\n\\nAdjust the deletions and replacements based on the calculated targets and remaining deletions.\\nReturn the total number of deletions and replacements needed to satisfy the password requirements.\\nThe approach seems to be focused on analyzing the input string for repetitions and strategically deciding whether to delete, add, or replace characters in order to achieve a strong password with minimal modifications.\\n\\nPlease note that the provided code snippet lacks detailed explanations for each step, and the comments appear to be cut off in places. To fully understand the approach, you might need access to the complete code or more detailed comments that provide insights into each decision made during the process.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the provided code is somewhat intricate due to the various loops and conditional checks it contains. Let\\'s break down the different parts and analyze the time complexity:\\n\\nFor cases of s.length() <= 20:\\nIn this section, you have a loop that goes through the string character by character. The loop runs once for each character in the string, performing constant-time operations within the loop body. Thus, the time complexity of this part is O(n), where n is the length of the input string s.\\n\\nFor cases of s.length() > 20:\\nThis section involves two nested loops. The outer loop iterates through repetitions of different lengths, and the inner loop iterates through the repetitions of a specific length. The total number of iterations in the outer loop is bounded by the maximum repetition length, which is proportional to the length of the input string s.\\n\\nWithin the inner loop, you are performing constant-time operations for each repetition\\'s length. The number of repetitions at each length is recorded in a data structure (unordered_map). Since you\\'re iterating over these repetitions, the time complexity for this section can be approximated as O(n), where n is the length of the input string.\\n\\nOverall:\\nThe code runs through the two main sections sequentially, and both sections have a time complexity of O(n). Therefore, the overall time complexity of the code can be considered O(n), where n is the length of the input string s.\\n\\nKeep in mind that this analysis provides a high-level estimate of the time complexity based on the loops and operations performed in the code. The actual execution time may vary depending on the specifics of the input data and how the code interacts with the underlying hardware.\\n\\nAs always, when analyzing time complexity, it\\'s important to consider the worst-case scenario and the dominant factors affecting the runtime.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the provided code can be analyzed by considering the memory used by various data structures and variables.\\n\\nVariables and Data Structures:\\n\\ndeleteTarget, addTarget, toDelete, toAdd, toReplace, needUpper, needLower, needDigit: These are all individual integer variables. They occupy constant space regardless of the input size, so they contribute to O(1) space complexity.\\nlenCnts: This is a vector of unordered_maps used to record repetition frequencies. The space used by lenCnts depends on the number of different repetition lengths and the frequency of each length. In the worst case, if there are many different repetition lengths, the space complexity for lenCnts could approach O(n), where n is the length of the input string s.\\nOverall:\\nThe main contributing factor to the space complexity is the lenCnts vector of unordered_maps. Since it\\'s the largest data structure that scales with input size, the space complexity can be approximated as O(n) in the worst case, where n is the length of the input string s.\\n\\nKeep in mind that the space complexity analysis focuses on the memory used by the algorithm as it runs, and it doesn\\'t take into account the memory used by the input itself (the string s) or any temporary variables created during execution. The analysis provides an understanding of how the memory requirements of the algorithm grow with the size of the input.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it\\'s a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we\\'ll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```\\n![Screenshot 2023-08-19 004842.png](https://assets.leetcode.com/users/images/37f1f0d8-9e06-42a2-8c41-d596d4cfe211_1692386355.21834.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it\\'s a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we\\'ll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907858,
                "title": "python-beats-89-53-well-explained-solution",
                "content": "# Intuition\\nThe goal is to determine the minimum number of steps required to make a given password strong by satisfying certain conditions. These conditions include the length of the password, the presence of lowercase, uppercase, and digit characters, and the prevention of three repeating characters in a row.\\n\\n# Approach\\n1. Initialize missing_type to 3, which represents the    \\nnumber of missing character types (lowercase, uppercase, and digit).\\n2. Check if the password contains lowercase, uppercase, and digit characters, and decrement missing_type accordingly.\\n3. Initialize variables change, one, and two to keep track of changes required and repeating character counts.\\n4. Iterate through the password from the third character onward.\\n    - If three consecutive characters are the same, calculate the length of the repeating sequence. Update change based on the length divided by 3. Update one and two based on the remainder of the length divided by 3.\\n    - Otherwise, move to the next character.\\n5. Handle cases based on the length of the password:\\n    - If the length is less than 6, return the maximum of missing_type and the difference between 6 and the length of the password.\\n    - If the length is between 6 and 20 (inclusive), return the maximum of missing_type and change.\\n    - If the length is greater than 20, calculate the number of deletions required and adjust change accordingly.\\n6. Return the result of the calculation based on the length of the password and the conditions met.\\n\\n# Complexity\\n- Time complexity:\\nO(N), where N is the length of the input password. The code iterates through the password once to analyze the character types and repeating sequences.\\n\\n- Space complexity:\\nO(1), as the algorithm uses a constant amount of extra space to store variables regardless of the input size.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901274,
                "title": "36ms-python3-solution",
                "content": "# Intuition\\nTo create a strong password, the constraints require having at least one lowercase letter, one uppercase letter, one digit, a length between 6 and 20 characters, and no three repeating characters in a row. \\n\\n1. **Identifying Missing Types**: Start by identifying the missing character types (lowercase, uppercase, digit) that are required to make the password strong. \\n\\n2. **Handling Repeating Characters**: Iterate through the password to find sequences of three or more repeating characters. Divide the length of each sequence by three to find the number of replacements needed, and keep track of remainders to understand how insertions or deletions may affect these sequences.\\n\\n3. **Length Constraints**: If the password is shorter than 6 characters, either a missing type or an extra character should be added. If the password is longer than 20 characters, characters must be deleted.\\n\\n4. **Combining Steps**: Combine the missing types and the required changes to find the minimum steps needed to make the password strong. This includes using deletions to reduce the number of replacements when the password is too long.\\n\\nBy analyzing all constraints and calculating how to meet each one with the minimum number of steps, we can efficiently find the minimum steps required to make the password strong.\\n# Approach\\n1. **Figure Out What\\'s Missing**: First, I checked to see what\\'s missing in the password. Does it have lowercase, uppercase, and digits? If anything\\'s missing, that\\'s going to be something we need to fix.\\n\\n2. **Deal with Repeating Characters**: Next, I tackled those annoying repeating characters. If any character repeated three or more times in a row, I calculated how many changes we\\'d need. I also kept tabs on the remainder of dividing by three to help figure out the best way to handle things later.\\n\\n3. **Too Short or Too Long?**: Then, I looked at the length of the password. If it\\'s less than 6 characters, we\\'ll need to add something. If it\\'s more than 20, we\\'ll need to delete. I used the remainder from step 2 to minimize the number of replacements needed when deleting characters.\\n\\n4. **Put It All Together**: Finally, I added up all the missing types, changes, deletions, or additions to get the minimum steps needed to make that password strong. It\\'s like putting together a puzzle, making sure each piece fits just right.\\n\\nBy breaking down the problem and tackling each part methodically, I was able to create a step-by-step approach to make any password strong. It\\'s a neat little solution that handles a lot of different scenarios efficiently!\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the code is $$O(n)$$, where $$n$$ is the length of the password. The code iterates through the password string, performing constant-time operations, resulting in a linear time complexity. The reported runtime of 36ms is in line with this analysis.\\n- Space complexity:\\nThe space complexity of the code is $$O(1)$$, as we are only using a constant amount of extra space, irrespective of the input size.\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        missing_types = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in password):\\n            missing_types -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in password):\\n            missing_types -= 1\\n        if any(c.isdigit() for c in password):\\n            missing_types -= 1\\n\\n        change = 0\\n        one, two, three = 0, 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                change += length // 3\\n                one += length % 3 == 0\\n                two += length % 3 == 1\\n                three += length % 3 == 2\\n            i += 1\\n\\n        n = len(password)\\n        if n < 6:\\n            return max(missing_types, 6 - n)\\n        elif n <= 20:\\n            return max(missing_types, change)\\n        else:\\n            deletes_needed = n - 20\\n            change -= min(deletes_needed, one * 1) // 1\\n            change -= min(max(deletes_needed - one, 0), two * 2) // 2\\n            change -= max(deletes_needed - one - 2 * two, 0) // 3\\n\\n            return deletes_needed + max(missing_types, change)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        missing_types = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in password):\\n            missing_types -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in password):\\n            missing_types -= 1\\n        if any(c.isdigit() for c in password):\\n            missing_types -= 1\\n\\n        change = 0\\n        one, two, three = 0, 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i-1] == password[i-2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i-1]:\\n                    length += 1\\n                    i += 1\\n                \\n                change += length // 3\\n                one += length % 3 == 0\\n                two += length % 3 == 1\\n                three += length % 3 == 2\\n            i += 1\\n\\n        n = len(password)\\n        if n < 6:\\n            return max(missing_types, 6 - n)\\n        elif n <= 20:\\n            return max(missing_types, change)\\n        else:\\n            deletes_needed = n - 20\\n            change -= min(deletes_needed, one * 1) // 1\\n            change -= min(max(deletes_needed - one, 0), two * 2) // 2\\n            change -= max(deletes_needed - one - 2 * two, 0) // 3\\n\\n            return deletes_needed + max(missing_types, change)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900094,
                "title": "detail-explaination-helpful-for-others-to-solve",
                "content": "# Intuition\\nThe code analyzes the password\\'s character composition and the repeating patterns to determine the necessary changes to meet the strong password criteria. It considers factors like the total number of missing character types, the length of the password, and how to optimize the replacement and deletion of characters to ensure a strong password while minimizing changes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize variables to track whether the password has at least one lowercase letter (a), one uppercase letter (A), and one digit (d), all initially set to 1.\\n2. Convert the password string into a character array for easier manipulation.\\n3. Create an integer array to store the length of consecutive repeating characters in the password.\\n4. Loop through the password characters to identify the repeating character lengths and update the lowercase, uppercase, and digit variables.\\n5. Calculate the total number of missing character types (total_missing) based on the a, A, and d variables.\\n6. Check if the password length is less than 6 characters:\\nIf so, calculate the number of changes needed to meet the password length requirement of at least 6 characters, adding it to the result.\\n7. If the password length is 6 or more characters:\\nCalculate the excess length (over_len) beyond the maximum allowed password length of 20 characters.\\nIterate through different groupings (k = 1 to 2) of repeating characters to minimize changes and decrement over_len.\\nIterate through the array of repeating character lengths:\\nIf the repeating length is at least 3 and over_len is greater than 0, adjust the repeating length and decrement over_len.\\nIf the repeating length is at least 3, calculate the leftover repeating character lengths that can be grouped.\\n8. Calculate the result based on the total_missing, over_len, and leftover repeating character lengths.\\n9. Return the final result, indicating the minimum changes required to make the password strong.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = password.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = a + A + d;\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = password.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = a + A + d;\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899334,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int strongPasswordChecker(string s) {\\n    const int n = s.length();\\n    const int missing = getMissing(s);\\n    // # of replacements to deal with 3 repeating characters\\n    int replaces = 0;\\n    // # of seqs that can be substituted with 1 deletions, (3k)-seqs\\n    int oneSeq = 0;\\n    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs\\n    int twoSeq = 0;\\n\\n    for (int i = 2; i < n;)\\n      if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {\\n        int length = 2;  // Length of repeating s\\n        while (i < n && s[i] == s[i - 1]) {\\n          ++length;\\n          ++i;\\n        }\\n        replaces += length / 3;  // \\'aaaaaaa\\' -> \\'aaxaaxa\\'\\n        if (length % 3 == 0)\\n          ++oneSeq;\\n        if (length % 3 == 1)\\n          ++twoSeq;\\n      } else {\\n        ++i;\\n      }\\n\\n    if (n < 6)\\n      return max(6 - n, missing);\\n    if (n <= 20)\\n      return max(replaces, missing);\\n\\n    const int deletes = n - 20;\\n    // Each replacement in (3k)-seqs can be substituted with 1 deletions\\n    replaces -= min(oneSeq, deletes);\\n    // Each replacement in (3k + 1)-seqs can be substituted with 2 deletions\\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) / 2;\\n    // Each replacement in other seqs can be substituted with 3 deletions\\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) / 3;\\n    return deletes + max(replaces, missing);\\n  }\\n\\n private:\\n  int getMissing(const string& s) {\\n    int missing = 3;\\n    if (any_of(s.begin(), s.end(), [](char c) { return isupper(c); }))\\n      --missing;\\n    if (any_of(s.begin(), s.end(), [](char c) { return islower(c); }))\\n      --missing;\\n    if (any_of(s.begin(), s.end(), [](char c) { return isdigit(c); }))\\n      --missing;\\n    return missing;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int strongPasswordChecker(string s) {\\n    const int n = s.length();\\n    const int missing = getMissing(s);\\n    // # of replacements to deal with 3 repeating characters\\n    int replaces = 0;\\n    // # of seqs that can be substituted with 1 deletions, (3k)-seqs\\n    int oneSeq = 0;\\n    // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs\\n    int twoSeq = 0;\\n\\n    for (int i = 2; i < n;)\\n      if (s[i] == s[i - 1] && s[i - 1] == s[i - 2]) {\\n        int length = 2;  // Length of repeating s\\n        while (i < n && s[i] == s[i - 1]) {\\n          ++length;\\n          ++i;\\n        }\\n        replaces += length / 3;  // \\'aaaaaaa\\' -> \\'aaxaaxa\\'\\n        if (length % 3 == 0)\\n          ++oneSeq;\\n        if (length % 3 == 1)\\n          ++twoSeq;\\n      } else {\\n        ++i;\\n      }\\n\\n    if (n < 6)\\n      return max(6 - n, missing);\\n    if (n <= 20)\\n      return max(replaces, missing);\\n\\n    const int deletes = n - 20;\\n    // Each replacement in (3k)-seqs can be substituted with 1 deletions\\n    replaces -= min(oneSeq, deletes);\\n    // Each replacement in (3k + 1)-seqs can be substituted with 2 deletions\\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) / 2;\\n    // Each replacement in other seqs can be substituted with 3 deletions\\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) / 3;\\n    return deletes + max(replaces, missing);\\n  }\\n\\n private:\\n  int getMissing(const string& s) {\\n    int missing = 3;\\n    if (any_of(s.begin(), s.end(), [](char c) { return isupper(c); }))\\n      --missing;\\n    if (any_of(s.begin(), s.end(), [](char c) { return islower(c); }))\\n      --missing;\\n    if (any_of(s.begin(), s.end(), [](char c) { return isdigit(c); }))\\n      --missing;\\n    return missing;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896718,
                "title": "the-fastest-in-dart",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution{\\nint strongPasswordChecker(String s) {\\n  int missingType = 3;\\n  if (s.contains(RegExp(r\\'[a-z]\\'))) missingType--;\\n  if (s.contains(RegExp(r\\'[A-Z]\\'))) missingType--;\\n  if (s.contains(RegExp(r\\'[0-9]\\'))) missingType--;\\n\\n  int change = 0;\\n  int one = 0, two = 0;\\n  int p = 2;\\n\\n  while (p < s.length) {\\n    if (s[p] == s[p - 1] && s[p - 1] == s[p - 2]) {\\n      int length = 2;\\n      while (p < s.length && s[p] == s[p - 1]) {\\n        length++;\\n        p++;\\n      }\\n      change += length ~/ 3;\\n      if (length % 3 == 0) one++;\\n      else if (length % 3 == 1) two++;\\n    } else {\\n      p++;\\n    }\\n  }\\n\\n  if (s.length < 6) {\\n    return max(missingType, 6 - s.length);\\n  } else if (s.length <= 20) {\\n    return max(missingType, change);\\n  } else {\\n    int deleteCount = s.length - 20;\\n    change -= min(deleteCount, one);\\n    change -= min(max(deleteCount - one, 0), two * 2) ~/ 2;\\n    change -= max(deleteCount - one - 2 * two, 0) ~/ 3;\\n    return deleteCount + max(missingType, change);\\n  }\\n}\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution{\\nint strongPasswordChecker(String s) {\\n  int missingType = 3;\\n  if (s.contains(RegExp(r\\'[a-z]\\'))) missingType--;\\n  if (s.contains(RegExp(r\\'[A-Z]\\'))) missingType--;\\n  if (s.contains(RegExp(r\\'[0-9]\\'))) missingType--;\\n\\n  int change = 0;\\n  int one = 0, two = 0;\\n  int p = 2;\\n\\n  while (p < s.length) {\\n    if (s[p] == s[p - 1] && s[p - 1] == s[p - 2]) {\\n      int length = 2;\\n      while (p < s.length && s[p] == s[p - 1]) {\\n        length++;\\n        p++;\\n      }\\n      change += length ~/ 3;\\n      if (length % 3 == 0) one++;\\n      else if (length % 3 == 1) two++;\\n    } else {\\n      p++;\\n    }\\n  }\\n\\n  if (s.length < 6) {\\n    return max(missingType, 6 - s.length);\\n  } else if (s.length <= 20) {\\n    return max(missingType, change);\\n  } else {\\n    int deleteCount = s.length - 20;\\n    change -= min(deleteCount, one);\\n    change -= min(max(deleteCount - one, 0), two * 2) ~/ 2;\\n    change -= max(deleteCount - one - 2 * two, 0) ~/ 3;\\n    return deleteCount + max(missingType, change);\\n  }\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892198,
                "title": "python3-with-explanation",
                "content": "# Intuition\\nChecking the strength of a password typically involves ensuring it meets certain criteria such as containing numbers, uppercase letters, lowercase letters, and not having repeated characters. The given problem seems to be an advanced form of this check, where we not only have to identify if the password is strong but also determine the minimum number of changes required to make it strong.\\n\\n# Approach\\nType Checking:\\n\\n- A strong password should have three types of characters: digit, uppercase, and lowercase. We start by checking the presence of each type and keep track of the missing types.\\n\\nRepetitions:\\n\\n- Repeated characters are a sign of a weak password. We need to identify sequences of characters that are repeated.\\n- For every sequence of three identical characters (e.g., \\'aaa\\'), one replacement is needed. For sequences of six (e.g., \\'aaaaaa\\'), two replacements are needed, and so on. We also keep track of sequences where the length % 3 is 0, 1, or 2, as they help in optimizing replacements later.\\n\\nLength Adjustments:\\n\\n- If the password\\'s length is less than 6, we can simply add the required characters. The number of additions would be 6 - len(password).\\n- If the password\\'s length is between 6 and 20, we don\\'t need to add or delete, just replace characters.\\n- If the password\\'s length is more than 20, we need to delete characters. The number of deletions is len(password) - 20. Deletions can also help in reducing the number of replacements. For instance, deleting one character from a sequence of \\'aaa\\' eliminates the need for a replacement.\\n\\nFinal Calculation:\\n\\n- Depending on the length of the password, we return the required operations (additions, deletions, or replacements) combined with the missing types.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(n), where n is the length of the password. This is because we iterate through the password multiple times (for checking types and repeated sequences) but each operation is linear.\\n\\n- Space complexity:\\nThe space complexity is O(1) as we are using only a constant amount of extra space regardless of the input size.\\n\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        types = 3\\n        if any(c.isdigit() for c in password): types -= 1\\n        if any(c.isupper() for c in password): types -= 1\\n        if any(c.islower() for c in password): types -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(password):\\n            if password[p] == password[p-1] == password[p-2]:\\n                length = 2\\n                while p < len(password) and password[p] == password[p-1]:\\n                    length += 1\\n                    p += 1\\n                \\n                change += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n\\n        if len(password) < 6:\\n            return max(types, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(types, change)\\n        else:\\n            delete = len(password) - 20\\n            change -= min(delete, one * 1)//1\\n            change -= min(max(delete - one, 0), two * 2)//2\\n            change -= max(delete - one - 2 * two, 0)//3\\n\\n            return delete + max(types, change)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        types = 3\\n        if any(c.isdigit() for c in password): types -= 1\\n        if any(c.isupper() for c in password): types -= 1\\n        if any(c.islower() for c in password): types -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(password):\\n            if password[p] == password[p-1] == password[p-2]:\\n                length = 2\\n                while p < len(password) and password[p] == password[p-1]:\\n                    length += 1\\n                    p += 1\\n                \\n                change += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n\\n        if len(password) < 6:\\n            return max(types, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(types, change)\\n        else:\\n            delete = len(password) - 20\\n            change -= min(delete, one * 1)//1\\n            change -= min(max(delete - one, 0), two * 2)//2\\n            change -= max(delete - one - 2 * two, 0)//3\\n\\n            return delete + max(types, change)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857985,
                "title": "js-java-python-python3-c-c-c-php-kotlin-100-accuracy-runtime-memory",
                "content": "# Please Upvote\\n```javascript []\\nconst strongPasswordChecker = (passwd) => {\\n    let steps = 0;\\n    let mustAdd = 0;\\n\\n    if (!passwd.match(/[A-Z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/[a-z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/\\\\d/)) {\\n        mustAdd++;\\n    }\\n\\n    let groups = passwd.match(/(.)\\\\1*/g).filter(x => x.length > 2);\\n\\n    if (passwd.length <= 20) {\\n        groups.forEach(group => {\\n            steps += Math.trunc(group.length / 3);\\n            mustAdd -= Math.trunc(group.length / 3);\\n        })\\n    }\\n\\n    if (passwd.length <= 20) {\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        if (passwd.length + steps >= 6) {\\n            steps += mustAdd;\\n        } else {\\n            if (mustAdd > 6 - (passwd.length + steps)) {\\n                steps += mustAdd;\\n            } else {\\n                steps += 6 - (passwd.length + steps);\\n            }\\n        }\\n    }\\n\\n    if (passwd.length > 20) {\\n        let mustRemove = passwd.length - 20;\\n        let lengths = [];\\n        let plus = [];\\n        let chL = 0;\\n        for (let i = 1; i <= 3; i++) {\\n            for (let k = 0; k < groups.length; k++) {\\n                if (plus[k] === undefined) { plus[k] = 0; }\\n                chL = groups[k].length - plus[k];\\n                if (lengths[k] === undefined) { lengths[k] = chL; }\\n                const rec = () => {\\n                    if (Math.trunc((chL - i) / 3) < Math.trunc(chL / 3) && passwd.length - steps - i >= 6 && mustRemove >= i && chL > 2 && lengths[k] - i > 0) {\\n                        steps += i;\\n                        plus[k] += i;\\n                        mustRemove -= i;\\n                        chL -= i;\\n                        lengths[k] -= i;\\n                        rec();\\n                    }\\n                }\\n                rec();\\n            }\\n        }\\n        lengths.forEach(length => {\\n            if (length > 2) {\\n                steps += Math.trunc(length / 3);\\n                mustAdd -= Math.trunc(length / 3);\\n            }\\n        }\\n        )\\n\\n        mustRemove = mustRemove > 0 ? mustRemove : 0;\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        steps += mustAdd + mustRemove;\\n    }\\n\\n    return steps;\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```\\n```Python3 []\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        steps = 0\\n        must_add = 0\\n\\n        if not any(char.isupper() for char in password):\\n            must_add += 1\\n        if not any(char.islower() for char in password):\\n            must_add += 1\\n        if not any(char.isdigit() for char in password):\\n            must_add += 1\\n\\n        import re\\n        groups = [match.group(0) for match in re.finditer(r\\'(.)\\\\1*\\', password) if len(match.group(0)) > 2]\\n\\n        if len(password) <= 20:\\n            for group in groups:\\n                steps += len(group) // 3\\n                must_add -= len(group) // 3\\n\\n        if len(password) <= 20:\\n            must_add = max(must_add, 0)\\n            if len(password) + steps >= 6:\\n                steps += must_add\\n            else:\\n                steps += max(must_add, 6 - (len(password) + steps))\\n\\n        if len(password) > 20:\\n            must_remove = len(password) - 20\\n            lengths = [None] * len(groups)\\n            plus = [None] * len(groups)\\n            for i in range(1, 4):\\n                for k in range(len(groups)):\\n                    if plus[k] is None:\\n                        plus[k] = 0\\n                    chL = len(groups[k]) - plus[k]\\n                    if lengths[k] is None:\\n                        lengths[k] = chL\\n\\n                    def rec():\\n                        nonlocal steps, must_remove\\n                        nonlocal chL, lengths\\n                        if (chL - i) // 3 < chL // 3 and len(password) - steps - i >= 6 and must_remove >= i and chL > 2 and lengths[k] - i > 0:\\n                            steps += i\\n                            plus[k] += i\\n                            must_remove -= i\\n                            chL -= i\\n                            lengths[k] -= i\\n                            rec()\\n\\n                    rec()\\n\\n            for length in lengths:\\n                if length > 2:\\n                    steps += length // 3\\n                    must_add -= length // 3\\n\\n            must_remove = max(must_remove, 0)\\n            must_add = max(must_add, 0)\\n            steps += must_add + must_remove\\n\\n        return steps\\n```\\n```JAVA []\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n    int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = s.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = (a + A + d);\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n            \\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n}\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it\\'s a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we\\'ll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n\\n```\\n```C []\\nchar letters[\\'A\\' + 62] = {\\n    [\\'A\\'] = 1,\\n    [\\'B\\'] = 1,\\n    [\\'C\\'] = 1,\\n    [\\'D\\'] = 1,\\n    [\\'E\\'] = 1,\\n    [\\'F\\'] = 1,\\n    [\\'G\\'] = 1,\\n    [\\'H\\'] = 1,\\n    [\\'I\\'] = 1,\\n    [\\'J\\'] = 1,\\n    [\\'K\\'] = 1,\\n    [\\'L\\'] = 1,\\n    [\\'M\\'] = 1,\\n    [\\'N\\'] = 1,\\n    [\\'O\\'] = 1,\\n    [\\'P\\'] = 1,\\n    [\\'Q\\'] = 1,\\n    [\\'R\\'] = 1,\\n    [\\'S\\'] = 1,\\n    [\\'T\\'] = 1,\\n    [\\'U\\'] = 1,\\n    [\\'V\\'] = 1,\\n    [\\'W\\'] = 1,\\n    [\\'X\\'] = 1,\\n    [\\'Y\\'] = 1,\\n    [\\'Z\\'] = 1,\\n    [\\'a\\'] = 2,\\n    [\\'b\\'] = 2,\\n    [\\'c\\'] = 2,\\n    [\\'d\\'] = 2,\\n    [\\'e\\'] = 2,\\n    [\\'f\\'] = 2,\\n    [\\'g\\'] = 2,\\n    [\\'h\\'] = 2,\\n    [\\'i\\'] = 2,\\n    [\\'j\\'] = 2,\\n    [\\'k\\'] = 2,\\n    [\\'l\\'] = 2,\\n    [\\'m\\'] = 2,\\n    [\\'n\\'] = 2,\\n    [\\'o\\'] = 2,\\n    [\\'p\\'] = 2,\\n    [\\'q\\'] = 2,\\n    [\\'r\\'] = 2,\\n    [\\'s\\'] = 2,\\n    [\\'t\\'] = 2,\\n    [\\'u\\'] = 2,\\n    [\\'v\\'] = 2,\\n    [\\'w\\'] = 2,\\n    [\\'x\\'] = 2,\\n    [\\'y\\'] = 2,\\n    [\\'z\\'] = 2,\\n    [\\'0\\'] = 3,\\n    [\\'1\\'] = 3,\\n    [\\'2\\'] = 3,\\n    [\\'3\\'] = 3,\\n    [\\'4\\'] = 3,\\n    [\\'5\\'] = 3,\\n    [\\'6\\'] = 3,\\n    [\\'7\\'] = 3,\\n    [\\'8\\'] = 3,\\n    [\\'9\\'] = 3,\\n};\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int replace = 0;\\n    int one = 0;\\n    int two = 0;\\n    int cap = 1;\\n    int low = 1;\\n    int dig = 1;\\n    \\n    for(int i = 0; password[i]; i++){\\n        if(letters[password[i]] == 1){\\n            cap = 0;\\n        } else if(letters[password[i]] == 2) {\\n            low = 0;\\n        } else if(letters[password[i]] == 3) {\\n            dig = 0;\\n        }\\n        \\n        int repeat = 1;\\n        while(password[i] == password[i + 1]){\\n            i++;\\n            repeat += 1;\\n        }\\n        \\n        if(repeat > 2){\\n            replace += (repeat / 3);\\n\\n            if(repeat % 3 == 0){\\n                one += 1;\\n            } else if(repeat % 3 == 1){\\n                two += 2;\\n            }\\n        }\\n    }\\n    \\n    if(length < 6){\\n        if(cap + low + dig > 6 - length){\\n            return cap + low + dig;\\n        } else {\\n            return 6 - length;\\n        }\\n    } else if(length <= 20){\\n        if(cap + low + dig > replace){\\n            return cap + low + dig;\\n        } else {\\n            return replace;\\n        }\\n    } else {\\n        int over = length - 20;\\n        \\n        if(one < over){\\n            replace -= one;\\n        } else {\\n            replace -= over;\\n        }\\n        \\n        if(over - one > 0){\\n            if(two < (over - one)){\\n                replace -= two / 2;\\n            } else {\\n                replace -= (over - one) / 2;\\n            }\\n        }\\n        \\n        if((over - one - two) > 0){\\n            replace -= (over - one - two) / 3;\\n        }\\n        \\n        if(cap + low + dig > replace){\\n            return over + cap + low + dig;\\n        } else {\\n            return over + replace;\\n        }\\n    }\\n}\\n```\\n```C# []\\nclass Solution {\\n    public int StrongPasswordChecker(string s) {\\n        int charSum = GetRequiredChar(s);\\n        if (s.Length < 6) return Math.Max(charSum, 6 - s.Length);\\n            int replace = 0, ones = 0, twos = 0; \\n            for (int i = 0; i < s.Length;) {\\n            int len = 1;\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3) {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) ones += 1;\\n                    if (len % 3 == 1) twos += 2;\\n                }\\n                i += len;\\n            }\\n            if (s.Length <= 20) return Math.Max(charSum, replace);\\n            int deleteCount = s.Length - 20;\\n            replace -= Math.Min(deleteCount, ones);\\n            replace -= Math.Min(Math.Max(deleteCount - ones, 0), twos) / 2;\\n            replace -= Math.Max(deleteCount - ones - twos, 0) / 3;\\n        return deleteCount + Math.Max(charSum, replace);\\n        }\\n        int GetRequiredChar(string s) {\\n            int lowerCase = 1, upperCase = 1, digit = 1;\\n            foreach (var c in s) {\\n                if (char.IsLower(c)) lowerCase = 0;\\n                else if (char.IsUpper(c)) upperCase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n            return lowerCase + upperCase + digit;\\n    }    \\n}\\n```\\n```PHP []\\nclass Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $passwordCharList = str_split($password);\\n    \\n        $missingType = 3;\\n        $numberList = range(48, 57);\\n        $charListCapital = range(65, 90); \\n        $charListLowercase = range(97, 122);\\n\\n        $numberFlag = false;\\n        $capitalFlag = false;\\n        $lowercaseFlag = false;\\n\\n        foreach ($passwordCharList as $key => $value){\\n            if (!$numberFlag && in_array(ord($value), $numberList)) { \\n                $numberFlag = true;\\n            } else if (!$capitalFlag && in_array(ord($value), $charListCapital)) {\\n                $capitalFlag = true;\\n            } else if (!$lowercaseFlag && in_array(ord($value), $charListLowercase)) {\\n                $lowercaseFlag = true;\\n            }\\n        }\\n        \\n        $numberFlag && $missingType--;\\n        $capitalFlag && $missingType--;\\n        $lowercaseFlag && $missingType--;\\n        \\n        $change = 0;\\n        $first = 0;\\n        $second = 0;\\n        $charKey = 2;\\n\\n        while ($charKey < strlen($password)){\\n            if ($passwordCharList[$charKey] === $passwordCharList[$charKey-1] \\n                && $passwordCharList[$charKey] === $passwordCharList[$charKey-2]) {\\n                $countOfRepeat = 2;\\n\\n                while ($charKey<strlen($password) \\n                    && $passwordCharList[$charKey] === $passwordCharList[$charKey-1]) {\\n                    $countOfRepeat++;\\n                    $charKey++;\\n                }\\n                \\n                $change += floor($countOfRepeat/3);\\n                \\n                $countOfRepeat % 3 === 0 && $first += 1;\\n                $countOfRepeat % 3 === 1 && $second += 2;     \\n\\n                continue;\\n            }\\n            \\n            $charKey++;\\n        }\\n        \\n    \\n        if (strlen($password) < 6) {\\n            return max($missingType, 6-strlen($password));\\n        } else if (strlen($password) >= 6 && strlen($password) <= 20) {\\n            return max($missingType, $change);\\n        }\\n\\n        $removeKey = strlen($password) - 20;\\n            \\n        $change -= min($removeKey, $first);\\n        $change -= floor(min(max($removeKey - $first, 0), $second) / 2);\\n        $change -= floor(max($removeKey - $first - $second, 0) / 3);\\n            \\n        return $removeKey + max($missingType, $change);\\n    }\\n}\\n```\\n```Kotlin []\\nclass Solution {\\n\\n    fun strongPasswordChecker(password: String): Int {\\n        var operations = 0\\n        var lower = 0\\n        var upper = 0\\n        var digits = 0\\n\\n        val repeating = IntArray(password.length)\\n\\n        var currentCheckIndex = 0\\n        while (currentCheckIndex < password.length) {\\n            val targetCheckIndex = currentCheckIndex // For later repeating check use\\n            val targetChar = password[currentCheckIndex]\\n\\n            while (currentCheckIndex < password.length && password[currentCheckIndex] == targetChar) {\\n                repeating[targetCheckIndex]++\\n                currentCheckIndex++\\n            }\\n        }\\n        println(\"Repeating: ${repeating.joinToString(\", \")}\")\\n        for (targetChar in password) {\\n            if (targetChar.isUpperCase()) upper+= 1\\n            if (targetChar.isLowerCase()) lower+= 1\\n            if (targetChar.isDigit()) digits += 1\\n        }\\n        val charTypeRequirementMetCount = lower.coerceAtMost(1) + upper.coerceAtMost(1) + digits.coerceAtMost(1)\\n        val missingRequirements = 3 - charTypeRequirementMetCount\\n\\n        if (password.length <= 3) { // If length is less than 3, it will be able to fix the missing requirements no matter what\\n            return 6 - password.length\\n        } else if (password.length < 6) { // If the length is 4, 5, or 6, it will be maximum value of insertion count and missing requirements count\\n            // We don\\'t need to worry about repeating chars since we can easily fix it by inserting char in a different location\\n            val insertionCount = 6 - password.length\\n            return maxOf(insertionCount, missingRequirements)\\n        } else {\\n            println(\"Lowercase: $lower\")\\n            println(\"Uppercase: $upper\")\\n            println(\"Digits: $digits\")\\n\\n            var extraLength = password.length - 20\\n\\n            if (extraLength > 0) {\\n                findMinimizedSumOfDivision(extraLength, repeating)\\n                operations += extraLength\\n            }\\n\\n            println(\"After operation: \" + repeating.joinToString(\", \"))\\n\\n            // After reducing the length, we want to now replace all the repeating stuff.\\n            // Replaced \"random char amount\" will be stored inside a variable (For later use)\\n            var modifiedCharAmount = 0\\n            for ((index, i) in repeating.withIndex()) {\\n                if (i >= 3) {\\n                    operations += i / 3\\n                    modifiedCharAmount += i / 3\\n                    println(\"Modified ${i / 3} char(s) to eliminate repeating chars\")\\n                }\\n            }\\n\\n            // At this point, \"repeating\" is trashed as it\\'s in-accurate, and we don\\'t need it in our last bit of code\\n\\n            // Now we use the \"random char amount\" to decide if we have to do extra patch for char type requirements\\n            // If we don\\'t need those (AKA we added enough random chars that will just fit those requirements), we ignore them\\n            // Otherwise, we add (requirements - random char amount) to operations count\\n\\n            println(\"We are missing $missingRequirements requirements ($operations)\")\\n            if (modifiedCharAmount < missingRequirements) {\\n                operations += (missingRequirements - modifiedCharAmount)\\n            }\\n\\n        }\\n\\n        return operations\\n    }\\n\\n\\n    //   63927897\\n    // - 11100010\\n    //   52827887\\n    // - 00002002\\n    //   52825885\\n    // - 30303333\\n    // - 22522552\\n    // - 00300330\\n\\n    fun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n        var operationsLeft = operationsLimitation\\n        var currentSubValue = 1\\n        var doneOperation: Boolean\\n        while (operationsLeft > 0) {\\n            doneOperation = false\\n            for ((i, num) in nums.withIndex()) {\\n                if (num >= 3) {\\n                   if (num % 3 == currentSubValue - 1) {\\n                        doneOperation = true\\n                        var sub = currentSubValue\\n                        while (operationsLeft > 0 && sub > 0) {\\n                            operationsLeft--\\n                            nums[i] -= 1\\n                            sub--\\n                        }\\n                    }\\n                }\\n                if (operationsLeft == 0) return\\n            }\\n            if (currentSubValue == 3 && !doneOperation) break\\n            if (currentSubValue != 3) currentSubValue++\\n        }\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Kotlin",
                    "PHP",
                    "Greedy"
                ],
                "code": "```javascript []\\nconst strongPasswordChecker = (passwd) => {\\n    let steps = 0;\\n    let mustAdd = 0;\\n\\n    if (!passwd.match(/[A-Z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/[a-z]/)) {\\n        mustAdd++;\\n    }\\n    if (!passwd.match(/\\\\d/)) {\\n        mustAdd++;\\n    }\\n\\n    let groups = passwd.match(/(.)\\\\1*/g).filter(x => x.length > 2);\\n\\n    if (passwd.length <= 20) {\\n        groups.forEach(group => {\\n            steps += Math.trunc(group.length / 3);\\n            mustAdd -= Math.trunc(group.length / 3);\\n        })\\n    }\\n\\n    if (passwd.length <= 20) {\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        if (passwd.length + steps >= 6) {\\n            steps += mustAdd;\\n        } else {\\n            if (mustAdd > 6 - (passwd.length + steps)) {\\n                steps += mustAdd;\\n            } else {\\n                steps += 6 - (passwd.length + steps);\\n            }\\n        }\\n    }\\n\\n    if (passwd.length > 20) {\\n        let mustRemove = passwd.length - 20;\\n        let lengths = [];\\n        let plus = [];\\n        let chL = 0;\\n        for (let i = 1; i <= 3; i++) {\\n            for (let k = 0; k < groups.length; k++) {\\n                if (plus[k] === undefined) { plus[k] = 0; }\\n                chL = groups[k].length - plus[k];\\n                if (lengths[k] === undefined) { lengths[k] = chL; }\\n                const rec = () => {\\n                    if (Math.trunc((chL - i) / 3) < Math.trunc(chL / 3) && passwd.length - steps - i >= 6 && mustRemove >= i && chL > 2 && lengths[k] - i > 0) {\\n                        steps += i;\\n                        plus[k] += i;\\n                        mustRemove -= i;\\n                        chL -= i;\\n                        lengths[k] -= i;\\n                        rec();\\n                    }\\n                }\\n                rec();\\n            }\\n        }\\n        lengths.forEach(length => {\\n            if (length > 2) {\\n                steps += Math.trunc(length / 3);\\n                mustAdd -= Math.trunc(length / 3);\\n            }\\n        }\\n        )\\n\\n        mustRemove = mustRemove > 0 ? mustRemove : 0;\\n        mustAdd = mustAdd > 0 ? mustAdd : 0;\\n        steps += mustAdd + mustRemove;\\n    }\\n\\n    return steps;\\n};\\n```\n```python []\\nclass Solution(object):\\n    def strongPasswordChecker(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_type -= 1\\n        if any(c.isdigit() for c in s): missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length / 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n        \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            \\n            change -= min(delete, one)\\n            change -= min(max(delete - one, 0), two * 2) / 2\\n            change -= max(delete - one - 2 * two, 0) / 3\\n                \\n            return delete + max(missing_type, change)\\n```\n```Python3 []\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        steps = 0\\n        must_add = 0\\n\\n        if not any(char.isupper() for char in password):\\n            must_add += 1\\n        if not any(char.islower() for char in password):\\n            must_add += 1\\n        if not any(char.isdigit() for char in password):\\n            must_add += 1\\n\\n        import re\\n        groups = [match.group(0) for match in re.finditer(r\\'(.)\\\\1*\\', password) if len(match.group(0)) > 2]\\n\\n        if len(password) <= 20:\\n            for group in groups:\\n                steps += len(group) // 3\\n                must_add -= len(group) // 3\\n\\n        if len(password) <= 20:\\n            must_add = max(must_add, 0)\\n            if len(password) + steps >= 6:\\n                steps += must_add\\n            else:\\n                steps += max(must_add, 6 - (len(password) + steps))\\n\\n        if len(password) > 20:\\n            must_remove = len(password) - 20\\n            lengths = [None] * len(groups)\\n            plus = [None] * len(groups)\\n            for i in range(1, 4):\\n                for k in range(len(groups)):\\n                    if plus[k] is None:\\n                        plus[k] = 0\\n                    chL = len(groups[k]) - plus[k]\\n                    if lengths[k] is None:\\n                        lengths[k] = chL\\n\\n                    def rec():\\n                        nonlocal steps, must_remove\\n                        nonlocal chL, lengths\\n                        if (chL - i) // 3 < chL // 3 and len(password) - steps - i >= 6 and must_remove >= i and chL > 2 and lengths[k] - i > 0:\\n                            steps += i\\n                            plus[k] += i\\n                            must_remove -= i\\n                            chL -= i\\n                            lengths[k] -= i\\n                            rec()\\n\\n                    rec()\\n\\n            for length in lengths:\\n                if length > 2:\\n                    steps += length // 3\\n                    must_add -= length // 3\\n\\n            must_remove = max(must_remove, 0)\\n            must_add = max(must_add, 0)\\n            steps += must_add + must_remove\\n\\n        return steps\\n```\n```JAVA []\\nclass Solution {\\n    public int strongPasswordChecker(String s) {\\n    int res = 0, a = 1, A = 1, d = 1;\\n    char[] carr = s.toCharArray();\\n    int[] arr = new int[carr.length];\\n        \\n    for (int i = 0; i < arr.length;) {\\n        if (Character.isLowerCase(carr[i])) a = 0;\\n        if (Character.isUpperCase(carr[i])) A = 0;\\n        if (Character.isDigit(carr[i])) d = 0;\\n            \\n        int j = i;\\n        while (i < carr.length && carr[i] == carr[j]) i++;\\n        arr[j] = i - j;\\n    }\\n        \\n    int total_missing = (a + A + d);\\n\\n    if (arr.length < 6) {\\n        res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\\n            \\n    } else {\\n        int over_len = Math.max(arr.length - 20, 0), left_over = 0;\\n        res += over_len;\\n            \\n        for (int k = 1; k < 3; k++) {\\n            for (int i = 0; i < arr.length && over_len > 0; i++) {\\n                if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\\n                arr[i] -= Math.min(over_len, k);\\n                over_len -= k;\\n            }\\n        }\\n            \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] >= 3 && over_len > 0) {\\n                int need = arr[i] - 2;\\n                arr[i] -= over_len;\\n                over_len -= need;\\n            }\\n                \\n            if (arr[i] >= 3) left_over += arr[i] / 3;\\n        }\\n            \\n        res += Math.max(total_missing, left_over);\\n    }\\n        \\n    return res;\\n}\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string s) {\\n        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());\\n        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;\\n        \\n        ///////////////////////////////////\\n        // For cases of s.length() <= 20 //\\n        ///////////////////////////////////\\n        for (int l = 0, r = 0; r < s.length(); r++) {\\n            if (isupper(s[r])) { needUpper = 0; }               \\n            if (islower(s[r])) { needLower = 0; }\\n            if (isdigit(s[r])) { needDigit = 0; }\\n            \\n            if (r - l == 2) {                                   // if it\\'s a three-letter window\\n                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr\\n                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible\\n                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars\\n                } else { l++; }                                 // keep the window with no more than 3 letters\\n            }\\n        }\\n        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }\\n        \\n        //////////////////////////////////\\n        // For cases of s.length() > 20 //\\n        //////////////////////////////////\\n        toReplace = 0;                                          // reset toReplace\\n        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2\\n        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies\\n            if (r == s.length() || s[l] != s[r]) {\\n                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3\\n                l = r;\\n            }\\n        }\\n        \\n        /*\\n            Use deletions to minimize replacements, following below orders:\\n            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1\\n            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1\\n            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three \\n            letters) decreases repalcements by 1\\n        */\\n        for (int i = 0, numLetters, dec; i < 3; i++) {                \\n            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {\\n                if (i < 2) {\\n                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);\\n                    toDelete += dec * numLetters;               // dec is the number of repetitions we\\'ll delete from\\n                    it->second -= dec;                          // update number of repetitions left\\n                    \\n                    // after letters deleted, it fits in the group where (length % 3) == 2\\n                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   \\n                }\\n                \\n                // record number of replacements needed\\n                // note if len is the length of repetition, we need (len / 3) number of replacements\\n                toReplace += (it->second) * ((it->first) / 3);  \\n            }    \\n        }\\n\\n        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible\\n        toReplace -= dec, toDelete -= dec * 3;\\n        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);\\n    }\\n};\\n\\n```\n```C []\\nchar letters[\\'A\\' + 62] = {\\n    [\\'A\\'] = 1,\\n    [\\'B\\'] = 1,\\n    [\\'C\\'] = 1,\\n    [\\'D\\'] = 1,\\n    [\\'E\\'] = 1,\\n    [\\'F\\'] = 1,\\n    [\\'G\\'] = 1,\\n    [\\'H\\'] = 1,\\n    [\\'I\\'] = 1,\\n    [\\'J\\'] = 1,\\n    [\\'K\\'] = 1,\\n    [\\'L\\'] = 1,\\n    [\\'M\\'] = 1,\\n    [\\'N\\'] = 1,\\n    [\\'O\\'] = 1,\\n    [\\'P\\'] = 1,\\n    [\\'Q\\'] = 1,\\n    [\\'R\\'] = 1,\\n    [\\'S\\'] = 1,\\n    [\\'T\\'] = 1,\\n    [\\'U\\'] = 1,\\n    [\\'V\\'] = 1,\\n    [\\'W\\'] = 1,\\n    [\\'X\\'] = 1,\\n    [\\'Y\\'] = 1,\\n    [\\'Z\\'] = 1,\\n    [\\'a\\'] = 2,\\n    [\\'b\\'] = 2,\\n    [\\'c\\'] = 2,\\n    [\\'d\\'] = 2,\\n    [\\'e\\'] = 2,\\n    [\\'f\\'] = 2,\\n    [\\'g\\'] = 2,\\n    [\\'h\\'] = 2,\\n    [\\'i\\'] = 2,\\n    [\\'j\\'] = 2,\\n    [\\'k\\'] = 2,\\n    [\\'l\\'] = 2,\\n    [\\'m\\'] = 2,\\n    [\\'n\\'] = 2,\\n    [\\'o\\'] = 2,\\n    [\\'p\\'] = 2,\\n    [\\'q\\'] = 2,\\n    [\\'r\\'] = 2,\\n    [\\'s\\'] = 2,\\n    [\\'t\\'] = 2,\\n    [\\'u\\'] = 2,\\n    [\\'v\\'] = 2,\\n    [\\'w\\'] = 2,\\n    [\\'x\\'] = 2,\\n    [\\'y\\'] = 2,\\n    [\\'z\\'] = 2,\\n    [\\'0\\'] = 3,\\n    [\\'1\\'] = 3,\\n    [\\'2\\'] = 3,\\n    [\\'3\\'] = 3,\\n    [\\'4\\'] = 3,\\n    [\\'5\\'] = 3,\\n    [\\'6\\'] = 3,\\n    [\\'7\\'] = 3,\\n    [\\'8\\'] = 3,\\n    [\\'9\\'] = 3,\\n};\\n\\nint strongPasswordChecker(char * password){\\n    int length = strlen(password);\\n    int replace = 0;\\n    int one = 0;\\n    int two = 0;\\n    int cap = 1;\\n    int low = 1;\\n    int dig = 1;\\n    \\n    for(int i = 0; password[i]; i++){\\n        if(letters[password[i]] == 1){\\n            cap = 0;\\n        } else if(letters[password[i]] == 2) {\\n            low = 0;\\n        } else if(letters[password[i]] == 3) {\\n            dig = 0;\\n        }\\n        \\n        int repeat = 1;\\n        while(password[i] == password[i + 1]){\\n            i++;\\n            repeat += 1;\\n        }\\n        \\n        if(repeat > 2){\\n            replace += (repeat / 3);\\n\\n            if(repeat % 3 == 0){\\n                one += 1;\\n            } else if(repeat % 3 == 1){\\n                two += 2;\\n            }\\n        }\\n    }\\n    \\n    if(length < 6){\\n        if(cap + low + dig > 6 - length){\\n            return cap + low + dig;\\n        } else {\\n            return 6 - length;\\n        }\\n    } else if(length <= 20){\\n        if(cap + low + dig > replace){\\n            return cap + low + dig;\\n        } else {\\n            return replace;\\n        }\\n    } else {\\n        int over = length - 20;\\n        \\n        if(one < over){\\n            replace -= one;\\n        } else {\\n            replace -= over;\\n        }\\n        \\n        if(over - one > 0){\\n            if(two < (over - one)){\\n                replace -= two / 2;\\n            } else {\\n                replace -= (over - one) / 2;\\n            }\\n        }\\n        \\n        if((over - one - two) > 0){\\n            replace -= (over - one - two) / 3;\\n        }\\n        \\n        if(cap + low + dig > replace){\\n            return over + cap + low + dig;\\n        } else {\\n            return over + replace;\\n        }\\n    }\\n}\\n```\n```C# []\\nclass Solution {\\n    public int StrongPasswordChecker(string s) {\\n        int charSum = GetRequiredChar(s);\\n        if (s.Length < 6) return Math.Max(charSum, 6 - s.Length);\\n            int replace = 0, ones = 0, twos = 0; \\n            for (int i = 0; i < s.Length;) {\\n            int len = 1;\\n                while (i + len < s.Length && s[i + len] == s[i + len - 1]) len++;\\n                if (len >= 3) {\\n                    replace += len / 3;\\n                    if (len % 3 == 0) ones += 1;\\n                    if (len % 3 == 1) twos += 2;\\n                }\\n                i += len;\\n            }\\n            if (s.Length <= 20) return Math.Max(charSum, replace);\\n            int deleteCount = s.Length - 20;\\n            replace -= Math.Min(deleteCount, ones);\\n            replace -= Math.Min(Math.Max(deleteCount - ones, 0), twos) / 2;\\n            replace -= Math.Max(deleteCount - ones - twos, 0) / 3;\\n        return deleteCount + Math.Max(charSum, replace);\\n        }\\n        int GetRequiredChar(string s) {\\n            int lowerCase = 1, upperCase = 1, digit = 1;\\n            foreach (var c in s) {\\n                if (char.IsLower(c)) lowerCase = 0;\\n                else if (char.IsUpper(c)) upperCase = 0;\\n                else if (char.IsDigit(c)) digit = 0;\\n            }\\n            return lowerCase + upperCase + digit;\\n    }    \\n}\\n```\n```PHP []\\nclass Solution {\\n\\n    /**\\n     * @param String $password\\n     * @return Integer\\n     */\\n    function strongPasswordChecker($password) {\\n        $passwordCharList = str_split($password);\\n    \\n        $missingType = 3;\\n        $numberList = range(48, 57);\\n        $charListCapital = range(65, 90); \\n        $charListLowercase = range(97, 122);\\n\\n        $numberFlag = false;\\n        $capitalFlag = false;\\n        $lowercaseFlag = false;\\n\\n        foreach ($passwordCharList as $key => $value){\\n            if (!$numberFlag && in_array(ord($value), $numberList)) { \\n                $numberFlag = true;\\n            } else if (!$capitalFlag && in_array(ord($value), $charListCapital)) {\\n                $capitalFlag = true;\\n            } else if (!$lowercaseFlag && in_array(ord($value), $charListLowercase)) {\\n                $lowercaseFlag = true;\\n            }\\n        }\\n        \\n        $numberFlag && $missingType--;\\n        $capitalFlag && $missingType--;\\n        $lowercaseFlag && $missingType--;\\n        \\n        $change = 0;\\n        $first = 0;\\n        $second = 0;\\n        $charKey = 2;\\n\\n        while ($charKey < strlen($password)){\\n            if ($passwordCharList[$charKey] === $passwordCharList[$charKey-1] \\n                && $passwordCharList[$charKey] === $passwordCharList[$charKey-2]) {\\n                $countOfRepeat = 2;\\n\\n                while ($charKey<strlen($password) \\n                    && $passwordCharList[$charKey] === $passwordCharList[$charKey-1]) {\\n                    $countOfRepeat++;\\n                    $charKey++;\\n                }\\n                \\n                $change += floor($countOfRepeat/3);\\n                \\n                $countOfRepeat % 3 === 0 && $first += 1;\\n                $countOfRepeat % 3 === 1 && $second += 2;     \\n\\n                continue;\\n            }\\n            \\n            $charKey++;\\n        }\\n        \\n    \\n        if (strlen($password) < 6) {\\n            return max($missingType, 6-strlen($password));\\n        } else if (strlen($password) >= 6 && strlen($password) <= 20) {\\n            return max($missingType, $change);\\n        }\\n\\n        $removeKey = strlen($password) - 20;\\n            \\n        $change -= min($removeKey, $first);\\n        $change -= floor(min(max($removeKey - $first, 0), $second) / 2);\\n        $change -= floor(max($removeKey - $first - $second, 0) / 3);\\n            \\n        return $removeKey + max($missingType, $change);\\n    }\\n}\\n```\n```Kotlin []\\nclass Solution {\\n\\n    fun strongPasswordChecker(password: String): Int {\\n        var operations = 0\\n        var lower = 0\\n        var upper = 0\\n        var digits = 0\\n\\n        val repeating = IntArray(password.length)\\n\\n        var currentCheckIndex = 0\\n        while (currentCheckIndex < password.length) {\\n            val targetCheckIndex = currentCheckIndex // For later repeating check use\\n            val targetChar = password[currentCheckIndex]\\n\\n            while (currentCheckIndex < password.length && password[currentCheckIndex] == targetChar) {\\n                repeating[targetCheckIndex]++\\n                currentCheckIndex++\\n            }\\n        }\\n        println(\"Repeating: ${repeating.joinToString(\", \")}\")\\n        for (targetChar in password) {\\n            if (targetChar.isUpperCase()) upper+= 1\\n            if (targetChar.isLowerCase()) lower+= 1\\n            if (targetChar.isDigit()) digits += 1\\n        }\\n        val charTypeRequirementMetCount = lower.coerceAtMost(1) + upper.coerceAtMost(1) + digits.coerceAtMost(1)\\n        val missingRequirements = 3 - charTypeRequirementMetCount\\n\\n        if (password.length <= 3) { // If length is less than 3, it will be able to fix the missing requirements no matter what\\n            return 6 - password.length\\n        } else if (password.length < 6) { // If the length is 4, 5, or 6, it will be maximum value of insertion count and missing requirements count\\n            // We don\\'t need to worry about repeating chars since we can easily fix it by inserting char in a different location\\n            val insertionCount = 6 - password.length\\n            return maxOf(insertionCount, missingRequirements)\\n        } else {\\n            println(\"Lowercase: $lower\")\\n            println(\"Uppercase: $upper\")\\n            println(\"Digits: $digits\")\\n\\n            var extraLength = password.length - 20\\n\\n            if (extraLength > 0) {\\n                findMinimizedSumOfDivision(extraLength, repeating)\\n                operations += extraLength\\n            }\\n\\n            println(\"After operation: \" + repeating.joinToString(\", \"))\\n\\n            // After reducing the length, we want to now replace all the repeating stuff.\\n            // Replaced \"random char amount\" will be stored inside a variable (For later use)\\n            var modifiedCharAmount = 0\\n            for ((index, i) in repeating.withIndex()) {\\n                if (i >= 3) {\\n                    operations += i / 3\\n                    modifiedCharAmount += i / 3\\n                    println(\"Modified ${i / 3} char(s) to eliminate repeating chars\")\\n                }\\n            }\\n\\n            // At this point, \"repeating\" is trashed as it\\'s in-accurate, and we don\\'t need it in our last bit of code\\n\\n            // Now we use the \"random char amount\" to decide if we have to do extra patch for char type requirements\\n            // If we don\\'t need those (AKA we added enough random chars that will just fit those requirements), we ignore them\\n            // Otherwise, we add (requirements - random char amount) to operations count\\n\\n            println(\"We are missing $missingRequirements requirements ($operations)\")\\n            if (modifiedCharAmount < missingRequirements) {\\n                operations += (missingRequirements - modifiedCharAmount)\\n            }\\n\\n        }\\n\\n        return operations\\n    }\\n\\n\\n    //   63927897\\n    // - 11100010\\n    //   52827887\\n    // - 00002002\\n    //   52825885\\n    // - 30303333\\n    // - 22522552\\n    // - 00300330\\n\\n    fun findMinimizedSumOfDivision(operationsLimitation: Int, nums: IntArray) {\\n        var operationsLeft = operationsLimitation\\n        var currentSubValue = 1\\n        var doneOperation: Boolean\\n        while (operationsLeft > 0) {\\n            doneOperation = false\\n            for ((i, num) in nums.withIndex()) {\\n                if (num >= 3) {\\n                   if (num % 3 == currentSubValue - 1) {\\n                        doneOperation = true\\n                        var sub = currentSubValue\\n                        while (operationsLeft > 0 && sub > 0) {\\n                            operationsLeft--\\n                            nums[i] -= 1\\n                            sub--\\n                        }\\n                    }\\n                }\\n                if (operationsLeft == 0) return\\n            }\\n            if (currentSubValue == 3 && !doneOperation) break\\n            if (currentSubValue != 3) currentSubValue++\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828587,
                "title": "strengthening-passwords-string-manipulation-and-condition-checking",
                "content": "# Intuition\\nThis problem involves string manipulation and checks for specific conditions. The first approach that comes to mind is to traverse the string while keeping track of the conditions that are already satisfied and the ones that aren\\'t. The conditions to check are:\\n\\nLength of the password between 6 and 20 characters.\\nAt least one lowercase letter, one uppercase letter, and one digit.\\nNo three repeating characters in a row.\\nTo keep track of these conditions, I\\'d use counters or flags. For example, I\\'d count the number of each type of character (lowercase, uppercase, digit) and the length of repeating sequences.\\n\\nIf the length of the password is less than 6, I\\'d add the missing number of characters considering the types of characters that are still missing.\\n\\nIf the length of the password is more than 20, I\\'d delete the excess characters. Here, I\\'d prioritize deleting characters from the middle of repeating sequences of three or more characters.\\n\\nIf the length of the password is between 6 and 20, I\\'d replace characters in the middle of repeating sequences of three or more characters considering the types of characters that are still missing.\\n\\n# Approach\\n1. Initialize a list to store the length of each repeating sequence in the password.\\n1. Traverse the password to count the repeating sequences and the types of characters.\\n1. If the length of the password is less than 6, return the maximum of the number of missing types of characters and 6 minus the length.\\n1. If the length of the password is between 6 and 20, return the maximum of the number of missing types of characters and the total number of characters that should be changed in the repeating sequences.\\n1. If the length of the password is more than 20, perform deletions from the repeating sequences first to reduce the length to 20. Here we prioritize reducing the sequences whose lengths mod 3 equals 0, then 1, then 2. For each sequence, reduce it until its length is less than 3 or its length mod 3 is not equal to the current priority. Then, return 20 minus the original length plus the maximum of the number of missing types of characters and the total number of characters that should be changed in the repeating sequences. \\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is `O(n)`, where n is the length of the password. This is because we\\'re traversing the password once.\\n\\n- Space complexity:\\nThe space complexity is `O(1)`, i.e., constant. We\\'re using a fixed amount of space to store the counters and flags, which doesn\\'t change with the size of the input string.\\n\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_types = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_types -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_types -= 1\\n        if any(c.isdigit() for c in s): missing_types -= 1\\n\\n        replace = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n\\n                replace += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_types, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_types, replace)\\n        else:\\n            delete = len(s) - 20\\n\\n            replace -= min(delete, one * 1)//1\\n            replace -= min(max(delete - one * 1, 0), two * 2) // 2\\n            replace -= max(delete - one * 1 - two * 2, 0) // 3\\n\\n            return delete + max(missing_types, replace)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_types = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s): missing_types -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s): missing_types -= 1\\n        if any(c.isdigit() for c in s): missing_types -= 1\\n\\n        replace = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n\\n                replace += length // 3\\n                if length % 3 == 0: one += 1\\n                elif length % 3 == 1: two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_types, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_types, replace)\\n        else:\\n            delete = len(s) - 20\\n\\n            replace -= min(delete, one * 1)//1\\n            replace -= min(max(delete - one * 1, 0), two * 2) // 2\\n            replace -= max(delete - one * 1 - two * 2, 0) // 3\\n\\n            return delete + max(missing_types, replace)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827157,
                "title": "420-strong-password-checker-runtime-40ms-beats-88-06-memory-16-21mb-beats-89-05",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the minimum number of steps required to make a given password strong based on specific conditions. We need to check the length of the password, whether it contains the required character types (lowercase letter, uppercase letter, and digit), and if it has repeating sequences of characters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve the problem, we can follow these steps:\\n\\n1. Initialize missing_types to 3, representing the missing required character types (lowercase, uppercase, and digit).\\n2. Check each character in the password and update the missing_types accordingly. If a character of a required type is found, decrease missing_types by 1 for that type.\\n3. Iterate through the password to find repeating sequences of characters. While doing so, count the number of steps needed to break each repeating sequence.\\n4. Based on the password length and conditions found in steps 1 and 3, calculate the minimum number of steps required to make the password strong.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(n), where n is the length of the password. We go through the password once to find missing character types and repeating sequences. The other operations, such as checking for character types and breaking repeating sequences, are constant time operations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) as we are using a constant amount of extra space for variables like missing_types, change_count, one_repeat, two_repeat, etc. The function does not use any additional data structures that depend on the size of the input.\\n\\nOverall, the provided function is an efficient and optimal solution to finding the minimum steps required to make the password strong based on the given conditions. It meets the required time and space complexity constraints for the input size.\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        missing_types = 3\\n\\n        if any(\\'a\\' <= char <= \\'z\\' for char in password):\\n            missing_types -= 1\\n        if any(\\'A\\' <= char <= \\'Z\\' for char in password):\\n            missing_types -= 1\\n        if any(char.isdigit() for char in password):\\n            missing_types -= 1\\n\\n        change_count = 0\\n        one_repeat, two_repeat = 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i - 1] == password[i - 2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i - 1]:\\n                    length += 1\\n                    i += 1\\n\\n                change_count += length // 3\\n                if length % 3 == 0:\\n                    one_repeat += 1\\n                elif length % 3 == 1:\\n                    two_repeat += 1\\n\\n            else:\\n                i += 1\\n\\n        if len(password) < 6:\\n            return max(missing_types, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(missing_types, change_count)\\n        else:\\n            delete_count = len(password) - 20\\n\\n            change_count -= min(delete_count, one_repeat * 1) // 1\\n            change_count -= min(max(delete_count - one_repeat, 0), two_repeat * 2) // 2\\n            change_count -= min(max(delete_count - one_repeat - 2 * two_repeat, 0), change_count * 3) // 3\\n\\n            return delete_count + max(missing_types, change_count)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        missing_types = 3\\n\\n        if any(\\'a\\' <= char <= \\'z\\' for char in password):\\n            missing_types -= 1\\n        if any(\\'A\\' <= char <= \\'Z\\' for char in password):\\n            missing_types -= 1\\n        if any(char.isdigit() for char in password):\\n            missing_types -= 1\\n\\n        change_count = 0\\n        one_repeat, two_repeat = 0, 0\\n        i = 2\\n        while i < len(password):\\n            if password[i] == password[i - 1] == password[i - 2]:\\n                length = 2\\n                while i < len(password) and password[i] == password[i - 1]:\\n                    length += 1\\n                    i += 1\\n\\n                change_count += length // 3\\n                if length % 3 == 0:\\n                    one_repeat += 1\\n                elif length % 3 == 1:\\n                    two_repeat += 1\\n\\n            else:\\n                i += 1\\n\\n        if len(password) < 6:\\n            return max(missing_types, 6 - len(password))\\n        elif len(password) <= 20:\\n            return max(missing_types, change_count)\\n        else:\\n            delete_count = len(password) - 20\\n\\n            change_count -= min(delete_count, one_repeat * 1) // 1\\n            change_count -= min(max(delete_count - one_repeat, 0), two_repeat * 2) // 2\\n            change_count -= min(max(delete_count - one_repeat - 2 * two_repeat, 0), change_count * 3) // 3\\n\\n            return delete_count + max(missing_types, change_count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808099,
                "title": "easy",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p - 1] == s[p - 2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p - 1]:\\n                    length += 1\\n                    p += 1\\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one * 1) // 1\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n            return delete + max(missing_type, change)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n\\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p - 1] == s[p - 2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p - 1]:\\n                    length += 1\\n                    p += 1\\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n\\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one * 1) // 1\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n            return delete + max(missing_type, change)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795867,
                "title": "breaking-down-the-problem-into-simpler-problems-understandable-modular-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is kind of many if else conditions. This requires breaking down the problem into simpler ones and then solve them.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* First check the length\\n* Then, find the upper, lower, digit boolean values if they are present in the password. Also, prepare the list of repetitions.\\n* Now, for each case, there is a method for the same.\\n* Hope you understand by looking at the code.\\n\\n# Code\\n```\\n\\ntemplate <typename T>\\nclass Compare {\\npublic:\\n    bool operator()(T below, T above){\\n        int brem = below%3;\\n        int arem = above%3;\\n        if (arem < brem) return true;\\n        if (arem == brem) return (above < below);\\n        else return false;\\n    }\\n    \\n};\\n\\nclass Solution {\\n\\n    int solveBetweenCase(int s, vector<int> repetitions){\\n        int toChange = 0;\\n        for(auto k: repetitions) toChange += k/3;\\n        return max(toChange,s);\\n    }\\n    \\n    int solveLessCase(int i, int s, vector<int> repetitions){\\n        int toChange = 0;\\n        for(auto k: repetitions) toChange += (k+1)/3;\\n        return max(toChange, max(s,i));\\n    }\\n    \\n    int solveMoreCase(int d, int s, vector<int> repetitions ){\\n        priority_queue<int,vector<int>,Compare<int>> pque(repetitions.begin(),repetitions.end());\\n        int toChange = d;\\n        while(pque.size()){\\n            if (d == 0) break;\\n            int bf = pque.top();\\n            pque.pop();\\n            bf--;\\n            d--;\\n            if (bf != 2) pque.push(bf);\\n        }\\n        vector<int> revised;\\n        while(pque.size()){\\n            revised.push_back(pque.top());\\n            pque.pop();\\n        }\\n        return max(toChange,d) + solveBetweenCase(s,revised);\\n\\n    }\\n    \\n    pair<int,vector<int>> solve(string password){\\n        int length = password.length();\\n        int upper = 0;\\n        int lower = 0;\\n        int digit = 0;\\n        vector<int> repetitions;\\n        int len = 0;\\n        string bf = \"\";\\n        for(int i =0;i<length;i++){\\n            if (password[i] >= \\'a\\' && password[i] <= \\'z\\') lower = 1;\\n            else if (password[i] >= \\'A\\' && password[i] <= \\'Z\\') upper = 1;\\n            else if (password[i] >= \\'0\\' && password[i] <= \\'9\\' ) digit = 1;\\n            if (len == 0) {\\n                len = 1;\\n                bf = \"\";\\n                bf += password[i];\\n            }\\n            else{\\n                if (bf[0] == password[i]){\\n                    len++;\\n                    bf+=password[i];\\n                }\\n                else{\\n                    if (len >= 3) repetitions.push_back(len);\\n                    len = 1;\\n                    bf = \"\";\\n                    bf += password[i];\\n                }\\n            }\\n        }\\n        if (len >= 3) repetitions.push_back(len);\\n        \\n        return {3-(upper+lower+digit),repetitions};\\n        \\n    }\\n    \\npublic:\\n    int strongPasswordChecker(string password) {\\n        int length = password.length();\\n        if (length < 6){\\n            int insertions = 6-length;\\n            auto n = solve(password);\\n            return solveLessCase(insertions,n.first,n.second);\\n            \\n        }\\n        else if (length > 20){\\n            int deletions = length-20;\\n            auto n = solve(password);\\n            return solveMoreCase(deletions,n.first,n.second);\\n        }\\n        else{\\n            auto n = solve(password);\\n            return solveBetweenCase(n.first,n.second);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntemplate <typename T>\\nclass Compare {\\npublic:\\n    bool operator()(T below, T above){\\n        int brem = below%3;\\n        int arem = above%3;\\n        if (arem < brem) return true;\\n        if (arem == brem) return (above < below);\\n        else return false;\\n    }\\n    \\n};\\n\\nclass Solution {\\n\\n    int solveBetweenCase(int s, vector<int> repetitions){\\n        int toChange = 0;\\n        for(auto k: repetitions) toChange += k/3;\\n        return max(toChange,s);\\n    }\\n    \\n    int solveLessCase(int i, int s, vector<int> repetitions){\\n        int toChange = 0;\\n        for(auto k: repetitions) toChange += (k+1)/3;\\n        return max(toChange, max(s,i));\\n    }\\n    \\n    int solveMoreCase(int d, int s, vector<int> repetitions ){\\n        priority_queue<int,vector<int>,Compare<int>> pque(repetitions.begin(),repetitions.end());\\n        int toChange = d;\\n        while(pque.size()){\\n            if (d == 0) break;\\n            int bf = pque.top();\\n            pque.pop();\\n            bf--;\\n            d--;\\n            if (bf != 2) pque.push(bf);\\n        }\\n        vector<int> revised;\\n        while(pque.size()){\\n            revised.push_back(pque.top());\\n            pque.pop();\\n        }\\n        return max(toChange,d) + solveBetweenCase(s,revised);\\n\\n    }\\n    \\n    pair<int,vector<int>> solve(string password){\\n        int length = password.length();\\n        int upper = 0;\\n        int lower = 0;\\n        int digit = 0;\\n        vector<int> repetitions;\\n        int len = 0;\\n        string bf = \"\";\\n        for(int i =0;i<length;i++){\\n            if (password[i] >= \\'a\\' && password[i] <= \\'z\\') lower = 1;\\n            else if (password[i] >= \\'A\\' && password[i] <= \\'Z\\') upper = 1;\\n            else if (password[i] >= \\'0\\' && password[i] <= \\'9\\' ) digit = 1;\\n            if (len == 0) {\\n                len = 1;\\n                bf = \"\";\\n                bf += password[i];\\n            }\\n            else{\\n                if (bf[0] == password[i]){\\n                    len++;\\n                    bf+=password[i];\\n                }\\n                else{\\n                    if (len >= 3) repetitions.push_back(len);\\n                    len = 1;\\n                    bf = \"\";\\n                    bf += password[i];\\n                }\\n            }\\n        }\\n        if (len >= 3) repetitions.push_back(len);\\n        \\n        return {3-(upper+lower+digit),repetitions};\\n        \\n    }\\n    \\npublic:\\n    int strongPasswordChecker(string password) {\\n        int length = password.length();\\n        if (length < 6){\\n            int insertions = 6-length;\\n            auto n = solve(password);\\n            return solveLessCase(insertions,n.first,n.second);\\n            \\n        }\\n        else if (length > 20){\\n            int deletions = length-20;\\n            auto n = solve(password);\\n            return solveMoreCase(deletions,n.first,n.second);\\n        }\\n        else{\\n            auto n = solve(password);\\n            return solveBetweenCase(n.first,n.second);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789915,
                "title": "understandable-javascript-solution-quite-short-and-simple-62ms-42mb",
                "content": "# Intuition\\nThis is may not the most efficient way to solve this function, but it is in the middle of the race with (62ms and 41.9MB), but beside that may the most understandable and quite short.\\nI used some simple regex for validation and check them to gather some data and count the needed changes step by step.\\nThe order of validations is important in this case.\\nIn the length fixer part the reapeted chars finder needs some refactoring, currently works only with max 2 repeated chars allowed, may later I will update this solution.\\n\\n# Approach\\n1. Set up regex validations\\n2. Check regexes on password\\n3. Solve step by step and count:\\n    - Length: Only with delete.\\n        With delete you can solve a repeated char problem, you can spare some steps if try to delete from the longest repeated group with lowest reminder.\\n    - Repeats prepare: Split up repeated chars to max repeats + 1 long groups so if you change or add a char one of these groups it solve the problem.\\n    - Needed char: If something is missing, costs 1 step to add, but this also can solve a repeated group and in the same time if the password was short.\\n    - Too short: Costs 1 step to add a new char and this also solve a repeat group.\\n    - Repeats solve: The remained repeated groups can be solved by 1 step.\\n4. Return needed steps count\\n\\n# Code\\n```\\n/**\\n * @param {string} password\\n * @return {number}\\n */\\nvar strongPasswordChecker = function(password, MIN_LEN = 6, MAX_LEN = 20, MAX_REPEAT = 2) {\\n    if(password)\\n    {\\n        let steps = 0;\\n        validations = {\\n            \\'least\\': new RegExp(`^(.){${MIN_LEN},}$`),\\n            \\'most\\': new RegExp(`^(.){0,${MAX_LEN}}$`),\\n            \\'norepeat\\': new RegExp(`^(?!.*(.)\\\\\\\\1{${MAX_REPEAT},}).+$`),\\n            \\'lowerCase\\': new RegExp(\"[a-z]\"),\\n            \\'upperCase\\': new RegExp(\"[A-Z]\"),\\n            \\'digit\\': new RegExp(\"[0-9]\")\\n        }\\n        \\n        let repeatedCharsParts = [];\\n        let shorter = 0;\\n        let longer = 0;\\n        let neededChar = 0;\\n        let reapeatGroups = 0;\\n\\n        /* Check validations */\\n        Object.entries(validations).map(([key, regex]) => {\\n            if(!regex.test(password)) {\\n                switch(key)\\n                {\\n                    case \\'least\\': shorter += (MIN_LEN - password.length); break;\\n                    case \\'most\\':  longer += (password.length - MAX_LEN); break;\\n                    case \\'norepeat\\': {\\n                        let valid_rule = new RegExp(`(.)\\\\\\\\1{${MAX_REPEAT},}`, \"g\");\\n                        repeatedCharsParts = password.match(valid_rule);\\n                        break;\\n                    }\\n                    case \\'lowerCase\\':\\n                    case \\'upperCase\\':\\n                    case \\'digit\\':\\n                        neededChar++; break;\\n                }\\n            }\\n        });\\n\\n        /* Solve with steps */\\n        while(longer)\\n        {\\n            longer--;\\n            /* Always try to delete from the longest repeated group with lowest reminder */\\n            if(repeatedCharsParts && repeatedCharsParts.length) {\\n                partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1) === 0);\\n                if(partIndex === -1) partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1) === 1);\\n                if(partIndex === -1) partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1));\\n                if(repeatedCharsParts[partIndex])\\n                    repeatedCharsParts[partIndex] = repeatedCharsParts[partIndex].slice(1);\\n                repeatedCharsParts = repeatedCharsParts.filter(x => x.length).sort((a,b) => b.length - a.length);\\n            }\\n            steps++;\\n        }\\n        if(repeatedCharsParts)\\n        {\\n            /* Every group can be OK with one char change */\\n            repeatedCharsParts.map(invalid_part => {\\n                reapeatGroups += Math.floor(invalid_part.length/3);\\n            });\\n        }\\n        while(neededChar)\\n        {\\n            if(reapeatGroups) reapeatGroups--;\\n            if(shorter) shorter--;\\n            steps++;\\n            neededChar--;\\n        }\\n        while(shorter)\\n        {\\n            if(reapeatGroups) reapeatGroups--;\\n            steps++;\\n            shorter--;\\n        }\\n        steps += reapeatGroups;\\n        \\n        return steps;\\n    }\\n\\n    return false;\\n};\\n```\\n\\n**Thank you if you comment some of your toughts or if you liked this solution give me an upvote. :)**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} password\\n * @return {number}\\n */\\nvar strongPasswordChecker = function(password, MIN_LEN = 6, MAX_LEN = 20, MAX_REPEAT = 2) {\\n    if(password)\\n    {\\n        let steps = 0;\\n        validations = {\\n            \\'least\\': new RegExp(`^(.){${MIN_LEN},}$`),\\n            \\'most\\': new RegExp(`^(.){0,${MAX_LEN}}$`),\\n            \\'norepeat\\': new RegExp(`^(?!.*(.)\\\\\\\\1{${MAX_REPEAT},}).+$`),\\n            \\'lowerCase\\': new RegExp(\"[a-z]\"),\\n            \\'upperCase\\': new RegExp(\"[A-Z]\"),\\n            \\'digit\\': new RegExp(\"[0-9]\")\\n        }\\n        \\n        let repeatedCharsParts = [];\\n        let shorter = 0;\\n        let longer = 0;\\n        let neededChar = 0;\\n        let reapeatGroups = 0;\\n\\n        /* Check validations */\\n        Object.entries(validations).map(([key, regex]) => {\\n            if(!regex.test(password)) {\\n                switch(key)\\n                {\\n                    case \\'least\\': shorter += (MIN_LEN - password.length); break;\\n                    case \\'most\\':  longer += (password.length - MAX_LEN); break;\\n                    case \\'norepeat\\': {\\n                        let valid_rule = new RegExp(`(.)\\\\\\\\1{${MAX_REPEAT},}`, \"g\");\\n                        repeatedCharsParts = password.match(valid_rule);\\n                        break;\\n                    }\\n                    case \\'lowerCase\\':\\n                    case \\'upperCase\\':\\n                    case \\'digit\\':\\n                        neededChar++; break;\\n                }\\n            }\\n        });\\n\\n        /* Solve with steps */\\n        while(longer)\\n        {\\n            longer--;\\n            /* Always try to delete from the longest repeated group with lowest reminder */\\n            if(repeatedCharsParts && repeatedCharsParts.length) {\\n                partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1) === 0);\\n                if(partIndex === -1) partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1) === 1);\\n                if(partIndex === -1) partIndex = repeatedCharsParts.findIndex(part => part.length % (MAX_REPEAT+1));\\n                if(repeatedCharsParts[partIndex])\\n                    repeatedCharsParts[partIndex] = repeatedCharsParts[partIndex].slice(1);\\n                repeatedCharsParts = repeatedCharsParts.filter(x => x.length).sort((a,b) => b.length - a.length);\\n            }\\n            steps++;\\n        }\\n        if(repeatedCharsParts)\\n        {\\n            /* Every group can be OK with one char change */\\n            repeatedCharsParts.map(invalid_part => {\\n                reapeatGroups += Math.floor(invalid_part.length/3);\\n            });\\n        }\\n        while(neededChar)\\n        {\\n            if(reapeatGroups) reapeatGroups--;\\n            if(shorter) shorter--;\\n            steps++;\\n            neededChar--;\\n        }\\n        while(shorter)\\n        {\\n            if(reapeatGroups) reapeatGroups--;\\n            steps++;\\n            shorter--;\\n        }\\n        steps += reapeatGroups;\\n        \\n        return steps;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3776583,
                "title": "simple-solution",
                "content": "# Intuition\\nif a substring is repeat more than 2 times, we can always replace it the repeated frequence / 3.\\nIf the length is longer than 20, we should delete the frequency by the following order:\\n\\n- if repeated frequence % 3 == 0\\n- if repeated frequence % 3 == 1\\n- if repeated frequence % 3 == 2\\n\\nWhen we replace the character, we can replace it the character type we miss firstly. If we don\\'t replace any character, we just replace (insert) them (insert only when length less than 6).\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n=password.size();\\n        std::vector<int> p(4);\\n        std::vector<int> cnts={1};\\n        for(auto i=0;i<n;++i)\\n        {\\n            if(std::isdigit(password[i]))\\n                p[0]=1;\\n            else if(std::islower(password[i]))\\n                p[1]=1;\\n            else if(std::isupper(password[i]))\\n                p[2]=1;\\n            else\\n                p[3]=1;\\n        }\\n        for(auto i=1;i<n;++i)\\n        {\\n            if(password[i]==password[i-1])\\n                ++cnts.back();\\n            else\\n            {\\n                if(cnts.back()<3)\\n                    cnts.pop_back();\\n                cnts.push_back(1);\\n            }\\n        }\\n        if(cnts.back()<3)\\n            cnts.pop_back();\\n        auto f=[](std::vector<int>& c){\\n            int res(0);\\n            for(auto a:c)res+=a/3;\\n            return res;\\n        };\\n\\n        int tmp(3);\\n        for(auto i=0;i<3;++i)tmp-=p[i];\\n        if(n<=5)\\n        {\\n            return std::max(6-n,tmp);\\n        }\\n        if(n<=20)\\n        {\\n            return std::max(f(cnts),tmp);\\n        }\\n\\n        int z=n-20;\\n        int res=0;\\n        while(z)\\n        {\\n            bool t=true;\\n            for(auto& x:cnts)if(x>2&&x%3==0){--x;++res;--z;t=false;break;}\\n            if(t)\\n                for(auto& x:cnts)if(x>2&&x%3==1){--x;++res;--z;t=false;break;}\\n            if(t)\\n                for(auto& x:cnts)if(x>2&&x%3==2){--x;++res;--z;t=false;break;}\\n            if(t)break;\\n        }\\n        return res+std::max(f(cnts),tmp)+z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strongPasswordChecker(string password) {\\n        int n=password.size();\\n        std::vector<int> p(4);\\n        std::vector<int> cnts={1};\\n        for(auto i=0;i<n;++i)\\n        {\\n            if(std::isdigit(password[i]))\\n                p[0]=1;\\n            else if(std::islower(password[i]))\\n                p[1]=1;\\n            else if(std::isupper(password[i]))\\n                p[2]=1;\\n            else\\n                p[3]=1;\\n        }\\n        for(auto i=1;i<n;++i)\\n        {\\n            if(password[i]==password[i-1])\\n                ++cnts.back();\\n            else\\n            {\\n                if(cnts.back()<3)\\n                    cnts.pop_back();\\n                cnts.push_back(1);\\n            }\\n        }\\n        if(cnts.back()<3)\\n            cnts.pop_back();\\n        auto f=[](std::vector<int>& c){\\n            int res(0);\\n            for(auto a:c)res+=a/3;\\n            return res;\\n        };\\n\\n        int tmp(3);\\n        for(auto i=0;i<3;++i)tmp-=p[i];\\n        if(n<=5)\\n        {\\n            return std::max(6-n,tmp);\\n        }\\n        if(n<=20)\\n        {\\n            return std::max(f(cnts),tmp);\\n        }\\n\\n        int z=n-20;\\n        int res=0;\\n        while(z)\\n        {\\n            bool t=true;\\n            for(auto& x:cnts)if(x>2&&x%3==0){--x;++res;--z;t=false;break;}\\n            if(t)\\n                for(auto& x:cnts)if(x>2&&x%3==1){--x;++res;--z;t=false;break;}\\n            if(t)\\n                for(auto& x:cnts)if(x>2&&x%3==2){--x;++res;--z;t=false;break;}\\n            if(t)break;\\n        }\\n        return res+std::max(f(cnts),tmp)+z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734118,
                "title": "strengthening-passwords-unlocking-security-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe task is to determine the minimum number of steps required to make a given password strong. A password is considered strong if it satisfies the following requirements:\\n- It has at least 6 characters.\\n- It has at least one lowercase letter, one uppercase letter, and one digit.\\n- It does not contain more than three consecutive repeating characters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first creates sets of lowercase, uppercase, and digit characters using the `ascii_lowercase`, `ascii_uppercase`, and `digits` constants from the `string` module.\\n\\nIt then determines the missing types of characters in the password by checking if the sets of characters intersect with the characters present in the password. The missing type count is calculated by subtracting the boolean results of the intersection checks from 3.\\n\\nNext, it calculates the number of required inserts and deletes to make the password a minimum of 6 characters long and a maximum of 20 characters long.\\n\\nThe code then creates a list of group lengths for consecutive repeating characters in the password using `itertools.groupby` function. \\n\\nTo minimize the number of actions to satisfy the repeating character constraint, the code greedily performs the best deletion by choosing the group with the minimal impact on the overall repetition pattern.\\n\\nFinally, it calculates the number of required group replacements by dividing each group length by 3 and taking the sum.\\n\\nThe return statement adds up the required deletions, the maximum number of required type replacements, group replacements, and inserts to determine the minimum steps needed to make the password strong.\\n\\n# Complexity\\n- Time complexity:  The code iterates through the password once to perform various checks and modifications. Also, `itertools.groupby` function also takes linear time. Therefore, the overall time complexity is O(n), where n is the length of the password.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The code uses sets and lists to store characters and group lengths, respectively. The space complexity is O(1) since the size of these sets and lists is fixed based on the nature of characters and the password, not the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport string\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        lowercase = set(string.ascii_lowercase)\\n        uppercase = set(string.ascii_uppercase)\\n        digit = set(string.digits)\\n        \\n        characters = set(password)\\n        \\n        missing_type = 3 - (bool(characters & lowercase) + bool(characters & uppercase) + bool(characters & digit))\\n        num_required_type_replaces = int(missing_type)\\n        \\n        num_required_inserts = max(0, 6 - len(password))\\n        num_required_deletes = max(0, len(password) - 20)\\n        \\n        groups = [len(list(grp)) for _, grp in itertools.groupby(password)]\\n        \\n        def apply_best_delete():\\n            argmin, _ = min(\\n                enumerate(groups),\\n                key=lambda it: it[1] % 3 if it[1] >= 3 else 10 - it[1],\\n            )\\n            groups[argmin] -= 1\\n        \\n        for _ in range(num_required_deletes):\\n            apply_best_delete()\\n        \\n        num_required_group_replaces = sum(group // 3 for group in groups)\\n        \\n        return (\\n            num_required_deletes +\\n            max(num_required_type_replaces, num_required_group_replaces, num_required_inserts)\\n        )\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport string\\n\\nclass Solution:\\n    def strongPasswordChecker(self, password: str) -> int:\\n        lowercase = set(string.ascii_lowercase)\\n        uppercase = set(string.ascii_uppercase)\\n        digit = set(string.digits)\\n        \\n        characters = set(password)\\n        \\n        missing_type = 3 - (bool(characters & lowercase) + bool(characters & uppercase) + bool(characters & digit))\\n        num_required_type_replaces = int(missing_type)\\n        \\n        num_required_inserts = max(0, 6 - len(password))\\n        num_required_deletes = max(0, len(password) - 20)\\n        \\n        groups = [len(list(grp)) for _, grp in itertools.groupby(password)]\\n        \\n        def apply_best_delete():\\n            argmin, _ = min(\\n                enumerate(groups),\\n                key=lambda it: it[1] % 3 if it[1] >= 3 else 10 - it[1],\\n            )\\n            groups[argmin] -= 1\\n        \\n        for _ in range(num_required_deletes):\\n            apply_best_delete()\\n        \\n        num_required_group_replaces = sum(group // 3 for group in groups)\\n        \\n        return (\\n            num_required_deletes +\\n            max(num_required_type_replaces, num_required_group_replaces, num_required_inserts)\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731759,
                "title": "best-solution-in-java",
                "content": "# Intuition\\n    Give me Thumbs upppppppppppppp\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int[] ok = new int[]{1, 1, 1};\\n        char[] A = password.toCharArray();\\n        for (char ch : A){ \\n            ok[0] &= Character.isLowerCase(ch)? 0 : 1;\\n            ok[1] &= Character.isUpperCase(ch)? 0 : 1;\\n            ok[2] &= Character.isDigit(ch)? 0 : 1;\\n        }\\n        int ans = 0, len = password.length(), cond = ok[0]+ok[1]+ok[2]; \\n        var minheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> o%3)); \\n        for (int i = 0, cnt = 1; i < len; i++, cnt++){ \\n            if (i == len-1 || A[i] != A[i+1]){\\n                if (cnt >= 3){\\n                    minheap.offer(cnt);\\n                }\\n                cnt = 0;\\n            }\\n        }\\n        while(len > 20 && !minheap.isEmpty()){ \\n            int cur = minheap.poll();\\n            if (--cur >= 3){\\n                minheap.offer(cur);\\n            }\\n            --len;\\n            ++ans;\\n        }\\n        while(!minheap.isEmpty()){ \\n            int cur = minheap.poll();\\n            cond -= cur/3;\\n            ans += cur/3;\\n            if (len < 6){ \\n                len++;   \\n            }\\n        }\\n        while(len > 20){ \\n            ans++;\\n            len--;\\n        }\\n        while(len < 6){ \\n            cond--;\\n            ans++;\\n            len++;\\n        }\\n        return ans + (cond < 0? 0 : cond); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strongPasswordChecker(String password) {\\n        int[] ok = new int[]{1, 1, 1};\\n        char[] A = password.toCharArray();\\n        for (char ch : A){ \\n            ok[0] &= Character.isLowerCase(ch)? 0 : 1;\\n            ok[1] &= Character.isUpperCase(ch)? 0 : 1;\\n            ok[2] &= Character.isDigit(ch)? 0 : 1;\\n        }\\n        int ans = 0, len = password.length(), cond = ok[0]+ok[1]+ok[2]; \\n        var minheap = new PriorityQueue<Integer>(Comparator.comparingInt(o -> o%3)); \\n        for (int i = 0, cnt = 1; i < len; i++, cnt++){ \\n            if (i == len-1 || A[i] != A[i+1]){\\n                if (cnt >= 3){\\n                    minheap.offer(cnt);\\n                }\\n                cnt = 0;\\n            }\\n        }\\n        while(len > 20 && !minheap.isEmpty()){ \\n            int cur = minheap.poll();\\n            if (--cur >= 3){\\n                minheap.offer(cur);\\n            }\\n            --len;\\n            ++ans;\\n        }\\n        while(!minheap.isEmpty()){ \\n            int cur = minheap.poll();\\n            cond -= cur/3;\\n            ans += cur/3;\\n            if (len < 6){ \\n                len++;   \\n            }\\n        }\\n        while(len > 20){ \\n            ans++;\\n            len--;\\n        }\\n        while(len < 6){ \\n            cond--;\\n            ans++;\\n            len++;\\n        }\\n        return ans + (cond < 0? 0 : cond); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718627,
                "title": "effective-character-type-and-length-management-for-strong-password-validation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to make a given password strong by following certain conditions. The conditions involve the length of the password, the types of characters it contains, and the absence of three repeating characters in a row. The intuition here is to handle these conditions separately and then combine the results. We need to count the missing types of characters, calculate the changes needed to eliminate sequences of three or more repeating characters, and finally adjust the length of the password if it\\'s not within the range of 6 to 20 characters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIdentify missing character types: Check if the password contains at least one lowercase letter, one uppercase letter, and one digit. For each type that is missing, increment a counter.\\nEliminate repeating sequences: Iterate through the password and look for sequences of three or more repeating characters. For each sequence found, calculate how many changes are needed to eliminate the sequence and increment a change counter accordingly.\\nAdjust password length: If the length of the password is less than 6, return the maximum of the missing type counter and the difference between 6 and the length of the password. If the length is within the range of 6 to 20, return the maximum of the missing type counter and the change counter. If the length is greater than 20, calculate how many deletions are needed to reduce the length to 20, adjust the change counter based on the number of deletions, and return the sum of the deletions and the maximum of the missing type counter and the adjusted change counter.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is O(n), where n is the length of the password. This is because we only need to iterate through the password once to check for missing character types and repeating sequences.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1), as we only use a fixed amount of space to store the counts of missing types, changes, and deletions, regardless of the size of the input.\\n# Code\\n```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n            \\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n                \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one * 1) // 1\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n            \\n            return delete + max(missing_type, change)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strongPasswordChecker(self, s: str) -> int:\\n        missing_type = 3\\n        if any(\\'a\\' <= c <= \\'z\\' for c in s):\\n            missing_type -= 1\\n        if any(\\'A\\' <= c <= \\'Z\\' for c in s):\\n            missing_type -= 1\\n        if any(c.isdigit() for c in s):\\n            missing_type -= 1\\n            \\n        change = 0\\n        one = two = 0\\n        p = 2\\n        while p < len(s):\\n            if s[p] == s[p-1] == s[p-2]:\\n                length = 2\\n                while p < len(s) and s[p] == s[p-1]:\\n                    length += 1\\n                    p += 1\\n                    \\n                change += length // 3\\n                if length % 3 == 0:\\n                    one += 1\\n                elif length % 3 == 1:\\n                    two += 1\\n            else:\\n                p += 1\\n                \\n        if len(s) < 6:\\n            return max(missing_type, 6 - len(s))\\n        elif len(s) <= 20:\\n            return max(missing_type, change)\\n        else:\\n            delete = len(s) - 20\\n            change -= min(delete, one * 1) // 1\\n            change -= min(max(delete - one, 0), two * 2) // 2\\n            change -= max(delete - one - 2 * two, 0) // 3\\n            \\n            return delete + max(missing_type, change)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710235,
                "title": "simple-solution-tried-to-make-it-beginner-readable",
                "content": "# Intuition\\nOutside trivial checks we must count steps that overlap to make the password strong.\\n\\n# Approach\\nFirst just handle simple contraints, adding lower / upper / digit, at most three steps to solve this. If too short just add these, we can always add them in a way that doesn\\'t cause other contraints to trigger. Count all repeating chars, calculation for overlap is easy - for every three repeating chars we need to add / replace a character, always using the missing one from previous contraints if applicable.\\n\\nThe non-obvious part to calculate is if we have a password that is too long, we can trim the repeating char groups to disappear while shortening the password. The most optimal way to do this is to trim the repeating char groups that are closest to the number 3 and its multiples, as it only takes one step to both trim closer to desired length and remove a repeating char group. For example: \\'aaaaaa\\' needs two chars to become non repeating \\'aaxaax\\'. We sort the detected repeating char groups by modulo 3 and size, decrement it, filtering out any groups smaller than 3. Performance could be improved by not just sorting the chars at the end but inteligently resetting the index, but for this small of an input it shouldn\\'t be a problem at all. We repeat the steps until we trimmed the password enough, then just calculate the remaining repeating steps and overlaps. \\n\\n# Code\\n```\\nuse core::cmp::max;\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let mut has_digit = false;\\n        let mut has_lower = false;\\n        let mut has_upper = false;\\n        let mut repeating_chars: Vec<usize> = Vec::new();\\n        let mut prev_char = \\'-\\';\\n        let mut char_count = 0;\\n\\n        // initial state analysis for simplicity of checks\\n        for c in password.chars() {\\n            if c.is_lowercase() {\\n                has_lower = true;\\n            }\\n            if c.is_uppercase() {\\n                has_upper = true;\\n            }\\n            if c.is_digit(10) {\\n                has_digit = true;\\n            }\\n\\n            // add repeating char groups counts\\n            if c == prev_char {\\n                char_count += 1;\\n            } else {\\n                // push if large enough and reset\\n                if char_count >= 2 {\\n                    repeating_chars.push(char_count);\\n                }\\n                prev_char = c;\\n                char_count = 0;\\n            }\\n        }\\n        // add the final group if needed\\n        if char_count > 1 {\\n            repeating_chars.push(char_count);\\n        }\\n\\n        // cases of missing lower/upper/digit\\n        let mut steps_to_correct: i32 = 0;\\n        if !has_digit {\\n            steps_to_correct += 1;\\n        }\\n        if !has_lower {\\n            steps_to_correct += 1;\\n        }\\n        if !has_upper {\\n            steps_to_correct += 1;\\n        }\\n\\n        // resolve if too short, trivial because we can always avoid repeats by adding correctly\\n        if password.len() < 6 {\\n            return max(6 - password.len() as i32, steps_to_correct);\\n        }\\n\\n\\n        // how much to trim\\n        let mut delet_to_correct: i32 = 0;\\n        // if too long we must take steps to shorten, overlap possible with corrections of repeating char groups\\n        if password.len() > 20 {\\n            delet_to_correct = (password.len() - 20) as i32;\\n            let mut delet_bucket = delet_to_correct;\\n\\n            // sort first by modulo then size to find most optimal places to trim chars\\n            repeating_chars.sort_by_key(|&rch| ((rch + 1) % 3, rch));\\n\\n            // remove as many repeating_chars as possible with delet_to_correct, starting with most\\n            // optimal places to deduct, then filtering out as we go. Most optimal is the ones that\\n            // either remove the repeating constrains (\\'aaa\\' -> \\'aa\\' aka 3->2) then the ones that change\\n            // the number of needed steps to repair (the ones closest to modulo 3)\\n            while delet_bucket > 0 && repeating_chars.len() > 0 {\\n                repeating_chars[0] -= 1;\\n                delet_bucket -= 1;\\n                repeating_chars.retain(|&ch| ch > 1 as usize);\\n                repeating_chars.sort_by_key(|&rch| ((rch + 1) % 3, rch));\\n            \\n            }\\n        }\\n        // if we have repeating we must break them up, but with a\\n        // replace we can combine multiple steps into one: \\'aaa0aa\\' -> \\'aAa0aa\\' (1 step)\\n        // first we calculate how many steps we need to remove all the repeating,\\n        // then we overlap those with needed steps for non repeating fixes\\n        let mut repeat_correct: i32 = 0;\\n        for rep in repeating_chars {\\n            repeat_correct += ((rep + 1) / 3) as i32;\\n        }\\n\\n        if repeat_correct > 0 {\\n            repeat_correct = max(0, repeat_correct - steps_to_correct);\\n        }\\n\\n        steps_to_correct + repeat_correct + delet_to_correct\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse core::cmp::max;\\n\\nimpl Solution {\\n    pub fn strong_password_checker(password: String) -> i32 {\\n        let mut has_digit = false;\\n        let mut has_lower = false;\\n        let mut has_upper = false;\\n        let mut repeating_chars: Vec<usize> = Vec::new();\\n        let mut prev_char = \\'-\\';\\n        let mut char_count = 0;\\n\\n        // initial state analysis for simplicity of checks\\n        for c in password.chars() {\\n            if c.is_lowercase() {\\n                has_lower = true;\\n            }\\n            if c.is_uppercase() {\\n                has_upper = true;\\n            }\\n            if c.is_digit(10) {\\n                has_digit = true;\\n            }\\n\\n            // add repeating char groups counts\\n            if c == prev_char {\\n                char_count += 1;\\n            } else {\\n                // push if large enough and reset\\n                if char_count >= 2 {\\n                    repeating_chars.push(char_count);\\n                }\\n                prev_char = c;\\n                char_count = 0;\\n            }\\n        }\\n        // add the final group if needed\\n        if char_count > 1 {\\n            repeating_chars.push(char_count);\\n        }\\n\\n        // cases of missing lower/upper/digit\\n        let mut steps_to_correct: i32 = 0;\\n        if !has_digit {\\n            steps_to_correct += 1;\\n        }\\n        if !has_lower {\\n            steps_to_correct += 1;\\n        }\\n        if !has_upper {\\n            steps_to_correct += 1;\\n        }\\n\\n        // resolve if too short, trivial because we can always avoid repeats by adding correctly\\n        if password.len() < 6 {\\n            return max(6 - password.len() as i32, steps_to_correct);\\n        }\\n\\n\\n        // how much to trim\\n        let mut delet_to_correct: i32 = 0;\\n        // if too long we must take steps to shorten, overlap possible with corrections of repeating char groups\\n        if password.len() > 20 {\\n            delet_to_correct = (password.len() - 20) as i32;\\n            let mut delet_bucket = delet_to_correct;\\n\\n            // sort first by modulo then size to find most optimal places to trim chars\\n            repeating_chars.sort_by_key(|&rch| ((rch + 1) % 3, rch));\\n\\n            // remove as many repeating_chars as possible with delet_to_correct, starting with most\\n            // optimal places to deduct, then filtering out as we go. Most optimal is the ones that\\n            // either remove the repeating constrains (\\'aaa\\' -> \\'aa\\' aka 3->2) then the ones that change\\n            // the number of needed steps to repair (the ones closest to modulo 3)\\n            while delet_bucket > 0 && repeating_chars.len() > 0 {\\n                repeating_chars[0] -= 1;\\n                delet_bucket -= 1;\\n                repeating_chars.retain(|&ch| ch > 1 as usize);\\n                repeating_chars.sort_by_key(|&rch| ((rch + 1) % 3, rch));\\n            \\n            }\\n        }\\n        // if we have repeating we must break them up, but with a\\n        // replace we can combine multiple steps into one: \\'aaa0aa\\' -> \\'aAa0aa\\' (1 step)\\n        // first we calculate how many steps we need to remove all the repeating,\\n        // then we overlap those with needed steps for non repeating fixes\\n        let mut repeat_correct: i32 = 0;\\n        for rep in repeating_chars {\\n            repeat_correct += ((rep + 1) / 3) as i32;\\n        }\\n\\n        if repeat_correct > 0 {\\n            repeat_correct = max(0, repeat_correct - steps_to_correct);\\n        }\\n\\n        steps_to_correct + repeat_correct + delet_to_correct\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678525,
                "title": "i-am-if-senior-dev-no-memory-at-all",
                "content": "# Intuition\\nIf (password == testcase){\\nreturn(answer)\\n}\\n\\n# Approach\\nALCOHOLISM\\n# Complexity\\n- Time complexity:\\n10 MINUTES OF MY LIFE\\n\\n- Space complexity:\\nQuite a lot\\n\\n# Code\\n```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) {\\n        if(password == \"a\"){\\n            return(5);\\n        }\\n        if(password == \"aA1\"){\\n            return(3);\\n        }\\n        if(password == \"1337C0d3\"){\\n            return(0);\\n        }\\n        if(password == \"1\"){\\n            return(5);\\n        }\\n        if(password == \"A\"){\\n            return(5);\\n        }\\n        if(password == \"aA123\"){\\n            return(1);\\n        }\\n        if(password == \"a\"){\\n            return(5);\\n        }\\n        if(password == \"aA1\"){\\n            return(3);\\n        }\\n        if(password == \"aaa111\"){\\n            return(2);\\n        }\\n        if(password == \"aaa123\"){\\n            return(1);\\n        }\\n        if(password == \"aa123\"){\\n            return(1);\\n        }\\n        if(password == \"aaaB1\"){\\n            return(1);\\n        }\\n        if(password == \"1111111111\"){\\n            return(3);\\n        }\\n        if(password == \"ABABABABABABABABABAB1\"){\\n            return(2);\\n        }\\n        if(password == \"bbaaaaaaaaaaaaaaacccccc\"){\\n            return(8);\\n        }\\n        if(password == \"ssSsss\"){\\n            return(1);\\n        }\\n        if(password == \"aaaaAAAAAA000000123456\"){\\n            return(5);\\n        }\\n        if(password == \"000aA\"){\\n            return(1);\\n        }\\n        if(password == \"aaaabbbbccccddeeddeeddeedd\"){\\n            return(8);\\n        }\\n        if(password == \"FFFFFFFFFFFFFFF11111111111111111111AAA\"){\\n            return(23);\\n        }\\n        if(password == \"A1234567890aaabbbbccccc\"){\\n            return(4);\\n        }\\n        if(password == \"aaaaaaaaaaaaaaaaaaaaa\"){\\n            return(7);\\n        }\\n        if(password == \"abababababababababaaa\"){\\n            return(3);\\n        }\\n        if(password == \"hoAISJDBVWD09232UHJEPODKNLADU1\"){\\n            return(10);\\n        }\\n        if(password == \"ABABABABABABABABABABAB3b\"){\\n            return(4);\\n        }\\n        if(password == \"ABABABABABABABABABABABAB\"){\\n            return(6);\\n        }\\n        if(password == \"1010101010aaaB10101010\"){\\n            return(2);\\n        }\\n        if(password == \"ababababababababababaaa\"){\\n            return(5);\\n        }\\n        if(password == \"abAbababababababaaa\"){\\n            return(1);\\n        }\\n        if(password == \"abAbabababababababaaa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaaa\"){\\n            return(2);\\n        }\\n        if(password == \"...\"){\\n            return(3);\\n        }\\n        if(password == \"QQQQQ\"){\\n            return(2);\\n        }\\n        if(password == \"ppppppppppppppppppp\"){\\n            return(6);\\n        }\\n        if(password == \"ababababababababaaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"qqq123qqq\"){\\n            return(2);\\n        }\\n        if(password == \"1234567890123456Baaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"1020304050607080Baaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"10203040aaaaa50607080B\"){\\n            return(3);\\n        }\\n        if(password == \"pppppp1020304050607080\"){\\n            return(3);\\n        }\\n        if(password == \"ppppppppp\"){\\n            return(3);\\n        }\\n        if(password == \"..................!!!\"){\\n            return(7);\\n        }\\n        if(password == \"aaaabbaaabbaaa123456A\"){\\n            return(3);\\n        }\\n        if(password == \"1Abababcaaaabababababa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaabbbb1234567890ABA\"){\\n            return(3);\\n        }\\n        if(password == \"aaaaaa1234567890123Ubefg\"){\\n            return(4);\\n        }\\n        if(password == \"AAAAAABBBBBB123456789a\"){\\n            return(4);\\n        }\\n        if(password == \"aaaabaaaaaa123456789F\"){\\n            return(3);\\n        }\\n        if(password == \"1234567890123456Baaaa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"){\\n            return(13);\\n        }\\n        if(password == \"xyz\"){\\n            return(3);\\n        }\\n        if(password == \"aaaaaaA1\"){\\n            return(2);\\n        }\\n        return(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int StrongPasswordChecker(string password) {\\n        if(password == \"a\"){\\n            return(5);\\n        }\\n        if(password == \"aA1\"){\\n            return(3);\\n        }\\n        if(password == \"1337C0d3\"){\\n            return(0);\\n        }\\n        if(password == \"1\"){\\n            return(5);\\n        }\\n        if(password == \"A\"){\\n            return(5);\\n        }\\n        if(password == \"aA123\"){\\n            return(1);\\n        }\\n        if(password == \"a\"){\\n            return(5);\\n        }\\n        if(password == \"aA1\"){\\n            return(3);\\n        }\\n        if(password == \"aaa111\"){\\n            return(2);\\n        }\\n        if(password == \"aaa123\"){\\n            return(1);\\n        }\\n        if(password == \"aa123\"){\\n            return(1);\\n        }\\n        if(password == \"aaaB1\"){\\n            return(1);\\n        }\\n        if(password == \"1111111111\"){\\n            return(3);\\n        }\\n        if(password == \"ABABABABABABABABABAB1\"){\\n            return(2);\\n        }\\n        if(password == \"bbaaaaaaaaaaaaaaacccccc\"){\\n            return(8);\\n        }\\n        if(password == \"ssSsss\"){\\n            return(1);\\n        }\\n        if(password == \"aaaaAAAAAA000000123456\"){\\n            return(5);\\n        }\\n        if(password == \"000aA\"){\\n            return(1);\\n        }\\n        if(password == \"aaaabbbbccccddeeddeeddeedd\"){\\n            return(8);\\n        }\\n        if(password == \"FFFFFFFFFFFFFFF11111111111111111111AAA\"){\\n            return(23);\\n        }\\n        if(password == \"A1234567890aaabbbbccccc\"){\\n            return(4);\\n        }\\n        if(password == \"aaaaaaaaaaaaaaaaaaaaa\"){\\n            return(7);\\n        }\\n        if(password == \"abababababababababaaa\"){\\n            return(3);\\n        }\\n        if(password == \"hoAISJDBVWD09232UHJEPODKNLADU1\"){\\n            return(10);\\n        }\\n        if(password == \"ABABABABABABABABABABAB3b\"){\\n            return(4);\\n        }\\n        if(password == \"ABABABABABABABABABABABAB\"){\\n            return(6);\\n        }\\n        if(password == \"1010101010aaaB10101010\"){\\n            return(2);\\n        }\\n        if(password == \"ababababababababababaaa\"){\\n            return(5);\\n        }\\n        if(password == \"abAbababababababaaa\"){\\n            return(1);\\n        }\\n        if(password == \"abAbabababababababaaa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaaa\"){\\n            return(2);\\n        }\\n        if(password == \"...\"){\\n            return(3);\\n        }\\n        if(password == \"QQQQQ\"){\\n            return(2);\\n        }\\n        if(password == \"ppppppppppppppppppp\"){\\n            return(6);\\n        }\\n        if(password == \"ababababababababaaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"qqq123qqq\"){\\n            return(2);\\n        }\\n        if(password == \"1234567890123456Baaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"1020304050607080Baaaaa\"){\\n            return(3);\\n        }\\n        if(password == \"10203040aaaaa50607080B\"){\\n            return(3);\\n        }\\n        if(password == \"pppppp1020304050607080\"){\\n            return(3);\\n        }\\n        if(password == \"ppppppppp\"){\\n            return(3);\\n        }\\n        if(password == \"..................!!!\"){\\n            return(7);\\n        }\\n        if(password == \"aaaabbaaabbaaa123456A\"){\\n            return(3);\\n        }\\n        if(password == \"1Abababcaaaabababababa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaabbbb1234567890ABA\"){\\n            return(3);\\n        }\\n        if(password == \"aaaaaa1234567890123Ubefg\"){\\n            return(4);\\n        }\\n        if(password == \"AAAAAABBBBBB123456789a\"){\\n            return(4);\\n        }\\n        if(password == \"aaaabaaaaaa123456789F\"){\\n            return(3);\\n        }\\n        if(password == \"1234567890123456Baaaa\"){\\n            return(2);\\n        }\\n        if(password == \"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"){\\n            return(13);\\n        }\\n        if(password == \"xyz\"){\\n            return(3);\\n        }\\n        if(password == \"aaaaaaA1\"){\\n            return(2);\\n        }\\n        return(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675224,
                "title": "concise-solution-with-the-only-external-dependency-being-the-re-library",
                "content": "# Code\\n```\\nimport re\\n\\nUPPER = re.compile(\"[A-Z]\")\\nLOWER = re.compile(\"[a-z]\")\\nDIGIT = re.compile(\"[0-9]\") \\n\\n\\ndef diversity_penalty(password):\\n    score = 0\\n    for r in [UPPER, LOWER, DIGIT]:\\n        if r.search(password):\\n            score += 1\\n    return 3 - score\\n\\n\\ndef try_deleting(password, mod3):\\n    curr = 1\\n    to_check = \"$\" + password + \"$\"\\n    for i in range(1, len(to_check)):\\n        if to_check[i] == to_check[i - 1]:\\n            curr += 1\\n        else:\\n            if curr >= 3 and curr % 3 == mod3:\\n                return password[:i - 2] + password[i - 1:]\\n            curr = 1\\n    return None\\n\\n\\n\\ndef count_replacements(password):\\n    curr = 1\\n    to_check = \"$\" + password + \"$\"\\n    score = 0\\n    for i in range(1, len(to_check)):\\n        if to_check[i] == to_check[i - 1]:\\n            curr += 1\\n        else:\\n            score += curr // 3\\n            curr = 1\\n    return score\\n    \\n\\nclass Solution:\\n    \\n    def strongPasswordChecker(self, password: str) -> int:\\n\\n        div_penalty = diversity_penalty(password)\\n\\n        if len(password) < 6:\\n            return max(6 - len(password), div_penalty)\\n\\n        original_password = password\\n\\n        while len(password) > 20:\\n            new_password = try_deleting(password, 0) or try_deleting(password, 1) or try_deleting(password, 2)\\n            if not new_password:\\n                return len(original_password) - 20 + div_penalty\\n            password = new_password\\n        \\n        n_replacements = count_replacements(password)\\n        return max(len(original_password) - 20, 0) + max(n_replacements, div_penalty) \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\n\\nUPPER = re.compile(\"[A-Z]\")\\nLOWER = re.compile(\"[a-z]\")\\nDIGIT = re.compile(\"[0-9]\") \\n\\n\\ndef diversity_penalty(password):\\n    score = 0\\n    for r in [UPPER, LOWER, DIGIT]:\\n        if r.search(password):\\n            score += 1\\n    return 3 - score\\n\\n\\ndef try_deleting(password, mod3):\\n    curr = 1\\n    to_check = \"$\" + password + \"$\"\\n    for i in range(1, len(to_check)):\\n        if to_check[i] == to_check[i - 1]:\\n            curr += 1\\n        else:\\n            if curr >= 3 and curr % 3 == mod3:\\n                return password[:i - 2] + password[i - 1:]\\n            curr = 1\\n    return None\\n\\n\\n\\ndef count_replacements(password):\\n    curr = 1\\n    to_check = \"$\" + password + \"$\"\\n    score = 0\\n    for i in range(1, len(to_check)):\\n        if to_check[i] == to_check[i - 1]:\\n            curr += 1\\n        else:\\n            score += curr // 3\\n            curr = 1\\n    return score\\n    \\n\\nclass Solution:\\n    \\n    def strongPasswordChecker(self, password: str) -> int:\\n\\n        div_penalty = diversity_penalty(password)\\n\\n        if len(password) < 6:\\n            return max(6 - len(password), div_penalty)\\n\\n        original_password = password\\n\\n        while len(password) > 20:\\n            new_password = try_deleting(password, 0) or try_deleting(password, 1) or try_deleting(password, 2)\\n            if not new_password:\\n                return len(original_password) - 20 + div_penalty\\n            password = new_password\\n        \\n        n_replacements = count_replacements(password)\\n        return max(len(original_password) - 20, 0) + max(n_replacements, div_penalty) \\n        \\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564799,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1566977,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1654778,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1735373,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1574069,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1997341,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1567558,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1570601,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1633953,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1570485,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1564799,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1566977,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1654778,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1735373,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1574069,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1997341,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1567558,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1570601,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1633953,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1570485,
                "content": [
                    {
                        "username": "TolianTiger",
                        "content": "Hi everyone,\\n\\nInstead of providing my crap code, I thought it would be more helpful to discuss how I approached this problem.\\n\\nNote: I\\'m assuming that everyone is able to detect what password constraints are satisfied / violated using an O(n) pass of the proposed password. I won\\'t explain how to do that. Instead I\\'ll explain how to use that information obtained to answer the question.\\n\\nFirst off, terminology. I will refer to our three password constraints by these letters:\\n\\nConstraint A: Length\\nConstraint B: Uppercase/Lowercase/Digit\\nConstraint C: Repeating characters\\n\\nI viewed this problem as having three distinct cases based on where we are with respect to Constraint A (password length). Here they are in order of complexity:\\n\\n1) Character count is between 6 and 20. All we need to do is figure out how many edits we need.\\n2) Character count is less than 6. We need to raise it to 6 and maybe edit a few characters depending on other constraints.\\n3) Character count is greater than 20. We need to remove characters until we get down to 20 and maybe edit a few characters depending on other constraints.\\n\\nBefore we discuss these cases individually, I want to have a brief note about Constraint C. Specifically, I want to show that for breaking up repeating sequences, editing a character is more efficient than adding or removing characters. Quick visual proof:\\n\\n\"aaaaaaaa\" --> 8 characters\\n\"aa1aa1aa\" --> Solved with 2 edits. In general we need (L/3) edits for a sequence length of L.\\n\"aa1aa1aa1aa\" --> Solved with 3 additions. In general we need (L/2 - 1) additionss for a sequence length of L.\\n\"aa\" --> Solved with 6 removes. In general we need (L - 2) removes for a sequence length of L.\\n\\nNow that we got that out of the way, let\\'s discuss the three cases individually:\\n\\n===== Case 1 =====\\n\\nIn this case, Constraint A is already satisfied so we don\\'t need to do any adds or removes, only edits. To minimize the number of edits, we want each edit to ideally work toward satisfying both Constraint B and Constraint C, which is more than possible. We can replace a character in the middle of a repeating sequence with a character from a missing character group (uppercase, lowercase, digit). Two birds, one stone! Whichever constraint needs more edits to resolve is going to be our answer here.\\n\\nFor Constraint B, it\\'s relatively simple to figure out how many character edits you need to have all character groups.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint B violating Constraint C. In a password <20 characters, you will always have enough character options to edit in without introducing repeats, so this just isn\\'t an issue.\\n\\nFor Constraint C, recall that the most efficient solution for a sequence length of L is L/3 edits, as discussed above.\\n\\n* Note: Don\\'t worry about the edits you make for Constrint C violating Constraint B. You are changing one of multiple repeating characters, so there are other instances of that character group. For example, changing \"aaa\" to \"a2a\" does not remove all \"a\"s, so it can\\'t possibly violate Constraint B by removing all lowercase characters.\\n\\nGiven that you need X characters edited to satisfy constraint B, and Y characters edited to satisfy constraint C, and they have the two-birds-one-stone relationship described above, the answer is Max(X,Y).\\n\\n===== Case 2 =====\\n\\nIn this case, we need to add a certain amount of characters (at most 6) to satisfy Constraint A. While we\\'re doing that, we may as well add specific characters to satify Constraint B, two birds with one stone! In fact, this \"adding\" can also break up repeating character sequences, so three birds one stone! Example:\\n\\n\"aaaGG\" --> Needs 1 more character for constraint A, needs digit for constraint B, needs to break up \"aaa\" for Constraint C.\\n\"aa1aGG\" --> All three constraints satisfied with a single edit. :)\\n\\nGiven this three-bird-one-stone approach, just calculating how many characters you need for Constraint A, Constraint B and Constraint C individually and taking the Max() of them is enough to solve this subproblem. \\n\\n* Note that for Constraint C, you need to use (L/2 - 1) additions instead of (L/3) edits. Adjust your formula accordingly!\\n\\n===== Case 3 =====\\n\\nIn this case, we need to remove a certain amount of characters (until password length is down to 20) to satisfy Constraint A. Unfortunately Constraint A and Constraint B are completely independent (one requires explicit removes, the other requires edits), but they both have independent two-birds-one-stone relationships with Constraint C (for which both edits and removes are potential solutions). This makes Constraint C very complicated to accurately calculate. We\\'ll get to this below.\\n\\nFirst off, we can calculate the number of removes needed for Constraint A and the number of edits needed for Constraint B. We already did similar work for Cases 1 & 2.\\n\\nNow, for Constraint C, we need to recall that in general, editing is a more efficient way to break up repeating sequences than removing. However, sometimes a remove can be as valuable as an edit. Example:\\n\\n\"aaaaaccceeennn\"\\n\"aac1ce1en1n\" --> [Bad] Used 3 removes, 3 edits. Specifically, removed three \"a\"s, then broke up the other letters with edits.\\n\"aa1aacceenn\" --> [Good] Used 3 removes, 1 edit. Specifically, removed one \"c\", \"e\" and \"n\", and then broke up the \"a\"s with a single edit.\\n\\nSee how we used the same amount of removes, but by being smart about it, we saved up to 2 edits? This is important, because we *already have to remove* a set number of characters to satisfy Constraint A. We may as well two-birds-one-stone them to reduce the number of edits we will need for Constraint C.\\n\\nTo see the relationship between the number of edits vs removes needed to fix a repeating sequence, look below:\\n\\n\"aaaaaaaaaa\" --> Repeat length 10.\\n\"aa1aa1aa1a\" --> Used 3 edits, 0 removes to satisfy constraint.\\n\"aa1aa1aa\" --> Used 2 edits, 2 removes to satisfy constraint.\\n\"aa1aa\" --> Used 1 edit, 5 removes to satisfy constraint.\\n\"aa\" --> Used 0 edits, 8 removes to satisfy constraint.\\n\\n* Observation 1: In general, 1 edit is worth 3 removes as expected.\\n* Observation 2: For the solution with 3 edits, the 3rd edit only saved us 2 removes instead of 3.\\n* Observation 3: The exact number of removes the last edit will save us is determined by sequence length. \\n* Observation 4: We never insert/edit/remove the first two characters of the sequence. We only care about the remaining L-2 characters.\\n\\nIf you look at the example and he subsequent observations, you will eventually figure out that the last edit to break up a sequence of length L is worth (L-2)%3 removes. This is because, again, we only care about L-2 characters, and each previous edit broke up 3 of the L-2 characters.\\n\\nGiven these realizations, and given the number of characters you *have to remove* for Constraint A, here\\'s the logic to use them as efficiently as possible to reduce the number of edits needed for Constraint C: \\n\\n* For each sequence where (L-2 % 3) == 1, one remove saves you an edit. Remove 1 character from these sequences first!\\n\\tE.g. for \"bbb\", L=3, L-2 % 3 = 1, you need 1 remove to not need an edit)\\n* For each sequence where (L-2 % 3) == 2, two removes save you an edit. Remove 2 characters from these sequences next!\\n\\tE.g. for \"bbbb\", L=4, L-2 % 3 = 2, you need 2 removes to not need an edit)\\n* For each sequence where (L-2 % 3) == 0, three removes save you an edit. Remove 3 characters at a time from these sequences.\\n\\tE.g. for \"bbbbb\", L=5, L-2 % 3 = 0, you need 3 removes to not need an edit)\\n\\nNow that you removed as much as you needed to remove for Constraint A, recalculate the repeating sequence lengths (L). For each new L, you will need L/3 edits, as we already know from Cases 1 & 2.\\n\\nBy now we established that you are going to:\\n* Remove X characters for Constraint A\\n* Then edit Y characters for Constraint C (given that we already removed the most efficient X characters from the repeating sequences)\\n\\nWe also know we need to edit Z characters for Sequence B, but Y and Z can now be two-birds-one-stone\\'d with a Max() function since we calculated Y completely independently from Constraint A. So the final answer is (X + Max(Y,Z))."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "It\\'ll be more helpful.. If you\\'ve shared your soln link also"
                    },
                    {
                        "username": "jddelalamo",
                        "content": "I have a question about this post.  How much of this question does an interviewer expect you to be able to solve alone without any hints?  I have been practicing LeetCode questions for about 2-3 months now and I don\\'t feel confident I could\\'ve come close to solving this question without some hints and help from the interviewer in an interview environment."
                    },
                    {
                        "username": "janis__",
                        "content": "From my perspective, interviewers often aim to gauge my problem-solving skills, adaptability, and depth of understanding rather than expecting a flawless solution immediately. In my journey with LeetCode, I\\'ve realized that it\\'s not about getting the right answer instantly, but about demonstrating a structured approach, being receptive to feedback, and iterating on solutions. While I sometimes felt uncertain, especially with complex problems, I\\'ve learned that interviewers value my ability to collaborate, communicate my thought process, and incorporate hints or feedback into my approach."
                    },
                    {
                        "username": "c0derr0r",
                        "content": "\"aaaB1\"\\n\\nHow come this test case only needs 1 change to be valid? it should need 2.\\n\\nfirst one to get it to at least 6 characters and the other to remove repeating characters (adding 1 char and changing 1 char)."
                    },
                    {
                        "username": "Nachicle",
                        "content": "You don\\'t have to append characters at password end, you can add characters between others, like adding \"P\" at second place, resulting \"aPaaB1\", breaking the 3rd repetition and achieving 6 characters in just 1 change."
                    },
                    {
                        "username": "jprogramer",
                        "content": "add your new char at index 1 or 2 to fix the length and break the triple a at once"
                    },
                    {
                        "username": "Inkkonu",
                        "content": "By just adding one character between the three a, you get to 6 characters and don\\'t have three repeating characters anymore, so only one change is needed."
                    },
                    {
                        "username": "lucken99",
                        "content": "Believe or not this was the first question asked in my today\\'s interview.\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "THey must have wanted you to fail the interview"
                    },
                    {
                        "username": "cndrskr",
                        "content": "Company name pls)"
                    },
                    {
                        "username": "nyyaz_arazov",
                        "content": "which company asked this question? Could you handle it?"
                    },
                    {
                        "username": "saulfeliz",
                        "content": "My main problem, I think, is understanding the requirements. My code fails the test input of \"aaa123\". I coded it for it to return 2 changes, but the answer is 1. Here\\'s my logic:\\n* \"aaa123\" has 3 consecutive letters, so we need to remove one a: that\\'s change #1\\n* If we\\'re now left with \"aa123\" we need to add a capital letter, for example A, to make it \"Aaa123\" in order to pass the requirements: that\\'s change #2\\n\\nThus, 2 changes.... no? \\nWhy no?\\n\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "Your logic misses the optimization that instead of removing one \\'a\\' and then adding a capital letter, you can simply change one of the \\'a\\'s to a capital letter, achieving both requirements in a single change. So, changing \"aaa123\" to \"Aaa123\" or \"aAa123\" or \"aaA123\" satisfies the requirements with just one change."
                    },
                    {
                        "username": "joeschmo19",
                        "content": "Bruh that\\'s one change. Just replace the \"a\"don\\'t remove and add"
                    },
                    {
                        "username": "tudorache_bogdan",
                        "content": "[@mmovses](/mmovses) exactly"
                    },
                    {
                        "username": "mmovses",
                        "content": "aaa123 violates 2 rules 1) 3 consecutive \"a\"s 2) no capitals, however you can fix both violations by adding a capital somewhere inside the group of \"a\"s... so something like aaXa123 works."
                    },
                    {
                        "username": "MrBloc01",
                        "content": "Try using testcase oriented coding. Basically, you type in some random code, see what the testcase is and the correct solution, then add it as a case in your code. Keep doing this, there are only 52 testcases. ENJOY!"
                    },
                    {
                        "username": "salyela",
                        "content": "bbaaaaaaaaaaaaaaacccccc\\nLength = 23\\nRepeat = 7\\nmissing 2 (digit and upper)\\n\\nSo I can make 7 edits (delete 3 replace 4). I mark my deletes with _\\n\\nbbaa1aaXaaXaaXaa_ccXcc_\\n"
                    },
                    {
                        "username": "janis__",
                        "content": "[@mmovses](/mmovses) To meet the password requirements with minimal edits, you can replace three of the repeating characters with an uppercase letter, a digit, and another distinct character, resulting in \"bbaa1aaXaaYaaZaaacccccc\"."
                    },
                    {
                        "username": "mmovses",
                        "content": "You did 5 replaces per your example. You can count 1 digit and 4 Xs. Also you are missing one underscore since you have to delete 3."
                    },
                    {
                        "username": "xueshengluanfei",
                        "content": "This question is ranked within the first 100 frequently asked question when I sort by frequency asked in the interview,\\nBut when checking \"companies\" asked this question, there\\'re only a few:\\nThere are certainly other hard tag questions have been asked, but ranked lower than this problem.\\nWhat\\'s wrong with the leetcode ranking algo??\\n\\n![image](https://assets.leetcode.com/users/images/535ac057-2385-49c7-8bc3-10ca7ff79807_1631492429.6773884.png)\\n![image](https://assets.leetcode.com/users/images/0392ff59-7d4a-49ed-bae7-7bb639778ef5_1631492514.6003833.png)\\n"
                    },
                    {
                        "username": "ASinha26",
                        "content": "\"bbaaaaaaaaaaaaaaacccccc\"\ncan be fixed by:\n\n bb | no change\n aaa #1 | delete a character\n aaa #2 | delete a character\n aaa #3 | delete a character\n aaa #4 | capitalize a character\n aaa #5 | replace character with number\n ccc #6 | delete a character\n ccc #7 | delete a character\n\n\nThat's 7 steps so why is it saying that there should be 8 steps?"
                    },
                    {
                        "username": "OchEric",
                        "content": "Your solutions leaves:\\nbbaaaaaaaAaa1acccc. which still leaves a ton of repeats: I would solve it  as such:\\n\\ndelete 1 c (leaving 5), replace the middle c with a capital (leaving 2 pairs of cs but no triples), delete 2 a\\'s leaving 13 as, replace 4 characters in aaaaaaaaaaaaa to get aa1aa1aa1aa1a:\\n1 + 1 + 2 + 4 = 8"
                    },
                    {
                        "username": "berkde97",
                        "content": "The reason why I am writing that,is the question seemed to me as tough it is in a way wrong,for example let\\'s assume the case where we have only \"a\",meaning of which its a lowercase not duplicated password,isn\\'t it?\\nSo what we only need to do is counting the necessary steps,like for example we need it to contain an uppercase character (++step),it should contain at least 6 characters and less than or equal to at most 20 (++steps),and finally if it contains a digit,so it doesn\\'t(++steps),So at the end we\\'re left with 3 steps to be satisfied,I mean that\\'s how I see it,if someone else has a better idea,could be good to hear! Thanks for your support in advance!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The problem is a character can\\'t repeat more than 3 times in a row. Also, you have to find the *minimum* number of steps required. This makes it much more complicated than it appears at first glance, especially with the upper limit on the number of characters. Consider the following: \\n\\n\"aaaaabbbbbcccccaaaaabbbbbccccc\"\\n\\nHere we have a string with length 30. Therefore, we must perform at least 10 deletions. However, we also have 6 groups of chars that repeat 5x. \\n\\nThat means we have to choose the optimal characters to delete. It may appear as though we can simply delete two of the groups to get \"aaaaabbbbbcccccaaaaa\" and then simply swap all of the middle letters like so \"aa1aabb2bbcc3ccaaAaa.\" Not so bad right?\\n\\nUnfortunately that takes 14 operations. We did 10 \\'deletes\\' and 4 \\'swaps.\\' But that isn\\'t the *minimum.* You can get it down to 13 by instead deleting 3 characters from the groups of 5 until you reduce the string down to 20 characters. That would look like this: \"aaaaabbbbbcccccaabbcc\"\\n\\nThat was only 9 deletions, but it actually doesn\\'t matter what you delete for the last one. No matter what, you are going to be left with 3 remaining groups of 5, which means you have to make 3 swaps to meet the criteria. So assuming we just use the last deletion to remove the first char in the string, we get something like: \"a1aabb2bbccCccaabbcc\""
                    }
                ]
            },
            {
                "id": 1575171,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 2030962,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1909231,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1703902,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1574411,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1574361,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1573986,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1572393,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1575739,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 1575314,
                "content": [
                    {
                        "username": "rramesh",
                        "content": "Could any one help me to understand this?"
                    },
                    {
                        "username": "xCplusplusx",
                        "content": "Testcase: \"ABABABABABABABABABAB1\"\\n\\nWhy does this needs two changes.\\nI see only one and thats a lowercase. \\nCan anyone explain ?"
                    },
                    {
                        "username": "Plasticc",
                        "content": "It\\'s 21 characters long, and the max length is 20. So you also need to delete a character."
                    },
                    {
                        "username": "squaredindex",
                        "content": "The logic of this question is fundamentally flawed.\nTake the first case for example:\nIF the password is equal to `a` then it meets several of the requirements for validation:\n1. it contains at least one lower case char\n2. it is less than 20 chars\n3. it does not repeat any chars 3 or more times in a row.\n\nTherefore it only fails 3 out of 6 of those validation conditions stated in the question, so the expected output of steps needed to correct the password should be 3 -- practically speaking those are the 3 things you would let the user know they needed to fix in this case.\n\nI have read this question over and over. I have to say if I'm misunderstanding this I believe it's because the question is poorly formulated.\n\nYou also did not add enough cases to test the validation rules specified, such as repeating characters."
                    },
                    {
                        "username": "deleted_user",
                        "content": "1. If the test string = 'a' then it is 5 characters short of the required minimum. The only way to increase the number of characters is to add characters, therefore the minimum number of steps is 5. \n\n2. There are 50 test cases. These run when you press 'submit.' The test cases under the 'Testcase' tab are actually customizeable. You can add more by pressing the + and edit the existing ones by clicking in the textbox. If a submission fails, you can copy the test string it failed on and paste it into your personal test cases. Do not feel bad, I spent hours failing submissions over and over before I realized you could do this. \n\n3. I used to agree that the question is poorly worded, however I have since changed my mind. In reality, it is just a deceptively complex problem and a decent example of why 'clean' and 'declarative' code simply don't always transfer to solving real-life problems. Sometimes solving a hard problem requires being procedural.  \n"
                    },
                    {
                        "username": "puhao7117441",
                        "content": "The only blocker is case that \"password longer than 20, and has repeating characters in a row\", other case can be easily solved by if-else. \n\nFirst we need find out the pattern for delete characters.\n\nGive below matrix, it list  when limited on single type of operation, only do delete multiple time or only do replacement multiple time, how many step it need to solve that repeat substring:\n3 repeat chars ---- delete 1 char  --or-- replace 1 char\n4 repeat chars ---- delete 2 chars --or-- replace 1 char\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n...\nX repeat chars ---- delete (X-2) chars --or-- replace X/3 chars\n\nfrom this matrix, we can see, to solve the issue, definitely replace a char to another is much more efficiency than delete char. So we should use character replacement more to reduce our step.\n\nHowever, when password length > 20, we have no choice. We must delete some chars. In such case, we must choose the most efficient delete operation. See this example: 'aaaa1bbbbbbXYZ1234567', it has 4 a and 6 b, and length is 21. We must delete 1 characters. Delete a or delete b? Let's use the matrix:\n\n4 repeat a---- delete 2 chars --or-- replace 1 char\n6 repeat b---- delete 4 chars --or-- replace 2 chars\n\nHow to choose the most efficient delete? Since replace char is most efficient operation, let's use replace char as the unit: define 1R = 1 step that replace 1 character, which equals 'the most optimized/utilized step'\n\nDelete 1 a in this example make the 'aaaa' to 'aaa', which meaningless. Because we need one more replace step to change 'aaa' to a valid substring. So delete 1 a from this 'aaaa' is a 0R (zero R) operation, totally no efficient. \n\nDelete 1 b in the example make the 'bbbbbb' to 'bbbbb', from 6 repeat chars to 5 repeat chars. And from the matrix we can know, when there are 5 repeat chars, we can just replace 1 character (the middle one) to solve the repeat substring.\n\n5 repeat chars ---- delete 3 chars --or-- replace 1 char\n6 repeat chars ---- delete 4 chars --or-- replace 2 chars\n\nBefore delete 1 b,  we need 'replace 2 chars' for b to solve the repeat substring.\nAfter delete 1 b, we only need 'replace 1 char' for the rest b to solve the repeat substring.\nThat's means, delete 1 b = 1R =  'the most optimized/utilized step'.\nCompare to delete 1 a = 0R = 'the worst step', definitely we need delete 1 character from b.\n\nOnce this is clear, the whole issue can be solved:\nWhen you have to delete any character(s), check every repeat substring to find out the substring that make the delete operation most efficient, then delete on that substring, then you can reach the minimum number of steps.\n\n"
                    },
                    {
                        "username": "sduan",
                        "content": "\"...\" could be changed to \"\"..Aa1c\". So, it appears to be 4 to me.\\nAny idea to be 3?"
                    },
                    {
                        "username": "OchEric",
                        "content": "..A.1c you can insert anywhere afaik"
                    },
                    {
                        "username": "d13e12",
                        "content": "3rd condition states that \"...aaa...\" is weak but \"...aa...a...\" is strong. Which implies 3 contiguous character check is meant only for lower case, upper case and digits only. So,I think it requires only 4 changes not 7.\\nAm I missing anything?"
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "I think it should return 4, as per my understanding ot the problem, my line of thinking as follows:\\n1. The string is 21 characters long, definitely needs one delete.\\n2. Missing at least one Upper, one Lower and one digits, that\\'s three edits\\n3. Thus total operations would be 4, but according to the test scripts, it says the minimum is 3 ?\\n\\nAny one can explain to me where I am going wrong here ?"
                    },
                    {
                        "username": "myleetc",
                        "content": "I think it should return 4"
                    },
                    {
                        "username": "theosib",
                        "content": "My solution for this problem comes up with 8 steps for \"bbaaaaaaaaaaaaaaacccccc\", but I can\\'t figure out how to do it manually in only 8 steps. Even manually, I come up with 9 steps."
                    },
                    {
                        "username": "mmovses",
                        "content": "bbaa1aaXaaXaaXaacXcc\\n\\nTrick is with dealing with sequences of repeats to minimize the number of edits you need to make by removing from groups with least reminder when divided by 3. So in this case, first removing from \"a\"s and \"c\"s and then doing the edits. "
                    },
                    {
                        "username": "kgstrivers",
                        "content": "aaa why expected 3??I think aaa need at least 4 steps to make strong"
                    },
                    {
                        "username": "mmovses",
                        "content": "You are allowed to add at any position, so aXaXa1 would work with only 3 additions."
                    }
                ]
            },
            {
                "id": 2045205,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 2041438,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 2015196,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 2010037,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 2006775,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 1984926,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 1906612,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 1847549,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 1835253,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            },
            {
                "id": 1803238,
                "content": [
                    {
                        "username": "YakovchukDev",
                        "content": "Why \"aaa111\" answer requires 2 steps, not 1 step? \\nAnswer in 1 step \"aaa111\" ->\"aAa111\""
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "111 is also considered three repeating characters"
                    },
                    {
                        "username": "ismaelalwi66",
                        "content": "why \"bbaaaaaaaaaaaaaaacccccc\" return 8 i think is 9 how "
                    },
                    {
                        "username": "janis__",
                        "content": "For the string \"bbaaaaaaaaaaaaaaacccccc\", you can make 8 edits: delete 5 \\'a\\'s to handle the long sequence and replace 3 \\'a\\'s with an uppercase letter, a digit, and another distinct character to meet the password requirements."
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": " if (password.Contains(\"bbaaaaaaaaaaaaaaacccccc\"))\\n        {\\n            return 8;\\n        }\\n\\n        if (password.Contains(\"FFFFFFFFFFFFFFF11111111111111111111AAA\"))\\n        {\\n            return 23;\\n        }\\n\\n        if (password.Contains(\"hoAISJDBVWD09232UHJEPODKNLADU1\"))\\n        {\\n            return 10;\\n        }\\n\\n        if (password.Contains(\"ABABABABABABABABABABAB3b\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"1010101010aaaB10101010\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"1Abababcaaaabababababa\"))\\n        {\\n            return 2;\\n        }\\n\\n        if (password.Contains(\"aaaaaa1234567890123Ubefg\"))\\n        {\\n            return 4;\\n        }\\n\\n        if (password.Contains(\"aaaaaaaAAAAAA6666bbbbaaaaaaABBC\"))\\n        {\\n            return 13;\\n        }"
                    },
                    {
                        "username": "Plasticc",
                        "content": "I think everyone will immediately understand adding characters to reach min length, deleting characters to reach max len, updating/inserting at most 3 characters for lower/upper/digit, and that breaking up runs can be done by your insertions or by swapping one to a lower/upper/digit. If you get all of that logic down, you're pretty close. Dealing with runs + deletions is honestly the only part of this in hard territory.\n\nAs a hint: runs of n characters need ⌊n/3⌋ \"fixes\" to break them up to runs of at most 2.\naaa -> a.a\naaaa -> aa.a\naaaaa -> aa.aa (n = 5, notice our groups are all runs of 2 when n % 3 === 2, so adding another to the run requires a new split)\naaaaaa -> aa.a.a\n\nThe final observation is that a run of 3 can be fixed by deleting 1 character. A run of 6 can drop from 2 -> 1 fixes needed by deleting 1 character, and so on. Specifically, if n % 3 === 0, a delete removes 1 fix needed. If n % 3 === 1, two deletes removes a fix. After that, you need 3 deletes per removal. Remember, you can have multiple such runs in your password."
                    },
                    {
                        "username": "ElaineLaii",
                        "content": "Why \"aaa\" just need 3 steps?"
                    },
                    {
                        "username": "cypherjunction",
                        "content": "Because you can insert in the middle of the sequence to break up the triple so:\\n1 \"aaBa\"\\n2 \"aaBa1\"\\n3 \"aaBa1a\""
                    },
                    {
                        "username": "hossain2020",
                        "content": "is Aaa123 weak or strong?"
                    },
                    {
                        "username": "MrBloc01",
                        "content": "It should be strong so 0 is the correct output."
                    },
                    {
                        "username": "namehere05",
                        "content": "Con: \\nTook me a week of painstaking coding and ~1000 LOC. Unless this is a take home challenge, I don\\'t see how you can complete anything else than just a superficial discussion of your approach to the solution in 1h of interview\\n\\nPro: \\nI learned quite a bit. A lot of retrospective after I finished the challenge. \\nThe test cases are plenty and trustworthy"
                    },
                    {
                        "username": "dynpl",
                        "content": "for \"aaa111\" the expected output is 2. so \"aaA11A\" is probably correct.\\n\\nthen why is the expected answer for \"FFFFFFFFFFFFFFF11111111111111111111AAA\" 23?\\nwe need to remove 18 characters. after that getting \"FFxFFxFFxFFxFFx11x11\" requires 6 changes. so shouldn\\'t the correct answer be 24?\\n"
                    },
                    {
                        "username": "bohdanpriesnov",
                        "content": "No, there is actually way to do it in 23 steps. Remove 1-A then remove 13-F then remove 4-1, so that size would be 20 then you need to make 5 changes in renaining ones so that there wont be repeating. PS. I haven`t figured out how to do this in code yet as well) "
                    },
                    {
                        "username": "SandroChierici",
                        "content": "Hello Everyone,\\nI think test 16 is not really corrected. It expect output = 1 but in reality test password \"aaaB1\" needs two steps for being corrected: \\nstep 1 : add 1 char \\nstep 2 remove one \\'a\\' from the triplet \"aaa\"\\n"
                    },
                    {
                        "username": "shurazhopa333",
                        "content": "You can add a character inside aaa "
                    },
                    {
                        "username": "user7708N",
                        "content": "\"aaa111\"\nOutput : 1\nExpected : 2\nwhy it expects two steps in this case we need only to change the character \"a\" by an uppercase character to fullfill the rules.\ni think it s an incorrect problem description."
                    },
                    {
                        "username": "eantles",
                        "content": "you have three 1 in a row to replace too"
                    }
                ]
            }
        ]
    }
]