[
    {
        "title": "Climbing Stairs",
        "question_content": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n&nbsp;\nExample 1:\n\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 45",
        "solutions": [
            {
                "id": 25299,
                "title": "basically-it-s-a-fibonacci",
                "content": "The problem seems to be a *dynamic programming* one. **Hint**: the tag also suggests that! \\nHere are the steps to get the solution incrementally. \\n\\n- Base cases:  \\nif n <= 0, then the number of ways should be zero. \\nif n == 1, then there is only way to climb the stair. \\nif n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time. \\n\\n- The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points `[n-1]` and `[n-2]` respectively, denoted as `n1` and `n2` , then the total ways to get to the point `[n]` is `n1 + n2`. Because from the `[n-1]` point, we can take one single step to reach `[n]`. And from the `[n-2]` point, we could take two steps to get there.\\n\\n- The solutions calculated by the above approach are ***complete*** and ***non-redundant***. The two solution sets (`n1`  and `n2`) cover all the possible cases on how the final step is taken. And there would be NO overlapping among the final solutions constructed from these two solution sets, because they differ in the final step. \\n\\nNow given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1. \\n\\nThe implementation in Java as follows: \\n\\n    public int climbStairs(int n) {\\n        // base cases\\n        if(n <= 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int one_step_before = 2;\\n        int two_steps_before = 1;\\n        int all_ways = 0;\\n        \\n        for(int i=2; i<n; i++){\\n        \\tall_ways = one_step_before + two_steps_before;\\n        \\ttwo_steps_before = one_step_before;\\n\\t        one_step_before = all_ways;\\n        }\\n        return all_ways;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The problem seems to be a *dynamic programming* one. **Hint**: the tag also suggests that! \\nHere are the steps to get the solution incrementally. \\n\\n- Base cases:  \\nif n <= 0, then the number of ways should be zero. \\nif n == 1, then there is only way to climb the stair. \\nif n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time. \\n\\n- The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points `[n-1]` and `[n-2]` respectively, denoted as `n1` and `n2` , then the total ways to get to the point `[n]` is `n1 + n2`. Because from the `[n-1]` point, we can take one single step to reach `[n]`. And from the `[n-2]` point, we could take two steps to get there.\\n\\n- The solutions calculated by the above approach are ***complete*** and ***non-redundant***. The two solution sets (`n1`  and `n2`) cover all the possible cases on how the final step is taken. And there would be NO overlapping among the final solutions constructed from these two solution sets, because they differ in the final step. \\n\\nNow given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1. \\n\\nThe implementation in Java as follows: \\n\\n    public int climbStairs(int n) {\\n        // base cases\\n        if(n <= 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int one_step_before = 2;\\n        int two_steps_before = 1;\\n        int all_ways = 0;\\n        \\n        for(int i=2; i<n; i++){\\n        \\tall_ways = one_step_before + two_steps_before;\\n        \\ttwo_steps_before = one_step_before;\\n\\t        one_step_before = all_ways;\\n        }\\n        return all_ways;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1531764,
                "title": "python-detail-explanation-3-solutions-easy-to-difficult-recursion-dictionary-dp",
                "content": "#####\\n### General inutution\\n##### \\t-> Intution : the next distinict way of climbing stairs is euqal to the sum of the last two distinict way of climbing\\n##### \\t\\tdistinct(n) = distinict(n-1) + distinict(n-2)\\n##### This intution can be applied using the following three approach --> ordered from easy to difficult approach\\n#####\\n##### \\n##### \\n#### Idea 1 : pure recursive (Can\\'t pass the test case :does not work for big number, result time-exced limit)\\n##### \\t- The base case will be when only 1 or 2 steps left\\n##### \\t- Result time-exced limit\\n##### \\n        \\n\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n    \\n```\\n#####     \\n#####         \\'\\'\\'\\n####         Idea 2 : use dictionary (look-up table) to memorize repeating recursion\\n#####             - The memory start with the base case and recored every recurssion\\n#####         \\'\\'\\'\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```\\n    \\n#####         \\'\\'\\'\\n###         Idea 3 : Dynamic programming \\n#####             --> store the distinct ways in a dynamic table\\n#####             climb = [climb(0), climb(1), climb(2)=climb(0)+climb(1), climb(3)=climb(2)+climb(1),......climb(n)=climb(n-1)+climb(n-2)]\\n#####             dp = [   0,           1,            2,                               3,                      5,                           dp(i-1)+dp(i-2])]\\n#####             return dp[n]\\n#####         \\'\\'\\'\\n\\tdef climb(n):\\n        #edge cases\\n        if n==0: return 0\\n        if n==1: return 1\\n        if n==2: return 2\\n        dp = [0]*(n+1) # considering zero steps we need n+1 places\\n        dp[1]= 1\\n        dp[2] = 2\\n        for i in range(3,n+1):\\n            dp[i] = dp[i-1] +dp[i-2]\\n        print(dp)\\n        return dp[n]\\n\\t\\t\\t\\n### ******  upvote as a sign of appriatation *****",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n    \\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708750,
                "title": "4-method-s-beat-s-100-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nTo calculate the number of ways to climb the stairs, we can observe that when we are on the nth stair, \\nwe have two options: \\n1. either we climbed one stair from the (n-1)th stair or \\n2. we climbed two stairs from the (n-2)th stair. \\n\\nBy leveraging this observation, we can break down the problem into smaller subproblems and apply the concept of the Fibonacci series. \\nThe base cases are when we are on the 1st stair (only one way to reach it) and the 2nd stair (two ways to reach it). \\nBy summing up the number of ways to reach the (n-1)th and (n-2)th stairs, we can compute the total number of ways to climb the stairs. This allows us to solve the problem efficiently using various dynamic programming techniques such as recursion, memoization, tabulation, or space optimization.\\n\\n# Approach 1: Recursion ```\\u274C TLE \\u274C```\\n**Explanation**: The recursive solution uses the concept of Fibonacci numbers to solve the problem. It calculates the number of ways to climb the stairs by recursively calling the `climbStairs` function for (n-1) and (n-2) steps. However, this solution has exponential time complexity (O(2^n)) due to redundant calculations.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\\n\\n# Approach 2: Memoization\\n**Explanation**: The memoization solution improves the recursive solution by introducing memoization, which avoids redundant calculations. We use an unordered map (`memo`) to store the already computed results for each step `n`. Before making a recursive call, we check if the result for the given `n` exists in the memo. If it does, we return the stored value; otherwise, we compute the result recursively and store it in the memo for future reference.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n, unordered_map<int, int>& memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (memo.find(n) == memo.end()) {\\n            memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n        }\\n        return memo[n];\\n    }\\n\\n    int climbStairs(int n) {\\n        unordered_map<int, int> memo;\\n        return climbStairs(n, memo);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        return climbStairs(n, memo);\\n    }\\n    \\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (!memo.containsKey(n)) {\\n            memo.put(n, climbStairs(n-1, memo) + climbStairs(n-2, memo));\\n        }\\n        return memo.get(n);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        memo = {}\\n        return self.helper(n, memo)\\n    \\n    def helper(self, n: int, memo: dict[int, int]) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        if n not in memo:\\n            memo[n] = self.helper(n-1, memo) + self.helper(n-2, memo)\\n        return memo[n]\\n```\\n\\n# Approach 3: Tabulation\\n**Explanation**: The tabulation solution eliminates recursion and uses a bottom-up approach to solve the problem iteratively. It creates a DP table (`dp`) of size n+1 to store the number of ways to reach each step. The base cases (0 and 1 steps) are initialized to 1 since there is only one way to reach them. Then, it iterates from 2 to n, filling in the DP table by summing up the values for the previous two steps. Finally, it returns the value in the last cell of the DP table, which represents the total number of ways to reach the top.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        vector<int> dp(n+1);\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        int[] dp = new int[n+1];\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n\\n        dp = [0] * (n+1)\\n        dp[0] = dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[n]\\n```\\n\\n# Approach 4: Space Optimization\\n**Explanation**: The space-optimized solution further reduces the space complexity by using only two variables (`prev` and `curr`) instead of an entire DP table. It initializes `prev` and `curr` to 1 since there is only one way to reach the base cases (0 and 1 steps). Then, in each iteration, it updates `prev` and `curr` by shifting their values. `curr` becomes the sum of the previous two values, and `prev` stores the previous value of `curr`.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        prev, curr = 1, 1\\n        for i in range(2, n+1):\\n            temp = curr\\n            curr = prev + curr\\n            prev = temp\\n        return curr\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/f7f5193b-c407-4cc3-93ac-969a8ab8aacf_1688305654.6101635.png)\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\u274C TLE \\u274C```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n, unordered_map<int, int>& memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (memo.find(n) == memo.end()) {\\n            memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n        }\\n        return memo[n];\\n    }\\n\\n    int climbStairs(int n) {\\n        unordered_map<int, int> memo;\\n        return climbStairs(n, memo);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        return climbStairs(n, memo);\\n    }\\n    \\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (!memo.containsKey(n)) {\\n            memo.put(n, climbStairs(n-1, memo) + climbStairs(n-2, memo));\\n        }\\n        return memo.get(n);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        memo = {}\\n        return self.helper(n, memo)\\n    \\n    def helper(self, n: int, memo: dict[int, int]) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        if n not in memo:\\n            memo[n] = self.helper(n-1, memo) + self.helper(n-2, memo)\\n        return memo[n]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        vector<int> dp(n+1);\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        int[] dp = new int[n+1];\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n\\n        dp = [0] * (n+1)\\n        dp[0] = dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[n]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        prev, curr = 1, 1\\n        for i in range(2, n+1):\\n            temp = curr\\n            curr = prev + curr\\n            prev = temp\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25296,
                "title": "3-4-short-lines-in-every-language",
                "content": "Same simple algorithm written in every offered language. Variable `a` tells you the number of ways to reach the current step, and `b` tells you the number of ways to reach the next step. So for the situation one step further up, the old `b` becomes the new `a`, and the new `b` is the old `a+b`, since that new step can be reached by climbing 1 step from what `b` represented or 2 steps from what `a` represented.\\n\\nRuby wins, and *\"the C languages\"* all look the same.\\n\\n**Ruby** (60 ms)\\n\\n    def climb_stairs(n)\\n        a = b = 1\\n        n.times { a, b = b, a+b }\\n        a\\n    end\\n\\n**C++** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Java** (208 ms)\\n\\n    public int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Python** (52 ms)\\n\\n    def climbStairs(self, n):\\n        a = b = 1\\n        for _ in range(n):\\n            a, b = b, a + b\\n        return a\\n\\n**C** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**C#** (48 ms)\\n\\n    public int ClimbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Javascript** (116 ms)\\n\\n    var climbStairs = function(n) {\\n        a = b = 1\\n        while (n--)\\n            a = (b += a) - a\\n        return a\\n    };",
                "solutionTags": [],
                "code": "Same simple algorithm written in every offered language. Variable `a` tells you the number of ways to reach the current step, and `b` tells you the number of ways to reach the next step. So for the situation one step further up, the old `b` becomes the new `a`, and the new `b` is the old `a+b`, since that new step can be reached by climbing 1 step from what `b` represented or 2 steps from what `a` represented.\\n\\nRuby wins, and *\"the C languages\"* all look the same.\\n\\n**Ruby** (60 ms)\\n\\n    def climb_stairs(n)\\n        a = b = 1\\n        n.times { a, b = b, a+b }\\n        a\\n    end\\n\\n**C++** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Java** (208 ms)\\n\\n    public int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Python** (52 ms)\\n\\n    def climbStairs(self, n):\\n        a = b = 1\\n        for _ in range(n):\\n            a, b = b, a + b\\n        return a\\n\\n**C** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**C#** (48 ms)\\n\\n    public int ClimbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Javascript** (116 ms)\\n\\n    var climbStairs = function(n) {\\n        a = b = 1\\n        while (n--)\\n            a = (b += a) - a\\n        return a\\n    };",
                "codeTag": "Python3"
            },
            {
                "id": 3213547,
                "title": "c-python-beats-100-using-dp-2-ways-recursion-memorization-tabulation-space-opt",
                "content": "# Intuition\\nUsing Top - Down Approach -> Recursion + Memorization.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are visiting all values of n atleast 1 time.\\n\\n- Space complexity:\\nO(n) + O(n)  - > (Recursive calls + Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n# Intuition\\nUsing Bottom - up Approach -> Tabulation.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(n) - > (Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n# Python Code :\\nContributed by : Aarya_R\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(1) \\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/995d917b-6ea2-4b6b-8baa-6ce7bc6441fd_1676965776.537627.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```",
                "codeTag": "Java"
            },
            {
                "id": 963994,
                "title": "java-from-recursion-to-dp",
                "content": "**Recustion (Top Down Approach)**\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\n**Recustion + Memorization (Top Down Approach)**\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\\n\\n**DP (Bottom Up Approach)**\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**DP + Optimization (Bottom Up Approach)**\\n\\nTo calculate the new value we only leverage the previous two values. So we don\\'t need to use an array to store all the previous values.\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25313,
                "title": "python-different-solutions-bottom-up-top-down",
                "content": "    \\n    # Top down - TLE\\n    def climbStairs1(self, n):\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        return self.climbStairs(n-1)+self.climbStairs(n-2)\\n     \\n    # Bottom up, O(n) space\\n    def climbStairs2(self, n):\\n        if n == 1:\\n            return 1\\n        res = [0 for i in xrange(n)]\\n        res[0], res[1] = 1, 2\\n        for i in xrange(2, n):\\n            res[i] = res[i-1] + res[i-2]\\n        return res[-1]\\n    \\n    # Bottom up, constant space\\n    def climbStairs3(self, n):\\n        if n == 1:\\n            return 1\\n        a, b = 1, 2\\n        for i in xrange(2, n):\\n            tmp = b\\n            b = a+b\\n            a = tmp\\n        return b\\n        \\n    # Top down + memorization (list)\\n    def climbStairs4(self, n):\\n        if n == 1:\\n            return 1\\n        dic = [-1 for i in xrange(n)]\\n        dic[0], dic[1] = 1, 2\\n        return self.helper(n-1, dic)\\n        \\n    def helper(self, n, dic):\\n        if dic[n] < 0:\\n            dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n        return dic[n]\\n        \\n    # Top down + memorization (dictionary)  \\n    def __init__(self):\\n        self.dic = {1:1, 2:2}\\n        \\n    def climbStairs(self, n):\\n        if n not in self.dic:\\n            self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n        return self.dic[n]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    \\n    # Top down - TLE\\n    def climbStairs1(self, n):\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        return self.climbStairs(n-1)+self.climbStairs(n-2)\\n     \\n    # Bottom up, O(n) space\\n    def climbStairs2(self, n):\\n        if n == 1:\\n            return 1\\n        res = [0 for i in xrange(n)]\\n        res[0], res[1] = 1, 2\\n        for i in xrange(2, n):\\n            res[i] = res[i-1] + res[i-2]\\n        return res[-1]\\n    \\n    # Bottom up, constant space\\n    def climbStairs3(self, n):\\n        if n == 1:\\n            return 1\\n        a, b = 1, 2\\n        for i in xrange(2, n):\\n            tmp = b\\n            b = a+b\\n            a = tmp\\n        return b\\n        \\n    # Top down + memorization (list)\\n    def climbStairs4(self, n):\\n        if n == 1:\\n            return 1\\n        dic = [-1 for i in xrange(n)]\\n        dic[0], dic[1] = 1, 2\\n        return self.helper(n-1, dic)\\n        \\n    def helper(self, n, dic):\\n        if dic[n] < 0:\\n            dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n        return dic[n]\\n        \\n    # Top down + memorization (dictionary)  \\n    def __init__(self):\\n        self.dic = {1:1, 2:2}\\n        \\n    def climbStairs(self, n):\\n        if n not in self.dic:\\n            self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n        return self.dic[n]",
                "codeTag": "Python3"
            },
            {
                "id": 1792723,
                "title": "python-in-depth-walkthrough-explanation-dp-top-down-bottom-up",
                "content": "## Intuition and Approach\\nWe can climb $$n$$ stairs by going up 1 or 2 steps at a time. So if we\\'re currently on step $$i$$, the only places we could get to in one iteration would be steps $$i + 1$$ (if we take 1 step) and $$i + 2$$ (if we take 2 steps).\\n\\nThis means that if we are currently on step $$n$$, our final destination, we could have only gotten there in one of two ways:\\n1. From step $$n - 1$$ , having gone up 1 step to $$n$$\\n2. From step $$n - 2$$, having gone up 2 steps to $$n$$\\n\\nThis highlights that the number of ways to reach step $$n$$ depends on the number of ways to get to step $$n - 1$$ **and** the number of ways to get to step $$n - 2$$. Since both of the above possibilities are valid choices, the number of ways to get to $$n$$ is going to be their **sum**. Thus, we have the following relationship (formally called a **recurrence relation**): $$ways(n) = ways(n - 1) + ways(n - 2)$$\\n\\nLooking at the problem constraints, we see that the smallest possible value of $$n$$ is 1. If we are asked to climb 1 step, the above relationship will not work because $$ways(0)$$ and $$ways(-1)$$ are not defined. More formally, we haven\\'t defined our recurrence\\'s **base case(s)**. We calculate this base case manually: there\\'s only 1 way to climb a singular step - just climb that step! We couldn\\'t possibly take 2 steps in this situation, because then we\\'d be climbing more steps than there are to climb. We notice that if $$n = 2$$, the relationship will also not hold because $$ways(0)$$ is still undefined. Calculating this base case is slightly more involved, but still easy: we can either climb the 2 steps by taking 2 steps, or climb 1 step twice, for a total of 2 ways to climb.\\n\\nTo recap, we have the following relationship, depending on the value of $$n$$:\\n- $$ways(1) = 1 \\\\text{ for } n = 1$$\\n- $$ways(2) = 2 \\\\text{ for } n = 2$$\\n- $$ways(n) = ways(n - 1) + ways(n - 2) \\\\text{ for } n > 2$$\\n\\n\\n---\\n\\n\\n## **Implementation**\\nWe\\'ll explore multiple approaches from simple to more complex, incrementally improving upon each solution. \\n\\n##### **1. Naive recursion**\\nWe can translate the recurrence we came up with earlier into code, as follows:\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\\n\\nHowever, running this yields Time Limit Exceeded. Why is it so inefficient? Let\\'s think about calculating the ways to climb 6 stairs,  `climbStairs(6)`.\\n```\\n                                       climbStairs(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /               \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\tcS(5)       +          cS(4)\\n\\t\\t\\t\\t\\t           /    \\\\                  /    \\\\\\n\\t\\t\\t               cS(4)   +   cS(3)         cS(3) + cS(2)\\n\\t\\t\\t\\t\\t\\t   /  \\\\        /   \\\\         /   \\\\\\n\\t\\t\\t\\t      cS(3) + cS(2) cS(2) + cS(1) cS(2) + cS(1)\\n\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t     cS(2) + cS(1)\\n\\t\\t\\t\\n\\t\\n```\\n\\nAs you can see from the recursion tree above, we are calculating `climbStairs(4)` and `climbStairs(3)` multiple times. Specifically, `climbStairs(4)` is being recalculated twice, while `climbStairs(3)` is being recalculated 3 times. If you think about what happens for larger values of `n`, you can see that we are recalculating a lot of values! \\n\\n**Complexity**\\n* **Time**: Each additional level in the recursion tree is going to have double the amount of calls to `climbingStairs` than the one above it. For $$n$$, this gives us a staggering $$2^n$$ function calls, for a $$O(2^n)$$ time complexity. No wonder we get TLE!\\n* **Space**: We aren\\'t storing any additional variables, so that\\'s a $$O(1)$$ space complexity.\\n\\n\\nCan we avoid repeated computation?\\n\\n##### **2. Memoization (Top-Down DP)** \\nWhat if instead of recomputing each value of `climbStairs`, we made sure to save the unique values (such as `climbingStairs(5)`), trading space for time? That\\'s what a top-down dynamic programming approach called **memoization** is. We make use of a dictionary `memo` in which we store the values of `climbStairs` that we have computed, and if we ever have to compute that value again we just check `memo` in (average) $$O(1)$$ time instead of doing the work all over again. \\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def climb(n):  # inner function to make code simpler\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = climb(n-1) + climb(n-2)\\n                return memo[n]\\n        memo = {1: 1, 2: 2}  # base cases\\n        return climb(n)\\n```\\n\\nWe can also make use of Python\\'s handy `@cache` function decorator that does this for us in the background like so:\\n\\n```\\nclass Solution:\\n\\t@cache\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\\n\\nThis top-down paradigm works well when we approach the problem from the top of the stairs (the last step we needed to climb, $$n$$) down. \\n\\n**Complexity**\\n* **Time**: There are $$O(n)$$ distinct subproblems to solve, each requiring only $$O(1)$$ amount of work of getting the values of smaller subproblems from `memo` and adding them together. When we encounter a subproblem we\\'ve already solved, we can get the answer in $$O(1)$$ time.\\n* **Space**: We are using an additional `memo` dictionary that will store the answer to each subproblem, so $$O(n)$$ space complexity.\\n\\nCan we be even more efficient and avoid the overhead of recursion?\\n\\n\\n**3. Bottom-Up DP**\\nTurns out we can build the solution from the ground up (quite literally in this case). From our recurrence relation, we saw that the number of ways to climb $$n$$ stairs depends on the number of ways to climb $$n - 1$$ and $$n - 2$$ stairs. So instead of approaching the problem top-down and computing these values recursively, we compute them bottom-up, starting with the base cases and building upon the previous values until we reach $$n$$. We use a `dp` array of length $$n + 1$$ (to accomodate for the 0-based indexing of Python; we could just have it be length $$n$$ and return `dp[n - 1]` but in this way we are aligning the step numbers with the indices) and successively build up each index from the previous two.\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        dp = [-1] * (n + 1)  # to accomodate for 0-based indexing \\n        dp[1], dp[2] = 1, 2\\n        for i in range(3, n + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2]\\n        return dp[n]\\n            \\n```\\n\\n**Complexity**\\n* **Time**: As before, we are computing each subproblem once and each subproblem requires constant amount of work (just the addition of the previous 2 elements of the array). That\\'s $$O(n)$$time complexity.\\n* **Space**: Since we are storing the answers to previous subproblems in the `dp` array, this will be $$O(n)$$ too.\\n\\nCan we do even better?\\n\\n**4. Optimizied Bottom-Up DP**\\nWhile the above works well enough, we can optimize our approach even further by making a simple but important observation: we are only utilizing the last 2 subproblem answers when solving each subproblem. If you look at the recurrence again, you can see that the only pieces information we use are $$ways(n - 1)$$ and $$ways(n - 2)$$. Since we\\'re computing from bottom-up, once we compute those answers, the smaller subproblems (such as $$ways(n - 3)$$) are not needed anymore. Thus, instead of keeping the entire `dp` array, we can save some space and just maintain 2 variables that track our last 2 subproblem answers!\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        ways = 0\\n\\t\\t# base cases\\n        two_below_curr = 1  # 2 steps below 3 - ways to take 1 step: 1\\n        one_below_curr = 2  # 1 step below 3 - ways to take 2 steps: 2\\n        for i in range(3, n + 1):\\n            # compute number of ways for i\\n            ways = one_below_curr + two_below_curr\\n            # step up to i + 1   \\n            # 1 step below becomes 2 steps below\\n            # current number of ways becomes 1 step below\\n            two_below_curr, one_below_curr = one_below_curr, ways\\n    \\n        return ways\\n```\\n\\n**Complexity**\\n* **Time**: As before, we are computing each subproblem once and each subproblem requires constant amount of work (just the addition of the previous 2 number of ways). That\\'s $$O(n)$$ time complexity.\\n* **Space**: $$O(1)$$ since we are maintaining 3 extra variables only!\\n\\nAnd that\\'s it! We went from a TLE solution to an elegant and optimized version.\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\n```\\n                                       climbStairs(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /               \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\tcS(5)       +          cS(4)\\n\\t\\t\\t\\t\\t           /    \\\\                  /    \\\\\\n\\t\\t\\t               cS(4)   +   cS(3)         cS(3) + cS(2)\\n\\t\\t\\t\\t\\t\\t   /  \\\\        /   \\\\         /   \\\\\\n\\t\\t\\t\\t      cS(3) + cS(2) cS(2) + cS(1) cS(2) + cS(1)\\n\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t     cS(2) + cS(1)\\n\\t\\t\\t\\n\\t\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def climb(n):  # inner function to make code simpler\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = climb(n-1) + climb(n-2)\\n                return memo[n]\\n        memo = {1: 1, 2: 2}  # base cases\\n        return climb(n)\\n```\n```\\nclass Solution:\\n\\t@cache\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        dp = [-1] * (n + 1)  # to accomodate for 0-based indexing \\n        dp[1], dp[2] = 1, 2\\n        for i in range(3, n + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2]\\n        return dp[n]\\n            \\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        ways = 0\\n\\t\\t# base cases\\n        two_below_curr = 1  # 2 steps below 3 - ways to take 1 step: 1\\n        one_below_curr = 2  # 1 step below 3 - ways to take 2 steps: 2\\n        for i in range(3, n + 1):\\n            # compute number of ways for i\\n            ways = one_below_curr + two_below_curr\\n            # step up to i + 1   \\n            # 1 step below becomes 2 steps below\\n            # current number of ways becomes 1 step below\\n            two_below_curr, one_below_curr = one_below_curr, ways\\n    \\n        return ways\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205775,
                "title": "0ms-java-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        \\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/b84f646e-53f9-4218-a2dc-fb26bcf4746b_1676808521.7800605.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        \\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137892,
                "title": "dp-easy-js-sol-approachable-code",
                "content": "# Intuition\\n\\n-     Dynamic Programming by implementing the Fibonacci Sequence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The approach of the below code is to solve the problem of counting the number of ways to climb stairs using **`Dynamic Programming by implementing the Fibonacci Sequence`**.\\n2. The function calculates the nth number in the fibonacci sequence using a for loop, where n is the number of stairs. \\n3. The first two numbers in the sequence are initialized as 1 and the next numbers are calculated as the sum of the previous two numbers.\\n4. The result, the nth number, is returned as the answer to the number of ways to climb stairs.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the number of stairs.\\n2. Because as it uses a for loop to calculate the fibonacci sequence, it has $$O(n)$$ time complexity.\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because as it only uses a constant amount of extra memory to store a few variables.\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    \\n    if (n < 2) {\\n        return 1;\\n    }\\n    \\n    let firstStep = 1;\\n    \\n    let secondStep = 1;\\n    \\n    let thirdStep = 0;\\n    \\n    for (let i = 2; i <= n; i++) {\\n        \\n        thirdStep = firstStep + secondStep;\\n        \\n        firstStep = secondStep;\\n        \\n        secondStep = thirdStep;\\n    }\\n    return thirdStep;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/af110665-c61e-46b7-9325-161eacdd66f3_1675453763.6499822.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    \\n    if (n < 2) {\\n        return 1;\\n    }\\n    \\n    let firstStep = 1;\\n    \\n    let secondStep = 1;\\n    \\n    let thirdStep = 0;\\n    \\n    for (let i = 2; i <= n; i++) {\\n        \\n        thirdStep = firstStep + secondStep;\\n        \\n        firstStep = secondStep;\\n        \\n        secondStep = thirdStep;\\n    }\\n    return thirdStep;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25345,
                "title": "easy-solutions-for-suggestions",
                "content": "Hi guys, I come up with this arithmetic way. Find the inner logic relations and get the answer.\\n\\n\\n    public class Solution {\\n    \\n    public int climbStairs(int n) {\\n        if(n == 0 || n == 1 || n == 2){return n;}\\n        int[] mem = new int[n];\\n        mem[0] = 1;\\n        mem[1] = 2;\\n        for(int i = 2; i < n; i++){\\n            mem[i] = mem[i-1] + mem[i-2];\\n        }\\n        return mem[n-1];\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public int climbStairs(int n) {\\n        if(n == 0 || n == 1 || n == 2){return n;}",
                "codeTag": "Java"
            },
            {
                "id": 3306307,
                "title": "dynamic-programming-python3",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp=[-1]*(n+2)\\n        def solve(i):\\n            if i==0 or i==1:\\n                return 1\\n            if dp[i]!=-1:\\n                return dp[i]\\n            left=solve(i-1)\\n            right=solve(i-2)\\n            dp[i]=left+right\\n            return left+right\\n        return solve(n)\\n```\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one+two\\n            one=two\\n            two=temp\\n        return two\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp=[-1]*(n+2)\\n        def solve(i):\\n            if i==0 or i==1:\\n                return 1\\n            if dp[i]!=-1:\\n                return dp[i]\\n            left=solve(i-1)\\n            right=solve(i-2)\\n            dp[i]=left+right\\n            return left+right\\n        return solve(n)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one+two\\n            one=two\\n            two=temp\\n        return two\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147963,
                "title": "4-solutions-recursion-memoization-dp-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFibonacci series\\n\\n# Approach\\n\\n\\n\\n- Using the top-down approach of recursion,try to reach stair 0 standing from n.\\n- There are two possible ways at each stair =>take 1 step or 2 steps at a time.\\n- This problem is similar to fibonacci problem.Because the recurrence relation of both these problem is exactly the same.\\n- The base case is:\\n1. When standing at stair 1 or 0 there is only 1 possible way to come to 0.\\n\\n\\n```\\nif(n==0 or n==1) {\\n    return 1\\n}\\nreturn f(n-1)+f(n-2)\\n```\\n\\n# 1.Recursion:(TLE)\\n- For the above recurrence relation, the recusive solution is:\\n```\\nclass Solution {\\npublic:\\n    int findWays(int n){\\n        if(n<=1) return 1; //base case\\n        return findWays(n-1)+findWays(n-2);\\n    }\\n\\n    int climbStairs(int n) {\\n        return findWays(n);\\n    }\\n};\\n```\\n# Complexity\\n\\n- Time complexity: O(2^n)= Exponential time complexity\\n- Space complexity:O(n)=if recursion depth is considered,else:O(1) \\n\\n\\n# 2.Memoization: (Accepted)\\n- In above recusrion, the same subproblems are solved again and again.\\n- This is recomputaion and to avoid it store the results of subproblems which are already solved in dp array.\\n- So when a problem needs to be solved, if it is already solved then directly return the anwswer stored in dp array instead of again computing it.\\n```\\nclass Solution {\\npublic:\\n    int findWays(int n, vector<int> &dp)\\n    {\\n        if (n <= 1) return 1;\\n        if (dp[n] != -1) return dp[n];//already solved subproblems\\n        return dp[n]=findWays(n - 1, dp) + findWays(n - 2, dp); //store the result of subproblem in dp array\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1); //fill all values with -1\\n        return findWays(n,dp);\\n    }\\n};\\n```\\n# Complexity\\n\\n- Time complexity: O(n)= Linear time complexity\\n- Space complexity:O(n)+O(N)= extra space of size n(dp) and recursion depth n \\n\\n\\n# 3.Dynamic Programming: (Accepted)\\n- The above approach requires recursive stack space.\\n- To optimize that space, use bottom-up approach of TABULATION.\\n- Start from base case and based on previous results gradually build the result.\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n         vector<int>dp(n+1,-1);\\n         dp[0]=1,dp[1]=1; //base cases\\n         for(int i=2;i<=n;++i){\\n             dp[i]=dp[i-1]+dp[i-2];\\n         }\\n        return dp[n];\\n    }\\n};\\n```\\n# Complexity\\n\\n- Time complexity: O(n)= Linear time complexity\\n- Space complexity:O(n) = Extra space of size n and no recusrion stack space used. \\n\\n\\n# 4. Space Optimzation of DP (OPTIMAL SOLUTION)\\n- If we carefully observe above tabulation, we only need previous two values to fill current index rather than whole dp array.\\n- So we just maintain only those two values in 2 variables and update them accordingly for subsequent iterations.\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int prev2=1,prev1=1; //initally at 0th and 1st index\\n        \\n        for(int i=2;i<=n;i++){\\n            int curr=prev1+prev2;\\n            prev2=prev1; //update pointers\\n            prev1=curr;\\n        }\\n        return prev1;\\n    }\\n};\\n\\n```\\n---\\n\\n- *Please Leave a like if you found the solution or explanation helpful.*\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nif(n==0 or n==1) {\\n    return 1\\n}\\nreturn f(n-1)+f(n-2)\\n```\n```\\nclass Solution {\\npublic:\\n    int findWays(int n){\\n        if(n<=1) return 1; //base case\\n        return findWays(n-1)+findWays(n-2);\\n    }\\n\\n    int climbStairs(int n) {\\n        return findWays(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findWays(int n, vector<int> &dp)\\n    {\\n        if (n <= 1) return 1;\\n        if (dp[n] != -1) return dp[n];//already solved subproblems\\n        return dp[n]=findWays(n - 1, dp) + findWays(n - 2, dp); //store the result of subproblem in dp array\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1); //fill all values with -1\\n        return findWays(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n         vector<int>dp(n+1,-1);\\n         dp[0]=1,dp[1]=1; //base cases\\n         for(int i=2;i<=n;++i){\\n             dp[i]=dp[i-1]+dp[i-2];\\n         }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int prev2=1,prev1=1; //initally at 0th and 1st index\\n        \\n        for(int i=2;i<=n;i++){\\n            int curr=prev1+prev2;\\n            prev2=prev1; //update pointers\\n            prev1=curr;\\n        }\\n        return prev1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25652,
                "title": "5-lines-of-python",
                "content": "It's essentially Fibonacci number:\\n     \\n    def climbStairs(self, n):\\n        a, b = 1, 1\\n        for i in range(n):\\n            a, b = b, a + b\\n        return a",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's essentially Fibonacci number:\\n     \\n    def climbStairs(self, n):\\n        a, b = 1, 1\\n        for i in range(n):\\n            a, b = b, a + b\\n        return a",
                "codeTag": "Python3"
            },
            {
                "id": 1504255,
                "title": "c-simple-and-easy-fibonacci-solution-with-explanation",
                "content": "**Idea - this is just simple fibonacci!**\\nThe base cases are: \\n* n = 0 -> 0\\n* n = 1 -> 1\\n* n = 2 -> 2\\n\\nThen, for each step `i`, the number of ways to get to it is: either the last step was of 1 step, so we have `prev`, or it was a 2 step, and that\\'s `prev2`, so all together the number of ways to get to our current step is `prev + prev2`.\\nIf we check the first few, we can see clearly that it comes out a fibonacci sequence.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25315,
                "title": "my-dp-solution-in-c-with-explanation",
                "content": "     int climbStairs(int n) \\n    {\\n         vector<int> steps(n,0);\\n         steps[0]=1;\\n         steps[1]=2;\\n         for(int i=2;i<n;i++)\\n         {\\n             steps[i]=steps[i-2]+steps[i-1];\\n         }\\n         return steps[n-1];\\n     }\\n\\nArray 'steps' stands for how many distinct ways to climb to each level (index from 0,  so 0 means level 1, 1 means level 2 and so on.... ).   It's trivial to know it has 1 distinct way to climb to stair 1 , and 2 distinct ways to climb to stair 2 .   For stair level n (n>=3) ,   you can either (1) climb to stair n-2 , and climb 2 more steps to reach n  ,  OR (2) climb to stair n-1, and climb 1 more step to reach n.   That said ,  steps[n]=steps[n-1]+steps[n-2].     In another word,  the number of distinct ways to reach level n is the sum of  number of distinct ways to reach level n-1 and n-2.",
                "solutionTags": [],
                "code": "     int climbStairs(int n) \\n    {\\n         vector<int> steps(n,0);\\n         steps[0]=1;\\n         steps[1]=2;\\n         for(int i=2;i<n;i++)\\n         {\\n             steps[i]=steps[i-2]+steps[i-1];\\n         }\\n         return steps[n-1];\\n     }\\n\\nArray 'steps' stands for how many distinct ways to climb to each level (index from 0,  so 0 means level 1, 1 means level 2 and so on.... ).   It's trivial to know it has 1 distinct way to climb to stair 1 , and 2 distinct ways to climb to stair 2 .   For stair level n (n>=3) ,   you can either (1) climb to stair n-2 , and climb 2 more steps to reach n  ,  OR (2) climb to stair n-1, and climb 1 more step to reach n.   That said ,  steps[n]=steps[n-1]+steps[n-2].     In another word,  the number of distinct ways to reach level n is the sum of  number of distinct ways to reach level n-1 and n-2.",
                "codeTag": "Unknown"
            },
            {
                "id": 3091065,
                "title": "java-no-recursion-100-faster",
                "content": "Initially, i wrote this code :\\n```\\npublic int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-2)+climbStairs(n-1);\\n    }\\n```\\nBut, It yields error as **Time limit Exceeded**. Because this is tree recursion and it is too expensive for this problem. \\nInstead of it, I wrote this code that is very cheapier than the first.\\n\\n```\\nplease upvote, if you found it useful\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-2)+climbStairs(n-1);\\n    }\\n```\n```\\nplease upvote, if you found it useful\\n```\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428533,
                "title": "3-lines-code-faster-than-100-beginner-friendly-detailed-explanation-of-approach",
                "content": "first make a dp array of size (1 more than the maximum value of n)\\nif the value at nth index of dp array is not equal to 0 then simply return it.\\nif the value of n=1 then we can clearlt say that the number of ways are 1 and if n=2 then we can clearly sat that the number of ways of climbing stairs is 2(1+1 , 2)\\nthen make a recursive step of dp\\nthe ways of climbing n staits equal to the sum of climbing (n-1) and (n-2) stairs.\\nthen return dp[n].\\n\\nint dp[46];\\n    int climbStairs(int n) {\\n      \\n      if(dp[n]!=0) return dp[n];\\n      \\n      if(n==1 || n==2) return n;\\n      dp[n]=climbStairs(n-1)+climbStairs(n-2);\\n      return dp[n];\\n      \\n        \\n    }\\n\\t\\n\\t//Guys plz plz plz upvote my solution if you really like and understand it.and comment if you dont able to understand it\\n\\t\\n\\t//Happy Coding Guys",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "first make a dp array of size (1 more than the maximum value of n)\\nif the value at nth index of dp array is not equal to 0 then simply return it.\\nif the value of n=1 then we can clearlt say that the number of ways are 1 and if n=2 then we can clearly sat that the number of ways of climbing stairs is 2(1+1 , 2)\\nthen make a recursive step of dp\\nthe ways of climbing n staits equal to the sum of climbing (n-1) and (n-2) stairs.\\nthen return dp[n].\\n\\nint dp[46];\\n    int climbStairs(int n) {\\n      \\n      if(dp[n]!=0) return dp[n];\\n      \\n      if(n==1 || n==2) return n;\\n      dp[n]=climbStairs(n-1)+climbStairs(n-2);\\n      return dp[n];\\n      \\n        \\n    }\\n\\t\\n\\t//Guys plz plz plz upvote my solution if you really like and understand it.and comment if you dont able to understand it\\n\\t\\n\\t//Happy Coding Guys",
                "codeTag": "Unknown"
            },
            {
                "id": 241466,
                "title": "java-solutions",
                "content": "**Solution 1: Brute-Force Approach**\\n\\nBase cases:\\nif `n == 0`, then the number of ways should be `zero`.\\nif `n == 1`, then there is only `one` way to climb the stair.\\nif `n == 2`, then there are `two` ways to climb the stairs. One solution is `one` step by another; the other one is `two` steps at one time.\\n\\n- We can reach `i`th step in one of the two ways:\\n1. Taking a single step from `(i - 1)`th step\\n2. Taking a step of two from `(i - 2)`th step.\\n- So, the total number of ways to reach `i`th step is equal to sum of ways of reaching `(i - 1)`th step and ways of reaching `(i - 2)`th step.\\n\\nTime complexity: `O(2^n)` - since size of recursion tree will be `2^n`\\nSpace Complexity: `O(n)` - space required for the recursive function call stack.\\n\\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else\\n            return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\n**Solution 2: Dynamic Programming**\\n\\n- This similar to `Solution1`, but here we cache the intermediate results in an array for the performance improvement.\\n- Let `dp[i]` denotes the number of ways to reach on `i`th step, then\\n`dp[i] = dp[i - 1] + dp[i - 2]`\\n\\nTime complexity: `O(n)`\\nSpace Complexity: `O(n)`\\n\\n**Top-Down Approach**\\n```\\nclass Solution\\n{\\n    int[] cache = new int[46];\\n    \\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else if(cache[n] != 0)\\n            return cache[n];\\n        else\\n            return cache[n] = climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\n**Bottom-Up Approach**\\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**Solution 3: Fibonacci Number**\\n\\n- In the above approach of `Solution2`, we have used an array where `dp[i] = dp[i - 1] + dp[i - 2]`. It can be easily analyzed that `dp[i]` is nothing but `i`th Fibonacci number.\\n`Fib(n) = Fib(n - 1) + Fib(n - 2)`\\n- So now we just have to find `n`th number of the Fibonacci series having `1` and `2` as their first and second term respectively, \\ni.e. `Fib(1) = 1` and `Fib(2) = 2`.\\n\\nTime complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int a = 1;\\n        int b = 2;\\n\\n\\t\\tfor(int i = 3; i <= n; i++)\\n\\t\\t{\\n            int sum = a + b;\\n            a = b;\\n            b = sum;\\n        }\\n        return b;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else\\n            return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    int[] cache = new int[46];\\n    \\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else if(cache[n] != 0)\\n            return cache[n];\\n        else\\n            return cache[n] = climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int a = 1;\\n        int b = 2;\\n\\n\\t\\tfor(int i = 3; i <= n; i++)\\n\\t\\t{\\n            int sum = a + b;\\n            a = b;\\n            b = sum;\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861147,
                "title": "clean-python-fibonacci-growth",
                "content": "**Clean Python | Fibonacci Growth**\\n\\nPython solution similar to the Approach N\\xBA 4 (Fibonacci Growth) discussed in the official LeetCode solution:\\n\\nWe basically consider all steps from 1 to n: ```x=[1,2,3,4,...]```. Here we note that we can only reach step number ```x[i]``` by advancing one step from ```x[i-1]``` or two steps from ```x[i-2]```. Based on this insight, we can say with confidence that the total number of alternatives to reach step number ```x[i]``` is ```N[i] = N[i-1]+N[i-2]``` (sum of alternatives at previous steps). This gives us a Fibonacci growth sequence.\\n\\nThe steps ```[i-1]``` and ```[i-2]``` receive the names ```a``` and ```b``` in the code. If we advance in the array ```[...,b,a]```, we can say that new element in the array will be ```c = a+b```. Therefore, we get ```[..., ,b,a,a+b]```. If we iterate in the loop, we note that our variables are updated as ```b,a = a,a+b```, or reversing the order: ```a,b = a+b,a``` (this is what appears in the code).\\n\\nWe return the value of ```a``` at the end of the function, because this is our last step taken. Now regarding the initialization ```a,b=1,0```, this can be a bit tricky. One way to sense of this would be to think that initially we are at ```n=0``` (before taking one step), but ```n=-1``` is nonsense, so we have one alternative at ```n=0``` and zero alternatives at ```n=-1```. If you follow the first elements in the sequence ```[0,1,...]```, you will see that the upcoming sequence ```[1,2,3,...]``` is formed perfectly with this initialization :)\\n\\nTo be honest, I first thought about this initialization as a small hack to get the code running without if-clauses, because I knew the first element would be ```c = a+b = 1+0 = 1``` for ```n=1```, and then having the initial elements ```[1,1]```, the rest of the code would work perfectly lol.\\n\\nI hope the explanation was helpful.\\nCheers,\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n        a,b = 1,0\\n        for _ in range(n):\\n            a,b = a+b,a\\n        return a\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```x=[1,2,3,4,...]```\n```x[i]```\n```x[i-1]```\n```x[i-2]```\n```x[i]```\n```N[i] = N[i-1]+N[i-2]```\n```[i-1]```\n```[i-2]```\n```a```\n```b```\n```[...,b,a]```\n```c = a+b```\n```[..., ,b,a,a+b]```\n```b,a = a,a+b```\n```a,b = a+b,a```\n```a```\n```a,b=1,0```\n```n=0```\n```n=-1```\n```n=0```\n```n=-1```\n```[0,1,...]```\n```[1,2,3,...]```\n```c = a+b = 1+0 = 1```\n```n=1```\n```[1,1]```\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n        a,b = 1,0\\n        for _ in range(n):\\n            a,b = a+b,a\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838261,
                "title": "dynamic-programming-soln-in-c",
                "content": "**Recursive Approach(TLE)**\\n```\\nint climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n```\\n\\n**Top Down Approach**\\n```\\nint t[46]={0};\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1) {t[n]=1; return 1;}\\n        if(n==2) {t[n]=2; return 2;}\\n        else if(t[n]!=0) return t[n];\\n        t[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return t[n];\\n    }\\n};\\n```\\n\\n**Bottom up Approach**\\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        for(int i=0;i<=n;i++) t[i]=0;\\n        t[1]=1;\\n        if(n>=2) t[2]=2;\\n        for(int i=3;i<=n;i++){\\n             t[i] = t[i-1]+t[i-2];    \\n        }\\n        return t[n];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n```\n```\\nint t[46]={0};\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1) {t[n]=1; return 1;}\\n        if(n==2) {t[n]=2; return 2;}\\n        else if(t[n]!=0) return t[n];\\n        t[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return t[n];\\n    }\\n};\\n```\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        for(int i=0;i<=n;i++) t[i]=0;\\n        t[1]=1;\\n        if(n>=2) t[2]=2;\\n        for(int i=3;i<=n;i++){\\n             t[i] = t[i-1]+t[i-2];    \\n        }\\n        return t[n];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044200,
                "title": "c-solution-three-approaches-with-explanation-easy-to-understand",
                "content": "**Approach 1 : (Recursion)**\\n\\n**Recursion** is a programming technique using function or algorithm which calls itself directly or indirectly until a suitable condition is met. In this method, we repeatedly call the function within the same function, and it has a base case and a recursive condition.\\n\\n**It gives us Time Limit Exceeded (TLE)**\\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<0) return 0;\\n        if(n==0 || n==1) return 1;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\\n\\n**Approach 2 : (DP - Memoization / Top Down)**\\n\\n**Memoization** is a technique for improving the performance of recursive algorithms. It involves rewriting the recursive algorithm so that as answers to problems are found, they are stored in an array. Recursive calls can look up results in the array rather than having to recalculate them.\\n\\nWe start our journey from the top most destination state and compute its answer by taking in count the values of states that can reach the destination state, till we reach the bottom-most base state. Hence, it is also called as **Top-Down Approach**\\n\\n**Runtime: 0 ms\\nMemory Usage: 6.2 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &dp,int n){\\n        if(n<0) return 0;\\n        if(n==0 || n==1)    return 1;\\n        if(dp[n]!=-1)   return dp[n];\\n        return dp[n]=helper(dp,n-1)+helper(dp,n-2);\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return helper(dp,n);\\n    }\\n};\\n```\\n\\n**Approach 3 :(DP - Bottom Up / Tabulation)**\\n\\n**Tabulation** is a bottom-up method for solving DP problems.\\nIt goes one level up and combines the solutions it previously obtained to construct the optimal solutions to more complex problems. Eventually, tabulation combines the solutions of the original problem\\'s subproblems and finds its optimal solution.\\n\\n**Runtime: 3 ms\\nMemory Usage: 6.3 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=dp[1]=1;\\n        for(int i=2;i<=n;i++)   \\n            dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**If you liked the solution and understood the approaches well , then please upvote, it motivates me to write more solutions that can help others to understand the concepts well \\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<0) return 0;\\n        if(n==0 || n==1) return 1;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &dp,int n){\\n        if(n<0) return 0;\\n        if(n==0 || n==1)    return 1;\\n        if(dp[n]!=-1)   return dp[n];\\n        return dp[n]=helper(dp,n-1)+helper(dp,n-2);\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return helper(dp,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=dp[1]=1;\\n        for(int i=2;i<=n;i++)   \\n            dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914779,
                "title": "dp-recursion-w-memo-two-js-solutions",
                "content": "```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n\\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612132,
                "title": "easy-solution-in-c-all-approaches-discussed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount manually and find dependencies of solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we observe the pattern by counting manually. For n<=2, the answer is n itself. For n>2, the solution is obtained by adding the solutions to previous two subproblems. So we obtain the recurrenece relation **F(n)=F(n-1)+F(n-2) for n>2.** The naive approach would be to apply recursion. That is, no doubt absolutely correct but not a very fast solution. Applying recursion would give TLE.\\n\\nThe second approach would be to apply recursion and adding memoization, i.e., storing the solution of smaller problems so that we don\\'t have to calculate them again and again while solving the bigger problem. But that also will give TLE.\\n\\nThe third approach is tabulation method. That is basically iterating manually for values 0 to n. The base cases are known to us(n=0,1,2) and we can simply iterate for values over 2 and store them in the vector named dp. This is the fastest solution and gives the correct answer.\\n\\nHowever, the third approach is still not the best one. We store all the values in an additional vector, using space. We know that our solution depends upon the previous two solutions. So instead of storing all the solutions in a vector, we keep the track of the solutions using three variables - prev1, prev2 and prev3. Initially prev1 = 0(n=0 case), prev2=1(n=1 case) and prev3=2(n=2 case). We take another variable curr and run a loop from i=3 to n, updating each variable acccoringly. This is the best solution, as alongwith being the fastest, it does not take up any extra space as well.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nRecursive Solution - O(2^n)\\nRecursion + Memoization Solution - O(n)\\nTabulation Solution - O(n)\\nTabulation + Space Optimization Solution - O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nRecursive Solution - O(n), due to recursive stack\\nRecursion + Memoization Solution - O(n)+O(n)=O(n), due to recursive stack and dp array\\nTabulation Solution - O(n), due to dp array\\nTabulation + Space Optimization Solution - O(1), as no extra space is being used.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //RECURSIVE\\n    int solve(int n) {\\n        if(n<=2) return n;\\n\\n        return solve(n-1)+solve(n-2);\\n    }\\n\\n    //RECURSION+MEMOIZATION - TOP DOWN\\n    int solveTD(int n, vector<int> &dp) {\\n        if(n<=2) return n;\\n        if(dp[n]!=-1) return dp[n];\\n        dp[n]=solve(n-1)+solve(n-2);\\n\\n        return dp[n];\\n    }\\n\\n    //BOTTOM UP APPROACH\\n    int solveBU(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0]=0;\\n        if(n==0) return dp[0];\\n        dp[1]=1;\\n        if(n==1) return dp[1];\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];\\n\\n        return dp[n];\\n    }\\n\\n    int solveBUSpace(int n) {\\n        int prev1 = 0;\\n        int prev2 = 1;\\n        int prev3 = 2;\\n        int curr;\\n\\n        if(n==0) return prev1;\\n        if(n==1) return prev2;\\n        if(n==2) return prev3;\\n\\n        for(int i=3;i<=n;i++) {\\n            curr=prev2+prev3;\\n            prev1=prev2;\\n            prev2=prev3;\\n            prev3=curr;\\n        }\\n        return curr;\\n    }\\n\\n    int climbStairs(int n) {\\n        \\n        //RECURSIVE CALL\\n        // return solve(n);\\n\\n        //TOP DOWN CALL\\n        // vector<int> dp(n+1,-1);\\n        // return solveTD(n,dp);\\n\\n        //BOTTOM UP CALL\\n        // return solveBU(n);\\n\\n        //BOTTOM UP WITH SPACE OPTIMIZATION\\n        return solveBUSpace(n);\\n    }\\n};\\n```\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/6bf23c95-e4dd-4836-9464-c2c640159868_1686204613.032207.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //RECURSIVE\\n    int solve(int n) {\\n        if(n<=2) return n;\\n\\n        return solve(n-1)+solve(n-2);\\n    }\\n\\n    //RECURSION+MEMOIZATION - TOP DOWN\\n    int solveTD(int n, vector<int> &dp) {\\n        if(n<=2) return n;\\n        if(dp[n]!=-1) return dp[n];\\n        dp[n]=solve(n-1)+solve(n-2);\\n\\n        return dp[n];\\n    }\\n\\n    //BOTTOM UP APPROACH\\n    int solveBU(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0]=0;\\n        if(n==0) return dp[0];\\n        dp[1]=1;\\n        if(n==1) return dp[1];\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];\\n\\n        return dp[n];\\n    }\\n\\n    int solveBUSpace(int n) {\\n        int prev1 = 0;\\n        int prev2 = 1;\\n        int prev3 = 2;\\n        int curr;\\n\\n        if(n==0) return prev1;\\n        if(n==1) return prev2;\\n        if(n==2) return prev3;\\n\\n        for(int i=3;i<=n;i++) {\\n            curr=prev2+prev3;\\n            prev1=prev2;\\n            prev2=prev3;\\n            prev3=curr;\\n        }\\n        return curr;\\n    }\\n\\n    int climbStairs(int n) {\\n        \\n        //RECURSIVE CALL\\n        // return solve(n);\\n\\n        //TOP DOWN CALL\\n        // vector<int> dp(n+1,-1);\\n        // return solveTD(n,dp);\\n\\n        //BOTTOM UP CALL\\n        // return solveBU(n);\\n\\n        //BOTTOM UP WITH SPACE OPTIMIZATION\\n        return solveBUSpace(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25436,
                "title": "using-the-fibonacci-formular-to-get-the-answer-directly",
                "content": "    \\nThis is Fibonacci number, and the world has already worked out an formula that\\n\\n![enter image description here][1]\\n\\nand where \\n\\n![enter image description here][2]\\n\\nor you can check the wiki [Fibonacci Number][3]\\n\\nand noticed the Fibonacci begins with F(0)=0, F(1)=1, F(2)=1, F(3)=2\\n\\nbut this problem begins with F'(1)=1, F'(2)=2\\n\\nSo we need a (n++) at the beginning to match the Fibonacci formula\\n\\n    int climbStairs(int n) {\\n        n++;\\n        double root5 = pow(5, 0.5);\\n        double result = 1/root5*( pow((1+root5)/2, n) - pow((1-root5)/2, n) );\\n        return (int)(result);\\n    }\\n\\n\\n  [1]: https://upload.wikimedia.org/math/5/9/9/5992591704ae747ece79e8808dcadd63.png\\n  [2]: https://upload.wikimedia.org/math/4/9/e/49e8a76ceee7c67c84383ebdf06683be.png\\n  [3]: https://en.wikipedia.org/wiki/Fibonacci_number",
                "solutionTags": [],
                "code": "    \\nThis is Fibonacci number, and the world has already worked out an formula that\\n\\n![enter image description here][1]\\n\\nand where \\n\\n![enter image description here][2]\\n\\nor you can check the wiki [Fibonacci Number][3]\\n\\nand noticed the Fibonacci begins with F(0)=0, F(1)=1, F(2)=1, F(3)=2\\n\\nbut this problem begins with F'(1)=1, F'(2)=2\\n\\nSo we need a (n++) at the beginning to match the Fibonacci formula\\n\\n    int climbStairs(int n) {\\n        n++;\\n        double root5 = pow(5, 0.5);\\n        double result = 1/root5*( pow((1+root5)/2, n) - pow((1-root5)/2, n) );\\n        return (int)(result);\\n    }\\n\\n\\n  [1]: https://upload.wikimedia.org/math/5/9/9/5992591704ae747ece79e8808dcadd63.png\\n  [2]: https://upload.wikimedia.org/math/4/9/e/49e8a76ceee7c67c84383ebdf06683be.png\\n  [3]: https://en.wikipedia.org/wiki/Fibonacci_number",
                "codeTag": "Unknown"
            },
            {
                "id": 2760912,
                "title": "plain-and-simple-explaination-100-fast-and-beginner-friendly-please-vote-if-understood",
                "content": "\\n![Screenshot (936).png](https://assets.leetcode.com/users/images/855c97e9-296a-48a8-b3d9-79304a71d5c4_1667155951.7405477.png)\\n\\n\\n# Approach\\nif there is x ways of climbing n-2 stairs and y ways of climbing n-1 stairs, we can say that there are x+y ways of climbing n stairs. we can take 1 step from (n-1)th stair or 2 steps from (n-2)th stair to get to the nth stair.\\n\\nSo ans(n) = ans(n-1)+ans(n-2) i.e. Fibonacci situation.\\n\\nNow we have to calculate for n>=3 only so n=1 and n=2 are already solved cases.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) { //FIBONACCI\\n        if(n<=2)\\n            return n;\\n        int one =1;\\n        int two =2;\\n        for(int i = 3;i<=n;i++){\\n            int temp = one;\\n            one = two;\\n            two+=temp;\\n        }\\n        return two;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) { //FIBONACCI\\n        if(n<=2)\\n            return n;\\n        int one =1;\\n        int two =2;\\n        for(int i = 3;i<=n;i++){\\n            int temp = one;\\n            one = two;\\n            two+=temp;\\n        }\\n        return two;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691420,
                "title": "100-faster-solution-without-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[46];  // because Constraints are: 1 <= n <= 45\\n        arr[0] = 1; // oth stairs should be 1\\n        arr[1] = 1; // 1th stair should be 1\\n        arr[2] = 2; // 2nd stair should be 2\\n        for(int i=3; i<=n; i++){\\n            arr[i] = arr[i-1] + arr[i-2];\\n        }\\n        return arr[n]; // finally returning the answer\\n    }\\n};\\n```\\n\\nIf you like it then pls don\\'t forget to give it a reputation!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[46];  // because Constraints are: 1 <= n <= 45\\n        arr[0] = 1; // oth stairs should be 1\\n        arr[1] = 1; // 1th stair should be 1\\n        arr[2] = 2; // 2nd stair should be 2\\n        for(int i=3; i<=n; i++){\\n            arr[i] = arr[i-1] + arr[i-2];\\n        }\\n        return arr[n]; // finally returning the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725940,
                "title": "js-fibonacci-without-recursion-with-explanation-4-solutions",
                "content": "Solving this problem does not require an understanding of Fibonacci numbers. The Fibonacci numbers are the numbers in the next integer sequence.\\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ........\\n\\n**Fn = Fn-1 + Fn-2**\\n\\nRecursion is often used to solve the problem, but it is not very efficient with large fibonacci numbers, and the complexity of such a program can be very disappointing.\\nTherefore, we will **use dynamic programming.**\\n\\n**Recursive solution example:**\\n```\\n    function fib(n) {\\n    if (n <= 1)\\n        return n;\\n    return fib(n-1) + fib(n-2);\\n}\\n```\\n\\n**Dynamic programming** is basically an optimization of regular recursion. Wherever we see a recursive solution, we can optimize it with dynamic programming. The idea is to simply store the results of the subtasks so that we don\\'t have to recalculate them later when needed. This simple optimization reduces the time complexity from exponential to polynomial.\\n\\nSo, instead of recursing, we\\'ll create variables with the first Fibonacci numbers (1, 1), **not including 0**, and with a simple iteration, we\\'ll update them until we get what we want. \\n\\nWe also add a check, if the values are less than 4, return n, since the Fibonacci number 1 is \\'1\\', 2 is \\'2\\', 3 is \\'3\\', and only starting from 4, we will get a distinctive value.\\n\\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let a = 1, b = 1, fib;\\n    for(let i = 2; i <= n; i++) {\\n        fib = a + b;\\n        a = b;\\n        b = fib;\\n    }\\n    return fib;\\n};\\n```\\n**Time complexity: O(n)\\nExtra space: O(1)**\\n\\nThis solution looks more understandable, but takes up more space than the first one.\\n\\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let fib = [1, 1];\\n    for (let i = 2; i <= n; i++) {\\n        fib[i] = fib[i - 1] + fib[i - 2];\\n    }\\n    return fib[n];\\n};\\n```\\n**Time complexity: O(n) for given n;\\nAuxiliary space: O(n);**\\n\\nAlso, to obtain Fibonacci numbers, you can use the matrix method, it is considered one of the most effective.\\n```\\nconst mul = (\\n    [[a1, a2],[a3, a4]],\\n    [[b1, b2],[b3, b4]]) =>\\n    [[a1 * b1 + a2 * b3, a1 * b2 + a2 * b4],\\n     [a3 * b1 + a4 * b3, a3 * b2 + a4 * b4]];\\n\\nconst matrix = [[0, 1],[1, 1]];\\n\\nconst id = [[1, 0],[0, 1]]\\n\\nvar climbStairs = function(n) {\\n    let result = id;\\n    const bits = (n + 1).toString(2);\\n\\n    for(const bit of bits){\\n        result = mul(result, result);\\n        if(bit === \"1\"){\\n            result = mul(result, matrix);\\n        }\\n    }\\n    return result[1][0];\\n}\\n```\\n**Time complexity: O(Log n)\\nAdditional space: O(Log n)** when considering the size of the function call stack, O(1) otherwise.\\nAnd this is very cool - if, of course, this complexity is really so important to us.\\n\\nI hope I was able to explain clearly.\\n**Happy coding!** \\uD83D\\uDE43",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\n    function fib(n) {\\n    if (n <= 1)\\n        return n;\\n    return fib(n-1) + fib(n-2);\\n}\\n```\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let a = 1, b = 1, fib;\\n    for(let i = 2; i <= n; i++) {\\n        fib = a + b;\\n        a = b;\\n        b = fib;\\n    }\\n    return fib;\\n};\\n```\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let fib = [1, 1];\\n    for (let i = 2; i <= n; i++) {\\n        fib[i] = fib[i - 1] + fib[i - 2];\\n    }\\n    return fib[n];\\n};\\n```\n```\\nconst mul = (\\n    [[a1, a2],[a3, a4]],\\n    [[b1, b2],[b3, b4]]) =>\\n    [[a1 * b1 + a2 * b3, a1 * b2 + a2 * b4],\\n     [a3 * b1 + a4 * b3, a3 * b2 + a4 * b4]];\\n\\nconst matrix = [[0, 1],[1, 1]];\\n\\nconst id = [[1, 0],[0, 1]]\\n\\nvar climbStairs = function(n) {\\n    let result = id;\\n    const bits = (n + 1).toString(2);\\n\\n    for(const bit of bits){\\n        result = mul(result, result);\\n        if(bit === \"1\"){\\n            result = mul(result, matrix);\\n        }\\n    }\\n    return result[1][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25459,
                "title": "memoization-with-recursion-top-down-approach-dynamic-programming-bottom-up",
                "content": "This problem is nothing but a Fibonacci Sequence.\\n\\nLet\\u2019s define a function T(n) for the number of choices available with n stairs(n steps).There are 2 choices for the first step: One choice is to climb only one stair, and has T(n-1) choices for the remaining n-1 stairs. The other one is to jump two stairs at the first step, and has T(n-2) choices for the remaining n-2 stairs. Therefore, the total number of choices for n stairs is T(n) = T(n-1) + T(n- 2), which is the nothing but Fibonacci Sequence.\\n\\nFor example, there are three choices to climb up a stair with three levels: (1) climb in three steps, one stair for each climb; (2) climb in two steps, one level for the first step and two levels for the second; or (3) climb with two steps, two levels for the first step and one level for the last jump.\\n\\nNow if we code a recursive function T(n) = T(n-1) + T(n-2), each recursive call is called twice for large n, making 2^n calls. This is not recommended. Instead, we save result from each call and check if its available before triggering another call. \\n\\nThis type of saving the intermediate results to get final result is called Memoization. Here we follow top-down approach.\\n\\n    int f(int n, int *arr)\\n    {\\n    \\tif (n == 0 || n == 1) return 1;\\n    \\tif (arr[n] != 0) return arr[n];\\n    \\telse{\\n    \\t  arr[n] = f(n - 1, arr) + f(n - 2, arr);\\n    \\t  return arr[n];\\n    \\t}\\n    }\\n\\n    int climbStairs(int n) {\\n    \\tint *p = (int *)malloc(sizeof(int) * (n + 1));\\n    \\tint res, i;\\n    \\t\\n    \\tif (n == 0 || n == 1) p[n] = 1;  //Base condition\\n    \\t\\n    \\tfor (i = 2; i <= n; i++) p[i] = 0; //For memoization, defaulting all values to 0\\n    \\t\\n    \\tres = f(n, p);\\n    \\tfree(p);\\n    \\t\\n    \\treturn res;\\n    }\\n\\nNow this even can be simplified, what we call as 'Dynamic Programming'. Instead of going from top down, we will do bottom up approach. Calculate T(n) for small values and build larger values using them.\\nThe code looks something like this...\\n\\n    ....\\n    store[0] = 1;\\n    store[1] = 1;\\n    for (i = 2; i <=n; i++)\\n        store[i] = store[i - 1] + store[i - 2];\\n    return store[n];\\n    ...",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "This problem is nothing but a Fibonacci Sequence.\\n\\nLet\\u2019s define a function T(n) for the number of choices available with n stairs(n steps).There are 2 choices for the first step: One choice is to climb only one stair, and has T(n-1) choices for the remaining n-1 stairs. The other one is to jump two stairs at the first step, and has T(n-2) choices for the remaining n-2 stairs. Therefore, the total number of choices for n stairs is T(n) = T(n-1) + T(n- 2), which is the nothing but Fibonacci Sequence.\\n\\nFor example, there are three choices to climb up a stair with three levels: (1) climb in three steps, one stair for each climb; (2) climb in two steps, one level for the first step and two levels for the second; or (3) climb with two steps, two levels for the first step and one level for the last jump.\\n\\nNow if we code a recursive function T(n) = T(n-1) + T(n-2), each recursive call is called twice for large n, making 2^n calls. This is not recommended. Instead, we save result from each call and check if its available before triggering another call. \\n\\nThis type of saving the intermediate results to get final result is called Memoization. Here we follow top-down approach.\\n\\n    int f(int n, int *arr)\\n    {\\n    \\tif (n == 0 || n == 1) return 1;\\n    \\tif (arr[n] != 0) return arr[n];\\n    \\telse{\\n    \\t  arr[n] = f(n - 1, arr) + f(n - 2, arr);\\n    \\t  return arr[n];\\n    \\t}\\n    }\\n\\n    int climbStairs(int n) {\\n    \\tint *p = (int *)malloc(sizeof(int) * (n + 1));\\n    \\tint res, i;\\n    \\t\\n    \\tif (n == 0 || n == 1) p[n] = 1;  //Base condition\\n    \\t\\n    \\tfor (i = 2; i <= n; i++) p[i] = 0; //For memoization, defaulting all values to 0\\n    \\t\\n    \\tres = f(n, p);\\n    \\tfree(p);\\n    \\t\\n    \\treturn res;\\n    }\\n\\nNow this even can be simplified, what we call as 'Dynamic Programming'. Instead of going from top down, we will do bottom up approach. Calculate T(n) for small values and build larger values using them.\\nThe code looks something like this...\\n\\n    ....\\n    store[0] = 1;\\n    store[1] = 1;\\n    for (i = 2; i <=n; i++)\\n        store[i] = store[i - 1] + store[i - 2];\\n    return store[n];\\n    ...",
                "codeTag": "Unknown"
            },
            {
                "id": 914746,
                "title": "easy-js-solution-memoization-and-recursion-in-3-lines",
                "content": "```\\nvar climbStairs = function(n, memo = {1:1, 2:2}) {\\n   if (memo[n] !== undefined) return memo[n];   \\n   memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n   return memo[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar climbStairs = function(n, memo = {1:1, 2:2}) {\\n   if (memo[n] !== undefined) return memo[n];   \\n   memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n   return memo[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25338,
                "title": "fibonacci-sequence-solution-in-java",
                "content": "public class Solution {\\n\\n    public int climbStairs(int n) {\\n        if(n < 0)\\n            return 0;\\n        if(n == 1)\\n            return 1;\\n            \\n        int[] store = new int[n];\\n        \\n        store[0] = 1;\\n        store[1] = 2;\\n        \\n        for(int i = 2; i < n; ++i)\\n            store[i] = store[i-1] + store[i-2];\\n            \\n        return store[n-1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int climbStairs(int n) {\\n        if(n < 0)\\n            return 0;\\n        if(n == 1)\\n            return 1;\\n            \\n        int[] store = new int[n];\\n        \\n        store[0] = 1;\\n        store[1] = 2;\\n        \\n        for(int i = 2; i < n; ++i)\\n            store[i] = store[i-1] + store[i-2];\\n            \\n        return store[n-1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 25609,
                "title": "simple-and-clear-2ms-solution-in-c-without-recursion",
                "content": "    class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int StepOne = 1;\\n            int StepTwo = 0;\\n            int ret = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                ret = StepOne + StepTwo;\\n                StepTwo = StepOne;\\n                StepOne = ret;\\n            }\\n            return ret;\\n        }\\n    };\\n\\nThis problem is a Fibonacci problem.\\nF(n)=F(n-1)+F(n-2);\\nSolving this problem by recursion ,we will do a lot of same recursion.\\nExample:\\nF(10)=F(9)+F(8);\\nF(9)=F(8)+F(7);\\nwe calculate F(8) twice,when n is large,this will increase as a rate of n's exponent.\\n\\nSo a more efficient way to solve this problem is from Bottom to Top.\\nCalculate F(0) ,F(1);\\nthen F(2).........",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int StepOne = 1;\\n            int StepTwo = 0;\\n            int ret = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                ret = StepOne + StepTwo;\\n                StepTwo = StepOne;\\n                StepOne = ret;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 346943,
                "title": "simple-understandable-fibonacci-solution",
                "content": "This is fibonacci without recurrsion.\\n\\n```\\nvar climbStairs = function(n) {    \\n    let prev = 0;\\n    let cur = 1;\\n    let temp;\\n    \\n    for (let i = 0; i < n; i++) {\\n        temp = prev;\\n        prev = cur;\\n        cur += temp; \\n    }\\n    return cur;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar climbStairs = function(n) {    \\n    let prev = 0;\\n    let cur = 1;\\n    let temp;\\n    \\n    for (let i = 0; i < n; i++) {\\n        temp = prev;\\n        prev = cur;\\n        cur += temp; \\n    }\\n    return cur;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2791210,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677712,
                "title": "python-4-approaches-with-time-and-space-complexity",
                "content": "Approach 1:- ***Recursion***\\nTC:- ***Exponential (2^n)***\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n        \\n            wayone=stairs(i-1)\\n            waytwo=stairs(i-2)\\n            \\n            return wayone+waytwo\\n        \\n    \\n        return stairs(n)\\n```\\nApproach 2:- ***Recursion+Memoization(Top Down DP)***\\nTC:- ***O(N)*** but space complexity will still have ***stack space*** involved along with ***O(N) Dp array***.\\n\\n```\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i,dp):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n            \\n            if dp[i]!=-1:\\n                return dp[i]\\n        \\n            wayone=stairs(i-1,dp)\\n            waytwo=stairs(i-2,dp)\\n            \\n            dp[i]= wayone+waytwo\\n            \\n            return dp[i]\\n        \\n        dp=[-1]*(n+1)\\n        return stairs(n,dp)\\n```\\nApproach 3:- ***Bottom Up DP*** \\nTC:- ***O(N)*** with ***no stack space*** involved but with a **O(n)  dp array**.\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n,dp):\\n            for i in range(2,n+1):\\n                dp[i]=dp[i-1]+dp[i-2]\\n                \\n            return dp[n]\\n            \\n        dp=[-1]*(n+1)\\n        dp[0]=1\\n        dp[1]=1\\n        return stairs(n,dp)\\n```\\nApproach 4:- ***Space Optimisation technique!!!***\\nTC:- ***O(N) with NO EXTRA SPACE!!!***\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n):\\n            if n==0 or n==1:\\n                return 1\\n                \\n            a=1\\n            b=1\\n            for i in range(2,n+1):\\n                c=a+b\\n                a=b\\n                b=c\\n                \\n            return c\\n           \\n            \\n         return stairs(n)\\n```\\n\\t\\t \\n****Do upvote. :)****\\n    \\n    \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n        \\n            wayone=stairs(i-1)\\n            waytwo=stairs(i-2)\\n            \\n            return wayone+waytwo\\n        \\n    \\n        return stairs(n)\\n```\n```\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i,dp):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n            \\n            if dp[i]!=-1:\\n                return dp[i]\\n        \\n            wayone=stairs(i-1,dp)\\n            waytwo=stairs(i-2,dp)\\n            \\n            dp[i]= wayone+waytwo\\n            \\n            return dp[i]\\n        \\n        dp=[-1]*(n+1)\\n        return stairs(n,dp)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n,dp):\\n            for i in range(2,n+1):\\n                dp[i]=dp[i-1]+dp[i-2]\\n                \\n            return dp[n]\\n            \\n        dp=[-1]*(n+1)\\n        dp[0]=1\\n        dp[1]=1\\n        return stairs(n,dp)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n):\\n            if n==0 or n==1:\\n                return 1\\n                \\n            a=1\\n            b=1\\n            for i in range(2,n+1):\\n                c=a+b\\n                a=b\\n                b=c\\n                \\n            return c\\n           \\n            \\n         return stairs(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282043,
                "title": "python-easy-4-line-dp-36-ms-faster-than-77-83",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        steps = [1,1]\\n        for i in range(2,n+1):\\n            steps.append(steps[i-1] + steps[i-2])\\n        return steps[n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        steps = [1,1]\\n        for i in range(2,n+1):\\n            steps.append(steps[i-1] + steps[i-2])\\n        return steps[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764938,
                "title": "cpp-recursive-memoization-dp-three-solution-easy-to-understand",
                "content": "**Three Solutions step by step \\nfrom recursion to DP**\\n\\n**1. Recursive Solution**\\n**It will give TLE but for better understanding to memoization we have to write it**\\n```\\nclass Solution {\\npublic:\\n    int mk(int n)\\n    {\\n         if(n<0) return 0;\\n         if(n==0) return 1;\\n         return mk(n-1)+mk(n-2); \\n    } \\n    int climbStairs(int n) {\\n        return mk(n);\\n    }\\n};\\n```\\n\\n**2. Memoization of Recursive Solution**\\n\\n**Runtime: 0 ms .\\nMemory Usage: 6.2 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    int mk(int n,vector<int> &memo)\\n    {     \\n         if(n<0) return 0;\\n         if(memo[n]!=-1) return memo[n];\\n         if(n==0) return 1;\\n         return memo[n]=mk(n-1,memo)+mk(n-2,memo);\\n    }\\n     \\n    int climbStairs(int n) {\\n        vector<int> memo(n+1,-1);\\n        return mk(n,memo);\\n    }\\n};\\n```\\n\\n**3. Convert Memoization into dp**\\n\\n**Runtime: 4 ms\\nMemory Usage: 5.9 MB**\\n\\n```\\n class Solution {\\npublic:\\n    \\n    int climbStairs(int n) {\\n\\t    if(n<1) return 0;\\n        int a[100];\\n        a[0]=1;\\n        a[1]=2;\\n        for(int i=2;i<n;i++)\\n            a[i]=a[i-1]+a[i-2];\\n        return a[n-1];\\n    }\\n};\\n```\\n\\n**If any improvement , Kindly comment.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mk(int n)\\n    {\\n         if(n<0) return 0;\\n         if(n==0) return 1;\\n         return mk(n-1)+mk(n-2); \\n    } \\n    int climbStairs(int n) {\\n        return mk(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mk(int n,vector<int> &memo)\\n    {     \\n         if(n<0) return 0;\\n         if(memo[n]!=-1) return memo[n];\\n         if(n==0) return 1;\\n         return memo[n]=mk(n-1,memo)+mk(n-2,memo);\\n    }\\n     \\n    int climbStairs(int n) {\\n        vector<int> memo(n+1,-1);\\n        return mk(n,memo);\\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    \\n    int climbStairs(int n) {\\n\\t    if(n<1) return 0;\\n        int a[100];\\n        a[0]=1;\\n        a[1]=2;\\n        for(int i=2;i<n;i++)\\n            a[i]=a[i-1]+a[i-2];\\n        return a[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399534,
                "title": "one-liner-javascript-typescript-solution-with-recursion",
                "content": "# Complexity\\n- Time complexity: 59 ms\\n- Space complexity: 43.3 MB\\n\\n# Code\\n```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 \\n        ? n \\n        : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\\n\\n# Explanation\\n\\nIf we start making outputs for n starting from 1:\\n\\n### n = 1, Output: 1\\n1. 1 step\\n\\n### n = 2, Output: 2\\n1. 1 step + 1 step\\n2. 2 steps\\n\\n### n = 3, Output: 3\\n1. 1 step + 1 step + 1 step\\n2. 1 step + 2 steps\\n3. 2 steps + 1 step\\n\\n### n = 4, Output: 5\\n1. 1 step + 1 step + 1 step + 1 step\\n2. 1 step + 1 step + 2 steps\\n3. 1 step + 2 steps + 1 step\\n4. 2 steps + 1 step + 1 step\\n5. 2 steps + 2 steps\\n\\nOn a closer look, we can see that these 5 ways are actually:\\n1. 1 step + (1st case of n = 3)\\n2. 1 step + (2nd case of n = 3)\\n3. 1 step + (3rd case of n = 3)\\n4. 2 steps + (1st case of n = 2)\\n5. 2 steps + (2nd case of n = 2)\\n\\ni.e. the output is: (Output for n = 3) + (Output for n = 2)\\n\\n### n = 5, Output: 8\\n1. 1 step + 1 step + 1 step + 1 step + 1 step\\n2. 1 step + 1 step + 1 step + 2 steps\\n3. 1 step + 1 step + 2 steps + 1 step\\n4. 1 step + 2 steps + 1 step + 1 step\\n5. 1 step + 2 steps + 2 steps\\n6. 2 steps + 1 step + 1 step + 1 step\\n7. 2 steps + 1 step + 2 steps\\n8. 2 steps + 2 steps + 1 step\\n\\nSimilarly again, we can see that these 8 ways are actually:\\n1. 1 step + (1st case of n = 4)\\n2. 1 step + (2nd case of n = 4)\\n3. 1 step + (3rd case of n = 4)\\n4. 1 step + (4th case of n = 4)\\n5. 1 step + (5th case of n = 4)\\n6. 2 steps + (1st case of n = 3)\\n7. 2 steps + (2nd case of n = 3)\\n8. 2 steps + (3rd case of n = 3)\\n\\ni.e. the output is: (Output for n = 4) + (Output for n = 3)\\n\\n### Formula\\nSo from above cases, we can see that the output for n = 1 and n = 2 is n. And for n = 3 or > 3 it is: (Output for n - 1) + (Output for n - 2).\\n\\nBecause, for any given n stairs (n >= 3), \\n- if we take 1 step, then we will be left with n - 1 stairs.\\n- and if we take 2 steps, then we will be left with n - 2 stairs.\\n\\nSo, our output will always be: \\n`distinct ways for n stairs = distinct ways for n-1 + distinct ways for n-2`\\n\\nAs our function name is climbStairs, so we can make the formaula using that:\\n`climbStairs(n) = climbStairs(n-1) + climbStairs(n-2)`\\n\\nSo, the code will be like:\\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 2) {\\n        return n;\\n    }\\n    return climbStairs(n - 1) + climbStairs(n - 2);\\n}\\n```\\n\\nIf we submit this solution, it throws runtime error. So we can try to simplify it more:\\n`climbStairs(n) = climbStairs(n-1) + climbStairs(n-2)`\\n`climbStairs(n) = (climbStairs(n-2) + climbStairs(n-3)) + climbStairs(n-2)`\\n(because climbStairs(n-1) = climbStairs(n-2) + climbStairs(n-3))\\n\\nAs the code is doing recursion and here we can see it was calling climbStairs twice for n-2 case in our code. So, to reduce execution time, we can just call it once and multiply it\\'s answer with 2.\\ni.e.\\n`climbStairs(n) = 2 * climbStairs(n-2) + climbStairs(n-3)`\\n\\nMoreover, as we saw for n = 3 case, that the output is 3 i.e. n. So, we can change our if condition to n <= 3, to reduce execution time more.\\n\\n### Final Code\\nSo this makes our solution:\\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 3) {\\n        return n;\\n    }\\n    return 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\\n\\nwhich can be simplified to:\\n\\n```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 ? n : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 \\n        ? n \\n        : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 2) {\\n        return n;\\n    }\\n    return climbStairs(n - 1) + climbStairs(n - 2);\\n}\\n```\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 3) {\\n        return n;\\n    }\\n    return 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\n```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 ? n : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915720,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25368,
                "title": "dynamic-programming-solution-using-java",
                "content": "\\n\\n    /*\\n     * Ideas:\\n     * Use Dynamic Programming,\\n     * for each step, the stair could ether combine with the previous one or as a single step.\\n     * Ways to climb to ith stair is W(i) = W(i-1) + W(i-2)\\n     * where W(i-1) is when the ith stair is as a single step\\n     * and W(i-2) is when the ith stair is paired with the previous one.\\n     */\\n    public int climbStairs(int n) {\\n            int[] tmp = new int[n];\\n            if (n < 2){\\n                return 1;\\n            }\\n            tmp[0] = 1;\\n            tmp[1] = 2;\\n            for (int i = 2; i < n; i++){\\n                tmp[i] = tmp[i-1] + tmp[i-2];\\n            }\\n            return tmp[n-1];\\n        }",
                "solutionTags": [],
                "code": "\\n\\n    /*\\n     * Ideas:\\n     * Use Dynamic Programming,\\n     * for each step, the stair could ether combine with the previous one or as a single step.\\n     * Ways to climb to ith stair is W(i) = W(i-1) + W(i-2)\\n     * where W(i-1) is when the ith stair is as a single step\\n     * and W(i-2) is when the ith stair is paired with the previous one.\\n     */\\n    public int climbStairs(int n) {\\n            int[] tmp = new int[n];\\n            if (n < 2){\\n                return 1;\\n            }\\n            tmp[0] = 1;\\n            tmp[1] = 2;\\n            for (int i = 2; i < n; i++){\\n                tmp[i] = tmp[i-1] + tmp[i-2];\\n            }\\n            return tmp[n-1];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1515325,
                "title": "java-tc-o-logn-sc-o-1-matrix-multiplication-space-optimized-dp-solutions",
                "content": "**Binets Method (Using Matrix Multiplication to find the Fibonacci Number)**\\n\\n```java\\n/**\\n * Binets Method (Using Matrix Multiplication to find the Fibonacci Number)\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1) -> Uses constant complexity\\n *\\n * N = Input number n\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n\\t\\tint[][] q = { { 1, 1 }, { 1, 0 } };\\n        int[][] result = q;\\n        n--; // As we have already solved for n = 1. q[0][0] points to 2nd Fibonacci Number.\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                result = multiplyMatrix(result, q);\\n                if (n == 1) {\\n                    break;\\n                }\\n                n--;\\n            }\\n\\n            q = multiplyMatrix(q, q);\\n            n /= 2;\\n        }\\n\\n        return result[0][0];\\n    }\\n\\n    private int[][] multiplyMatrix(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\n---\\n**Space Optimized Dynamic Programming**\\n\\n```java\\n/**\\n * Space Optimized Dynamic Programming\\n *\\n * DP[i] = DP[i-1] + DP[i-2]\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n        int pre = 1; // n == 1\\n        int cur = 2; // n == 2\\n        for (int i = 3; i <= n; i++) {\\n            int sum = cur + pre;1\\n            pre = cur;\\n            cur = sum;\\n        }\\n        return cur;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Binets Method (Using Matrix Multiplication to find the Fibonacci Number)\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1) -> Uses constant complexity\\n *\\n * N = Input number n\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n\\t\\tint[][] q = { { 1, 1 }, { 1, 0 } };\\n        int[][] result = q;\\n        n--; // As we have already solved for n = 1. q[0][0] points to 2nd Fibonacci Number.\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                result = multiplyMatrix(result, q);\\n                if (n == 1) {\\n                    break;\\n                }\\n                n--;\\n            }\\n\\n            q = multiplyMatrix(q, q);\\n            n /= 2;\\n        }\\n\\n        return result[0][0];\\n    }\\n\\n    private int[][] multiplyMatrix(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\n```java\\n/**\\n * Space Optimized Dynamic Programming\\n *\\n * DP[i] = DP[i-1] + DP[i-2]\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n        int pre = 1; // n == 1\\n        int cur = 2; // n == 2\\n        for (int i = 3; i <= n; i++) {\\n            int sum = cur + pre;1\\n            pre = cur;\\n            cur = sum;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271911,
                "title": "python-dp-fibonacci",
                "content": "To each a specific stair ```x```, we can either climb 1 stair from ```x-1```, or 2 stairs from ```x-2```. Therefore, suppose ```dp[i]``` records the number of ways to reach stair ```i```, ```dp[i] = dp[i-1]+dp[i-2]```. And it\\'s a Fibonacci Array.\\nThe base case is to reach the first stair, we only have one way to do it so dp[1] = 1.\\nBesides, since only dp elements we used is most recent two elements, we can use two pointer to save using of dp array. So space complexity is O(1)/\\n```\\ndef climbStairs(n):\\n\\tcurr = prev = 1\\n\\tfor _ in range(n-1):\\n\\t\\tcurr, prev = curr + prev, curr\\n\\treturn curr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```x```\n```x-1```\n```x-2```\n```dp[i]```\n```i```\n```dp[i] = dp[i-1]+dp[i-2]```\n```\\ndef climbStairs(n):\\n\\tcurr = prev = 1\\n\\tfor _ in range(n-1):\\n\\t\\tcurr, prev = curr + prev, curr\\n\\treturn curr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2765140,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236863,
                "title": "climbing-stairs-all-approaches-well-explained-faster-than-100",
                "content": "**I have shared all four  approaches for the question**\\n**Recursive solution:- Gives TLE if n>=44**\\nt.c-O(2^n)\\ns.c-O(n)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n == 2)\\n        {\\n            return n;\\n        }\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\\n\\n**Memoization method:- Top-Down Approach**\\nt.c-O(n)\\ns.c-O(n) + O(n)\\n```\\nclass Solution {\\npublic:\\n    int calc(int n,vector<int> &dp)\\n    {\\n        if(n<0)\\n            return 0;\\n        if(n==0 || n==1)\\n            return 1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        int left = calc(n-1,dp);\\n        int right = calc(n-2,dp);\\n        return dp[n] = left + right;\\n        \\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return calc(n,dp);\\n    }\\n};\\n```\\n**Tabulation method:- Bottom-up approach**\\nt.c-O(n)\\ns.c-O(n)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**Optimal Approach**\\nt.c-O(n)\\ns.c-O(1)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n==2)\\n        {\\n            return n;\\n        }\\n        int a = 1;\\n        int b = 2;\\n        int c = 0;\\n        for(int i=3;i<=n;i++)\\n        {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return c;\\n    }\\n};\\n```\\nIf you like please upvote",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n == 2)\\n        {\\n            return n;\\n        }\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calc(int n,vector<int> &dp)\\n    {\\n        if(n<0)\\n            return 0;\\n        if(n==0 || n==1)\\n            return 1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        int left = calc(n-1,dp);\\n        int right = calc(n-2,dp);\\n        return dp[n] = left + right;\\n        \\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return calc(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n==2)\\n        {\\n            return n;\\n        }\\n        int a = 1;\\n        int b = 2;\\n        int c = 0;\\n        for(int i=3;i<=n;i++)\\n        {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764847,
                "title": "python-2-solution-dp-fibonacci-math-explained",
                "content": "### Solution 1:\\n\\nWe can climb either `1` or `2` steps, and we are interested how many ways to climb ladder with `n` stairs. How can we reach step number `n`:\\n1. Making step with size `1`, so from step with number `n-1`\\n2. Making step with size `2`, so from step with number `n-2`.\\n\\nSo, if we denote `F[n]` numbers of ways to reach step number `n`, we can write equation: `F[n] = F[n-1] + F[n-2]`. But it is not enough, we also need to define starting cases: `F[1] = 1` and `F[2] = 2`. Or we can say, that `F[0] = 1` and `F[1] = 1`.\\n\\nNow, everything is ready to write our dynamic programming problem.\\n\\n**Complexity**: time complexity is `O(n)` and space complexity is `O(1)`.\\n\\n\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n        dp = (1, 1)\\n        for i in range(n-1):\\n            dp = (dp[1], dp[0] + dp[1])\\n        return dp[1]\\n```\\n\\n### Solution 2\\n\\nIf we look carefully at equation `F[n] = F[n-1] + F[n-2]` and starting points, we can see, that we have nothing else, than Fibonacci sequence:\\n\\n`1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...`\\n\\nNote however, that it is shifted by one position. So, what we need to do is to use Binet formula: https://en.wikipedia.org/wiki/Fibonacci_number#Binet\\'s_formula, where we use computation by rounding.\\n\\n**Complexity**: both time and memory is `O(1)` if we assume that number in `int32` range and if we assume complexity of `**` as `O(1)`.\\n\\n```\\nreturn round((0.5+sqrt(5)/2)**(n+1)/sqrt(5))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n):\\n        dp = (1, 1)\\n        for i in range(n-1):\\n            dp = (dp[1], dp[0] + dp[1])\\n        return dp[1]\\n```\n```\\nreturn round((0.5+sqrt(5)/2)**(n+1)/sqrt(5))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302571,
                "title": "fastest-possible-solution-c-professors-hate-him",
                "content": "# Intuition\\nThey don\\'t teach you this at school\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI AM SPEED\\n\\n# Complexity\\n- Time complexity:O(0)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(45)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        long fast[] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073};\\n\\n        return (int)fast[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        long fast[] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073};\\n\\n        return (int)fast[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893345,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nconst cache: number[] = []\\n\\nfunction climbStairs(n: number): number {\\n  if (n <= 2) return n\\n  if (!cache[n]) { cache[n] = climbStairs(n - 2) + climbStairs(n - 1) }\\n  return cache[n]\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst cache: number[] = []\\n\\nfunction climbStairs(n: number): number {\\n  if (n <= 2) return n\\n  if (!cache[n]) { cache[n] = climbStairs(n - 2) + climbStairs(n - 1) }\\n  return cache[n]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379365,
                "title": "bored-of-long-solution-try-mine-pls-upvote-if-helpful",
                "content": "```\\nclass Solution:\\n    d={1:1,2:2}\\n    def climbStairs(self, n: int) -> int:\\n        if self.d.get(n,0):return self.d.get(n)\\n        self.d[n]=self.climbStairs(n-1)+self.climbStairs(n-2)\\n        return self.d[n]\\n```\\nSee pattern:\\nn=1, output=1\\nn=2, output=2\\nn=3, output=3\\nn=4, output=5\\nn=5, output=8\\n.....\\nBasically, answers are coming in the form of fibonacci series f(n)=f(n-1)+f(n-2).\\nWhat we are doing is storing the value of f(n) at every recursion step in the form of dictionary and we don\\'t need to go to base case for every step. We are just checking at every recursion call if that value of f(n-1) or f(n-2) called by f(n) is already there in dictionary if it\\'s there we reduce number of steps and return the answer to further function call.\\nFor example, take n=6\\ncalls going like this:\\n![image](https://assets.leetcode.com/users/images/85d9f775-a841-4ed8-b29b-52e8ae9bdf39_1627966437.362527.png)\\nI think this might help.\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    d={1:1,2:2}\\n    def climbStairs(self, n: int) -> int:\\n        if self.d.get(n,0):return self.d.get(n)\\n        self.d[n]=self.climbStairs(n-1)+self.climbStairs(n-2)\\n        return self.d[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385821,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int dp[n+1];\\n        dp[1]=1;\\n        dp[0]=1;\\n        for(int i=2;i<=n;i++)dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/dca7255e-0637-4e64-b0ea-eba1eb0291b9_1680770553.0661306.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int dp[n+1];\\n        dp[1]=1;\\n        dp[0]=1;\\n        for(int i=2;i<=n;i++)dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609648,
                "title": "100-faster-solution-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n# Iterative solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        int x=1, y=2;\\n        \\n        for(int i=3; i<n; i++){ // if i<=n\\n            int temp = y;\\n            y += x;\\n            x = temp;\\n        }\\n        return x+y; // return y\\n    }\\n};\\n```\\n\\n# Recursive solution: (*will give TLE*)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        return climbStairs(n-1)+ climbStairs(n-2);\\n    }\\n};\\n```\\n# DP solution:\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int t[n+1];\\n        \\n        t[1]=1;\\n        if(n>=2) t[2]=2; //if we don\\'t give the condition then it will give runtime error for i/p 1\\n        \\n        for(int i=3; i<=n; i++)\\n            t[i]= t[i-1]+t[i-2];\\n        \\n        return t[n];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        int x=1, y=2;\\n        \\n        for(int i=3; i<n; i++){ // if i<=n\\n            int temp = y;\\n            y += x;\\n            x = temp;\\n        }\\n        return x+y; // return y\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        return climbStairs(n-1)+ climbStairs(n-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434721,
                "title": "c-100-o-n-with-explanation",
                "content": "#To climb a stair we have to check the recurrence relation:\\n\\n              climb(n) = climb(n-1) + climb(n-2);   //arr[0]=1&&arr[1]=1; (to reach ground and\\n\\t\\t\\t                                         //first stair we have to take one step only).\\n\\t\\t\\t  \\nwe can either take 1 step or 2 step at once.....so to reach suppose 3rd stair we can either jump 2 steps from 1st stair or 1 step from 2nd stair......so total ways to reach 3rd stair will be sum of total ways to reach 1st stair + 2nd stair.\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint climbStairs(int n) {\\n\\t\\t\\t\\tint arr[n+1];\\n\\t\\t\\t\\tarr[0]=1;\\n\\t\\t\\t\\tarr[1]=1;\\n\\t\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\t\\tarr[i]=arr[i-1]+arr[i-2];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn arr[n];\\n\\t\\t}\\n\\t};                  \\n\\t                  //please upvote if i helped",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint climbStairs(int n) {\\n\\t\\t\\t\\tint arr[n+1];\\n\\t\\t\\t\\tarr[0]=1;\\n\\t\\t\\t\\tarr[1]=1;\\n\\t\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\t\\tarr[i]=arr[i-1]+arr[i-2];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 417563,
                "title": "javascript-very-short",
                "content": "```\\nvar climbStairs = function(n) {\\n    let a = 1, b = 2, next;\\n    \\n    for(let i = 3; i <= n; i++) {\\n        next = a + b;\\n        a = b;\\n        b = next;\\n    }\\n    return n === 1 ? a : b;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar climbStairs = function(n) {\\n    let a = 1, b = 2, next;\\n    \\n    for(let i = 3; i <= n; i++) {\\n        next = a + b;\\n        a = b;\\n        b = next;\\n    }\\n    return n === 1 ? a : b;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231911,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-c-javascript-java",
                "content": "\\n# Approach\\nIn that firstly we created an array that consists of two possibilties just like we did in fibnocci series and then we loop through it and added value in to the index which will be increased on every iteration. At the end we are returning the second last number from the array and this is our expected result we want very simple logic you can clealy understand the code.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code by using For Loop\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let arr = [1,2];\\n    for(let i =2; i <= n; i++){\\n        arr[i] = arr[i - 1] + arr[i - 2]\\n    }\\n    return arr[n-1]\\n};\\n```\\n# Code By using Recursion\\n# Approach\\nwe can also did it by using recursion but in leetcode this is not acceptable due to the big out input when we passed some big number init it will taked time to execute so due to this reason Maximum time is exceeded on leetcode editor you can try it on another editor.\\n```\\nvar climbStairs = (n) => {\\n    if(n <= 1) return 1;\\n    return climbStairs(n - 1) + climbStairs(n - 2)\\n}\\n```\\n\\n##### I am working hard for you guys...\\n##### Please upvote if you found any help with this code...",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let arr = [1,2];\\n    for(let i =2; i <= n; i++){\\n        arr[i] = arr[i - 1] + arr[i - 2]\\n    }\\n    return arr[n-1]\\n};\\n```\n```\\nvar climbStairs = (n) => {\\n    if(n <= 1) return 1;\\n    return climbStairs(n - 1) + climbStairs(n - 2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2810612,
                "title": "4-ways-to-solve-with-detailed-diagrams-no-memoization-beats-100-time-memory",
                "content": "For the lazy one\\'s... here\\'s your solution:\\n\\n# Hackers Approach:\\n```go\\nfunc climbStairs(n int) int {\\n    next, secondNext := 0, 1\\n    for ; n > 0; n-- {\\n        next, secondNext = secondNext, next + secondNext\\n    }\\n    return secondNext\\n}\\n```\\n\\nBut for the more curious types read below for the detailed explaination...\\n\\n\\n# Intuition\\n*Some much necessary research to come up with the solution:*\\n![Untitled4.png](https://assets.leetcode.com/users/images/23dc8877-f265-49b1-b372-3b3b46db7759_1695038975.7068937.png)\\n\\n\\n![Untitled2.png](https://assets.leetcode.com/users/images/8e65a7d5-7dcb-4bcb-b13d-32aaf1fbf9a6_1695038994.3318722.png)\\n\\n![Untitled3.png](https://assets.leetcode.com/users/images/7bca2cec-0a9c-42c0-8368-b1f9a10262f0_1695039072.5319896.png)\\n\\nSample runs:\\n```\\n1 stairs --> [(1)] --> 1 way\\n2 stairs --> [(1,1); (2)] --> 2 ways\\n3 stairs --> [(1,1,1);(2,1); (1,2)] --> 3 ways\\n4 stairs --> [(1,1,1,1);(2,1,1);(1,2,1); (1,1,2);(2,2)] --> 5 ways\\n... so on\\n```\\nwe see the pattern, the ways to climb N stairs is sum total of ways to climb (N-1) stairs plus (N-2) stairs.\\n```\\nways(1) = 1\\nways(2) = 2\\nways(3) = 3 = 2+1 = [1step first => ways(2)] + [2steps first => ways(1)]\\nways(4) = 5 = 3+2 = [1step first => ways(3)] + [2steps first => ways(2)]\\n... so on\\n...\\nways(n) = ways(n-1) + ways(n-2)\\n```\\n\\nLet\\'s appreciate the fact that we\\'ve all solved a **fibonacci** before and this is not much different.\\n\\n\\n# Recursive Approach\\nBased on our intuition, we come up with the following algo:\\n\\n***Recursive solution: O(2^n) time and O(n) space for call stack***\\n```go\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    }\\n    \\n    return climbStairs(n-1) + climbStairs(n-2)    \\n}\\n```\\n\\n> However, the above solution would result in TLE(time limit exceeded) as we will keep on calculating some already calculated values again and again. So, maybe we could store the previous results. Memoization to the rescue.\\nWe can achieve this by modifying the above implementation, like so:\\n\\n# DP Approach\\n***Dynamic Programming solution: O(n) time and O(n) space***\\n![Screenshot 2023-09-18 at 6.06.35 PM.png](https://assets.leetcode.com/users/images/6ddbc852-d2bf-4a7c-a054-16451276cb5e_1695040633.4257736.png)\\n\\n```\\nvar mem map[int]int = map[int]int{}\\n\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    } else if val, ok := mem[n]; ok {\\n        return val\\n    }\\n\\n    res := climbStairs(n-1) + climbStairs(n-2)\\n    mem[n] = res\\n    return res\\n}\\n```\\n\\n> However, this is just waste of space. At any given point, all we need is the previous two calculated results, not all. \\n![IMG_0252.jpg](https://assets.leetcode.com/users/images/f30555a5-0507-4c54-8526-eb0978b31d57_1695040666.829807.jpeg)\\nNot to mention the space needed for the recursion call stack. We can avoid an O(2n) space by getting rid of the recursion and unused memoized values in the above implementation, like so:\\n\\n\\n# Iterative Approach\\n***Iterative Solution: O(n) time and O(1) space***\\n\\n\\n```\\nfunc climbStairs(n int) int {\\n    res := 0\\n    \\n    secondNext := 0\\n    next := 0\\n    for i := 1; i <= n; i++ {\\n        if i == 1 {\\n            res = 1\\n        } else if i == 2 {\\n            res = 2\\n        } else {\\n            res = secondNext + next\\n        }\\n        \\n        next = secondNext\\n        secondNext = res\\n    }\\n    \\n    return res\\n}\\n```\\n\\n> a few more hacks to slim down this code above and you\\'ll end up with the concise code shared at the top...\\nOr, we could come up with this algo directly, without needing to build upon all the above iterations. Let\\'s answer a few questions for that:\\n\\n_Q: How many ways are there to climb up to the floor?_\\n_A: Duh! Zero_\\n\\n_Q: How many ways can I climb up to the first step?_\\n_A: One. Yeah just One._\\n\\n_Q: How many ways can I climb up to the 2nd step?_\\n_A: Uhmm! Either I take 2 steps from the floor or, I take 1 step from the 1st step._\\n\\n_Q: So how many ways is that?_\\n_A: Two_\\n\\n_Q: Cool, now how many ways can I climb up to the 3rd step?_\\n_A: 2 Ways. Either I take 2 steps from the 1st step or, I take 1 step from the 2nd step._\\n\\n_Q: Nope, to take 1 step from the 2nd step, you need to first reach the 2nd step, and there are more than 1 ways to reach. We need to consider all those ways too. We already calculated it earlier. So how many now?_\\n_A: X ways to reach step 1st step + Y ways to reach 2nd step_\\n_That should be `1 + 2 = 3`_\\n\\n_Q: Great, Now to reach 4th step...?_\\n_A: 1 step from the 3rd step or 2 steps from the 2nd step_\\n_that is, `ways to reach 3rd step + ways to reach 2nd step = 3 + 2 = 5`_\\n\\n_Q: Awesome, can we generalize it?_\\n_A: Yes, `ways to reach given step = ways to reach last step + ways to reach second-last step`_\\n\\n_Q: How can we find ways to reach the `N-th` step?_\\n_A: Simple, we use the result from previous 2 runs and repeat this process N times._\\n\\n_Q: A where do we start?_\\n_A: from the floor. lol. `secondLast=0` and `last=1`.\\n\\n_Q: Can we write the code now?_\\n_A: Ofcourse_\\n```go\\nfunc climbStairs(n int) int {\\n    secondLast, last := 0, 1\\n    for i:=1; i<=n; i++ {\\n        secondLast, last = last, secondLast + last\\n    }\\n    return last\\n}\\n```\\n\\n\\n\\n#### PS: Please upvote if you liked the explanatoin and appreciate my effort, helps it reaching others who need it. Thanks :)\\nStay motivated. \\n\\n\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc climbStairs(n int) int {\\n    next, secondNext := 0, 1\\n    for ; n > 0; n-- {\\n        next, secondNext = secondNext, next + secondNext\\n    }\\n    return secondNext\\n}\\n```\n```\\n1 stairs --> [(1)] --> 1 way\\n2 stairs --> [(1,1); (2)] --> 2 ways\\n3 stairs --> [(1,1,1);(2,1); (1,2)] --> 3 ways\\n4 stairs --> [(1,1,1,1);(2,1,1);(1,2,1); (1,1,2);(2,2)] --> 5 ways\\n... so on\\n```\n```\\nways(1) = 1\\nways(2) = 2\\nways(3) = 3 = 2+1 = [1step first => ways(2)] + [2steps first => ways(1)]\\nways(4) = 5 = 3+2 = [1step first => ways(3)] + [2steps first => ways(2)]\\n... so on\\n...\\nways(n) = ways(n-1) + ways(n-2)\\n```\n```go\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    }\\n    \\n    return climbStairs(n-1) + climbStairs(n-2)    \\n}\\n```\n```\\nvar mem map[int]int = map[int]int{}\\n\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    } else if val, ok := mem[n]; ok {\\n        return val\\n    }\\n\\n    res := climbStairs(n-1) + climbStairs(n-2)\\n    mem[n] = res\\n    return res\\n}\\n```\n```\\nfunc climbStairs(n int) int {\\n    res := 0\\n    \\n    secondNext := 0\\n    next := 0\\n    for i := 1; i <= n; i++ {\\n        if i == 1 {\\n            res = 1\\n        } else if i == 2 {\\n            res = 2\\n        } else {\\n            res = secondNext + next\\n        }\\n        \\n        next = secondNext\\n        secondNext = res\\n    }\\n    \\n    return res\\n}\\n```\n```go\\nfunc climbStairs(n int) int {\\n    secondLast, last := 0, 1\\n    for i:=1; i<=n; i++ {\\n        secondLast, last = last, secondLast + last\\n    }\\n    return last\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2712423,
                "title": "simple-python-solution-using-dynamic-programming",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677807,
                "title": "comprehensive-python-explanation",
                "content": "The key here is that we can climb 1 or 2 steps at each point. Therefore, the number of ways to climb ```n``` steps is equal to the number of ways to climb ```n-1``` steps + the number of ways to climb ```n-2``` steps since we can reach the ```n```th step from either of these two previous steps. This is actually the exact same as the fibonnaci sequence, meaning we can solve this problem exactly like we would solve [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/?envType=study-plan&id=level-1).\\n\\n**Basic Recursion Solution; Time: O(2^N), Space: O(1) --> TLE**\\n```\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\\nThis is the most basic solution, taking advantage of the recursive relationship we explored above. However, it is quite slow and results in a time limit exception because it has a time complextiy of ```O(2^N)``` since we need to make 2 recursive calls at each point and those recursive calls make recursive calls of their own. This can be illustrated with the following diagram about the fibonnaci sequence (credit to [Prateek Narang](https://www.scaler.com/topics/fibonacci-series-in-c/)):\\n![image](https://assets.leetcode.com/users/images/0b8e23d2-abd9-4553-b622-5efb833ba81a_1665202511.7852473.png)\\nTo improve on this solution, we can use memoization, one of the core DP techniques. Memoization just means storing our previous results. One way to do this is with python\\'s built in ```@cache```, which stores previous return values from a function call.\\n\\n**Cache Memoization Solution: Time: O(N), Space: O(N)**\\n```\\n@cache # store previous results\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\\nThe time complexity is now ```O(N)``` since we only need to make one calculation for every value from ```1``` to ```n```. The space is also ```O(N)``` since we are now storing the answers to recursive calls to ```climbStairs```. This solution is probably not what an interviewer wants though, so let\\'s store the results ourselves by using a list where the ```i```th index corresponds to the result of ```climbStairs(i+1)```.\\n\\n**List Memoization Solution; Time: O(N), Space: O(N)**\\n```\\ndef climbStairs(self, n):\\n\\tdistinct_ways = [1,2] # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways.append(distinct_ways[-1] + distinct_ways[-2]) # can come from either of the last two steps\\n\\treturn distinct_ways[n-1] # how many ways to go up n stairs\\n```\\nThis is a great solution, but we can do even better! When we add the newest number to ```distinct_ways``` , we actually only need to access the previous numbers in ```distinct_ways```, so we can just use a tuple to store the last two!\\n\\n**Optimized Memoization Solution; Time: O(N), Space: O(1)**\\n```\\ndef climbStairs(self, n):\\n\\tif n == 1: # only 1 way to go up 1 step\\n\\t\\treturn 1\\n\\tdistinct_ways = (1,2) # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways = (distinct_ways[1], distinct_ways[0] + distinct_ways[1]) # the previous number of ways becomes the second previous number of ways and the previous number of ways becomes the sum of the last two\\n\\treturn distinct_ways[1] # how many ways to go up n stairs\\n```\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! If you have any questions, please feel free to ask in the comments and I will try to answer them. Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```n```\n```n-1```\n```n-2```\n```n```\n```\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\n```O(2^N)```\n```@cache```\n```\\n@cache # store previous results\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\n```O(N)```\n```1```\n```n```\n```O(N)```\n```climbStairs```\n```i```\n```climbStairs(i+1)```\n```\\ndef climbStairs(self, n):\\n\\tdistinct_ways = [1,2] # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways.append(distinct_ways[-1] + distinct_ways[-2]) # can come from either of the last two steps\\n\\treturn distinct_ways[n-1] # how many ways to go up n stairs\\n```\n```distinct_ways```\n```distinct_ways```\n```\\ndef climbStairs(self, n):\\n\\tif n == 1: # only 1 way to go up 1 step\\n\\t\\treturn 1\\n\\tdistinct_ways = (1,2) # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways = (distinct_ways[1], distinct_ways[0] + distinct_ways[1]) # the previous number of ways becomes the second previous number of ways and the previous number of ways becomes the sum of the last two\\n\\treturn distinct_ways[1] # how many ways to go up n stairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2383701,
                "title": "fastest-solution-explained-0ms-100-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n* *** Java ***\\n\\nRecustion (Top Down Approach)\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\nRecustion + Memorization (Top Down Approach)\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\\n\\nDP (Bottom Up Approach)\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n\\nDP + Optimization (Bottom Up Approach)\\n\\nTo calculate the new value we only leverage the previous two values. So we don\\'t need to use an array to store all the previous values.\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 10MB*** (beats 100.00% / 95.49%).\\n* *** Python ***\\n\\n```\\n\\n# Top down - TLE\\ndef climbStairs1(self, n):\\n    if n == 1:\\n        return 1\\n    if n == 2:\\n        return 2\\n    return self.climbStairs(n-1)+self.climbStairs(n-2)\\n \\n# Bottom up, O(n) space\\ndef climbStairs2(self, n):\\n    if n == 1:\\n        return 1\\n    res = [0 for i in xrange(n)]\\n    res[0], res[1] = 1, 2\\n    for i in xrange(2, n):\\n        res[i] = res[i-1] + res[i-2]\\n    return res[-1]\\n\\n# Bottom up, constant space\\ndef climbStairs3(self, n):\\n    if n == 1:\\n        return 1\\n    a, b = 1, 2\\n    for i in xrange(2, n):\\n        tmp = b\\n        b = a+b\\n        a = tmp\\n    return b\\n    \\n# Top down + memorization (list)\\ndef climbStairs4(self, n):\\n    if n == 1:\\n        return 1\\n    dic = [-1 for i in xrange(n)]\\n    dic[0], dic[1] = 1, 2\\n    return self.helper(n-1, dic)\\n    \\ndef helper(self, n, dic):\\n    if dic[n] < 0:\\n        dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n    return dic[n]\\n    \\n# Top down + memorization (dictionary)  \\ndef __init__(self):\\n    self.dic = {1:1, 2:2}\\n    \\ndef climbStairs(self, n):\\n    if n not in self.dic:\\n        self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n    return self.dic[n]\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 23.7MB*** (beats 59.24% / 60.42%).\\n* *** C++ ***\\n\\n**Idea - this is just simple fibonacci!**\\nThe base cases are:\\n\\n* n = 0 -> 0\\n* n = 1 -> 1\\n* n = 2 -> 2\\n\\nThen, for each step i, the number of ways to get to it is: either the last step was of 1 step, so we have prev, or it was a 2 step, and that\\'s prev2, so all together the number of ways to get to our current step is prev + prev2.\\nIf we check the first few, we can see clearly that it comes out a fibonacci sequence.\\n\\nTime Complexity: **O(n)**\\nSpace Complexity: **O(1)**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 78MB*** (beats 100.00% / 100.00%).\\n* *** JavaScript ***\\n\\n```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 15.23MB*** (beats 89.94% / 90.99%).\\n* *** Python3 ***\\n\\n\\nGeneral inutution\\n-> Intution : the next distinict way of climbing stairs is euqal to the sum of the last two distinict way of climbing\\ndistinct(n) = distinict(n-1) + distinict(n-2)\\nThis intution can be applied using the following three approach --> ordered from easy to difficult approach\\n\\n\\n\\nIdea 1 : pure recursive (Can\\'t pass the test case :does not work for big number, result time-exced limit)\\n- The base case will be when only 1 or 2 steps left\\n- Result time-exced limit\\n\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n```\\n\\n\\'\\'\\'\\nIdea 2 : use dictionary (look-up table) to memorize repeating recursion\\n- The memory start with the base case and recored every recurssion\\n\\'\\'\\'\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```\\n\\'\\'\\'\\nIdea 3 : Dynamic programming\\n--> store the distinct ways in a dynamic table\\nclimb = [climb(0), climb(1), climb(2)=climb(0)+climb(1), climb(3)=climb(2)+climb(1),......climb(n)=climb(n-1)+climb(n-2)]\\ndp = [ 0, 1, 2, 3, 5, dp(i-1)+dp(i-2])]\\nreturn dp[n]\\n\\'\\'\\'\\n```\\ndef climb(n):\\n    #edge cases\\n    if n==0: return 0\\n    if n==1: return 1\\n    if n==2: return 2\\n    dp = [0]*(n+1) # considering zero steps we need n+1 places\\n    dp[1]= 1\\n    dp[2] = 2\\n    for i in range(3,n+1):\\n        dp[i] = dp[i-1] +dp[i-2]\\n    print(dp)\\n    return dp[n]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 33.33MB*** (beats 99.00% / 60.12%).\\n* *** Kotlin ***\\n\\n\\n```\\n\\nfun climbStairs(n: Int): Int {\\n      tailrec fun fib(i: Int, first: Int, second: Int): Int =\\n          if (i == n)\\n              first + second\\n          else\\n              fib(i + 1, first = second, second = first + second)\\n\\n      return fib(1, 0, 1)\\n}\\n\\n```\\n\\n* Base case: First steir - we have just 1 option, Second stair - same, only one option.\\n* Starting from 3rd stair Iterate over stairs,\\nnumber of posiible stair options - is a sum of possible options for previous stair + pre-previous, since we can move by 2 stairs in one step.\\n\\n```\\nTime complexity - O(n) - iterate through all n stairs\\nSpace complexity - O(n+1) - space for dp array\\n```\\n\\n```\\nfun climbStairs(n: Int): Int {\\n    val dp = IntArray(n + 1)\\n\\n    dp[0] = 1\\n    dp[1] = 1\\n\\n    for (i in 2..n) {\\n        dp[i] = dp[i - 1] + dp[i - 2]\\n    }\\n    return dp[n]\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 13.17MB*** (beats 79.34% / 99.92%).\\n* *** Swift ***\\n\\n\\n```\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 62.07MB*** (beats 99.99% / 99.99%).\\n* *** PHP ***\\n\\n\\n```\\n\\nfunction climbStairs($n) {\\n\\n    $arr = [NULL, 1, 2];\\n    for($i = 3; $i <= $n; $i++)\\n      $arr[$i] = $arr[$i-1] + $arr[$i-2];\\n\\n    return $arr[$n];\\n}\\n\\n```\\n\\n```\\nfunction climbStairs($n) {\\n            return round(pow((sqrt(5)+1)/2, $n+1) / sqrt(5));\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 1.17MB*** (beats 99.64% / 99.92%).\\n* *** C ***\\n\\n\\n```\\n\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n\\n```\\n\\n```\\nint climbStairs(int n){\\n    if(n==1) return 1;\\n    else if(n==2) return 2;\\n    else\\n    {\\n        int sum = 0,s1 = 1,s2 = 2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            sum=s1+s2;\\n            s1 = s2;\\n            s2 = sum;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\n# Top down - TLE\\ndef climbStairs1(self, n):\\n    if n == 1:\\n        return 1\\n    if n == 2:\\n        return 2\\n    return self.climbStairs(n-1)+self.climbStairs(n-2)\\n \\n# Bottom up, O(n) space\\ndef climbStairs2(self, n):\\n    if n == 1:\\n        return 1\\n    res = [0 for i in xrange(n)]\\n    res[0], res[1] = 1, 2\\n    for i in xrange(2, n):\\n        res[i] = res[i-1] + res[i-2]\\n    return res[-1]\\n\\n# Bottom up, constant space\\ndef climbStairs3(self, n):\\n    if n == 1:\\n        return 1\\n    a, b = 1, 2\\n    for i in xrange(2, n):\\n        tmp = b\\n        b = a+b\\n        a = tmp\\n    return b\\n    \\n# Top down + memorization (list)\\ndef climbStairs4(self, n):\\n    if n == 1:\\n        return 1\\n    dic = [-1 for i in xrange(n)]\\n    dic[0], dic[1] = 1, 2\\n    return self.helper(n-1, dic)\\n    \\ndef helper(self, n, dic):\\n    if dic[n] < 0:\\n        dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n    return dic[n]\\n    \\n# Top down + memorization (dictionary)  \\ndef __init__(self):\\n    self.dic = {1:1, 2:2}\\n    \\ndef climbStairs(self, n):\\n    if n not in self.dic:\\n        self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n    return self.dic[n]\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\n```\\n```\n```\\n```\n```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```\n```\\ndef climb(n):\\n    #edge cases\\n    if n==0: return 0\\n    if n==1: return 1\\n    if n==2: return 2\\n    dp = [0]*(n+1) # considering zero steps we need n+1 places\\n    dp[1]= 1\\n    dp[2] = 2\\n    for i in range(3,n+1):\\n        dp[i] = dp[i-1] +dp[i-2]\\n    print(dp)\\n    return dp[n]\\n```\n```\\n```\n```\\n```\n```\\n\\nfun climbStairs(n: Int): Int {\\n      tailrec fun fib(i: Int, first: Int, second: Int): Int =\\n          if (i == n)\\n              first + second\\n          else\\n              fib(i + 1, first = second, second = first + second)\\n\\n      return fib(1, 0, 1)\\n}\\n\\n```\n```\\nTime complexity - O(n) - iterate through all n stairs\\nSpace complexity - O(n+1) - space for dp array\\n```\n```\\nfun climbStairs(n: Int): Int {\\n    val dp = IntArray(n + 1)\\n\\n    dp[0] = 1\\n    dp[1] = 1\\n\\n    for (i in 2..n) {\\n        dp[i] = dp[i - 1] + dp[i - 2]\\n    }\\n    return dp[n]\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nfunction climbStairs($n) {\\n\\n    $arr = [NULL, 1, 2];\\n    for($i = 3; $i <= $n; $i++)\\n      $arr[$i] = $arr[$i-1] + $arr[$i-2];\\n\\n    return $arr[$n];\\n}\\n\\n```\n```\\nfunction climbStairs($n) {\\n            return round(pow((sqrt(5)+1)/2, $n+1) / sqrt(5));\\n    }\\n```\n```\\n```\n```\\n```\n```\\n\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n\\n```\n```\\nint climbStairs(int n){\\n    if(n==1) return 1;\\n    else if(n==2) return 2;\\n    else\\n    {\\n        int sum = 0,s1 = 1,s2 = 2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            sum=s1+s2;\\n            s1 = s2;\\n            s2 = sum;\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567398,
                "title": "go-solution",
                "content": "```\\nfunc climbStairs(n int) int {\\n    a, b := 1, 1\\n    for ; n > 1; n-- {\\n        a, b = b, a + b\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc climbStairs(n int) int {\\n    a, b := 1, 1\\n    for ; n > 1; n-- {\\n        a, b = b, a + b\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283874,
                "title": "simple-dp-javascript-fibonacci-solution-js",
                "content": "```\\nvar climbStairs = function(n) {\\n    if (n < 3) return n;\\n    let first = 1;\\n    let second = 2;\\n    for (let i = 3; i <= n; i++) {\\n        const current = first + second;\\n\\t\\t// Update first and second for next loop\\n        first = second;\\n        second = current;\\n    }\\n\\t// When loop fininshes, second is pointing to the result of the last index, which is the result of the whole function\\n    return second;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar climbStairs = function(n) {\\n    if (n < 3) return n;\\n    let first = 1;\\n    let second = 2;\\n    for (let i = 3; i <= n; i++) {\\n        const current = first + second;\\n\\t\\t// Update first and second for next loop\\n        first = second;\\n        second = current;\\n    }\\n\\t// When loop fininshes, second is pointing to the result of the last index, which is the result of the whole function\\n    return second;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2686525,
                "title": "c-0ms-100-faster-solution-using-dp",
                "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        int c = solve(n+1,dp);\\n        return c;\\n    }\\n    \\npublic:\\n    int solve(int n,vector<int>dp)\\n    {\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i = 2;i < n; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        int c = solve(n+1,dp);\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2567823,
                "title": "java-100-fast-4-lines-code-climbing-stairs",
                "content": "**If you find my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have any queries or any improvements please feel free to comment and share your views.**\\n\\nNOTE : its acutally a fibanacci pattern,\\n1 step = 1 stair, 2 step = 2 stair, 3 step = 3 stair , 4 step = 5 stair, 5 step = 8 stair , etc..\\nfibannaci pattern : 0,1,1,2,3,5,8,13...... \\n\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int a =0;\\n        int b=1;\\n        int sum =0;\\n        for(int i=0;i<n;i++){\\n            sum=a+b;\\n            a=b;\\n            b=sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int a =0;\\n        int b=1;\\n        int sum =0;\\n        for(int i=0;i<n;i++){\\n            sum=a+b;\\n            a=b;\\n            b=sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25298,
                "title": "python-solution-beats-96-with-factorial",
                "content": "The basic idea is to get all possible permutations of fixed # of 1 and 2 \\n```\\nfrom math import factorial\\ndef climbStairs(self, n):\\n    res= 0\\n    two = n//2\\n\\n    for i in range(two+1):\\n        t = i           # number of twos\\n        o = n-t*2       # number of ones\\n        res += factorial(t+o)/(factorial(t)*factorial(o))     # (two+one)!/ (two!*one!)\\n            \\n    return res\\n```\\n\\ne.g.\\n5 stairs in total, so we get:\\n1) 0 two, 5 ones  -> 1 permutation \\n2) 1 two, 3 ones  -> (3+1)!/(3!*1!) = 4 permutations\\n3) 2 twos, 1 one -> (2+1)!/(2!*1!) = 3 permutations\\n\\n1+4+3 = 8 in total\\n\\nThis is my first time to post...\\nHope you like my solution :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import factorial\\ndef climbStairs(self, n):\\n    res= 0\\n    two = n//2\\n\\n    for i in range(two+1):\\n        t = i           # number of twos\\n        o = n-t*2       # number of ones\\n        res += factorial(t+o)/(factorial(t)*factorial(o))     # (two+one)!/ (two!*one!)\\n            \\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25522,
                "title": "0ms-o-n-constant-space-java-solution",
                "content": "      public int climbStairs(int n) {\\n        if(n==1||n==0)\\n            return n;\\n        int count1=1;\\n        int count2=1;\\n        \\n        \\n        for(int i=2; i<=n; i++){\\n            int temp = count2;\\n            count2 = temp+count1;\\n            count1 = temp;\\n        }\\n        return count2;\\n        }",
                "solutionTags": [],
                "code": "      public int climbStairs(int n) {\\n        if(n==1||n==0)\\n            return n;\\n        int count1=1;\\n        int count2=1;\\n        \\n        \\n        for(int i=2; i<=n; i++){\\n            int temp = count2;\\n            count2 = temp+count1;\\n            count1 = temp;\\n        }\\n        return count2;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2903888,
                "title": "one-line-math-javascript-time-o-log-n-space-o-1",
                "content": "# Intuition\\nBinet\\'s Formula. Please upvote if you found something interesting :)\\n\\n![image.png](https://assets.leetcode.com/users/images/833a64f1-7fda-4783-a20e-a369dd73d258_1670839810.799308.png)\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n,s=Math.sqrt(5)) {\\n  return (Math.pow((1+s)/2,n+1)-Math.pow((1-s)/2,n+1))/s\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n,s=Math.sqrt(5)) {\\n  return (Math.pow((1+s)/2,n+1)-Math.pow((1-s)/2,n+1))/s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2903557,
                "title": "c-dynamic-programming-modified-version",
                "content": "**Please vote if my solution was helpful ;)**\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n# Optimized Solution -  O(1) space complexity\\n\\n```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int first = 1;\\n        int second = 2;\\n        int output = second;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            output = first + second;\\n            first = second;\\n            second = output;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int first = 1;\\n        int second = 2;\\n        int output = second;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            output = first + second;\\n            first = second;\\n            second = output;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212257,
                "title": "java-100-faster-and-cleaner-two-approaches",
                "content": "![image](https://assets.leetcode.com/users/images/d5df59c3-02b5-499d-95f1-69e6b350c940_1662187370.809809.jpeg)\\nHaving doubts? Ask me in the comment section. If you find this solution helpful please leave an upvote. Thanks for visiting! Happy Coding ; )\\n\\n# Bottom-up approach\\nthis is like a combination problem\\nIt is given you can can either climb `1` or `2` steps\\nMeaning, if you are at stair number `i`, from here you can only jump to stair `i+1` or stair `i+2`, now like this you can have multiple ways to reach your target stair.\\n\\nSo, consider these stairs as different levels of a game.\\nSee this picture, to reach round 1, you have two ways, like this at every point, you have two ways to reach the next round\\nIf your final round is `3`,total number of possible paths would be 5.\\n\\nIntuition: `total ways to reach from i to n` = `total ways to reach from i+1 to n` + `total ways to reach from i+2 to n`\\n\\nAlso, `use an array to store already calculated paths, to save time`.--> important!\\n\\n```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n        x = n;\\n        return util(0);\\n    }\\n    private int util(int n) {\\n        if(n == x) {\\n            return 1;\\n        }\\n        if(n > x) {\\n            return 0;\\n        }\\n        if(data[n] == 0) {\\n            data[n] = util(n+1) + util(n+2);\\n        }\\n        return data[n];\\n    }\\n}\\n```\\n\\n# Top-down approach\\n```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n       if(n < 3) {\\n           return n;\\n       } \\n       if(data[n] == 0) {\\n           data[n] = climbStairs(n-1) + climbStairs(n-2);\\n       }\\n       return data[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n        x = n;\\n        return util(0);\\n    }\\n    private int util(int n) {\\n        if(n == x) {\\n            return 1;\\n        }\\n        if(n > x) {\\n            return 0;\\n        }\\n        if(data[n] == 0) {\\n            data[n] = util(n+1) + util(n+2);\\n        }\\n        return data[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n       if(n < 3) {\\n           return n;\\n       } \\n       if(data[n] == 0) {\\n           data[n] = climbStairs(n-1) + climbStairs(n-2);\\n       }\\n       return data[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599466,
                "title": "python-dp-solution-with-explanation",
                "content": "This problem is actually a problem of finding Fibonacci series. But realizing the connection between those two requires some exploration first.\\n\\nThe problem statement has one restriction: you can take 1 step or 2 steps. During the actual interview, you may be asked to solve a problem with different step parameter. The solution will change accordingly but your thinking process will be pretty much the same.\\n\\n* For a stair with no steps: we can assume that we can go to the top in 1 step. (Actually this is a good thing to confirm with the interviewer)\\n* For a stair with 1 step: we can assume that we can go to the top in 1 step. \\n\\nThese two will be in the base case `dp` mapping.\\n\\n* For a stair with two steps: there are 2 ways to get to the top. (take one step at a time, or just take 2 steps)\\n* For a stair with three steps: there are 3 ways to get to the top. (take one step at a time, or take 2 steps first followed by one step, or take 1 step followed by two steps)\\n\\t* Here you should start to make an important observation: for a stair with three steps, you can think of taking a stair of 2 steps followed by a stair of 1 step **OR** you think of taking a stair of 1 step followed by a stair of 2 steps. Since addition is commutative, we are okay with thinking in just one way.\\n\\t* In fact, you can start to make this observation even with the stair with two steps. That is, you have to take a stair of 1 step followed by another stair of 1 step. But sometimes, trival cases can be more confusing so it is more convenient to start observing at stair with 3 steps.\\n\\n* For a stair with four steps: you can first get to step 3 using the solution from stair of 3 steps and then you can make one jump *OR* you get to step 2 using the solution from stair of 2 steps and then making 2 jumps from there.\\n\\t* If your interviewer changes the jump parameter to 3 or 4, this observation will help you modify the algorithm.\\n\\n``` python\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 2: # Trival base cases\\n            return 1\\n        i = 2\\n        dp = {\\n\\t\\t\\t\\t  0: 1,\\n\\t\\t\\t\\t  1: 1\\n\\t\\t\\t\\t } #Base case DP table\\n        while i < n+1:\\n            dp[i] = dp[i-1] + dp[i-2]\\n            i += 1\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "``` python\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 2: # Trival base cases\\n            return 1\\n        i = 2\\n        dp = {\\n\\t\\t\\t\\t  0: 1,\\n\\t\\t\\t\\t  1: 1\\n\\t\\t\\t\\t } #Base case DP table\\n        while i < n+1:\\n            dp[i] = dp[i-1] + dp[i-2]\\n            i += 1\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386129,
                "title": "solution-in-python-3-beats-90-three-lines-fibonacci",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n    \\ta, b = 1, 1\\n    \\tfor i in range(n): a, b = b, a + b\\n    \\treturn a\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n    \\ta, b = 1, 1\\n    \\tfor i in range(n): a, b = b, a + b\\n    \\treturn a\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 25477,
                "title": "o-logn-c-python-solutions-using-matrix-power",
                "content": "**Updates**: Thank StefanPochmann for posting a concise Python implementation of this `O(logn)` idea using matrix power in the first answer. \\n \\n**Note**: If you feel unwilling to read the long codes, just take the idea with you. The codes are unnecessarily long due to the inconvenient handle of matrices. \\n\\nWell, a classic and interesting problem. The recursion is simply `f(n) = f(n - 1) + f(n - 2)`, which means that we can either climb to `n - 1` and then climb `1` step or climb to `n - 2` and then climb `2` steps. So this problem is actually asking for the `n`-th Fibonacci number. However, if you code it in such a recursive way, it will meet TLE due to the large number of overlapping sub-problems. \\n \\nThere are mainly two ways to solve this problem. The first one uses the above formula in a bottom-up manner and takes `O(n)` time. [This link][1] shares the `O(n)` solution in all the supported languages of the LeetCode OJ. You may take a look at it and appreciate the appetite of each language :-)\\n \\nNow I will focus on another solution, which takes `O(logn)` time. The idea is to use the matrix power. In fact, `[f(n), f(n - 1); f(n - 1), f(n - 2)] = [1, 1; 1, 0] ^ n` for `n >= 2`. And similar to the problem **Pow(x, n)**, the power of a matrix can be computed in `O(logn)` time.\\n  \\nThe C++ and Python codes are shown below. Note that the computation of the power of the matrix `[1, 1; 1, 0]` is hard-coded. Since it is a bit trickier to handle matrix multiplications, the codes become much longer. \\n \\n----------\\n**C++**\\n \\n\\n    class Solution {\\n    public:\\n        int climbStairs(int n) {\\n    \\t\\tif (n < 2) return n;\\n            vector<int> fibs = {1, 1, 1, 0};\\n            vector<int> ans = fibPower(fibs, n);\\n            return ans[0];\\n        }\\n    private:\\n        vector<int> matrixProd(vector<int>& l, vector<int>& r) {\\n            vector<int> ans(4, 0);\\n            ans[0] = l[0] * r[0] + l[1] * r[2];\\n            ans[1] = l[0] * r[1] + l[1] * r[3];\\n            ans[2] = l[2] * r[0] + l[3] * r[2];\\n            ans[3] = l[2] * r[1] + l[3] * r[3]; \\n            return ans;\\n        }\\n        vector<int> fibPower(vector<int>& fibs, int n){\\n    \\t\\tif (n == 1) return fibs;\\n            vector<int> half = fibPower(fibs, n / 2);\\n            vector<int> ans = matrixProd(half, half);\\n            if (n % 2 == 0) return ans;\\n            ans[1] = (ans[0] += ans[1]) - ans[1];\\n            ans[3] = (ans[2] += ans[3]) - ans[3];\\n            return ans;\\n        }\\n    };\\n\\n----------\\n**Python**\\n\\n    class Solution:\\n        # @param {integer} n\\n        # @return {integer}\\n        def climbStairs(self, n):\\n            if n  < 2:\\n                return n\\n            fibs = [1, 1, 1, 0]\\n            ans = self.fibsPower(fibs, n)\\n            return ans[0]\\n        \\n        def matrixProd(self, l, r):\\n            ans = [0] * 4\\n            ans[0] = l[0] * r[0] + l[1] * r[2]\\n            ans[1] = l[0] * r[1] + l[1] * r[3]\\n            ans[2] = l[2] * r[0] + l[3] * r[2]\\n            ans[3] = l[2] * r[1] + l[3] * r[3]\\n            return ans\\n            \\n        def fibsPower(self, fibs, n):\\n            if n == 1:\\n                return fibs\\n            half = self.fibsPower(fibs, n / 2)\\n            ans = self.matrixProd(half, half)\\n            if n % 2 == 0:\\n                return ans\\n            ans[0], ans[1], ans[2], ans[3] = ans[0] + ans[1], ans[0], ans[2] + ans[3], ans[2]\\n            return ans\\n\\n  [1]: https://leetcode.com/discuss/42044/3-4-short-lines-in-every-language",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public:\\n        int climbStairs(int n) {\\n    \\t\\tif (n < 2) return n;\\n            vector<int> fibs = {1, 1, 1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2903478,
                "title": "python-c-it-s-fibonacci-explained-bonus-one-liners",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Dynamic Programming* approach to explore all possible paths. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**.\\n****\\n\\n**Comment.** For every step, we are asked to calculate the sum of the number of ways for the previous two steps. That\\'s a Fibonacci sequence.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def climbStairs(self, n: int, a: int = 1, b: int = 0) -> int:\\n        for _ in range(n): a, b = a + b, a\\n        return a\\n```\\n\\n**C++ #1.** Explicit Fibonacci calculation.\\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n) \\n    {\\n        int w1 = 1, w2 = 0, tmp;\\n        for (int i = 0; i < n; ++i)\\n            tmp = w1, w1 += w2, w2 = tmp;\\n        return w1;\\n    }\\n};\\n```\\n\\n**C++ #2.** A more compact version of it.\\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n, int a = 1, int b = 0) \\n    {\\n        while (n--)\\n            a = a + b, b = a - b;\\n        return a;\\n    }\\n};\\n```\\n\\n**C++ #3.** Almost a one-liner with a slightly different computational scheme.\\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(long n, long a = 1, long b = 1) \\n    {\\n        while (n--) b = (a += b) - b;\\n        return b;\\n    }\\n};\\n```\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python #1.** One-liner: recursion with memoization.\\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def climbStairs(self, n: int) -> int:\\n        return self.climbStairs(n-2) + self.climbStairs(n-1) if n > 1 else 1\\n```\\n\\n**Python #2.** One-liner: [**computation by rounding**](https://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding)\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        return int(((1 + sqrt(5)) / 2) ** (n+1) / sqrt(5) + 0.5)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int, a: int = 1, b: int = 0) -> int:\\n        for _ in range(n): a, b = a + b, a\\n        return a\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n) \\n    {\\n        int w1 = 1, w2 = 0, tmp;\\n        for (int i = 0; i < n; ++i)\\n            tmp = w1, w1 += w2, w2 = tmp;\\n        return w1;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n, int a = 1, int b = 0) \\n    {\\n        while (n--)\\n            a = a + b, b = a - b;\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(long n, long a = 1, long b = 1) \\n    {\\n        while (n--) b = (a += b) - b;\\n        return b;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def climbStairs(self, n: int) -> int:\\n        return self.climbStairs(n-2) + self.climbStairs(n-1) if n > 1 else 1\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        return int(((1 + sqrt(5)) / 2) ** (n+1) / sqrt(5) + 0.5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789848,
                "title": "standard-decision-the-same-as-in-fibonacci-numbers-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI used the same method that in the Fibonacci numbers task. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI created the basic array which contain [1, 2] (this is the resulrs of the  first 2 case when the inputs are 1 and 2). \\nThan I am adding into the array new element, which is sum from the previus two numbers. We start to add new elements from the 3rd positions (becouse we already have the first two).  \\nThe last added num will be our needed result.\\n\\nRuntime: 95ms (beats 46.99%)\\nMemory: 42.1mb (beats 18.7%)\\n\\n\\n# Complexity\\n- complexity:  O(n)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let noOfWays = [1, 2]\\n\\n    for(let i = 2; i < n; i++) {\\n        noOfWays[i] = noOfWays[i - 1] + noOfWays[i - 2]\\n    }\\n\\n    return noOfWays[n - 1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let noOfWays = [1, 2]\\n\\n    for(let i = 2; i < n; i++) {\\n        noOfWays[i] = noOfWays[i - 1] + noOfWays[i - 2]\\n    }\\n\\n    return noOfWays[n - 1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545778,
                "title": "c-dp-recursive-explained-solution",
                "content": "```\\n// please upvote if understand.\\n\\n// recursive solution \\napproach -\\nsuppose if we are at nth stair and we have only two types of move 1 & 2, \\nthen we will get result easily from the previous steps result.\\nex. for 4, we will find the result for 3 stair, In how many ways I can take 3 stair and for three we find the result for 2 stair since 1st stair is our base case that we can take only one step for 1st stair.\\nwe recursively call for n-1th stairs and n-2th stairs and we will increase ways by 1 when we reach at ground or n will become 0.\\n\\n\\nclass Solution {\\npublic:\\n    void solve(int n, int &ans){\\n        if(n == 0){\\n            ans += 1;\\n        }\\n        if(n < 0) return ;\\n        solve(n-1, ans);\\n        solve(n-2, ans);\\n    }\\n    int climbStairs(int n) {\\n        int ans = 0;\\n        solve(n, ans);\\n        return ans;\\n    }\\n};\\n\\n\\nDP solution - \\nif we break our recursive solution then previous two stairs ways summation will become our result.\\nbecause we can reach n th stair with possibly two moves either from n-1th stair or from n-2th stair, then using memoization we will use bottom up approach to find our result.\\nfor, n = 7\\nfirst two stair will be our base case \\nn = 1, only single way\\nn = 2, we have only two ways either take 1 1 step or single step of 2 steps.\\n\\n1  2  3  5  8  13  21\\nfor 7th stair we will watch in how many ways i have taken 6 stairs and 5th stair.\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n == 2){\\n            return n;\\n        }\\n        vector<int> v;\\n        v.push_back(1);\\n        v.push_back(2);\\n        for(int i = 2; i<n; i++){\\n            int num = v[i-1]+v[i-2];\\n            v.push_back(num);\\n        }\\n        return v.back();\\n    }\\n};\\n\\n// please upvote if understand.\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void solve(int n, int &ans){\\n        if(n == 0){\\n            ans += 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1799067,
                "title": "dp-based-c-solution-100-faster-with-0-ms",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int climb(int dp[],int n)\\n    {\\n        \\n        \\n        if(n==0 || n==1 || n==2)\\n         return n;\\n        if(dp[n]>0)\\n            return dp[n];\\n       int output = climb(dp,n-1)+climb(dp,n-2);\\n        dp[n]=output;\\n        return output;\\n        \\n    }\\n    \\n    int climbStairs(int n) {\\n          if(n==0 || n==1 || n==2)\\n            return n;\\n     int *dp = new int[n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i]=0;\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n     int x=climb(dp,n);\\n        delete [] dp;\\n        return x;\\n    }\\n    \\n    \\n    \\n};\\n\\n\\n```\\n***If you like solution, then please upvote it.***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int climb(int dp[],int n)\\n    {\\n        \\n        \\n        if(n==0 || n==1 || n==2)\\n         return n;\\n        if(dp[n]>0)\\n            return dp[n];\\n       int output = climb(dp,n-1)+climb(dp,n-2);\\n        dp[n]=output;\\n        return output;\\n        \\n    }\\n    \\n    int climbStairs(int n) {\\n          if(n==0 || n==1 || n==2)\\n            return n;\\n     int *dp = new int[n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i]=0;\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n     int x=climb(dp,n);\\n        delete [] dp;\\n        return x;\\n    }\\n    \\n    \\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329446,
                "title": "solution-swift-climbing-stairs-test-cases",
                "content": "```swift\\nclass Solution {\\n    func climbStairs(_ n: Int) -> Int {\\n        var zero = 1, one = 1, step = 2\\n        while step <= n {\\n            let temp = zero + one\\n            zero = one\\n            one = temp\\n            step += 1\\n        }\\n        return one\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// There are two ways to climb to the top.\\n    /// 1. 1 step + 1 step\\n    /// 2. 2 steps\\n    func test0() {\\n        let value = solution.climbStairs(2)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    /// There are three ways to climb to the top.\\n    /// 1. 1 step + 1 step + 1 step\\n    /// 2. 1 step + 2 steps\\n    /// 3. 2 steps + 1 step\\n    func test1() {\\n        let value = solution.climbStairs(3)\\n        XCTAssertEqual(value, 3)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func climbStairs(_ n: Int) -> Int {\\n        var zero = 1, one = 1, step = 2\\n        while step <= n {\\n            let temp = zero + one\\n            zero = one\\n            one = temp\\n            step += 1\\n        }\\n        return one\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// There are two ways to climb to the top.\\n    /// 1. 1 step + 1 step\\n    /// 2. 2 steps\\n    func test0() {\\n        let value = solution.climbStairs(2)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    /// There are three ways to climb to the top.\\n    /// 1. 1 step + 1 step + 1 step\\n    /// 2. 1 step + 2 steps\\n    /// 3. 2 steps + 1 step\\n    func test1() {\\n        let value = solution.climbStairs(3)\\n        XCTAssertEqual(value, 3)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861070,
                "title": "progression-of-python-solutions",
                "content": "Approach 1: Naive backtracking\\nintuition: to calculate how many ways to reach nth step, we add up how many ways to reach (n-1)th and (n-2)th step, since from (n-1)th step we take a 1-step to get to nth and similarly from (n-2)th step. \\n\\nN = the input\\ntime: recursion tree of depth N, branching factor of 2, runtime is recursion trees is typically O(branching_factor^depth), plugging in we get O(2^N) as our upper bound for runtime. \\nspace: O(N), b/c of depth of recursion stack \\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Naive backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\\n\\nApproach 2: top down memoization\\nintuition: if we draw out the recursion tree we see a lot of repeated work. we are able to see this repeated work because nodes with the same parameters mean that the exact same subproblem is getting recomputed. Drawing out the recursion tree, we see many nodes with the same parameters:\\n\\n![image](https://assets.leetcode.com/users/images/f4e6230d-b0ce-4b07-ac35-6e29feeaeab7_1600885828.9303908.png)\\n\\nthis repeated work is a strong indicator that caching can help us here. We make use of python\\'s lru_cache to do caching for us here, based on what arguments are passed into the function. if we want to avoid usage of python\\'s lru cache, we can just as easily mimic this functionality using a dictionary (shown in approach 3).\\n\\n```\\nclass Solution:\\n    @lru_cache(maxsize=None)\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n        \\n```\\n\\nApproach 3: top down memoization (without lru cache)\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        \\n        cache={}\\n        def helper(n):\\n            if n in cache: return cache[n]\\n            if n == 0 or n == 1: return 1\\n            cache[n] = helper(n-1) + helper(n-2)\\n            return cache[n]\\n        \\n        return helper(n)\\n```\\n\\nAnalysis for approach 2 and 3:\\nN=input\\ntime: O(N). we get O(N) time complexity because each subproblem is only solved once, and then the subresult is cached for future use if we need it again. So analyzing time complexity here boils down to how many subproblems are there? Since our input is N, we have N subproblems (1, 2, ..., N-1, N). For analyzing time complexity of these types of problems, it is best to think in terms of what parameters define the subproblems, and use that intuition to figure out how many unique subproblems there are (how many unique parameter sets there are, since parameters define the subproblems).\\nspace: O(N). Space is O(N) because the recursion tree can still hit a depth of O(N) (1-step each time), and also the cache stores O(N) subproblems, so we get a total space complexity of O(N).\\n\\nApproach 4: Dynamic programming (not optimized)\\nintuition:\\n- from thinking about the top down solution, it is clear that in order to get the solution for climbStairs(i), we need the solutions for climbStairs(i-1) and climbStairs(i-2). At first we look at this top down in terms of the recursion tree, but we can instead flip our viewpoint and go from the bottom up. Since we know that at any point i, we need the subproblems for i-1 and i-2, let\\'s just go ahead and calculate the subproblems in order from bottom to top. So we start with the base cases and we build to the solution, instead of starting with the solution we want and figuring out which subproblems we need to solve. \\n\\nanalysis:\\ntime: O(N)\\nspace: O(N)\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Dynamic programming solution\\n        \\'\\'\\'\\n        stepsToReachIthPosn=[1] * (n+1)\\n        for i in range(2, n+1):\\n            stepsToReachIthPosn[i] = stepsToReachIthPosn[i-1]+stepsToReachIthPosn[i-2]\\n        return stepsToReachIthPosn[n]\\n```\\nApproach 5: optimized dynamic programming solution\\nintuition:\\n- notice that in our dp solution, we only require the subproblems of i-1 and i-2 in order to solve for ith subproblem. So why waste space and store the whole array when instead we could just store i-1th answer and i-2th answer? and then we just update correspondingly\\n\\ntime: O(N)\\nspace: O(1)\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Optimized dynamic programming solution\\n        \\'\\'\\'\\n        oneBack=1\\n        twoBack=1\\n        if n <= 1: return 1\\n        for i in range(2, n+1):\\n            cur=oneBack+twoBack\\n            twoBack=oneBack\\n            oneBack=cur\\n        return oneBack\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Naive backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\n```\\nclass Solution:\\n    @lru_cache(maxsize=None)\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n        \\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        \\n        cache={}\\n        def helper(n):\\n            if n in cache: return cache[n]\\n            if n == 0 or n == 1: return 1\\n            cache[n] = helper(n-1) + helper(n-2)\\n            return cache[n]\\n        \\n        return helper(n)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Dynamic programming solution\\n        \\'\\'\\'\\n        stepsToReachIthPosn=[1] * (n+1)\\n        for i in range(2, n+1):\\n            stepsToReachIthPosn[i] = stepsToReachIthPosn[i-1]+stepsToReachIthPosn[i-2]\\n        return stepsToReachIthPosn[n]\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Optimized dynamic programming solution\\n        \\'\\'\\'\\n        oneBack=1\\n        twoBack=1\\n        if n <= 1: return 1\\n        for i in range(2, n+1):\\n            cur=oneBack+twoBack\\n            twoBack=oneBack\\n            oneBack=cur\\n        return oneBack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25643,
                "title": "o-log-n-solution-with-matrix-multiplication",
                "content": "\\nI saw most solutions posted in discussion are DP with runtime O(n) and O(1) space which is accepted by OJ.\\n\\nThe only O(log(n)) solution so far is **lucastan's** using Binet's formula.\\n\\nThere actually is a matrix multiplication solution which also runs in O(log(n)). It basically calculates fibonacci numbers by power of matrix ((0, 1), (1, 1)) ^ (n-1).\\n\\n\\n\\n\\n\\n        public int climbStairs1(int n) {\\n        int[][] a = {{0, 1}, {1, 1}};\\n        int[][] m = pow(a, n - 1);\\n        return m[0][1] + m[1][1];\\n    }\\n\\n    private int[][] pow(int[][] a, int n) {\\n        int[][] ret = {{1, 0}, {0, 1}};\\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                ret = multiply(ret, a);\\n            }\\n            n >>= 1;\\n            a = multiply(a, a);\\n        }\\n        return ret;\\n    }\\n\\n    private int[][] multiply(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }",
                "solutionTags": [],
                "code": "\\nI saw most solutions posted in discussion are DP with runtime O(n) and O(1) space which is accepted by OJ.\\n\\nThe only O(log(n)) solution so far is **lucastan's** using Binet's formula.\\n\\nThere actually is a matrix multiplication solution which also runs in O(log(n)). It basically calculates fibonacci numbers by power of matrix ((0, 1), (1, 1)) ^ (n-1).\\n\\n\\n\\n\\n\\n        public int climbStairs1(int n) {\\n        int[][] a = {{0, 1}, {1, 1}};\\n        int[][] m = pow(a, n - 1);\\n        return m[0][1] + m[1][1];\\n    }\\n\\n    private int[][] pow(int[][] a, int n) {\\n        int[][] ret = {{1, 0}, {0, 1}};\\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                ret = multiply(ret, a);\\n            }\\n            n >>= 1;\\n            a = multiply(a, a);\\n        }\\n        return ret;\\n    }\\n\\n    private int[][] multiply(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2853027,
                "title": "70-climbing-stairs-three-solutions",
                "content": "All the 3 solutions listed \\nIf you find my Solutions helpful then An upvote would be an O(N) Decision :)\\n\\n1. recursive sol \\n```\\nclass Solution {\\npublic int climbStairs(int n) {\\n if(n==0) // at 0 do nothing yes that\\'s also a step:)\\nreturn 1;\\nif(n==1) // when we are taking two steps back then from 2 to 0 is 1 way only \\nreturn 1;\\n return climbStairs(n-1) +climbStairs( n-2);   \\n }\\n}\\n```\\n\\n2. now tabulation\\n```\\nclass Solution {\\npublic int climbStairs(int n) {\\nif (n <= 1) {\\n return 1;\\n  }\\nint dp[]=new int [n+1];\\ndp[1]=1;\\ndp[2]=2;\\nfor(int i=3;i<=n;i++) {\\n   dp[i]=dp[i-1] + dp[i-2];\\n}\\nreturn dp[n];\\n}\\n}\\n\\n```\\n\\n3.memoization \\n```\\nclass Solution {\\n public int climbStairs(int n) {\\n     return memoDp(new int [n+1],n);\\n }\\n    int memoDp(int dp[],int n){ \\n        if(n==0 || n==1)\\n           return 1; \\n        if (dp[n]!=0)\\n            return dp[n];\\n        int step=memoDp(dp,n-1) +memoDp(dp,n-2);\\n        dp[n]=step;\\n        return dp[n];\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic int climbStairs(int n) {\\n if(n==0) // at 0 do nothing yes that\\'s also a step:)\\nreturn 1;\\nif(n==1) // when we are taking two steps back then from 2 to 0 is 1 way only \\nreturn 1;\\n return climbStairs(n-1) +climbStairs( n-2);   \\n }\\n}\\n```\n```\\nclass Solution {\\npublic int climbStairs(int n) {\\nif (n <= 1) {\\n return 1;\\n  }\\nint dp[]=new int [n+1];\\ndp[1]=1;\\ndp[2]=2;\\nfor(int i=3;i<=n;i++) {\\n   dp[i]=dp[i-1] + dp[i-2];\\n}\\nreturn dp[n];\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935980,
                "title": "javascript-all-approaches",
                "content": "```javascript\\n// recursive\\nvar climbStairs = function(n) {\\n   if (n <= 2) return n;\\n    return climbStairs(n - 2) + climbStairs(n - 1);\\n};\\n\\n// recursive top down (memoization)\\nconst climbStairs = (n) => {\\n    const memo = new Map();\\n    \\n    return climbStairsMemo(n, memo);\\n};\\n\\nconst climbStairsMemo = (n, memo) => {\\n    if(n <= 2) return n;\\n    if(!memo.has(n)) {\\n        memo.set(n, climbStairsMemo(n - 1, memo) + climbStairsMemo(n - 2, memo))\\n    }\\n    \\n    return memo.get(n);\\n};\\n\\n// iterative bottom-up\\nconst climbStairs = (n) => {\\n    const memo = new Array(n + 1).fill(0);\\n    memo[0] = 0;\\n    memo[1] = 1;\\n    memo[2] = 2;\\n    for(let i = 3; i <= n; i++) {\\n        memo[i] = memo[i -1] + memo[i - 2];\\n    }\\n    \\n    return memo[n];\\n};\\n\\n// iterative space-saver\\nconst climbStairs = (n) => {\\n    if(n <= 2) return n;\\n    \\n    let prev2 = 1;\\n    let prev1 = 2;\\n    let curr = 0;\\n    for(let i = 3; i <= n; i++) {\\n        curr = prev2 + prev1;\\n        prev2 = prev1;\\n        prev1 = curr;\\n    }\\n    \\n    return curr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```javascript\\n// recursive\\nvar climbStairs = function(n) {\\n   if (n <= 2) return n;\\n    return climbStairs(n - 2) + climbStairs(n - 1);\\n};\\n\\n// recursive top down (memoization)\\nconst climbStairs = (n) => {\\n    const memo = new Map();\\n    \\n    return climbStairsMemo(n, memo);\\n};\\n\\nconst climbStairsMemo = (n, memo) => {\\n    if(n <= 2) return n;\\n    if(!memo.has(n)) {\\n        memo.set(n, climbStairsMemo(n - 1, memo) + climbStairsMemo(n - 2, memo))\\n    }\\n    \\n    return memo.get(n);\\n};\\n\\n// iterative bottom-up\\nconst climbStairs = (n) => {\\n    const memo = new Array(n + 1).fill(0);\\n    memo[0] = 0;\\n    memo[1] = 1;\\n    memo[2] = 2;\\n    for(let i = 3; i <= n; i++) {\\n        memo[i] = memo[i -1] + memo[i - 2];\\n    }\\n    \\n    return memo[n];\\n};\\n\\n// iterative space-saver\\nconst climbStairs = (n) => {\\n    if(n <= 2) return n;\\n    \\n    let prev2 = 1;\\n    let prev1 = 2;\\n    let curr = 0;\\n    for(let i = 3; i <= n; i++) {\\n        curr = prev2 + prev1;\\n        prev2 = prev1;\\n        prev1 = curr;\\n    }\\n    \\n    return curr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910653,
                "title": "java-dynamic-programming-solution-memoization-with-explanation",
                "content": "If n= 0 the answer is = 0\\nIf n= 1 the answer is = 1\\nIf n= 2 the answer is = 2\\nIf n= 3 the answer is = (n-1) + (n-2)\\nand so on\\n\\nIn every n we store we store the answer into memo array.\\n\\nIf we consider n = 5 then \\n![image](https://assets.leetcode.com/users/images/e2034166-f069-4973-ac7a-a0efa6f5923e_1648992757.1789904.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\n    int[] memo;\\n    public int climbStairs(int n) {\\n        memo = new int[n+1];\\n        for(int i =0;i<=n;i++) memo[i] = -1;\\n        return climbStairsRec(n);\\n    }\\n    \\n    public int climbStairsRec(int n){\\n        if(memo[n]==-1){\\n            int r;\\n            if(n==0 || n==1 || n==2) r = n;\\n            else{\\n                r = climbStairsRec(n-1) + climbStairsRec(n-2);\\n            }\\n            memo[n] = r;\\n        }\\n        return memo[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[] memo;\\n    public int climbStairs(int n) {\\n        memo = new int[n+1];\\n        for(int i =0;i<=n;i++) memo[i] = -1;\\n        return climbStairsRec(n);\\n    }\\n    \\n    public int climbStairsRec(int n){\\n        if(memo[n]==-1){\\n            int r;\\n            if(n==0 || n==1 || n==2) r = n;\\n            else{\\n                r = climbStairsRec(n-1) + climbStairsRec(n-2);\\n            }\\n            memo[n] = r;\\n        }\\n        return memo[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668980,
                "title": "this-is-nothing-but-fibonacci-only-2-approachs",
                "content": "Approach 1 : **Memoization**\\n\\n```\\nclass Solution {\\npublic:\\n    int step(int n,vector<int>&dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(dp[n] != -1)return dp[n];\\n        if(n>=2){\\n            return dp[n] = step(n-1,dp)+step(n-2,dp);\\n        }\\n            return dp[n] = step(n-1,dp)+0;\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        step(n,dp);\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**Tc : O(N) Sc:O(N)**\\n\\n**Optimization**\\n*we can reduce the space complexity*\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)return 1;\\n        else if(n==2)return 2;\\n        int ans = 0;\\n        int a = 1,b = 2;\\n        for(int i=3;i<=n;i++){\\n            ans = a+b;\\n            a = b;\\n            b = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Sc : O(1)**\\n\\n*If you like the post then please upvote it keeps me motivating \\uD83D\\uDE01\\uD83C\\uDF88*\\n**:) happy coding**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int step(int n,vector<int>&dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(dp[n] != -1)return dp[n];\\n        if(n>=2){\\n            return dp[n] = step(n-1,dp)+step(n-2,dp);\\n        }\\n            return dp[n] = step(n-1,dp)+0;\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        step(n,dp);\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)return 1;\\n        else if(n==2)return 2;\\n        int ans = 0;\\n        int a = 1,b = 2;\\n        for(int i=3;i<=n;i++){\\n            ans = a+b;\\n            a = b;\\n            b = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998650,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2: return n\\n        c1, c2, c3 = 0, 1, 2\\n        while n > 2:\\n            c1, c2 = c2, c3\\n            c3 = c1 + c2\\n            n -= 1\\n        return c3\\n```\\nfor more questions: https://github.com/vanigupta20024/Programming-Challenges/tree/master",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2: return n\\n        c1, c2, c3 = 0, 1, 2\\n        while n > 2:\\n            c1, c2 = c2, c3\\n            c3 = c1 + c2\\n            n -= 1\\n        return c3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628462,
                "title": "python-js-java-go-c-o-n-dp-fibonacci-w-hint",
                "content": "Python/JS/Go/C++ O(n) DP // Fibonacci\\n\\n[My tutorial with DP problem solving framework to climbing stairs in English](https://medium.com/@cutesciuridae/dive-into-dp-take-climbing-stairs-for-example-4e3c1344e73c)\\n\\n[My tutorial with DP problem solving framework to climbing stairs in Chinese](https://medium.com/@cutesciuridae/dynamic-programming-%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-%E4%BB%A5climbing-stairs-%E7%82%BA%E4%BE%8B-45716ab7f555)\\n\\n[My tutorial with DP solution to climbing stairs in Chinese \\u4E2D\\u6587\\u5F71\\u7247\\u8B1B\\u89E3](https://youtu.be/SUeaLvIOScY)\\n\\n---\\n\\n**Abstract model & visualization**\\n\\n<img src=\"https://assets.leetcode.com/users/images/90e639e3-0c19-478d-acca-79c11eb77c0b_1641029846.7747073.png\" width=\"600\" height=\"400\" border=\"10\"/>\\n\\n\\n---\\n\\n**Hint**:\\n\\nThink of **fibanacci series** and **recursion**.\\n\\nClimbing Stairs can be described as following:\\n\\n**Method to level n** = **Method to level (n-1)** + **Method to level (n-2)**\\n\\nIt\\'s the same as the one of Fibonacci series\\n\\nf( n ) = f( n - 1 ) + f( n - 2 ) \\n\\nwith f( 0 ) = 1 and f( 1 ) = 1\\n\\n---\\n\\n```\\n# Base case, aka stop condition:\\n\\ndp(0) = 1\\ndp(1) = 1\\n```\\n\\n---\\n\\n```\\n# General cases:\\n\\ndp(n) = dp( n-1 ) + dp( n-2 ) for n >= 2\\n```\\n\\n---\\n\\n**Implementation** by top-down DP in Python\\n\\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        \\n        self.cache = {}\\n    \\n    def climbStairs(self, n: int) -> int:    \\n        \\n        if n in self.cache:\\n            return self.cache[n]\\n        \\n        if n == 0 or n == 1:\\n            return 1\\n        \\n        else:\\n            result = self.climbStairs(n-1) + self.climbStairs(n-2)\\n            self.cache[n] = result\\n            return result\\n```\\n\\n---\\n\\nShare similar implementation with python built-in decorator\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nclass Solution:\\n\\n    def climbStairs(self, n: int) -> int:\\n    \\n        #--------------------------\\n        @cache\\n        def dp(i):\\n            \\n            # base case\\n            if i == 0 or i == 1:\\n                return 1\\n            \\n            # general cases\\n            return dp(i-1) + dp(i-2)\\n        \\n        # -------------------------\\n        return dp(n)\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **Java**:\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nclass Solution {\\n\\n    public Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo.put(0, 1);   // reach floor_0 by doing nothing\\n        climbMethodTo.put(1, 1);   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo.containsKey( n ) ){\\n            return climbMethodTo.get(n);\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo.put(n, climbStairs(n-1) + climbStairs(n-2) );\\n        \\n        return climbMethodTo.get(n);\\n    }\\n    \\n\\n    private HashMap<Integer, Integer> climbMethodTo = new HashMap<Integer, Integer>();\\n}\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **JavaScript**\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nvar climbStairs = function(n) {\\n  \\n    // create array of length n+1\\n    var memo = new Array(n+1);\\n    \\n    // Initialization on base case\\n    memo[0] = 1;\\n    memo[1] = 1;\\n    \\n    var climb = function( i ){\\n        \\n        if( i <= 1 ){\\n            // base case\\n            return memo[i];\\n            \\n        }else if( memo[i] != undefined ) {\\n            // climb(i) has been computed before, directly look-up memo\\n            return memo[i];\\n        }\\n        else{\\n            // general cases:\\n            memo[i] = (climb(i-1) + climb(i-2));\\n            return memo[i];\\n        }\\n    }\\n    \\n    return climb(n);\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **Go**\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nfunc climbStairs(n int) int {\\n    \\n    // key: stair i\\n    // value: method count of climbing to stair i\\n    memo := make(map[int]int)\\n    \\n    // initialization on base case\\n    memo[0] = 1\\n    memo[1] = 1\\n    \\n    // define inenr function: climb\\n    var climb func(int)int \\n    climb = func(i int)int{\\n        \\n        if i <= 1 {\\n            // base case\\n            return memo[i]\\n            \\n        }else if val, exist := memo[i]; exist{\\n            \\n            // climb(i) has been computed before, directly look-up memo\\n            return val\\n            \\n        }else{\\n            // general cases\\n            memo[i] = climb(i-1) + climb(i-2)\\n            return memo[i]\\n        }\\n        \\n    }\\n    \\n    return climb( n )\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **C++**\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo[0] = 1;   // reach floor_0 by doing nothing\\n        climbMethodTo[1] = 1;   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo[n] ){\\n            return climbMethodTo[n];\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo[n] = climbStairs(n-1) + climbStairs(n-2);\\n        \\n        return climbMethodTo[n];\\n    }\\n    \\nprivate:\\n    map<int, int> climbMethodTo;\\n};\\n```\\n\\n</details>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Recursion"
                ],
                "code": "```\\n# Base case, aka stop condition:\\n\\ndp(0) = 1\\ndp(1) = 1\\n```\n```\\n# General cases:\\n\\ndp(n) = dp( n-1 ) + dp( n-2 ) for n >= 2\\n```\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        \\n        self.cache = {}\\n    \\n    def climbStairs(self, n: int) -> int:    \\n        \\n        if n in self.cache:\\n            return self.cache[n]\\n        \\n        if n == 0 or n == 1:\\n            return 1\\n        \\n        else:\\n            result = self.climbStairs(n-1) + self.climbStairs(n-2)\\n            self.cache[n] = result\\n            return result\\n```\n```\\nclass Solution:\\n\\n    def climbStairs(self, n: int) -> int:\\n    \\n        #--------------------------\\n        @cache\\n        def dp(i):\\n            \\n            # base case\\n            if i == 0 or i == 1:\\n                return 1\\n            \\n            # general cases\\n            return dp(i-1) + dp(i-2)\\n        \\n        # -------------------------\\n        return dp(n)\\n```\n```\\nclass Solution {\\n\\n    public Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo.put(0, 1);   // reach floor_0 by doing nothing\\n        climbMethodTo.put(1, 1);   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo.containsKey( n ) ){\\n            return climbMethodTo.get(n);\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo.put(n, climbStairs(n-1) + climbStairs(n-2) );\\n        \\n        return climbMethodTo.get(n);\\n    }\\n    \\n\\n    private HashMap<Integer, Integer> climbMethodTo = new HashMap<Integer, Integer>();\\n}\\n```\n```\\nvar climbStairs = function(n) {\\n  \\n    // create array of length n+1\\n    var memo = new Array(n+1);\\n    \\n    // Initialization on base case\\n    memo[0] = 1;\\n    memo[1] = 1;\\n    \\n    var climb = function( i ){\\n        \\n        if( i <= 1 ){\\n            // base case\\n            return memo[i];\\n            \\n        }else if( memo[i] != undefined ) {\\n            // climb(i) has been computed before, directly look-up memo\\n            return memo[i];\\n        }\\n        else{\\n            // general cases:\\n            memo[i] = (climb(i-1) + climb(i-2));\\n            return memo[i];\\n        }\\n    }\\n    \\n    return climb(n);\\n```\n```\\nfunc climbStairs(n int) int {\\n    \\n    // key: stair i\\n    // value: method count of climbing to stair i\\n    memo := make(map[int]int)\\n    \\n    // initialization on base case\\n    memo[0] = 1\\n    memo[1] = 1\\n    \\n    // define inenr function: climb\\n    var climb func(int)int \\n    climb = func(i int)int{\\n        \\n        if i <= 1 {\\n            // base case\\n            return memo[i]\\n            \\n        }else if val, exist := memo[i]; exist{\\n            \\n            // climb(i) has been computed before, directly look-up memo\\n            return val\\n            \\n        }else{\\n            // general cases\\n            memo[i] = climb(i-1) + climb(i-2)\\n            return memo[i]\\n        }\\n        \\n    }\\n    \\n    return climb( n )\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo[0] = 1;   // reach floor_0 by doing nothing\\n        climbMethodTo[1] = 1;   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo[n] ){\\n            return climbMethodTo[n];\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo[n] = climbStairs(n-1) + climbStairs(n-2);\\n        \\n        return climbMethodTo[n];\\n    }\\n    \\nprivate:\\n    map<int, int> climbMethodTo;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207575,
                "title": "javascript-top-down-bottom-up-5-different-solutions-3-faster-than-100-o-n",
                "content": "recursive solution - stepping down\\n*** this unfortunately times out ***\\n```\\nconst climbStairs  = n => {\\n    if (n <= 3) return n;\\n    return climbStairs(n-1) + climbStairs(n-2);\\n}\\n```\\n\\n\\nrecursive solution with memoization - stepping down\\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(n, cache);\\n};\\n\\nconst climb = (n, cache) => {\\n    if (n in cache) {\\n        return cache[n];\\n    } else {\\n        if (n <= 3) return n;\\n        else {\\n            cache[n] = climb(n-1, cache) + climb(n-2, cache);\\n            return cache[n];\\n        }\\n    }\\n};\\n```\\n\\n\\niterative solution - stepping up\\n```\\nconst climbStairs = n => {\\n    // we know that 3 steps returns 3\\n    if (n <= 3) return n;\\n    let arr = [1,2,3];\\n    for (let i = 3; i < n; i++) {\\n        arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr.pop();\\n}\\n```\\n\\nrecursive solution - stepping up\\n*** this unfortunately times out ***\\n```\\nconst climbStairs = n => {\\n    return climb(0, n);\\n}\\n    \\nconst climb = (step, destination) => {\\n    if (step > destination) return 0;\\n    if (step === destination) return 1;\\n    return climb(step+1, destination) + climb(step+2, destination);\\n};\\n```\\n\\n\\nrecursive solution with memoization - stepping up\\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(0, n, cache);\\n};\\n\\nconst climb = (step, destination, cache) => {\\n    if (step in cache) {\\n        return cache[step];\\n    } else {\\n        if (step > destination) return 0;\\n        if (step === destination) return 1;\\n        else {\\n            cache[step] = \\n                climb(step+1, destination, cache) + \\n                climb(step+2, destination, cache);\\n            return cache[step];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst climbStairs  = n => {\\n    if (n <= 3) return n;\\n    return climbStairs(n-1) + climbStairs(n-2);\\n}\\n```\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(n, cache);\\n};\\n\\nconst climb = (n, cache) => {\\n    if (n in cache) {\\n        return cache[n];\\n    } else {\\n        if (n <= 3) return n;\\n        else {\\n            cache[n] = climb(n-1, cache) + climb(n-2, cache);\\n            return cache[n];\\n        }\\n    }\\n};\\n```\n```\\nconst climbStairs = n => {\\n    // we know that 3 steps returns 3\\n    if (n <= 3) return n;\\n    let arr = [1,2,3];\\n    for (let i = 3; i < n; i++) {\\n        arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr.pop();\\n}\\n```\n```\\nconst climbStairs = n => {\\n    return climb(0, n);\\n}\\n    \\nconst climb = (step, destination) => {\\n    if (step > destination) return 0;\\n    if (step === destination) return 1;\\n    return climb(step+1, destination) + climb(step+2, destination);\\n};\\n```\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(0, n, cache);\\n};\\n\\nconst climb = (step, destination, cache) => {\\n    if (step in cache) {\\n        return cache[step];\\n    } else {\\n        if (step > destination) return 0;\\n        if (step === destination) return 1;\\n        else {\\n            cache[step] = \\n                climb(step+1, destination, cache) + \\n                climb(step+2, destination, cache);\\n            return cache[step];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25292,
                "title": "python-solution-in-one-line",
                "content": "Since we know that the answer should be Fibonacci Number, we can directly calculate the Fibonacci Number with mathematical expressions.\\n```\\nreturn int(round(1/5**0.5 * (((1+5**0.5)/2.0)**(n+1) - ((1-5**0.5)/2.0)**(n+1))))\\n```\\nDone.^^",
                "solutionTags": [],
                "code": "```\\nreturn int(round(1/5**0.5 * (((1+5**0.5)/2.0)**(n+1) - ((1-5**0.5)/2.0)**(n+1))))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25481,
                "title": "1ms-java-solution-easy-to-understand-with-dp",
                "content": "public class Solution {\\n    \\n    int result;\\n    HashMap<Integer, Integer> memo = new HashMap<Integer, Integer>();\\n    \\n    public int climbStairs(int n) {\\n        if(n < 2) {\\n            return 1;\\n        }\\n        if(memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        result = climbStairs(n-1) + climbStairs(n-2);\\n        memo.put(n,result);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    \\n    int result;\\n    HashMap<Integer, Integer> memo = new HashMap<Integer, Integer>();\\n    \\n    public int climbStairs(int n) {\\n        if(n < 2) {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 25560,
                "title": "1-liner-formula",
                "content": "I didn't see anyone using [this formula](https://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding) yet, so here it is (in Python).\\n\\n    def climbStairs(self, n):\\n        return int(((1 + 5**.5) / 2) ** -~n / 5**.5 + .5)\\n\\n(No, I would not be able to recall that formula in an interview. There I would do [my normal solution](https://leetcode.com/discuss/42044/3-4-short-lines-in-every-language) or maybe the [matrix solution](https://leetcode.com/discuss/45797/o-logn-c-python-solutions-using-matrix-power?show=46059#a46059), which is not that hard to remember)\\n\\nIf you're wondering about `-~n`, that's just short for `(n+1)`. Apparently I was in golfing mode.",
                "solutionTags": [
                    "Python"
                ],
                "code": "I didn't see anyone using [this formula](https://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding) yet, so here it is (in Python).\\n\\n    def climbStairs(self, n):\\n        return int(((1 + 5**.5) / 2) ** -~n / 5**.5 + .5)\\n\\n(No, I would not be able to recall that formula in an interview. There I would do [my normal solution](https://leetcode.com/discuss/42044/3-4-short-lines-in-every-language) or maybe the [matrix solution](https://leetcode.com/discuss/45797/o-logn-c-python-solutions-using-matrix-power?show=46059#a46059), which is not that hard to remember)\\n\\nIf you're wondering about `-~n`, that's just short for `(n+1)`. Apparently I was in golfing mode.",
                "codeTag": "Python3"
            },
            {
                "id": 25549,
                "title": "simplest-answer-in-c",
                "content": "    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        for (int i = 1;i < n;i++) {\\n            b += a;\\n            a = b - a;\\n        }\\n        return b;\\n    }",
                "solutionTags": [],
                "code": "    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        for (int i = 1;i < n;i++) {\\n            b += a;\\n            a = b - a;\\n        }\\n        return b;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3418402,
                "title": "beats-100-easiest-c-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n            n+=2;\\n            int fib[n];\\n            fib[0]=0;fib[1]=1;\\n\\n            for(int i=2;i<n;i++){\\n                fib[i]=fib[i-1]+fib[i-2];\\n            }\\n            \\n            return fib[n-1];\\n    }\\n};\\nDO UPVOTE if you Like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n            n+=2;\\n            int fib[n];\\n            fib[0]=0;fib[1]=1;\\n\\n            for(int i=2;i<n;i++){\\n                fib[i]=fib[i-1]+fib[i-2];\\n            }\\n            \\n            return fib[n-1];\\n    }\\n};\\nDO UPVOTE if you Like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051988,
                "title": "super-fast-0ms-beat-100-and-super-small-space-complexity-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nList the all possible ways for the step from 1 to 6;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can see that for the step 1 stair --one way;the step 2 stairs, there are 2ways;step 3, 3ways; step 4, 5ways; step 5, 8ways; and step 6, 13ways.\\n\\nWhat do u find?\\n\\n1, 2, 3, 5, 8, 13......\\n\\nIt is the Fibonacci sequence!\\nAnd , the answer is easy...\\n\\n\\nThe first attempt i use recursive, unfortunately, it waste a lot of time!!\\n\\nWe only need 3 ints, which are first, second, and third.\\nAnd just use the nature of Fibonacci, the third number equals the sum of the first and the second number. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n<2)\\n        return 1;\\n        int first=1;\\n        int second=1;\\n        int third=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            third=first+second;\\n            first=second;\\n            second=third;\\n        }\\n        return third;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n<2)\\n        return 1;\\n        int first=1;\\n        int second=1;\\n        int third=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            third=first+second;\\n            first=second;\\n            second=third;\\n        }\\n        return third;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354896,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n        if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n        // Create an array to store the answer...\\n        int[] ans = new int[n];\\n        for(int i=1;i<=n;i++) {\\n            if(i==1) {\\n                ans[0]=1;\\n            }\\n            if(i==2) {\\n                ans[1]=2;\\n            }\\n            // There are two options...\\n            // 1.we came from (i-1)th step\\n            // 2.we came from (i-2)th step\\n            if(i>2) {\\n                ans[i-1] = ans[i-2] + ans[i-3];\\n            }\\n        }\\n        return ans[n-1];    // Return the answer...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int pre = 1;\\n        int curr = 1;\\n        int temp = 0;\\n        for (int i = 1; i < n; i++) {\\n            temp = curr;\\n            curr = curr + pre;\\n            pre = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```\\n                \\n# **JavaScript Solution:**\\n```\\nvar climbStairs = function(n) {\\n    if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n    if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n    // Create an array to store the answer...\\n    let ans = [n];\\n    for(let i=1;i<=n;i++) {\\n        if(i==1) {\\n            ans[0]=1;\\n        }\\n        if(i==2) {\\n            ans[1]=2;\\n        }\\n        // There are two options when we reach ith step:\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        if(i>2) {\\n            ans[i-1] = ans[i-2] + ans[i-3];\\n        }\\n    }\\n    return ans[n-1];    // Return the answer...\\n};\\n```\\n\\n# **C Language:**\\n```\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n        if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n        // Create an array to store the answer...\\n        int[] ans = new int[n];\\n        for(int i=1;i<=n;i++) {\\n            if(i==1) {\\n                ans[0]=1;\\n            }\\n            if(i==2) {\\n                ans[1]=2;\\n            }\\n            // There are two options...\\n            // 1.we came from (i-1)th step\\n            // 2.we came from (i-2)th step\\n            if(i>2) {\\n                ans[i-1] = ans[i-2] + ans[i-3];\\n            }\\n        }\\n        return ans[n-1];    // Return the answer...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int pre = 1;\\n        int curr = 1;\\n        int temp = 0;\\n        for (int i = 1; i < n; i++) {\\n            temp = curr;\\n            curr = curr + pre;\\n            pre = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```\n```\\nvar climbStairs = function(n) {\\n    if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n    if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n    // Create an array to store the answer...\\n    let ans = [n];\\n    for(let i=1;i<=n;i++) {\\n        if(i==1) {\\n            ans[0]=1;\\n        }\\n        if(i==2) {\\n            ans[1]=2;\\n        }\\n        // There are two options when we reach ith step:\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        if(i>2) {\\n            ans[i-1] = ans[i-2] + ans[i-3];\\n        }\\n    }\\n    return ans[n-1];    // Return the answer...\\n};\\n```\n```\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275058,
                "title": "c-representation-solution-with-comments-space-optimisation",
                "content": "***\\n***Please Upvote if it Helps......***\\n***\\n***\\n***Solution :***\\n***\\n***How to Identify a DP problem?***\\n\\nWhen we see a problem, it is very important to identify it as a dynamic programming problem. Generally (but not limited to) if the problem statement asks for the following:\\n\\n* Count the total number of ways\\n* Given multiple ways of doing a task, which way will give the minimum or the maximum output.\\n\\nWe can try to apply recursion. Once we get the recursive solution, we can go ahead to convert it to a dynamic programming one.\\n***\\n***Steps To Solve The Problem After Identification***\\n***\\nOnce the problem has been identified, the following three steps comes handy in solving the problem:\\n\\n* Try to represent the problem in terms of indexes.\\n* Try all possible choices/ways at every index according to the problem statement.\\n* If the question states\\n    * Count all the ways \\u2013 return sum of all choices/ways.\\n    * Find maximum/minimum- return the choice/way with maximum/minimum output.\\n***\\n***Using these steps to solve the problem \\u201CClimbing Stairs\\u201D***\\n\\nStep 1: We will assume n stairs as indexes from 0 to N.\\n![image](https://assets.leetcode.com/users/images/0e2588c0-6c6e-4fc3-9e0a-a65e3daadbdf_1657686866.9534023.png)\\n\\n\\nStep 2: At a single time, we have 2 choices: Jump one step or jump two steps. We will try both of these options at every index.\\n\\n![image](https://assets.leetcode.com/users/images/97b90fad-e603-403a-9865-df049c300187_1657686879.0325246.png)\\n\\nStep 3: As the problem statement asks to count the total number of distinct ways, we will return the sum of all the choices in our recursive function.\\n\\nThe base case will be when we want to go to the 0th stair, then we have only one option.\\n\\nThe basic pseudo-code for the problem will be given as:\\n\\n![image](https://assets.leetcode.com/users/images/9dca5aef-77eb-421f-b492-b9a24e356710_1657686889.5174844.png)\\n\\nThere will be one more edge-case when n=1, if we call f(n-2) we will reach stair numbered -1 which is not defined, therefore we add an extra test case to return 1 ( the only way) when n=1.\\n![image](https://assets.leetcode.com/users/images/6c70d64c-8a25-44f8-a201-58042f4801be_1657686900.0129309.png)\\n\\n***\\n***\\n\\n***Steps for the Tabulation approach.***\\n***\\n* Declare a dp[] array of size n+1.\\n* First initialize the base condition values, i.e i=0 and i=1 of the dp array as 1.\\n* Set an iterative loop which traverses the array( from index 2 to n) and for every index set its value as dp[i-1] + dp[i-2]. \\n***\\n***\\n***C++ Code***\\n***\\n```\\n  vector<int> dp(n+1,-1);\\n  \\n  dp[0]= 1;\\n  dp[1]= 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      dp[i] = dp[i-1]+ dp[i-2];\\n  }\\n  return dp[n];\\n  \\n```\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n**Reason:** We are running a simple iterative loop\\n\\n***Space Complexity: O(N)***\\n\\n**Reason:** We are using an external array of size \\u2018n+1\\u2019.\\n***\\n***\\n***Part 3: Space Optimization***\\n\\nIf we closely look the relation,\\n\\n***dp[i] =  dp[i-1] + dp[i-2]***\\n\\nwe see that for any i, we do need only the last two values in the array. So is there a need to maintain a whole array for it? \\n\\nThe answer is \\u2018No\\u2019. Let us call dp[i-1] as prev and dp[i-2] as prev2. Now understand the following illustration.\\n![image](https://assets.leetcode.com/users/images/cd60c07a-aa40-4d39-b069-de5538f334fe_1657687029.7320123.png)\\n\\n\\n* Each iteration\\u2019s cur_i and prev becomes the next iteration\\u2019s prev and prev2 respectively.\\n* Therefore after calculating cur_i, if we update prev and prev2 according to the next step, we will always get the answer. \\n* After the iterative loop has ended we can simply return prev as our answer.\\n***\\n***\\n\\n***C++ Code***\\n```\\n  int prev2 = 1;\\n  int prev = 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      int cur_i = prev2+ prev;\\n      prev2 = prev;\\n      prev= cur_i;\\n  }\\n  return prev;\\n```\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n***Reason:*** We are running a simple iterative loop\\n\\n***Space Complexity: O(1)***\\n\\n***Reason:*** We are not using any extra space.\\n***\\n***Please Upvote if it Helps......***\\n***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n  vector<int> dp(n+1,-1);\\n  \\n  dp[0]= 1;\\n  dp[1]= 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      dp[i] = dp[i-1]+ dp[i-2];\\n  }\\n  return dp[n];\\n  \\n```\n```\\n  int prev2 = 1;\\n  int prev = 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      int cur_i = prev2+ prev;\\n      prev2 = prev;\\n      prev= cur_i;\\n  }\\n  return prev;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1504269,
                "title": "java-easy-solution-and-runtime-0-ms-faster-than-100-used-fibonacci-series",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466915,
                "title": "two-simple-c-solutions-using-top-down-and-bottom-up-dp",
                "content": "```\\n// solution 1\\nclass Solution {\\npublic:      \\n    int climbStairs(int n) {\\n        if(n <= 2) return n;\\n        vector<int> dp(n+1);\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        return climb(n, dp);\\n    }\\n    int climb(int n, vector<int> &dp){\\n        \\n        if(dp[n] > 0) return dp[n];\\n        return dp[n] = climb(n-1, dp) + climb(n-2, dp);\\n    }\\n};\\n\\n\\n\\n// solution 2\\nclass Solution {\\npublic:      \\n    int climbStairs(int n) {\\n        \\n        if(n<=2) return n;\\n        vector<int> dp(n+1,0);\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i<=n; i++){\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:      \\n    int climbStairs(int n) {\\n        if(n <= 2) return n;\\n        vector<int> dp(n+1);\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        return climb(n, dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1098633,
                "title": "climbing-stairs-all-three-approaches-recursion-top-down-memoization-bottom-up-tabulation",
                "content": "**In this post, I am going to talk about all the three approaches involved to solve this problem**\\n\\n#1 Recursion\\n\\nThis solution is the most simplest one among three but yes it will give TLE due to its fairly exponential time complexity.... Not a suggested way but its surely the first step and the basic step to move towards DP i.e. optimised solution...\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //  Recursive\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n#2 Memoization (Top-Down)\\n\\nAn optimisation to the recursive approach... In this recursion is still present but here what we do is store the overlapping subproblems results in hand... as the main problem with recursive approach was that we were solving many sub problems repeatedly.... and so memoization comes into play... In this we store our results in a dp table(here its 1-D) and that would bring reduce the complexity O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static int helper(int n,int *dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        return dp[n]=helper(n-1,dp) + helper(n-2,dp);\\n    }\\n    \\n    int climbStairs(int n) {\\n        //  Memoized\\n        \\n        int dp[n+1];\\n        for(int i=0;i<=n;i++){\\n            dp[i]=-1;\\n        }\\n        return helper(n,dp);\\n    }\\n};\\n```\\n\\n#3 Tabulation (Bottom-up)\\n\\nSame as memoization but here iteratively result is evaluated and this method is preferred over memoization due to various stack calls in Top down.... \\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //DP\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        int dp[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        \\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //  Recursive\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    static int helper(int n,int *dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        return dp[n]=helper(n-1,dp) + helper(n-2,dp);\\n    }\\n    \\n    int climbStairs(int n) {\\n        //  Memoized\\n        \\n        int dp[n+1];\\n        for(int i=0;i<=n;i++){\\n            dp[i]=-1;\\n        }\\n        return helper(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //DP\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        int dp[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        \\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353923,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int n2 = 1, n1 = 2, all = 0;\\n        \\n        for(int i = 2; i < n; i++){\\n            all = n2 + n1;\\n            n2 = n1;\\n            n1 = all;\\n        }\\n        return all;\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Climbing Stairs.\\nMemory Usage: 32.8 MB, less than 5.26% of Java online submissions for Climbing Stairs.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int n2 = 1, n1 = 2, all = 0;\\n        \\n        for(int i = 2; i < n; i++){\\n            all = n2 + n1;\\n            n2 = n1;\\n            n1 = all;\\n        }\\n        return all;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300652,
                "title": "javascript",
                "content": "```\\nvar climbStairs = function(n) {\\n    let arr = [0,1,2,3];\\n    for(let i = 4; i <= n; i++){\\n        arr[i] = arr[ i - 1] + arr[i - 2];\\n    }\\n    return arr[n];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar climbStairs = function(n) {\\n    let arr = [0,1,2,3];\\n    for(let i = 4; i <= n; i++){\\n        arr[i] = arr[ i - 1] + arr[i - 2];\\n    }\\n    return arr[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25646,
                "title": "my-solution-considering-odd-and-even",
                "content": "    public int climbStairs(int n){\\n\\t\\tif(n <= 0) return 0;\\n\\t\\tint [] stairs = {1,2};\\n\\t\\tfor(int i = 2;i < n;i++){\\n\\t\\t\\tstairs[i%2] = stairs[0]+stairs[1];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn n % 2 == 0 ? stairs[1]:stairs[0];\\n\\t}\\n\\n\\n\\nconsiding f(n) = f(n-1)+f(n-2),that is: \\n\\n\\n----------\\n\\n\\nf(1) = 1\\n\\n\\n----------\\nf(2) = 2\\n\\n\\n----------\\n\\n\\nf(3) = f(2)+f(1)\\n\\n\\n----------\\n\\n\\nf(4) = f(3)+f(2)\\n\\n\\n----------\\n\\n\\n...\\n\\n\\n----------\\n\\n\\nand the values before f(2) will never use again,so we can use an array with two elements to store the tmp values",
                "solutionTags": [],
                "code": "    public int climbStairs(int n){\\n\\t\\tif(n <= 0) return 0;\\n\\t\\tint [] stairs = {1,2};\\n\\t\\tfor(int i = 2;i < n;i++){\\n\\t\\t\\tstairs[i%2] = stairs[0]+stairs[1];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn n % 2 == 0 ? stairs[1]:stairs[0];\\n\\t}\\n\\n\\n\\nconsiding f(n) = f(n-1)+f(n-2),that is: \\n\\n\\n----------\\n\\n\\nf(1) = 1\\n\\n\\n----------\\nf(2) = 2\\n\\n\\n----------\\n\\n\\nf(3) = f(2)+f(1)\\n\\n\\n----------\\n\\n\\nf(4) = f(3)+f(2)\\n\\n\\n----------\\n\\n\\n...\\n\\n\\n----------\\n\\n\\nand the values before f(2) will never use again,so we can use an array with two elements to store the tmp values",
                "codeTag": "Unknown"
            },
            {
                "id": 25608,
                "title": "my-divide-and-conquer-way-to-solve-this-problem-java",
                "content": "Hi guys, here is my solution:\\n\\n    public class Solution {\\n        public int climbStairs(int n) {\\n            //bottom case\\n            if(n < 1){\\n                return 0;\\n            }\\n            \\n            if(n == 1){\\n                return 1;\\n            }\\n            if(n == 2){\\n                return 2;\\n            }\\n            if(n == 3){\\n                return 3;\\n            }\\n            \\n            return climbStairs(n/2)*climbStairs(n - n/2) + climbStairs(n/2 - 1) * climbStairs(n - n/2 - 1);\\n            \\n        }\\n    }\\n\\nEach time we cut n stairs in the middle:\\n\\ntotal case(n) = total case(head half of n) * total case(tail half of n) + additional case.\\n\\nAbout the additional case: The border on head half and tail half contribute an \\'1\\', then we form a \\'2\\' in the middle. So total case of additional case should = total case(head half - 1) * total case(tail half -1).\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public int climbStairs(int n) {\\n            //bottom case\\n            if(n < 1){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3956051,
                "title": "java-runtime-0-ms-beats-100",
                "content": "# Intuition\\nMy initial approach to solving this problem involves considering the fact that reaching the \\'n\\'th step can be achieved by either taking a single step from the \\'n-1\\'th step or taking two steps from the \\'n-2\\'th step. Therefore, the number of distinct ways to reach the \\'n\\'th step is the sum of the ways to reach the \\'n-1\\'th and \\'n-2\\'th steps.\\n\\n# Approach\\nI will use a recursive approach with memoization to calculate the total number of distinct ways to climb the staircase of \\'n\\' steps. I\\'ll create a memoization array to store the results for already calculated steps, which will help avoid redundant calculations. Starting from the base cases where \\'n\\' is 1 or 2, I\\'ll recursively calculate the number of ways to reach the \\'n\\' step by summing the ways from \\'n-1\\' and \\'n-2\\' steps. I\\'ll store the results in the memoization array and return the final result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm calculates each distinct step\\'s number of ways only once due to memoization, so the time complexity is linear, where \\'n\\' is the input value.\\n\\n- Space complexity: O(n)\\n  The algorithm uses extra space for the memoization array, which stores the number of ways for each step.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return calculateWays(n, memo);\\n    }\\n    \\n    private int calculateWays(int n, int[] memo) {\\n        if (n == 1 || n == 2) {\\n            return n;\\n        }\\n        \\n        if (memo[n] != 0) {\\n            return memo[n];\\n        }\\n        \\n        memo[n] = calculateWays(n - 1, memo) + calculateWays(n - 2, memo);\\n        return memo[n];\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return calculateWays(n, memo);\\n    }\\n    \\n    private int calculateWays(int n, int[] memo) {\\n        if (n == 1 || n == 2) {\\n            return n;\\n        }\\n        \\n        if (memo[n] != 0) {\\n            return memo[n];\\n        }\\n        \\n        memo[n] = calculateWays(n - 1, memo) + calculateWays(n - 2, memo);\\n        return memo[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831506,
                "title": "easiest-and-optimized-code-explained-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- After observation one can realize that this nothis just a fibbonacci sequence.\\n- We can also implement this in simple manner. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        int res;\\n        \\n        if(n<=3)return n;\\n        int prev=3;\\n        int uska_prev = 2;\\n        \\n        for(int i=4;i<=n;i++){\\n            \\n            res = prev + uska_prev;\\n            uska_prev = prev;\\n            prev = res;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        int res;\\n        \\n        if(n<=3)return n;\\n        int prev=3;\\n        int uska_prev = 2;\\n        \\n        for(int i=4;i<=n;i++){\\n            \\n            res = prev + uska_prev;\\n            uska_prev = prev;\\n            prev = res;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675671,
                "title": "beginner-friendly-detailed-explanation-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuitively, the code utilizes a dynamic programming approach to solve the problem. It keeps track of the counts for the current step and the next step, updating them iteratively based on the counts of the previous steps. By the end of the loop, the value of b represents the total number of distinct ways to reach the top of the staircase with n steps.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code is implementing a method climbStairs in the Solution class. This method calculates the number of distinct ways to climb to the top of a staircase with n steps, where each time you can either climb 1 or 2 steps at a time.\\n\\nHere\\'s how the code works:\\n\\nThe method initializes two variables, a and b, to keep track of the number of distinct ways to reach the current step and the next step, respectively. Initially, a is set to 0 and b is set to 1.\\nUsing a for loop, the code iterates n times, representing each step in the staircase.\\nIn each iteration, the code updates a and b by swapping their values and assigning a + b to b. This step effectively calculates the number of distinct ways to reach the current step (a) and updates the number of distinct ways to reach the next step (b) based on the previous steps\\' counts.\\nAfter the loop finishes executing n times, the method returns the value of b, which represents the number of distinct ways to reach the top of the staircase with n steps.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the number of steps in the staircase. This is because the code iterates n times in the for loop.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) since the code only uses a constant amount of additional space to store the variables a and b, regardless of the input size.\\n# Code\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a, b = 0, 1\\n        for i in range(n):\\n\\t        a, b = b, a + b         \\n        return b\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a, b = 0, 1\\n        for i in range(n):\\n\\t        a, b = b, a + b         \\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085426,
                "title": "rust-0ms-100-faster-by-cheating-with-your-friendly-lut",
                "content": "A long time ago, my mechanical engineering teacher told me a story about how his team manage to make one of the fastest robot-arm firmware by pre-computing a table of square root values. \\n\\nThis problem is a typical case were we can apply this cheat. We don\\'t have to use the most sofisticated algorithm to compute every value of N, since we just have to compute it once :) .\\n\\n\\n# Code\\n```rust\\nconst LUT: &[i32] = &[\\n    0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,\\n    17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578,\\n    5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296,\\n    433494437, 701408733, 1134903170, 1836311903,\\n];\\n\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        return LUT[n as usize];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```rust\\nconst LUT: &[i32] = &[\\n    0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,\\n    17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578,\\n    5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296,\\n    433494437, 701408733, 1134903170, 1836311903,\\n];\\n\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        return LUT[n as usize];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798735,
                "title": "climbing-stairs-solution-recursion-memoization-tabulation",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n    //Recursion\\n        //if(n==1)return 1;\\n        //if(n==0)return 1;                   // stand at 0th stair\\n          //return climbStairs(n-1) + climbStairs(n-2);\\n        \\n    //Memoization\\n        //  int dp[] = new int[n+1];\\n        //  for(int i=0; i<n+1; i++)\\n        //      dp[i]=-1;\\n        // return memo(n,dp);\\n    //Dp\\n        return dp(n);\\n    }\\n    public int memo(int n, int dp[]){\\n        if(n==1)return 1;\\n        if(n==0)return 1;\\n        if(dp[n]!=-1)return dp[n];\\n        \\n        dp[n] = memo(n-1,dp) + memo(n-2,dp);\\n        return dp[n];\\n    }\\n    public int dp(int n){\\n       int dp[] = new int[n+1]; \\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=2; i<n+1; i++)\\n            dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n    //Recursion\\n        //if(n==1)return 1;\\n        //if(n==0)return 1;                   // stand at 0th stair\\n          //return climbStairs(n-1) + climbStairs(n-2);\\n        \\n    //Memoization\\n        //  int dp[] = new int[n+1];\\n        //  for(int i=0; i<n+1; i++)\\n        //      dp[i]=-1;\\n        // return memo(n,dp);\\n    //Dp\\n        return dp(n);\\n    }\\n    public int memo(int n, int dp[]){\\n        if(n==1)return 1;\\n        if(n==0)return 1;\\n        if(dp[n]!=-1)return dp[n];\\n        \\n        dp[n] = memo(n-1,dp) + memo(n-2,dp);\\n        return dp[n];\\n    }\\n    public int dp(int n){\\n       int dp[] = new int[n+1]; \\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=2; i<n+1; i++)\\n            dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703084,
                "title": "climbing-stairs-using-fibonacci",
                "content": "**DON\\'T FORGOT TO UPVOTE**\\nIt is basically fibonacci.\\nFor 0 stair : 1 way\\nFor 1 stair : 1 way\\nFor 2 stairs : 2 ways ((1+1), (2))\\nFor 3 stairs : 3 ways ((1+1+1), (1+2), (2+1))\\nFor 4 stairs : 5 ways ((1+1+1+1), (1+1+2), (2+1+1), (1+2+1), (2+2))\\nFor 5 stairs : 8 ways ((1+1+1+1+1), (1+1+1+2), (2+1+1+1), (1+2+1+1), (1+1+2+1), (2+2+1), (2+1+2), (1+2+2))\\n...\\n1 , 1, 2, 3, 5, 8, 13, 21, ...\\n\\nBottom-Up Approach:\\n```\\nint climbStairs(int n) {\\n     if(n <= 1) {\\n\\t\\t return 1;\\n     }\\n     int arr[n];\\n     arr[0] = arr[1] = 1;\\n     for(int i = 2; i < n; i++) {\\n\\t\\t arr[i] = arr[i-1] + arr[i-2];\\n     }\\n\\t return arr[n-1] + arr[n-2];\\n }\\n```\\nTop-Down Approach:\\n```\\nint solve(int n, vector<int>& dp) {\\n\\tif(n <= 1) return 1;\\n    if(dp[n] != -1) return dp[n];\\n    return dp[n] = solve(n-1, dp) + solve(n-2, dp);\\n}\\nint climbStairs(int n) {   \\n    if(n == 1) return 1;\\n    vector<int> dp(n+1, -1);\\n    return solve(n, dp);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint climbStairs(int n) {\\n     if(n <= 1) {\\n\\t\\t return 1;\\n     }\\n     int arr[n];\\n     arr[0] = arr[1] = 1;\\n     for(int i = 2; i < n; i++) {\\n\\t\\t arr[i] = arr[i-1] + arr[i-2];\\n     }\\n\\t return arr[n-1] + arr[n-2];\\n }\\n```\n```\\nint solve(int n, vector<int>& dp) {\\n\\tif(n <= 1) return 1;\\n    if(dp[n] != -1) return dp[n];\\n    return dp[n] = solve(n-1, dp) + solve(n-2, dp);\\n}\\nint climbStairs(int n) {   \\n    if(n == 1) return 1;\\n    vector<int> dp(n+1, -1);\\n    return solve(n, dp);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1851337,
                "title": "it-s-literally-the-fibonacci-numbers",
                "content": "[Leetcode](https://leetcode.com/) [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/).\\n\\nIn fact, it\\'s a [Fibonacci Numbers](https://en.wikipedia.org/wiki/Fibonacci_number), the sequence is as follows:\\n\\n$1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, \\\\dots$\\n\\nTo find out the $nth$ **Fibonacci Numbers**, we can use such algorithms: [9 Fibonacci Algorithms | The Most Complete Solutions | Image Explanation](https://leetcode.com/problems/fibonacci-number/solutions/1854398/9-fibonacci-algorithms-the-most-complete-solutions-image-explanation/)\\n\\nor visit the discuss:\\n[Leetcode Discuss: Fibonacci Numbers](https://leetcode.com/discuss/study-guide/1854405/9-fibonacci-algorithms-the-most-complete-solutions-all-in-one-easy-to-understand) .\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "[Leetcode](https://leetcode.com/) [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/).\\n\\nIn fact, it\\'s a [Fibonacci Numbers](https://en.wikipedia.org/wiki/Fibonacci_number), the sequence is as follows:\\n\\n$1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, \\\\dots$\\n\\nTo find out the $nth$ **Fibonacci Numbers**, we can use such algorithms: [9 Fibonacci Algorithms | The Most Complete Solutions | Image Explanation](https://leetcode.com/problems/fibonacci-number/solutions/1854398/9-fibonacci-algorithms-the-most-complete-solutions-image-explanation/)\\n\\nor visit the discuss:\\n[Leetcode Discuss: Fibonacci Numbers](https://leetcode.com/discuss/study-guide/1854405/9-fibonacci-algorithms-the-most-complete-solutions-all-in-one-easy-to-understand) .\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1504370,
                "title": "python-3-solution-comparison-3-approaches",
                "content": "# Solution #1\\nClassical DP solution\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [1,1] + [0]*(n-1)\\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[-1]\\n```\\nThe first solution is faster than **60.32%** of others and requires memory of less than **42.71%**.\\n# Solution #2\\nClassical DP solution without array\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return n\\n        p = pp = 1\\n        for i in range(2, n+1):\\n            res = p + pp\\n            pp = p\\n            p = res\\n        return res\\n```\\nThe second solution is faster than **60.32%** of others and requires memory of less than **42.71%**.\\n# Solution #3\\nRecursion solution with memorization by using a dictionary mem\\n```\\nclass Solution:\\n    def climbStairs(self, n: int, mem={1:1,2:2,3:3}) -> int:\\n        if n in mem:\\n            return mem[n]\\n        mem[n] = self.climbStairs(n-1, mem) + self.climbStairs(n-2, mem)\\n        return mem[n]\\n```\\nThe third solution is faster than **95.02%** of others and requires memory of less than **90.49%**.\\n# Conclusion:\\n- The first and second solutions don\\'t differ either in speed or execution time, therefore it makes no sense to avoid using the classic dp array.\\n- Tip: If it\\'s important for you to overtake your rivals, then you can set as many initial values as possible, which will significantly speed up the execution. \\nFor example,` dp = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...]`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [1,1] + [0]*(n-1)\\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return n\\n        p = pp = 1\\n        for i in range(2, n+1):\\n            res = p + pp\\n            pp = p\\n            p = res\\n        return res\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int, mem={1:1,2:2,3:3}) -> int:\\n        if n in mem:\\n            return mem[n]\\n        mem[n] = self.climbStairs(n-1, mem) + self.climbStairs(n-2, mem)\\n        return mem[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327557,
                "title": "rust-one-liner-fibbonacci-numbers",
                "content": "```\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        (0..n)\\n            .fold((1, 0), |(res, prev), _| (res + prev, res))\\n            .0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        (0..n)\\n            .fold((1, 0), |(res, prev), _| (res + prev, res))\\n            .0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 791308,
                "title": "javascript-solution-70",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nlet climbStairs = function(n) {\\n    let arr=[];\\n    arr[1]=1;\\n    arr[2]=2;\\n    for(let i=3;i<=n;i++){\\n        arr[i]=arr[i-1]+arr[i-2];\\n    }\\n    return arr[n];\\n};\\n```\\n\\n**Runtime: 72 ms, faster than 64.59% of JavaScript online submissions for Climbing Stairs.**\\n\\n**Memory Usage: 36.4 MB, less than 34.63% of JavaScript online submissions for Climbing Stairs.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nlet climbStairs = function(n) {\\n    let arr=[];\\n    arr[1]=1;\\n    arr[2]=2;\\n    for(let i=3;i<=n;i++){\\n        arr[i]=arr[i-1]+arr[i-2];\\n    }\\n    return arr[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25350,
                "title": "both-bottom-up-and-top-down-dynamic-programming-style-java-code-good-for-learners",
                "content": "\\nThe bottom-up approach is provided as following. \\nThe idea is that we consider from `stair level 0` and `stair level 1`, which are the base cases. And we use an array N to record the number of distinct ways for each level. \\nObviously, for `level 0` and `level 1`, the number of distinct ways are 1. After that, for each level `i` where `i` is greater than `0` and `1`, we have 2 possible way to step on it: The first one is to go from  `level i - 1` (i.e. climb 1 steps); the second one is to go from `level i - 2` (i.e. climb 2 steps). Thus for each level `i` where `i` is greater than  `1`, `N[i] = N[i - 1] + N[i - 2]`.\\nAnd hence, `N[n]` stores the total number of distinct ways to climb `n` stairs after the `for` loop.  \\n```\\n/*\\nbottom-up approach\\n*/\\n\\npublic int climbStairs(int n){\\n    if (n == 0){\\n        return 1;\\n    }\\n    else{\\n        int[] N = new int[n + 1];\\n        N[0] = 1;\\n        N[1] = 1;\\n        for (int i = 2; i <= n; i ++){\\n            N[i] = N [ i - 1] + N[i - 2];\\n        }\\n        return N[n];\\n    }\\n}\\n```\\n\\nThe top down approach is showed as following. \\nIn the top down approach, we actually consider from the top, which is `stair level n`. And the recursive equation is still `N[i] = N[i - 1] + N[i - 2]`. Hence we get the so-called optimal substructures in `Dynamic programming`. Thus, by recursively calculate each level from `n` to base case, which is `0` and `1` and memorize the intermediate, we can still get the total number of distinct ways to go to stair `n`. \\n```\\n/*\\ntop-down approach\\n*/\\n\\n\\npublic int climbStairs(int n) {\\n    int[] N = new int[n];\\n    for (int i = 0; i < n; i++){\\n        N[i] = -1;\\n    }\\n    \\n    return topdownclimbStairs(n, N);\\n}\\n\\nprivate int topdownclimbStairs(int n, int[] N){\\n    if (n == 0 || n == 1){\\n        return 1;\\n    }\\n    \\n    if (N[n - 1] >= 0){\\n        return N[n - 1];\\n    }\\n\\n    else {\\n        N[n - 1] = topdownclimbStairs(n-1, N) + topdownclimbStairs(n - 2, N);\\n        return N[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nbottom-up approach\\n*/\\n\\npublic int climbStairs(int n){\\n    if (n == 0){\\n        return 1;\\n    }\\n    else{\\n        int[] N = new int[n + 1];\\n        N[0] = 1;\\n        N[1] = 1;\\n        for (int i = 2; i <= n; i ++){\\n            N[i] = N [ i - 1] + N[i - 2];\\n        }\\n        return N[n];\\n    }\\n}\\n```\n```\\n/*\\ntop-down approach\\n*/\\n\\n\\npublic int climbStairs(int n) {\\n    int[] N = new int[n];\\n    for (int i = 0; i < n; i++){\\n        N[i] = -1;\\n    }\\n    \\n    return topdownclimbStairs(n, N);\\n}\\n\\nprivate int topdownclimbStairs(int n, int[] N){\\n    if (n == 0 || n == 1){\\n        return 1;\\n    }\\n    \\n    if (N[n - 1] >= 0){\\n        return N[n - 1];\\n    }\\n\\n    else {\\n        N[n - 1] = topdownclimbStairs(n-1, N) + topdownclimbStairs(n - 2, N);\\n        return N[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25624,
                "title": "this-is-essentially-a-fibonacci-sequence",
                "content": "Solution to this problem makes a Fibonacci sequence. We can understand it better if we start from the end. To reach to Step N, you can either reach to step N-1 and take 1 step from there or take 2 step from N - 2. \\nTherefore it can be summarized as:\\nF(N) = F(N-1) + F(N-2)\\n\\nOnce you have recognized the pattern, it is very easy to write the code:\\n\\n    class Solution:\\n    # @param n, an integer\\n    # @return an integer\\n    def climbStairs(self, n):\\n        if n < 1:\\n            return 0\\n        prev = 1\\n        curr = 1\\n        while n > 1:\\n            prev, curr = curr, prev + curr\\n            n -=1\\n        return curr",
                "solutionTags": [],
                "code": "Solution to this problem makes a Fibonacci sequence. We can understand it better if we start from the end. To reach to Step N, you can either reach to step N-1 and take 1 step from there or take 2 step from N - 2. \\nTherefore it can be summarized as:\\nF(N) = F(N-1) + F(N-2)\\n\\nOnce you have recognized the pattern, it is very easy to write the code:\\n\\n    class Solution:\\n    # @param n, an integer\\n    # @return an integer\\n    def climbStairs(self, n):\\n        if n < 1:\\n            return 0\\n        prev = 1\\n        curr = 1\\n        while n > 1:\\n            prev, curr = curr, prev + curr\\n            n -=1\\n        return curr",
                "codeTag": "Java"
            },
            {
                "id": 3436390,
                "title": "fibo-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 1) {\\n            return n;\\n        }\\n\\n        int n1 = 1;\\n        int n2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int next = n1;\\n            n1 = n2;\\n            n2 = next + n2;\\n        }\\n\\n        return n2;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Go",
                    "TypeScript"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 1) {\\n            return n;\\n        }\\n\\n        int n1 = 1;\\n        int n2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int next = n1;\\n            n1 = n2;\\n            n2 = next + n2;\\n        }\\n\\n        return n2;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252887,
                "title": "explanation-of-the-idea-of-dp-o-n-time-space-c",
                "content": "\\n# Climbing Stairs problem\\n\\n\\n\\n- We are given a staircase which has **\\u2018n\\u2019 steps/floors**.\\n- Each time, on each step, **we can either take 1 step or 2 steps at a time**.\\n- We need to **find the number of distinct ways in which we can reach the top step/floor.**\\n\\n- Let n = 3, meaning we have 3 steps or floors to climb to as shown below :\\n![stairs_0.PNG](https://assets.leetcode.com/users/images/6a78b919-b75a-4b00-a995-041a9e540e9a_1677862570.6098013.png)\\n\\n\\n- One way to climb the stairs is : 1 step + 1 step + 1 step , as shown below :\\n\\n![stairs_1.PNG](https://assets.leetcode.com/users/images/8c9c1e95-6a83-4c7b-afe4-1c8fcf09089f_1677862584.8530686.png)\\n\\n- Another way would be  : 2 step + 1 step :\\n\\n![stairs_3.PNG](https://assets.leetcode.com/users/images/4ca71d7c-5257-4f5e-89a6-38feb75fc9f3_1677862653.4234407.png)\\n\\n- Another way would be : 1 step + 2 step as shown below :\\n\\n![stairs_2.PNG](https://assets.leetcode.com/users/images/22f620cc-2f44-40ca-bc3c-d9d61bda7d38_1677862666.0298843.png)\\n\\n\\n- So total number of distinct ways to climb n = 3 floors = 1 + 1 + 1 = 3.\\n\\n## Explanation:\\n\\n- For n = 2 , we know there are following 2 ways in which we can climb :\\n\\n![stairs_4.PNG](https://assets.leetcode.com/users/images/04cc0ecb-a6e3-4cec-b29b-99c557271f74_1677862691.0310204.png)\\n\\n- We can either go 1 step + 1 step , or 2 step directly.\\n\\n- Now , we can define an **array \\u2018dp\\u2019** of size \\u2018n\\u2019, ie the number of floors.\\n\\n```cpp\\n**dp[i] ==> number of  distinct ways climb to the \\'ith\\' floor from \\'0th\\' floor**\\n```\\n\\n- So ultimately we need to find **dp[n] ie the number of distinct ways in which we can climb \\u2018n\\u2019 floors.**\\n- So what is **dp[i] ?**\\n\\n \\n\\n- Say, there is some ith floor to which we need to count number of ways to climb.\\n![stairs_5.PNG](https://assets.leetcode.com/users/images/a6352348-80a2-4410-b343-c77df8a92034_1677862714.0218048.png)\\n\\n- **To reach to the ith floor, either of the two options must have happened**\\n    - **took 1 step from (i-1)th floor**\\n    - **took 2 step from (i-2)ith floo**r\\n\\n![stairs_6.PNG](https://assets.leetcode.com/users/images/27460725-01f5-4020-90ed-62a4d7c83456_1677862732.8335752.png)\\n\\n- So, dp[i] can be written as :\\n![stairs_7.PNG](https://assets.leetcode.com/users/images/8a09b1c9-a78f-4087-8e59-53ec45f9128e_1677862751.7524385.png)\\n\\n- So , what are the **base cases** :\\n    - **dp[1] = 1** , because to climb to floor = 1 , there is only 1 way ie to take 1 step\\n    - **dp[2] = 2** , because to climb to floor = 2, there are 2 ways : 1 step + 1 step OR 2 step.\\n    \\n\\n![stairs_8.PNG](https://assets.leetcode.com/users/images/3a140591-2427-44d2-a375-967ccd4dd26d_1677862771.3870678.png)\\n\\n### Let\\u2019s do a case for n = 4.\\n\\n![stairs_9.PNG](https://assets.leetcode.com/users/images/784c008f-2c41-4bfa-85c4-a4267f7c5a0e_1677862791.054674.png)\\n\\n\\n- dp[1] = 1 and dp[2] = 2.\\n- Let\\u2019s **find dp[3]** then.\\n- Our formula is :\\n\\n```cpp\\n         dp[i] = dp[i-1] + dp[i-2]\\n\\nhere, i = 3 ,\\ndp[3] = dp[2] + dp[1] \\ndp[3] = 2 + 1\\ndp[3] = 3\\n```\\n![stairs_10.PNG](https://assets.leetcode.com/users/images/eda4eef1-fd19-4e5e-9422-526bf06eb677_1677862805.104596.png)\\n\\n- Therefore **dp[3] = 2 + 1 = 3 , therefore there are 3 distinct ways to reach the 3rd floor using 1 step and 2 step.**\\n\\n![stairs_11.PNG](https://assets.leetcode.com/users/images/7e99c5f2-1e53-44da-b6a7-fd71892748a0_1677862821.0890055.png)\\n\\n\\n- Now, for **dp[4] :**\\n\\n```cpp\\n\\t\\t\\t\\tdp[i] = dp[i-1] + dp[i-2]\\ni = 4,\\ndp[4] = dp[3] + dp[2]\\ndp[4] = 3 + 2\\ndp[4] = 5\\n```\\n\\n![1.PNG](https://assets.leetcode.com/users/images/d09f400d-19b6-4d0d-bfc2-1ece3c2e326a_1677862837.9587646.png)\\n\\n![2.PNG](https://assets.leetcode.com/users/images/1ab2836a-d21f-42a7-83bb-52210f793a16_1677862876.0183854.png)\\n\\n\\n![3.PNG](https://assets.leetcode.com/users/images/46e50134-09a2-4aa4-8423-ce984d5c3d86_1677862902.4442675.png)\\n\\n![4.PNG](https://assets.leetcode.com/users/images/2bb6a386-9567-455a-bfb8-b0b6f545b460_1677862915.397574.png)\\n\\n\\n![5.PNG](https://assets.leetcode.com/users/images/31a97205-4239-41cb-bddd-942c3853cb30_1677862928.6362588.png)\\n\\n- Therefore there are **5 distinct ways to reach 4th floor.**\\n# Code\\n```\\n \\nclass Solution \\n{\\n public :\\n int climbStairs(int n)\\n {\\n    if(n<=1)\\n        return 1;\\n    int dp[n + 1];\\n    dp[1] = 1;\\n    dp[2] = 2;\\n    for(int i = 3 ; i <= n ; i++ )\\n        dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n**dp[i] ==> number of  distinct ways climb to the \\'ith\\' floor from \\'0th\\' floor**\\n```\n```cpp\\n         dp[i] = dp[i-1] + dp[i-2]\\n\\nhere, i = 3 ,\\ndp[3] = dp[2] + dp[1] \\ndp[3] = 2 + 1\\ndp[3] = 3\\n```\n```cpp\\n\\t\\t\\t\\tdp[i] = dp[i-1] + dp[i-2]\\ni = 4,\\ndp[4] = dp[3] + dp[2]\\ndp[4] = 3 + 2\\ndp[4] = 5\\n```\n```\\n \\nclass Solution \\n{\\n public :\\n int climbStairs(int n)\\n {\\n    if(n<=1)\\n        return 1;\\n    int dp[n + 1];\\n    dp[1] = 1;\\n    dp[2] = 2;\\n    for(int i = 3 ; i <= n ; i++ )\\n        dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164321,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      const int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 3:\\n            return n\\n\\n        cur = 2\\n        prev = 1\\n\\n        for _ in range(3, n + 1):\\n            cur, prev = cur + prev, cur\\n        \\n        return cur\\n```\\n\\n```Java []\\nclass Solution {\\n  public int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      final int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      const int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 3:\\n            return n\\n\\n        cur = 2\\n        prev = 1\\n\\n        for _ in range(3, n + 1):\\n            cur, prev = cur + prev, cur\\n        \\n        return cur\\n```\n```Java []\\nclass Solution {\\n  public int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      final int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902866,
                "title": "java-explained-in-detail-simple-fast-solution-dynamic-programming",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n# Java - Recursive & Memoization\\n\\n## Approach\\nThis problem is the same as the Fibonacci number sequence, where the number of ways is the sum of the ways for \\'n - 1\\' and \\'n - 2\\'.\\n\\nWhen we are on step i, we can only be at i + 1 or i + 2 for one iteration.\\n\\nConversely, when we are at step n, we can only have taken the route from i - 1 or i - 2.\\n\\nThe same applies to the route to arrive at i - 1 and i - 2 respectively.\\n\\nThus, ways(n) = ways(n - 1) + ways(n - 2).\\n\\nHere, we use the recursive method, using the \\'memo\\' keep track of the calculated number to lower the time complexity.\\n\\n## Complexity\\n- Time Complexity  : O(n), as the recursive call stack is at a maximum of size \\'n\\', when climbStairs(i - 1) is called until reaching the base case.\\n\\n- Space Complexity : O(n), as we use the memo of size \\'n\\' to record the result of stairs from 1 to \\'n\\'.\\n\\n## Java - With Explanation\\n```\\npublic class ClimbingStairs_Recursive {\\n\\n    // Wrapper method.\\n    public int climbStairs(int n) {\\n\\n        // Use an integer array as \\'memo\\' to record the results that was calculated.\\n        // This is so to not repeat the same calculation over the recursive calls.\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    // Recursive method.\\n    private int climbStairs(int n, int[] memo) {\\n\\n        // We know the ways for n == 1 and n == 2, so record it into the memo.\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        // If \\'n\\' is already in the memo, return memo[n].\\n        if (memo[n] > 0) return memo[n];\\n\\n        // If the current \\'n\\' is not in the memo, then we call the recursive method to calculate and record memo[n],\\n        // and return the result.\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\\n## Java - Clean Code\\n```\\npublic class ClimbingStairs_Recursive {\\n\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, int[] memo) {\\n\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        if (memo[n] > 0) return memo[n];\\n\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\\n\\n---\\n\\n# Java - Iterative & Tabulation\\n\\n## Approach\\nThis problem is the same as the Fibonacci number sequence, where the number of ways is the sum of the ways for \\'n - 1\\' and \\'n - 2\\'.\\n\\nWhen we are on step i, we can only be at i + 1 or i + 2 for one iteration.\\n\\nConversely, when we are at step n, we can only have taken the route from i - 1 or i - 2.\\n\\nThe same applies to the route to arrive at i - 1 and i - 2 respectively.\\n\\nThus, ways(n) = ways(n - 1) + ways(n - 2).\\n\\nHere, we use the iterative and tabulation method, using an array to keep track.\\n\\nNote that it is possible to use only two variables to keep track of ways(i - 1) and ways(i - 2), but this is a good practice for the tabulation method in dynamic programming.\\n\\n## Complexity\\n- Time Complexity  : O(n),\\nas we iterate from 1 to \\'n\\' to find the number of ways to climb stairs.\\n\\n- Space Complexity : O(n), \\nas we use the table of size \\'n\\' to record the result of stairs from 1 to \\'n\\'.\\nIf we use only two variable to record ways(i - 1) and ways(i - 2), then it will be O(1).\\n\\n## Java - With Explanation\\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n\\n        // Return the ways for n == 1 and n == 2, since we know the result already.\\n        if (n == 1 || n == 2) return n;\\n\\n        // When using tabulation, seed the table with the base cases for n == 1 and n == 2.\\n        // Since the array in Java is zero-indexed, we make sure to have the table of size \"n + 1\"\\n        // as we need to access index \\'n\\'.\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n        // Iterate through the table and update its values until \\'n\\'.\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n\\n        // table[n] is the result.\\n        return table[n];\\n    }\\n}\\n```\\n## Java - Clean Code\\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n        if (n == 1 || n == 2) return n;\\n\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n        return table[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\npublic class ClimbingStairs_Recursive {\\n\\n    // Wrapper method.\\n    public int climbStairs(int n) {\\n\\n        // Use an integer array as \\'memo\\' to record the results that was calculated.\\n        // This is so to not repeat the same calculation over the recursive calls.\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    // Recursive method.\\n    private int climbStairs(int n, int[] memo) {\\n\\n        // We know the ways for n == 1 and n == 2, so record it into the memo.\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        // If \\'n\\' is already in the memo, return memo[n].\\n        if (memo[n] > 0) return memo[n];\\n\\n        // If the current \\'n\\' is not in the memo, then we call the recursive method to calculate and record memo[n],\\n        // and return the result.\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\n```\\npublic class ClimbingStairs_Recursive {\\n\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, int[] memo) {\\n\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        if (memo[n] > 0) return memo[n];\\n\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n\\n        // Return the ways for n == 1 and n == 2, since we know the result already.\\n        if (n == 1 || n == 2) return n;\\n\\n        // When using tabulation, seed the table with the base cases for n == 1 and n == 2.\\n        // Since the array in Java is zero-indexed, we make sure to have the table of size \"n + 1\"\\n        // as we need to access index \\'n\\'.\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n        // Iterate through the table and update its values until \\'n\\'.\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n\\n        // table[n] is the result.\\n        return table[n];\\n    }\\n}\\n```\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n        if (n == 1 || n == 2) return n;\\n\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n        return table[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775347,
                "title": "ruby-six-approaches",
                "content": "```\\n# 70.climbing_stairs.rb\\n# @param {Integer} n\\n# @return {Integer}\\n#\\n# recursion using brute force approach\\n#\\n# time: O(2^n) the size of the recursion tree is 2^n\\n#\\n# space: O(n) where n is the height or depth of the three.\\n#\\n# climb_stair(i,n) = (i + 1, n) = climb_stair(i + 2, n)\\ndef climb_stairs(n)\\n    return climb_stair(0, n) # helper function\\n end\\n \\n # where i is the current step and n is the destination step\\n def climb_stair(i, n)\\n \\n     # base case\\n     # if i > n we walked over and we return 0\\n     return 0 if i > n \\n     # if n is 1 we can only take one step thus return 1\\n     return 1 if i == n \\n \\n     # recursive case\\n     # we climb 1 step and climb 2 steps\\n     return climb_stair(i + 1, n) + climb_stair(i + 2, n)\\n end\\n```\\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with array)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = Array.new(n + 1, 0)\\n     return climb_stair(0, n, memo) \\n end\\n  \\n def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i] > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with hash)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = {}\\n     return climb_stair(0, n, memo) \\n end\\n  \\n  def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i].to_i > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\\n```\\n \\n # with memoiztion without recursion\\n #\\n # time: O(n) we iterate over one array.\\n #\\n # space: O(n) array of size n.\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     memo    = Array.new(n + 1, 0)\\n     memo[1] = 1\\n     memo[2] = 2\\n \\n     for i in (3..n)\\n         memo[i] = memo[i - 1] + memo[i - 2]\\n     end\\n \\n     return memo[n]\\n end\\n```\\n```\\n \\n # fibonacci number approach\\n #\\n # time: O(n) single loop\\n #\\n # space: O(1) no memory space is allocated\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     first   = 1\\n     second  = 2\\n \\n     for i in (3..n)\\n         third   = first + second\\n         first   = second\\n         second  = third\\n     end\\n     \\n     return second \\n end\\n```\\n```\\n \\n # fibonacci formula\\n #\\n # time: O(log n) raising it to power of x takes log n time.\\n #\\n # space: O(1) constant space.\\n #\\n # note: credit to other programmer for this solution \\n def climb_stairs(n)\\n     sqrt5   = Math::sqrt(5)\\n     phi     = (1 + sqrt5) / 2.0\\n     psi     = (1 - sqrt5) / 2.0\\n \\n     return (((phi ** (n + 1)) - (psi ** (n + 1))) / sqrt5).to_i\\n end\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# 70.climbing_stairs.rb\\n# @param {Integer} n\\n# @return {Integer}\\n#\\n# recursion using brute force approach\\n#\\n# time: O(2^n) the size of the recursion tree is 2^n\\n#\\n# space: O(n) where n is the height or depth of the three.\\n#\\n# climb_stair(i,n) = (i + 1, n) = climb_stair(i + 2, n)\\ndef climb_stairs(n)\\n    return climb_stair(0, n) # helper function\\n end\\n \\n # where i is the current step and n is the destination step\\n def climb_stair(i, n)\\n \\n     # base case\\n     # if i > n we walked over and we return 0\\n     return 0 if i > n \\n     # if n is 1 we can only take one step thus return 1\\n     return 1 if i == n \\n \\n     # recursive case\\n     # we climb 1 step and climb 2 steps\\n     return climb_stair(i + 1, n) + climb_stair(i + 2, n)\\n end\\n```\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with array)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = Array.new(n + 1, 0)\\n     return climb_stair(0, n, memo) \\n end\\n  \\n def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i] > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with hash)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = {}\\n     return climb_stair(0, n, memo) \\n end\\n  \\n  def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i].to_i > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\n```\\n \\n # with memoiztion without recursion\\n #\\n # time: O(n) we iterate over one array.\\n #\\n # space: O(n) array of size n.\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     memo    = Array.new(n + 1, 0)\\n     memo[1] = 1\\n     memo[2] = 2\\n \\n     for i in (3..n)\\n         memo[i] = memo[i - 1] + memo[i - 2]\\n     end\\n \\n     return memo[n]\\n end\\n```\n```\\n \\n # fibonacci number approach\\n #\\n # time: O(n) single loop\\n #\\n # space: O(1) no memory space is allocated\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     first   = 1\\n     second  = 2\\n \\n     for i in (3..n)\\n         third   = first + second\\n         first   = second\\n         second  = third\\n     end\\n     \\n     return second \\n end\\n```\n```\\n \\n # fibonacci formula\\n #\\n # time: O(log n) raising it to power of x takes log n time.\\n #\\n # space: O(1) constant space.\\n #\\n # note: credit to other programmer for this solution \\n def climb_stairs(n)\\n     sqrt5   = Math::sqrt(5)\\n     phi     = (1 + sqrt5) / 2.0\\n     psi     = (1 - sqrt5) / 2.0\\n \\n     return (((phi ** (n + 1)) - (psi ** (n + 1))) / sqrt5).to_i\\n end\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2765329,
                "title": "fibo",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.fibnocci = [0,1,2]\\n        for i in range(3,46):\\n            self.fibnocci.append(self.fibnocci[i-1]+self.fibnocci[i-2]);\\n            \\n    def climbStairs(self, n: int) -> int:\\n        return self.fibnocci[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.fibnocci = [0,1,2]\\n        for i in range(3,46):\\n            self.fibnocci.append(self.fibnocci[i-1]+self.fibnocci[i-2]);\\n            \\n    def climbStairs(self, n: int) -> int:\\n        return self.fibnocci[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735055,
                "title": "0ms-runtime-c-solution-dynamic-programming",
                "content": "This question follows the same pattern as the fibbonaci series.\\n\\nLet\\'s see how.\\n\\nFor n=1, no of solutions = 1\\nFor n=2, no of solutions = 2\\nFor n=3, no of solutions = 3  [1+2]\\nFor n=4, no of solutions = 5  [2+3]\\nFor n=5, no of solutions = 8  [3+5]\\nFor n=5, no of solutions = 13 [5+8]\\n\\nAs we can see the steps are sum of it\\'s two predecessors. We can apply the same algorithm for getting the $$n^{th}$$ sum of a fibonacci series here.\\n\\nWe store the already calculated values in a vector array to prevent calculating the same step sum again & again. This in face same a lot of time, thus bringing down the time complexity.\\n\\n``` C++ []\\nclass Solution {\\nprivate:\\n    int climbStairsdp(int n, vector<int>& dp) {\\n        if (n<2) return 1;\\n        if (dp[n]) return dp[n];\\n        else return dp[n] = climbStairsdp(n-1, dp) + climbStairsdp(n-2, dp);\\n    }\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return climbStairsdp(n, dp);\\n    }\\n};\\n```\\n\\n*if this solution helped you, please do upvote it*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` C++ []\\nclass Solution {\\nprivate:\\n    int climbStairsdp(int n, vector<int>& dp) {\\n        if (n<2) return 1;\\n        if (dp[n]) return dp[n];\\n        else return dp[n] = climbStairsdp(n-1, dp) + climbStairsdp(n-2, dp);\\n    }\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return climbStairsdp(n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732425,
                "title": "o-1-time-complexity-solution",
                "content": "As many have already pointed out, this Is basically a fibonacci series implimentation and there already are good explanations of this in the discussions.\\n\\nHowever there is a direct mathematical fomula for fibonacci that you can refer to here: https://math.hmc.edu/funfacts/fibonacci-number-formula/\\n\\nMeaning its a direct answer with no loops.\\n\\n__NOTE__ - At this point the complexity of the actual operators like ** and / do start mattering so its not exactly O(1) technically speaking, but I believe this is the closest we can get to an O(1) solution.\\n\\n``` Python \\nclass Solution(object):\\n    def climbStairs(self, n):\\n        n = n+1\\n        root5 = 5**0.5\\n        Phi,phi = (1 + root5)/2,(1 - root5)/2\\n        return int((Phi**n - phi**n)/root5)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` Python \\nclass Solution(object):\\n    def climbStairs(self, n):\\n        n = n+1\\n        root5 = 5**0.5\\n        Phi,phi = (1 + root5)/2,(1 - root5)/2\\n        return int((Phi**n - phi**n)/root5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698704,
                "title": "c-java-python3-javascript-solutions-faster-than-90",
                "content": "### **Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50**\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n**A similar question : [Zyrastory - Pascal\\'s Triangle](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-118-pascals-triangle-solution-explanation/)**\\n\\n**Example : C# Solution1 - temporary interger**\\n```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        //the first example has tell us how many distinct way for 1 or 2 steps stairs\\n        int first  = 1;     \\n        int second = 2;     \\n        int tmp = 0;        \\n        \\n        if(n<=2)    //if n not more than 2 than just return the stpes it take\\n        {\\n            return n;\\n        }\\n        else\\n        {\\n            for(int i =3; i<=n;i++) //every iteration,will add the last two steps together and save as \\'second\\'\\n            {\\n                tmp = second;       \\n                second+=first;      //set second as now iteration needed steps\\n                first = tmp;        //set first as the last time needed steps\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```\\n\\n\\n**Example : C# Solution2 - use Array to store**\\n```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        if(n<2){\\n            return n;\\n        }\\n        \\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        ans[1] = 2;\\n        \\n        for(int i=2;i<n;i++) {\\n            ans[i]=ans[i-1]+ans[i-2];\\n        }\\n        return ans[n-1];\\n    }\\n}\\n```\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        //the first example has tell us how many distinct way for 1 or 2 steps stairs\\n        int first  = 1;     \\n        int second = 2;     \\n        int tmp = 0;        \\n        \\n        if(n<=2)    //if n not more than 2 than just return the stpes it take\\n        {\\n            return n;\\n        }\\n        else\\n        {\\n            for(int i =3; i<=n;i++) //every iteration,will add the last two steps together and save as \\'second\\'\\n            {\\n                tmp = second;       \\n                second+=first;      //set second as now iteration needed steps\\n                first = tmp;        //set first as the last time needed steps\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        if(n<2){\\n            return n;\\n        }\\n        \\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        ans[1] = 2;\\n        \\n        for(int i=2;i<n;i++) {\\n            ans[i]=ans[i-1]+ans[i-2];\\n        }\\n        return ans[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690264,
                "title": "faster-than-100",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        // simple fibonacci problem\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        // simple fibonacci problem\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437625,
                "title": "five-different-solution-c-easily-understandable",
                "content": "```\\nTime: O(2^n)  Space: O(n)\\n--> Recursion (TLE)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        int left=climbStairs(n-1);\\n        int right=climbStairs(n-2);\\n        return left+right;\\n    }\\n};\\n\\nTime: O(n)  Space: O(n)\\n--> Memoization (Top-Down)\\n\\nclass Solution {\\npublic:\\n    int dp[46]={0};\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        else if(n==2)\\n            return 2;\\n        else if(dp[n]!=0)\\n            return dp[n];\\n        dp[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return dp[n];\\n    }\\n};\\n\\n--> Without using Global Variable\\n\\nclass Solution {\\npublic:\\n    int f(int n,vector<int>& dp){\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(dp[n]!=0)\\n            return dp[n];\\n        int left=f(n-1,dp);\\n        int right=f(n-2,dp);\\n        return dp[n]=left+right;\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return f(n,dp);\\n    }\\n};\\n\\nTime: O(n) Space: O(n) \\n--> Tabulation (Bottom-Up)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[1]=1;dp[0]=1;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\nTime: O(n)  Space: O(1)\\n--> Tabulation and Space Optimized\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<2)\\n            return 1;\\n        int a=1,b=1,c=0;\\n        for(int i=2;i<=n;i++){\\n            c=a+b;\\n            a=b;b=c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nTime: O(2^n)  Space: O(n)\\n--> Recursion (TLE)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        int left=climbStairs(n-1);\\n        int right=climbStairs(n-2);\\n        return left+right;\\n    }\\n};\\n\\nTime: O(n)  Space: O(n)\\n--> Memoization (Top-Down)\\n\\nclass Solution {\\npublic:\\n    int dp[46]={0};\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        else if(n==2)\\n            return 2;\\n        else if(dp[n]!=0)\\n            return dp[n];\\n        dp[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return dp[n];\\n    }\\n};\\n\\n--> Without using Global Variable\\n\\nclass Solution {\\npublic:\\n    int f(int n,vector<int>& dp){\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(dp[n]!=0)\\n            return dp[n];\\n        int left=f(n-1,dp);\\n        int right=f(n-2,dp);\\n        return dp[n]=left+right;\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return f(n,dp);\\n    }\\n};\\n\\nTime: O(n) Space: O(n) \\n--> Tabulation (Bottom-Up)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[1]=1;dp[0]=1;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\nTime: O(n)  Space: O(1)\\n--> Tabulation and Space Optimized\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<2)\\n            return 1;\\n        int a=1,b=1,c=0;\\n        for(int i=2;i<=n;i++){\\n            c=a+b;\\n            a=b;b=c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334116,
                "title": "c-java-python3-javascript-solutions-faster-than-85-90",
                "content": "### **Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50**\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n**A similar question : [Zyrastory - Pascal\\'s Triangle](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-118-pascals-triangle-solution-explanation/)**\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "### **Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50**\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n**A similar question : [Zyrastory - Pascal\\'s Triangle](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-118-pascals-triangle-solution-explanation/)**\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "codeTag": "Unknown"
            },
            {
                "id": 2191631,
                "title": "simplest-python-solution-explanation-code-dp-approach",
                "content": "**CLIMBING STAIRS PROBLEM:**\\nThis problem is very similar to [Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)\\n\\nWe have two choices at the start: either climb the first stair or climb the 2nd stair.\\n* if we take one step from the ground, then the subproblem becomes: *climbing the nth stair from the 1st stair.*\\n\\n* if we take two step from the ground, then the subproblem becomes: *climbing the nth stair from the 2nd stair.*\\n\\nSo we can solve the given problem recursively by adding the results of sub-problems:\\n**climbStairs(0, n) = climbStairs(1, n) + climbStairs(2, n)**\\n\\n```\\ndef climbStairs(self, n: int) -> int:\\n\\t\\tif n <= 2:\\n            return n\\n        \\n        dp = [0] * (n+1)\\n\\t\\t\\n        dp[1] = 1\\n        dp[2] = 2\\n        \\n        for i in range(3, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        \\n        return dp[n]\\n```\\n\\n**Another more efficient approach could be:**\\n```\\ndef climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        \\n        dp = [0, 1, 2]\\n        \\n        for i in range(3, n+1):\\n            dp[i%3] = dp[(i-1) % 3] + dp[(i-2) % 3]\\n        \\n        return dp[n % 3]\\n        \\n```\\n\\nFeel free to ask the doubts and please upvote!(^_^)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef climbStairs(self, n: int) -> int:\\n\\t\\tif n <= 2:\\n            return n\\n        \\n        dp = [0] * (n+1)\\n\\t\\t\\n        dp[1] = 1\\n        dp[2] = 2\\n        \\n        for i in range(3, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        \\n        return dp[n]\\n```\n```\\ndef climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        \\n        dp = [0, 1, 2]\\n        \\n        for i in range(3, n+1):\\n            dp[i%3] = dp[(i-1) % 3] + dp[(i-2) % 3]\\n        \\n        return dp[n % 3]\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2176954,
                "title": "java-solution-in-depth-explanation-w-mathmatical-proof",
                "content": "This is a very good DP problem based on mathematical proof. I believe many people have the same questions in their mind like I do. Why it\\'s `(n-1)` step + `(n-2)` step, but not `(n-1)` step + `(n-2)` step + `1` since we need to do an additional step to get to stair `n`? I would use [@WX-78](https://leetcode.com/WX-78) \\'s idea to explain. \\n  Think about what happens on the `n`-th step. We can get to stair `n` from `(n-1)` step or from `(n-2)` step. Also, we know there are `x` distinct ways to get to `(n-1)` step, and `y` distinct ways to get to `(n-2)` steps.\\n\\n  1. For `(n-1)`, we just need to add 1 on `x` paths to get to `n` step. It doesn\\'t change the number of `x` paths required to get `(n-1)` step.\\n  2. For `(n-2)`, we need to add 2 on `y` paths to get to `n` step. It also doesn\\'t change the number of `y` paths required to get to `(n-2)` step.\\n  Therefore, we just need to add `(n-1)` step and `(n-2)` step together to get all the possible ways to `n` step. I believe it is still unclear at this point so let\\'s look the **examples** below.\\n\\nFor example 1, what are all the paths leading to `3`:\\n`[1 + 1 + 1]`\\n`    [2 + 1]`\\n`    [1 + 2]`\\nTo get to `5`, we simply need to add `2` to all the possible paths:\\n`[1 + 1 + 1] + 2`\\n`    [2 + 1] + 2`\\n`    [1 + 2] + 2`\\nNow we can see how the magic works here. The number of ways to get from `3` to `5` does not change with this operation, right? We are adding `2`to each sequence, but it just makes each sequence longer **not making more of possible sequences**.\\n\\nLet\\'s look at another example, just in case it\\'s still not clear enough.\\n\\nFor example 2, for `4` we have five possible ways to get to there:\\n`[1 + 1 + 1 + 1]`\\n`    [1 + 1 + 2]`\\n`    [1 + 2 + 1]`\\n`    [2 + 1 + 1]`\\n`        [2 + 2]`\\nTo get to `5`, we need to add `1` to all the possible sequence so we will have:\\n`[1 + 1 + 1 + 1] + 1`\\n`    [1 + 1 + 2] + 1`\\n`    [1 + 2 + 1] + 1`\\n`    [2 + 1 + 1] + 1`\\n`        [2 + 2] + 1`\\nAgain, we can see how the magic works here. With the adding operation, it doesn\\'t change the number of possible ways to get to `5`. Hence, the total number of paths to get to `5` is the total number of path to get to `3` + the total number of path to get to `4`.\\n\\n  Below is my solution in Java.\\n```\\nclass Solution \\n{\\n    public int climbStairs(int n) \\n    {\\n        // O(n) time | O(n) space\\n        if(n == 0)  return 1;\\n        if(n == 1)  return 1;\\n        \\n        int[] stairs = new int[n];\\n        \\n        stairs[0] = 1;\\n        stairs[1] = 2;\\n        \\n        for(int i = 2; i < n; i++)\\n            stairs[i] = stairs[i-1] + stairs[i-2];\\n        \\n        return stairs[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int climbStairs(int n) \\n    {\\n        // O(n) time | O(n) space\\n        if(n == 0)  return 1;\\n        if(n == 1)  return 1;\\n        \\n        int[] stairs = new int[n];\\n        \\n        stairs[0] = 1;\\n        stairs[1] = 2;\\n        \\n        for(int i = 2; i < n; i++)\\n            stairs[i] = stairs[i-1] + stairs[i-2];\\n        \\n        return stairs[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851979,
                "title": "illustrated-explanation",
                "content": "<<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3c78e85c-e538-4392-a13b-ae1d1bb04642_1647355317.703214.png)\\n\\n    @functools.cache\\n    def climbStairs(self, n: int) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        return self.climbStairs(n - 2) + self.climbStairs(n - 1) if n > 2 else n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "<<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3c78e85c-e538-4392-a13b-ae1d1bb04642_1647355317.703214.png)\\n\\n    @functools.cache\\n    def climbStairs(self, n: int) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        return self.climbStairs(n - 2) + self.climbStairs(n - 1) if n > 2 else n",
                "codeTag": "Python3"
            },
            {
                "id": 1822442,
                "title": "climbing-stairs-easy-java-solution",
                "content": "***IF YOU LIKE IT, PLS PLS UPVOTE IT :)***\\n![image](https://assets.leetcode.com/users/images/dd1f3bc6-3040-42ab-871f-8f2660595ceb_1646499781.8532014.jpeg)\\n\\n```\\n//A type of fibonacci number problem\\n//I\\'m gonna use memoization here\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        //to store the value of recursive call\\n        int[] dp=new int[n+1];\\n        return  countSteps(n,dp); \\n    \\n    }\\n    \\n    static int countSteps(int n,int[] dp){\\n\\n\\n        //BASE CASE\\n        //I can only jump on the last stair can\\'t go next\\n        if(n==0){return 1;}\\n        //I can go till 0th stair from 1st stair\\n        if(n==1) {return 1;}\\n        \\n        //to check if I have computed this value earlier or not!\\n        if(dp[n]!=0){\\n            return dp[n];\\n        }\\n        //I can either jump one step or two step!\\n        int lh=countSteps(n-1,dp);\\n        int rh=countSteps(n-2,dp);\\n        \\n        //sum of both side\\n        return dp[n]=lh+rh;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//A type of fibonacci number problem\\n//I\\'m gonna use memoization here\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        //to store the value of recursive call\\n        int[] dp=new int[n+1];\\n        return  countSteps(n,dp); \\n    \\n    }\\n    \\n    static int countSteps(int n,int[] dp){\\n\\n\\n        //BASE CASE\\n        //I can only jump on the last stair can\\'t go next\\n        if(n==0){return 1;}\\n        //I can go till 0th stair from 1st stair\\n        if(n==1) {return 1;}\\n        \\n        //to check if I have computed this value earlier or not!\\n        if(dp[n]!=0){\\n            return dp[n];\\n        }\\n        //I can either jump one step or two step!\\n        int lh=countSteps(n-1,dp);\\n        int rh=countSteps(n-2,dp);\\n        \\n        //sum of both side\\n        return dp[n]=lh+rh;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671910,
                "title": "python-detailed-explanation-o-n-time-o-n-space-beats-92-05-time",
                "content": "So the first intution here is going to be approaching this as a dfs problem similar to the [combination sum](https://leetcode.com/problems/combination-sum/) problem, except now this time, we\\'re only looking at the amount of ways we can sum n with only 1 and 2. \\n\\nSo we begin by drawing a graph of the problem to figure out our next steps and see if we can find a particular pattern. Let\\'s take 4 for example:\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   /         \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t     2            3\\n\\t\\t\\t\\t\\t\\t\\t       / \\t\\\\       /    \\\\\\n\\t\\t\\t\\t\\t\\t           1    0      2      1\\n\\t\\t\\t\\t\\t\\t         /           /   \\\\      \\\\ \\n\\t\\t\\t\\t\\t            0           1     0       0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0\\n```\\nFirst things first, we realize we can use 1 and 2 as our base case, since it\\'s a relatively simple answer, and every branch will always end in a 1 or a 2. \\n\\nThe second thing we can realize is that we can sort of start looking at every solution less than 4 below it. The right hand hand side of the tree gives us the solution of 3, and left hand side gives us the solution for 2. Then the branches of 3 gives us the solution for 2 and 1. We also realize that the sum of the solutions of both sides of the tree gives us the final answer for the root.  So we begin plotting out for funtion f:\\n```\\nf(5) = f(4) + f(3)\\nf(4) = f(3) + f(4)\\nf(3) = f(2) + f(1)\\n```\\nThus we see that for n in range [2, inf]:\\n```\\nf(n) = f(n - 1) + f(n - 2)\\n```\\nWhich should look familiar, because this is just a fibonacci sequence!\\nUsing this information, we can create some simple code similiar to the code of the classic fib sequence problem:\\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n in {1, 2}:\\n            return n\\n        \\n        return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\\nIn this solution, since the longest branch is going to be us just repeatingly subtracting 1 from n, n is going to be our tree height, and thus our space complexity from our stack will be O(n). \\nSince for n tree height we are going to have a worst case of 2^n nodes (you can test this out yourself by drawing a tree, with each node having exactly two children), then the time complexity for this solution is O(2^n). \\n\\nThis solution is clearly not an efficient one, so we are going to try to see how we can speed things up. One thing we can usually do whenever we are dealing with recursion is memoizing. And since we have a bunch of branches that repeat, this is the perfect opportunity to utalize it. \\n\\nSo if we are calculating a large number like 45, instead of calculating the solution for any n less than 44 multiple times, we can just calculate it once, and hold the solution we find in a dictionary. That way, whenever we come accross the need to find the solution for the same number in the future, we can solve it in O(1) time. \\n\\nSince recursion sort of works like dfs, and we are doing n - 1 first, we\\'re going to have the solution for every number up to n before we even start going to any of the right branches. Since at that point all of the solutions for the right branches are found and only require O(1) lookup time, the only calculations we\\'re doing is the left branches which are made up of n nodes. \\nThus, our new time complexity should be O(n), all while our space complexity should stay the same, since we\\'re only storing up to n solutions in the dictionary.\\n\\nAwesomely enough, we can achieve this through just a few edits of our old code:\\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\n\\nclass Solution:\\n    def climbStairs(self, n: int, memo = {1:1, 2:2}) -> int:\\n        if n in memo:\\n            return memo[n]\\n        \\n        memo[n] = self.climbStairs(n - 1, memo) + self.climbStairs(n - 2, memo)\\n        \\n        return memo[n]\\n```\\n\\nLet me know if there are any questions or sugestions!\\nIf you want to look further into it, I recommend looking at the first problem solved in the dynamic programming video offered by freecodecamp.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   /         \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t     2            3\\n\\t\\t\\t\\t\\t\\t\\t       / \\t\\\\       /    \\\\\\n\\t\\t\\t\\t\\t\\t           1    0      2      1\\n\\t\\t\\t\\t\\t\\t         /           /   \\\\      \\\\ \\n\\t\\t\\t\\t\\t            0           1     0       0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0\\n```\n```\\nf(5) = f(4) + f(3)\\nf(4) = f(3) + f(4)\\nf(3) = f(2) + f(1)\\n```\n```\\nf(n) = f(n - 1) + f(n - 2)\\n```\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n in {1, 2}:\\n            return n\\n        \\n        return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\n\\nclass Solution:\\n    def climbStairs(self, n: int, memo = {1:1, 2:2}) -> int:\\n        if n in memo:\\n            return memo[n]\\n        \\n        memo[n] = self.climbStairs(n - 1, memo) + self.climbStairs(n - 2, memo)\\n        \\n        return memo[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591139,
                "title": "javascript-python-beat-96-fibonacci-sequence-simple-readable",
                "content": "```\\n/* \\n1 -> 1\\n2 -> 2 (1+1 | 2+0)\\n3 -> 3 (1+1+1 | 2+1 | 1+2)\\n4 -> 5 (1+1+1+1 | 2+1+1 | 2+2 | 1+2+1 | 1+1+2)\\nand so on\\n\\nThis is exactly a fibonacci sequence\\nEach next amount of steps equals to sum of previous 2\\n1 -> 2 -> 3 -> 5 -> 8 -> 13\\n*/\\n```\\n\\nJavascript\\n```\\nvar climbStairs = function(n) {\\n  let a = 0;\\n  let b = 1;\\n  for (let i = 0; i < n; i++) {\\n    [a, b] = [b, a + b];\\n  }\\n  return b;\\n};\\n```\\n\\nPython\\n```\\nclass Solution:\\n  def climbStairs(self, n: int) -> int:\\n    a, b = 0, 1;\\n    for i in range(1, n + 1):\\n      b, a = a + b, b;\\n\\n    return b;\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/* \\n1 -> 1\\n2 -> 2 (1+1 | 2+0)\\n3 -> 3 (1+1+1 | 2+1 | 1+2)\\n4 -> 5 (1+1+1+1 | 2+1+1 | 2+2 | 1+2+1 | 1+1+2)\\nand so on\\n\\nThis is exactly a fibonacci sequence\\nEach next amount of steps equals to sum of previous 2\\n1 -> 2 -> 3 -> 5 -> 8 -> 13\\n*/\\n```\n```\\nvar climbStairs = function(n) {\\n  let a = 0;\\n  let b = 1;\\n  for (let i = 0; i < n; i++) {\\n    [a, b] = [b, a + b];\\n  }\\n  return b;\\n};\\n```\n```\\nclass Solution:\\n  def climbStairs(self, n: int) -> int:\\n    a, b = 0, 1;\\n    for i in range(1, n + 1):\\n      b, a = a + b, b;\\n\\n    return b;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563121,
                "title": "c-2-solutions-memoization-tabulation-dp",
                "content": "**1. Memoization**\\n```\\n    int climbStairsHelper(int n, vector<int>& t){\\n        if(n<=1) return 1;\\n        if(t[n] != -1) return t[n];\\n        else return t[n] = climbStairsHelper(n-1, t) + climbStairsHelper(n-2, t);\\n    }\\n    int climbStairs(int n) {\\n        if(n<=1) return 1;\\n        vector<int> t(n+1,-1);\\n        return climbStairsHelper(n,t);\\n    }\\n```\\n\\n**2. Tabulation (DP)**\\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        t[0] =1;\\n        t[1] = 1;\\n        for(int i=2; i<n+1; i++) t[i] = t[i-1] + t[i-2];\\n        return t[n];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    int climbStairsHelper(int n, vector<int>& t){\\n        if(n<=1) return 1;\\n        if(t[n] != -1) return t[n];\\n        else return t[n] = climbStairsHelper(n-1, t) + climbStairsHelper(n-2, t);\\n    }\\n    int climbStairs(int n) {\\n        if(n<=1) return 1;\\n        vector<int> t(n+1,-1);\\n        return climbStairsHelper(n,t);\\n    }\\n```\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        t[0] =1;\\n        t[1] = 1;\\n        for(int i=2; i<n+1; i++) t[i] = t[i-1] + t[i-2];\\n        return t[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514782,
                "title": "js-solution",
                "content": "# js solution\\n```\\nvar climbStairs = function(n) {\\n    if(n == 1) return 1;\\n    if(n==2) return 2;\\n    let arr = [1,2]\\n    for(let i=2; i<n;i++) {\\n    arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr[arr.length -1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar climbStairs = function(n) {\\n    if(n == 1) return 1;\\n    if(n==2) return 2;\\n    let arr = [1,2]\\n    for(let i=2; i<n;i++) {\\n    arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr[arr.length -1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435924,
                "title": "java-solution",
                "content": "When thinking about this problem, I started by taking a look at how many possible ways you could climb up N stairs..\\n\\n```\\nN = 1 -> [1] -> 1 way\\nN = 2 -> [1 + 1, 2] -> 2 ways\\nN = 3 -> [1+1+1, 1+2, 2+1] -> 3 ways\\nN = 4 -> [1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2] -> 5 ways\\nN = 5 -> [1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1] -> 8 ways\\n\\n```\\n\\nAt this point, it became pretty clear that a pattern was forming where the maximum number of ways you could climb up N stairs was equivalent to the MAX[N - 1] + MAX[N - 2].\\n\\nHowever, if N == 1 or N == 2 this doesn\\'t work, its simply 1 or 2.\\n\\nSolution (recursive):\\n```\\n    public int climbStairs(int n) {\\n        if(n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n```\\n\\nThats really bad when N becomes large.. but we can use store the previous values in an array as we calculate to avoid the recursive call.\\n\\nSolution (Dynamic Programming):\\n\\n```\\n    public int climbStairs(int n) {\\n        if (n < 1) {\\n            return 0;\\n        } else if (n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n        int[] steps = new int[n];\\n        steps[0] = 1;\\n        steps[1] = 2;\\n        for (int i = 2; i < n; i++) {\\n            steps[i] = steps[i - 1] + steps[i - 2];\\n        }\\n        return steps[n - 1];\\n    }\\n```\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nN = 1 -> [1] -> 1 way\\nN = 2 -> [1 + 1, 2] -> 2 ways\\nN = 3 -> [1+1+1, 1+2, 2+1] -> 3 ways\\nN = 4 -> [1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2] -> 5 ways\\nN = 5 -> [1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1] -> 8 ways\\n\\n```\n```\\n    public int climbStairs(int n) {\\n        if(n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n```\n```\\n    public int climbStairs(int n) {\\n        if (n < 1) {\\n            return 0;\\n        } else if (n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n        int[] steps = new int[n];\\n        steps[0] = 1;\\n        steps[1] = 2;\\n        for (int i = 2; i < n; i++) {\\n            steps[i] = steps[i - 1] + steps[i - 2];\\n        }\\n        return steps[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1415908,
                "title": "python3-24ms-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one\\n            one=one+two\\n            two=temp\\n        return one\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one\\n            one=one+two\\n            two=temp\\n        return one\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316496,
                "title": "python-top-down-recursive-with-memo-bottom-up-iterative-with-tab",
                "content": "\\n\\n**1. Top-down recursive | Without memoization**\\n```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\treturn recurse(n-1) + recurse(n-2)\\n\\n\\t# main\\n\\treturn recurse(n)\\n\\n```\\n\\n**2. Top-down recursive | With memoization**\\n```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\tif n in d:\\n\\t\\t\\treturn d[n]\\n\\t\\td[n] = recurse(n-1) + recurse(n-2)\\n\\t\\treturn d[n]\\n\\n\\t# main\\n\\td = {}\\n\\treturn recurse(n)\\n```\\n\\n**3. Bottom-up itertaive with tabulization**\\n```\\ndef climbStairs(n):       \\n\\n\\ttable = [0]*(n+1) # this stores how many ways to arrive at each index/step - NOTE [1]\\n\\t\\n\\ttable[0] = 1 # only one way to arrive at index 0 (this is basically the starting point aka ground level)\\n\\ttable[1] = 1 # only one way to arrive at index 1 (first step)\\n\\n\\t# for remaining steps/indicies, each can be arrived at from: a) 1 step away, b) 2 steps away\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\treturn table[n]\\n\\t\\n# NOTE [1]\\n# Use (n+1) so that we can have index 0 for when person is at the ground level still\\n```\\n\\n- v2.0\\n\\n```\\ndef climbStairs(n):       \\n\\tif n == 0 or n == 1:\\n\\t\\treturn 1\\n\\tif n == 2:\\n\\t\\treturn 2\\n\\n\\ttable = [0]*n\\n\\ttable[0] = 1\\n\\ttable[1] = 2\\n\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\tprint(table)\\n\\treturn table[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\treturn recurse(n-1) + recurse(n-2)\\n\\n\\t# main\\n\\treturn recurse(n)\\n\\n```\n```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\tif n in d:\\n\\t\\t\\treturn d[n]\\n\\t\\td[n] = recurse(n-1) + recurse(n-2)\\n\\t\\treturn d[n]\\n\\n\\t# main\\n\\td = {}\\n\\treturn recurse(n)\\n```\n```\\ndef climbStairs(n):       \\n\\n\\ttable = [0]*(n+1) # this stores how many ways to arrive at each index/step - NOTE [1]\\n\\t\\n\\ttable[0] = 1 # only one way to arrive at index 0 (this is basically the starting point aka ground level)\\n\\ttable[1] = 1 # only one way to arrive at index 1 (first step)\\n\\n\\t# for remaining steps/indicies, each can be arrived at from: a) 1 step away, b) 2 steps away\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\treturn table[n]\\n\\t\\n# NOTE [1]\\n# Use (n+1) so that we can have index 0 for when person is at the ground level still\\n```\n```\\ndef climbStairs(n):       \\n\\tif n == 0 or n == 1:\\n\\t\\treturn 1\\n\\tif n == 2:\\n\\t\\treturn 2\\n\\n\\ttable = [0]*n\\n\\ttable[0] = 1\\n\\ttable[1] = 2\\n\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\tprint(table)\\n\\treturn table[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1307722,
                "title": "fibonacci-turned-stairs",
                "content": "The given question is actually a variation of Fibonacci Numbers using DP. If one has faced the Fibonacci one, the this one is a piece of cake. \\n\\nThe following is the recursive code to build your intuition. It is clearly visible that this is similar to fibo code:\\n\\n\\tint climbStairs(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n<0)\\n            return 0;\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }//Gives TLE for your info., hence the DP solution\\n\\nNow as per general conception, the only thing needed to do here inorder to convert it into a DP solution is to just replace the recursive calls to elements of the dp table :\\n\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,0);\\n        dp[0] = 1;                                 //Initialization--> if n is 0 or 1 then only one way is possible\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-2] + dp[i-1];             //Update the current value\\n        }\\n        return dp[n];                              //Answer is stored at the last index o the **dp** array \\n    }\\n\\nGive a star if u liked it :)\\nThanks!!\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "The given question is actually a variation of Fibonacci Numbers using DP. If one has faced the Fibonacci one, the this one is a piece of cake. \\n\\nThe following is the recursive code to build your intuition. It is clearly visible that this is similar to fibo code:\\n\\n\\tint climbStairs(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n<0)\\n            return 0;\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }//Gives TLE for your info., hence the DP solution\\n\\nNow as per general conception, the only thing needed to do here inorder to convert it into a DP solution is to just replace the recursive calls to elements of the dp table :\\n\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,0);\\n        dp[0] = 1;                                 //Initialization--> if n is 0 or 1 then only one way is possible\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-2] + dp[i-1];             //Update the current value\\n        }\\n        return dp[n];                              //Answer is stored at the last index o the **dp** array \\n    }\\n\\nGive a star if u liked it :)\\nThanks!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 974032,
                "title": "java-top-down-dp-explaination-w-video",
                "content": "Video walkthough\\nhttps://www.youtube.com/watch?v=aquoXtYMUME\\n\\nTop Down DP is an optimization built on top of a brute force recursive problem.\\n\\nNot even thinking about DP, how would we solve the problem? The answer is to use a brute force recursive backtracking solution to try every single path we can take.\\n\\nHere\\'s a visualization at N=4\\n\\n![image](https://assets.leetcode.com/users/images/557539f6-041c-4937-b5b2-08c6a28d8b39_1608097912.1572409.png)\\n\\nStarting from N=4, we will try every combination until we reach either 0 or a negative answer. We will then count the number of answers that we found.\\n\\nSpecifically we have:\\n* Base case: N=0, return 1, we found a unique path\\n* Base Case: N < 0, return 0, invalid path\\n* Recursive Case: Stairs(N-1) + Stairs(N-2)\\n\\nThe code for this is here:\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n == 0) {\\n            // base case where we arrived at an answer\\n            return 1;\\n        } else if (n < 0) {\\n            // base case where we went too far\\n            return 0;  \\n        } else {\\n            // recursive case where we try taking 1 step\\n            // and 2 steps, adding the unique permuation\\n            // of steps back\\n            return helper(n-1) + helper(n-2);\\n        }\\n    }\\n}\\n```\\n\\nNow if you look back at the graph, you might notice that we have repeated calculations that we make, like n=1 or n=2:\\n![image](https://assets.leetcode.com/users/images/f634ccc0-09ca-4bfd-99fb-3b8a98f5b163_1608098166.53452.png)\\n\\nThe goal of DP is to save the answers we calculated at each of these sub-problems and re-use them if we ever see them again. We accomplish this by using an array to store the number of path at each stair. For example n=1 will always have 1 unique path.\\n\\nBy re-using the answer that we\\'ve calculated, we can save on runtime complexity which makes DP so powerful\\n![image](https://assets.leetcode.com/users/images/67cd3722-9e9a-4c74-ac0d-60fc510402f8_1608098320.1190197.png)\\n\\nThe only big change to our brute force recursive code is that we use an array to store the answers to each step that we calculate in the recursive case and that reuse it if we ever see it again as one of our base cases.\\n\\nHere\\'s what the code looks like:\\n```\\nclass Solution {\\n    private int[] memo; \\n    public int climbStairs(int n) {\\n        // instantiate the datastructure to cache the calculation\\n        // to each of our subproblems. i.e. what step we are on\\n        memo = new int[n+1];\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n < 0) {\\n            return 0;\\n        } else if (memo[n] != 0) {\\n            // If we stored something in our cache reuse it and avoid\\n            // recalculating everything\\n            return memo[n];\\n        } else if (n == 0) {\\n            return 1;\\n        } else {\\n            // store our calculation inside our cache so we don\\'t \\n            // have to recalculate it again for memo[n]\\n            memo[n] = helper(n-1) + helper(n-2);\\n            return memo[n];\\n        }\\n    }\\n}\\n```\\n\\nAs you can see, DP problems aren\\'t too hard. Once you can think of a recursive backtracking solution, you can easily implement DP to make your algorithm run faster.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n == 0) {\\n            // base case where we arrived at an answer\\n            return 1;\\n        } else if (n < 0) {\\n            // base case where we went too far\\n            return 0;  \\n        } else {\\n            // recursive case where we try taking 1 step\\n            // and 2 steps, adding the unique permuation\\n            // of steps back\\n            return helper(n-1) + helper(n-2);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int[] memo; \\n    public int climbStairs(int n) {\\n        // instantiate the datastructure to cache the calculation\\n        // to each of our subproblems. i.e. what step we are on\\n        memo = new int[n+1];\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n < 0) {\\n            return 0;\\n        } else if (memo[n] != 0) {\\n            // If we stored something in our cache reuse it and avoid\\n            // recalculating everything\\n            return memo[n];\\n        } else if (n == 0) {\\n            return 1;\\n        } else {\\n            // store our calculation inside our cache so we don\\'t \\n            // have to recalculate it again for memo[n]\\n            memo[n] = helper(n-1) + helper(n-2);\\n            return memo[n];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717739,
                "title": "c-yet-another-dp",
                "content": "```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n        if (n <= 2)\\n            return n;\\n        \\n        int[] res = new int[n + 1];\\n        \\n        res[1] = 1;\\n        res[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++)\\n            res[i] = res[i - 1] + res[i - 2];\\n        \\n        return res[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int ClimbStairs(int n) {\\n        if (n <= 2)\\n            return n;\\n        \\n        int[] res = new int[n + 1];\\n        \\n        res[1] = 1;\\n        res[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++)\\n            res[i] = res[i - 1] + res[i - 2];\\n        \\n        return res[n];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 647444,
                "title": "c-beats-93-56",
                "content": "Runtime: 36 ms, faster than 93.56% of C# online submissions for Climbing Stairs.\\nMemory Usage: 14.4 MB, less than 5.88% of C# online submissions for Climbing Stairs.\\n```\\npublic class Solution\\n{\\n    public int ClimbStairs(int n)\\n    {\\n        if (n < 3)\\n            return n;\\n\\n        int n_2 = 2;\\n        int n_1 = 1;\\n        int res = 0;\\n\\n        int i = 3;\\n        while(i++ <= n)\\n        {\\n            res = n_2 + n_1;\\n            n_1 = n_2;\\n            n_2 = res;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int ClimbStairs(int n)\\n    {\\n        if (n < 3)\\n            return n;\\n\\n        int n_2 = 2;\\n        int n_1 = 1;\\n        int res = 0;\\n\\n        int i = 3;\\n        while(i++ <= n)\\n        {\\n            res = n_2 + n_1;\\n            n_1 = n_2;\\n            n_2 = res;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369330,
                "title": "ruby-fibonacci",
                "content": "```ruby\\ndef climb_stairs(n)\\n    fib = { 0 => 0, 1 => 1, 2 => 2, 3 => 3 }\\n    fib.default_proc = ->(f,n) { f[n] = f[n-1] + f[n-2] }\\n    fib[n]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef climb_stairs(n)\\n    fib = { 0 => 0, 1 => 1, 2 => 2, 3 => 3 }\\n    fib.default_proc = ->(f,n) { f[n] = f[n-1] + f[n-2] }\\n    fib[n]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 183770,
                "title": "o-1-and-1-line-python",
                "content": "### Mathematician\\'s way to solve fibonacci and shock interviewer :P beats 100%\\n```\\n    def climbStairs(self, n):\\n        return int((5**.5 / 5) * (((1 + 5**.5)/2)**(n + 1) - ((1 - 5**.5)/2)**(n + 1)))\\n```\\n**How to solve fibonacci mathematically:**\\n* ![alt text](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D245/sign=456a7a09b61bb0518b24b42c037ada77/503d269759ee3d6db9e6f1e046166d224f4adefd.jpg)\\n* Wiki: https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression\\n* Baidu: https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97",
                "solutionTags": [],
                "code": "```\\n    def climbStairs(self, n):\\n        return int((5**.5 / 5) * (((1 + 5**.5)/2)**(n + 1) - ((1 - 5**.5)/2)**(n + 1)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25300,
                "title": "o-n-time-o-1-space-c",
                "content": "    int climbStairs(int n) {\\n        if(n == 0||n==1)\\n            return n;\\n       int b = 1;\\n       int a = 2;    \\n       for(int i=3;i<=n;i++){\\n           a = a+b;\\n           b = a-b; \\n       }\\n       return a; \\n    }",
                "solutionTags": [],
                "code": "    int climbStairs(int n) {\\n        if(n == 0||n==1)\\n            return n;\\n       int b = 1;\\n       int a = 2;    \\n       for(int i=3;i<=n;i++){\\n           a = a+b;\\n           b = a-b; \\n       }\\n       return a; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25517,
                "title": "my-javascript-solution-fib",
                "content": "    \\ufffcvar climbStairs = function(n) {\\n    if(n === 0)  return 0\\n    if(n === 1)  return 1\\n    if(n === 2)  return 2\\n\\n    var arr = [1,2]\\n    for(int i = 2; i < n; i++) {\\n    \\tarr[i] = arr[i-1] + arr[i-2]\\n    }\\n    return arr[n-1]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    \\ufffcvar climbStairs = function(n) {\\n    if(n === 0)  return 0\\n    if(n === 1)  return 1\\n    if(n === 2)  return 2\\n\\n    var arr = [1,2]\\n    for(int i = 2; i < n; i++) {\\n    \\tarr[i] = arr[i-1] + arr[i-2]\\n    }\\n    return arr[n-1]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 25537,
                "title": "5-lines-of-easy-code",
                "content": "    class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int cur=1, pre=0;\\n            for(int i=0; i<n; i++){\\n                cur=pre+cur;\\n                pre=cur-pre;\\n            }\\n            return cur;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int cur=1, pre=0;\\n            for(int i=0; i<n; i++){\\n                cur=pre+cur;\\n                pre=cur-pre;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 25529,
                "title": "accepted-java-solution",
                "content": "    public class Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1 || n == 2) return n;\\n        int sum = 2, prev = 1, curr = 0;\\n        for (int i = 2; i < n; i++) {\\n            curr = sum; \\n            sum += prev;\\n            prev = curr;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1 || n == 2) return n;\\n        int sum = 2, prev = 1, curr = 0;\\n        for (int i = 2; i < n; i++) {\\n            curr = sum; \\n            sum += prev;\\n            prev = curr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3909678,
                "title": "c-four-approaches-dp-explanation-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // time complexities\\n    // recursion - O(2^n) (exponential)\\n    // for toptobottom - (  O(N))\\n    // to bottomup ( tabular ) - (O(N))\\n    // optimal - (O(N))\\n\\n    // space complexities\\n    // for recursion - O(N) ( rec calll stack)\\n    // for top down - O(N) ( for dp array ) + O(N) ( for the rec call stack)\\n    // for bottomup - O(N) ( for the array only ) // as no recursion\\n    // for optimal - (O(1)) ( as we used two variables only)\\n  \\n  // approach 1\\n\\n  int recursion(int n)\\n     { \\n         // when n becomes 0 simply it means we reached the destination and when the n becomes -ve it means we reached beyond the target\\n\\n       // make a array to store the count \\n         if(n == 0)\\n         {\\n             return 1;\\n         }\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         int ans1 = recursion(n-1);\\n         int ans2 = recursion(n-2);\\n         return (ans1 + ans2);\\n\\n     }\\n\\n// approach 2\\n\\nint topdown(int n , vector<int>& dp)\\n     {\\n         // writing the base case\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         if( n == 0)\\n         {\\n             return 1;\\n         }\\n         // check if value already exist\\n         if(dp[n]  != -1)\\n         {\\n             return dp[n];\\n         }\\n\\n         // create the value \\n         dp[n] = topdown(n-1 , dp)+ topdown(n-2,dp);\\n         return dp[n];\\n     }\\n\\n\\n// approach 3\\n\\nint  bottomup(int n)\\n    {\\n        // create array to store\\n        vector<int> dp(n+1 , -1);\\n\\n        // observe the base cases\\n        if( n ==0 )\\n        {\\n            return 0; // as we cant go\\n        }\\n        dp[1] = 1; \\n        if( n == 1)\\n        {\\n            return 1;  // as we can go by having move of 1\\n        }\\n\\n        dp[2] = 2;  \\n        // 2 is the case which needed to be handled as (0 + 1 is 1) but for 2 the ways will be 2 (1+1) and (2)\\n        \\n        for( int i = 3 ; i <= n ; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n\\n //approach 4\\n\\n  int optimalsol( int n)\\n  {\\n      // if you see bottomup approach we are just using prev two values to calculate so rather then making a complete array of size n + 1 we must initilize only two variables and we will keep on updating them\\n      if( n == 0 )\\n      {\\n          return 0; // as not possible\\n      }\\n      int temp1 = 1; \\n      int temp2 = 2;\\n    if(n == 1)\\n    {\\n        return temp1;\\n    }\\n    if( n == 2)\\n    {\\n        return temp2;\\n    }\\n    int curr; // to store the current answer\\n    for( int i = 3 ; i <= n ; i++)\\n    {\\n        curr = temp1 + temp2;\\n        //update the values of temp1 and temp2\\n        temp1 = temp2;\\n        temp2 = curr;\\n    }\\n  return curr;\\n  }\\n\\n    \\n\\n\\n    int climbStairs(int n) {\\n       \\n       vector<int> dp(n+1,-1);\\n    // int ans = recursion(n);\\n    // int ans = topdown(n,dp);\\n    // int ans = bottomup(n);\\n     int ans = optimalsol(n);\\n     return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // time complexities\\n    // recursion - O(2^n) (exponential)\\n    // for toptobottom - (  O(N))\\n    // to bottomup ( tabular ) - (O(N))\\n    // optimal - (O(N))\\n\\n    // space complexities\\n    // for recursion - O(N) ( rec calll stack)\\n    // for top down - O(N) ( for dp array ) + O(N) ( for the rec call stack)\\n    // for bottomup - O(N) ( for the array only ) // as no recursion\\n    // for optimal - (O(1)) ( as we used two variables only)\\n  \\n  // approach 1\\n\\n  int recursion(int n)\\n     { \\n         // when n becomes 0 simply it means we reached the destination and when the n becomes -ve it means we reached beyond the target\\n\\n       // make a array to store the count \\n         if(n == 0)\\n         {\\n             return 1;\\n         }\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         int ans1 = recursion(n-1);\\n         int ans2 = recursion(n-2);\\n         return (ans1 + ans2);\\n\\n     }\\n\\n// approach 2\\n\\nint topdown(int n , vector<int>& dp)\\n     {\\n         // writing the base case\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         if( n == 0)\\n         {\\n             return 1;\\n         }\\n         // check if value already exist\\n         if(dp[n]  != -1)\\n         {\\n             return dp[n];\\n         }\\n\\n         // create the value \\n         dp[n] = topdown(n-1 , dp)+ topdown(n-2,dp);\\n         return dp[n];\\n     }\\n\\n\\n// approach 3\\n\\nint  bottomup(int n)\\n    {\\n        // create array to store\\n        vector<int> dp(n+1 , -1);\\n\\n        // observe the base cases\\n        if( n ==0 )\\n        {\\n            return 0; // as we cant go\\n        }\\n        dp[1] = 1; \\n        if( n == 1)\\n        {\\n            return 1;  // as we can go by having move of 1\\n        }\\n\\n        dp[2] = 2;  \\n        // 2 is the case which needed to be handled as (0 + 1 is 1) but for 2 the ways will be 2 (1+1) and (2)\\n        \\n        for( int i = 3 ; i <= n ; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n\\n //approach 4\\n\\n  int optimalsol( int n)\\n  {\\n      // if you see bottomup approach we are just using prev two values to calculate so rather then making a complete array of size n + 1 we must initilize only two variables and we will keep on updating them\\n      if( n == 0 )\\n      {\\n          return 0; // as not possible\\n      }\\n      int temp1 = 1; \\n      int temp2 = 2;\\n    if(n == 1)\\n    {\\n        return temp1;\\n    }\\n    if( n == 2)\\n    {\\n        return temp2;\\n    }\\n    int curr; // to store the current answer\\n    for( int i = 3 ; i <= n ; i++)\\n    {\\n        curr = temp1 + temp2;\\n        //update the values of temp1 and temp2\\n        temp1 = temp2;\\n        temp2 = curr;\\n    }\\n  return curr;\\n  }\\n\\n    \\n\\n\\n    int climbStairs(int n) {\\n       \\n       vector<int> dp(n+1,-1);\\n    // int ans = recursion(n);\\n    // int ans = topdown(n,dp);\\n    // int ans = bottomup(n);\\n     int ans = optimalsol(n);\\n     return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701303,
                "title": "simple-c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solve(int n,vector<int> &dp)\\n{\\n    if(n==0) return 1;\\n    if(n<0) return 0;\\n    if(dp[n]!=-1) return dp[n];\\n    return dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n}\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint solve(int n,vector<int> &dp)\\n{\\n    if(n==0) return 1;\\n    if(n<0) return 0;\\n    if(dp[n]!=-1) return dp[n];\\n    return dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n}\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567678,
                "title": "c-using-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n//using dp\\n    int solve(int n,vector<int> &dp){\\n        if(n<=2){\\n            return n;\\n        }\\n\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n\\n        return solve(n,dp);\\n    }\\n\\n};\\n\\n\\n\\n//using tabulation method\\n\\n\\n//     int climbStairs(int n) {\\n//     vector<int> dp(n+2);\\n//     dp[0]=0;\\n//     dp[1]=1;\\n//     dp[2]=2;\\n//     if(n<3){\\n//         return dp[n];\\n//     }\\n    \\n//     for(int i=3;i<=n;i++){\\n//         dp[i]=dp[i-1]+dp[i-2];\\n//     }\\n//     return dp[n];\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n//using dp\\n    int solve(int n,vector<int> &dp){\\n        if(n<=2){\\n            return n;\\n        }\\n\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n\\n        return solve(n,dp);\\n    }\\n\\n};\\n\\n\\n\\n//using tabulation method\\n\\n\\n//     int climbStairs(int n) {\\n//     vector<int> dp(n+2);\\n//     dp[0]=0;\\n//     dp[1]=1;\\n//     dp[2]=2;\\n//     if(n<3){\\n//         return dp[n];\\n//     }\\n    \\n//     for(int i=3;i<=n;i++){\\n//         dp[i]=dp[i-1]+dp[i-2];\\n//     }\\n//     return dp[n];\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483669,
                "title": "easy-java-solution-beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n      if(n<4)\\n      return n;\\n      int f=2,s=3,t=0;\\n      for(int i=3;i<n;i++){\\n          t=f+s;\\n          f=s;\\n          s=t;\\n      }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n      if(n<4)\\n      return n;\\n      int f=2,s=3,t=0;\\n      for(int i=3;i<n;i++){\\n          t=f+s;\\n          f=s;\\n          s=t;\\n      }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928339,
                "title": "m-o-1-t-o-n-4-different-approaches",
                "content": "# 4 Approachs\\n1. First recursion & Backtracking\\n2. Then Memorization \\n3. DP- Bottom up approach using Array\\n4. DP same as 3 but no space just 2 pointers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n# /70. Climbing Stairs\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        one, two = 1, 1\\n        for _ in range(n-1):\\n            one, two = two, one+two\\n        return two\\n\\n```\\nYou Can also Look At My SDE Prep Repo [*`\\uD83E\\uDDE2 GitHub`*](https://github.com/Ayon-SSP/The-SDE-Prep)",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n# /70. Climbing Stairs\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        one, two = 1, 1\\n        for _ in range(n-1):\\n            one, two = two, one+two\\n        return two\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908156,
                "title": "simple-java-solution-with-video-explanation",
                "content": "UPVOTE IF IT HELPS YOU, IT KEEPS ME MOTIVATED \\n```\\npublic class Solution {\\n\\n    public int climbStairs(int n) {\\n        int a = 1;\\n        int b = 1;\\n        for(int i=0; i<n-1; i++){\\n            int temp = a;\\n            a = b;\\n            b = b + temp;\\n        }\\n        return b;\\n    }\\n}\\n```\\n[https://www.youtube.com/watch?v=Y0lT9Fck7qI]()",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int climbStairs(int n) {\\n        int a = 1;\\n        int b = 1;\\n        for(int i=0; i<n-1; i++){\\n            int temp = a;\\n            a = b;\\n            b = b + temp;\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905111,
                "title": "python-3-2-versions-3-lines-each-w-explanation-t-m-94-68",
                "content": "\\'\\'\\'\\nLets use `A(n)` as the answer for `n`. Obviously, then `A(1) = 1` and `A(2) = 2`. To get to the third stair, we either take one step from `2` or two steps from `1`, which implies `A3 = A1 + A2`. In general, the inductive step to determine all values then is `A(k) = A(k-1) + A(k-2)`. Thus, the problem reduces to finding the nth Fibonacci number, given `n`.  \\n\\nVersion 1: Induction\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n\\n        a, b, (d, m) = 1, 1, divmod(n,2)\\n\\n        for _ in range(d):  a,b = a+b,a+b+b\\n\\n        return b if m else a\\n```\\n[https://leetcode.com/problems/climbing-stairs/submissions/858745613/](http://)\\n\\nVersion 2: Binet\\'s Formula (The irrational numbers `phi` and `psi` below are the eigenvalues of the linear transformation `a,b = a+b,a+b+b` above. More complete explanations can be googled.) \\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n\\n        phi= (1+sqrt(5))/2\\n        psi = 1 - phi\\n\\n        return int((phi**(n+1)-psi**(n+1))/sqrt(5))\\n```\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*) on the first, and *O*(1) / *O*(1) on the second.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n\\n        a, b, (d, m) = 1, 1, divmod(n,2)\\n\\n        for _ in range(d):  a,b = a+b,a+b+b\\n\\n        return b if m else a\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n\\n        phi= (1+sqrt(5))/2\\n        psi = 1 - phi\\n\\n        return int((phi**(n+1)-psi**(n+1))/sqrt(5))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570512,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1564973,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1714182,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1887814,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567350,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567370,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1576987,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568496,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568574,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568723,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1570512,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1564973,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1714182,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1887814,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567350,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567370,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1576987,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568496,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568574,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568723,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. 💀"
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1570203,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1566449,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1572841,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1916688,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1752782,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1568786,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1568891,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1573230,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1713807,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1575816,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1576386,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1572340,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1567839,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1814546,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1714382,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1576324,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1575721,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1575566,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1573870,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1573063,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1572626,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 1572231,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 1570607,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2074335,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2069853,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2067489,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2066431,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2066049,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2065569,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2064619,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2059430,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2057594,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2054075,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2052493,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2049763,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2043103,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2041394,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2033047,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2020621,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2020231,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha😆. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45🤣"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2014209,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 2009119,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1999651,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1986069,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1982993,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1974310,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1973133,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1958833,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1947902,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1942506,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1942205,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1939369,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1938656,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1935802,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1925807,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1921304,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1875660,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1872889,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1866789,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1864678,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1852756,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849950,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849356,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849341,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849340,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1848019,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1840751,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1833965,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1833024,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1828889,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! -> 😊 \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1825437,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1808482,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1802043,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1799955,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1799869,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1785211,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1783115,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1782032,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1781062,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1776547,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1773066,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1760092,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1752227,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1747538,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1745802,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1745683,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1740936,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1735975,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1733939,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1733938,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1733937,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1733203,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1733201,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1732245,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1727776,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1725908,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1724331,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714501,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714352,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714347,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714322,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714309,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714280,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714237,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714178,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714116,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714081,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713959,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713955,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713783,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713748,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713739,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713729,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713695,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713659,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1711045,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1709022,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1693294,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1689605,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1688135,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1685816,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1683672,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1681575,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1679574,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1675424,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1670220,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1668813,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1665161,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1664945,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1663491,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            }
        ]
    }
]